<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/vacuumlazy.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/vacuumlazy.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L136">LVRelState</a></li>
<li><a href="#L219">LVRelState</a></li>
<li><a href="#L222">LVSavedErrInfo</a></li>
<li><a href="#L227">LVSavedErrInfo</a></li>
<li><a href="#L134">VacErrPhase</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1389">cmpOffsetNumbers</a></li>
<li><a href="#L2677">count_nondeletable_pages</a></li>
<li><a href="#L2884">dead_items_add</a></li>
<li><a href="#L2819">dead_items_alloc</a></li>
<li><a href="#L2923">dead_items_cleanup</a></li>
<li><a href="#L2901">dead_items_reset</a></li>
<li><a href="#L1186">find_next_unskippable_block</a></li>
<li><a href="#L2948">heap_page_is_all_visible</a></li>
<li><a href="#L1088">heap_vac_scan_next_block</a></li>
<li><a href="#L295">heap_vacuum_rel</a></li>
<li><a href="#L2296">lazy_check_wraparound_failsafe</a></li>
<li><a href="#L2349">lazy_cleanup_all_indexes</a></li>
<li><a href="#L2466">lazy_cleanup_one_index</a></li>
<li><a href="#L818">lazy_scan_heap</a></li>
<li><a href="#L1285">lazy_scan_new_or_empty</a></li>
<li><a href="#L1650">lazy_scan_noprune</a></li>
<li><a href="#L1408">lazy_scan_prune</a></li>
<li><a href="#L2546">lazy_truncate_heap</a></li>
<li><a href="#L1861">lazy_vacuum</a></li>
<li><a href="#L1986">lazy_vacuum_all_indexes</a></li>
<li><a href="#L2191">lazy_vacuum_heap_page</a></li>
<li><a href="#L2103">lazy_vacuum_heap_rel</a></li>
<li><a href="#L2417">lazy_vacuum_one_index</a></li>
<li><a href="#L3182">restore_vacuum_error_info</a></li>
<li><a href="#L2526">should_attempt_truncation</a></li>
<li><a href="#L3064">update_relstats_all_indexes</a></li>
<li><a href="#L3163">update_vacuum_error_info</a></li>
<li><a href="#L3099">vacuum_error_callback</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L89">BYPASS_THRESHOLD_PAGES</a></li>
<li><a href="#L95">FAILSAFE_EVERY_PAGES</a></li>
<li><a href="#L117">PREFETCH_SIZE</a></li>
<li><a href="#L123">ParallelVacuumIsActive</a></li>
<li><a href="#L72">REL_TRUNCATE_FRACTION</a></li>
<li><a href="#L71">REL_TRUNCATE_MINIMUM</a></li>
<li><a href="#L111">SKIP_PAGES_THRESHOLD</a></li>
<li><a href="#L104">VACUUM_FSM_EVERY_PAGES</a></li>
<li><a href="#L81">VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL</a></li>
<li><a href="#L83">VACUUM_TRUNCATE_LOCK_TIMEOUT</a></li>
<li><a href="#L82">VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * vacuumlazy.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Concurrent (&quot;lazy&quot;) vacuuming.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The major space usage for vacuuming is storage for the dead tuple IDs that<br/></li>
<li></span><span class="Comment"> * are to be removed from indexes.&nbsp; We want to ensure we can <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> even the<br/></li>
<li></span><span class="Comment"> * very largest relations with finite memory space usage.&nbsp; To do that, we set<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds on the memory that can be used for keeping track of dead TIDs<br/></li>
<li></span><span class="Comment"> * at once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are willing to use at most <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> (or perhaps<br/></li>
<li></span><span class="Comment"> * <a href="../../postmaster/autovacuum.c.html#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a>) memory space to keep track of dead TIDs.&nbsp; If the<br/></li>
<li></span><span class="Comment"> * TID store is full, we must call <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a> to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> indexes (and to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment"> * the pages that we've pruned). This frees up the memory space dedicated to<br/></li>
<li></span><span class="Comment"> * store dead TIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In practice VACUUM will often complete its initial pass over the target<br/></li>
<li></span><span class="Comment"> * heap relation without ever running out of space to store TIDs.&nbsp; This means<br/></li>
<li></span><span class="Comment"> * that there only needs to be one call to <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a>, after the initial pass<br/></li>
<li></span><span class="Comment"> * completes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/vacuumlazy.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tidstore.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;portability/instr_time.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/freespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_rusage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Space/time tradeoff parameters: do these need to be user-tunable?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To consider truncating the relation, we want there to be at least<br/></li>
<li></span><span class="Comment"> * <a href="#L71" title="access/heap/vacuumlazy.c:71">REL_TRUNCATE_MINIMUM</a> or (relsize / <a href="#L72" title="access/heap/vacuumlazy.c:72">REL_TRUNCATE_FRACTION</a>) (whichever<br/></li>
<li></span><span class="Comment"> * is less) potentially-freeable pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">REL_TRUNCATE_MINIMUM</span>&nbsp; &nbsp; </span><span class="Constant">1000<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">REL_TRUNCATE_FRACTION</span>&nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Timing parameters for truncate locking heuristics.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These were not exposed as user tunable GUC <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> because it didn't seem<br/></li>
<li></span><span class="Comment"> * that the potential for improvement was great enough to merit the cost of<br/></li>
<li></span><span class="Comment"> * supporting them.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">20</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* ms */<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">50</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* ms */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VACUUM_TRUNCATE_LOCK_TIMEOUT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">5000</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* ms */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Threshold that controls whether we bypass index vacuuming and heap<br/></li>
<li></span><span class="Comment"> * vacuuming as an optimization<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L89">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BYPASS_THRESHOLD_PAGES</span>&nbsp; &nbsp; </span><span class="Constant">0.02</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* i.e. 2% of rel_pages */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a failsafe check each time we scan another 4GB of pages.<br/></li>
<li></span><span class="Comment"> * (Note that this is deliberately kept to a power-of-two, usually 2^19.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FAILSAFE_EVERY_PAGES</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((BlockNumber) (((uint64) </span><span class="Constant">4</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc">) / BLCKSZ))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When a table has no indexes, <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> the FSM after every 8GB, approximately<br/></li>
<li></span><span class="Comment"> * (it won't be exact because we only <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> FSM after processing a heap page<br/></li>
<li></span><span class="Comment"> * that has some removable tuples).&nbsp; When there are indexes, this is ignored,<br/></li>
<li></span><span class="Comment"> * and we <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> FSM after each index/heap cleaning pass.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VACUUM_FSM_EVERY_PAGES</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((BlockNumber) (((uint64) </span><span class="Constant">8</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc"> * </span><span class="Constant">1024</span><span class="PreProc">) / BLCKSZ))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Before we consider skipping a page that's marked as clean in<br/></li>
<li></span><span class="Comment"> * visibility map, we must've seen at least this many clean pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SKIP_PAGES_THRESHOLD</span>&nbsp; &nbsp; ((BlockNumber) </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of the prefetch window for lazy <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> backwards truncation scan.<br/></li>
<li></span><span class="Comment"> * Needs to be a power of 2.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PREFETCH_SIZE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((BlockNumber) </span><span class="Constant">32</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Macro to check if we are in a parallel <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; If true, we are in the<br/></li>
<li></span><span class="Comment"> * parallel mode and the DSM segment is initialized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ParallelVacuumIsActive</span>(vacrel) ((vacrel)-&gt;pvs != </span><span class="Constant">NULL</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Phases of <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> during which we report error context. */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; VACUUM_ERRCB_PHASE_UNKNOWN,<br/></li>
<li>&nbsp; &nbsp; VACUUM_ERRCB_PHASE_SCAN_HEAP,<br/></li>
<li>&nbsp; &nbsp; VACUUM_ERRCB_PHASE_VACUUM_INDEX,<br/></li>
<li>&nbsp; &nbsp; VACUUM_ERRCB_PHASE_VACUUM_HEAP,<br/></li>
<li>&nbsp; &nbsp; VACUUM_ERRCB_PHASE_INDEX_CLEANUP,<br/></li>
<li>&nbsp; &nbsp; VACUUM_ERRCB_PHASE_TRUNCATE,<br/></li>
<li><a id="L134">&#x200c;</a>} <span class="linkable">VacErrPhase</span>;<br/></li>
<li><br/></li>
<li><a id="L136">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LVRelState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Target heap relation and its indexes */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *indrels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nindexes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Buffer access strategy and parallel <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> state */<br/></li>
<li></span>&nbsp; &nbsp; BufferAccessStrategy bstrategy;<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/vacuumparallel.c.html#L161" title="commands/vacuumparallel.c:161">ParallelVacuumState</a> *pvs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Aggressive VACUUM? (must set relfrozenxid &gt;= FreezeLimit) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; aggressive;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use visibility map to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>? (disabled by DISABLE_PAGE_SKIPPING) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipwithvm;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider index vacuuming bypass optimization? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; consider_bypass_optimization;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Doing index vacuuming, index <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, rel truncation? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_index_vacuuming;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_index_cleanup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_rel_truncate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* VACUUM operation's cutoffs for freezing and pruning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> VacuumCutoffs cutoffs;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *vistest;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tracks oldest extant XID/MXID for setting relfrozenxid/relminmxid */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId NewRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId NewRelminMxid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skippedallvis;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Error reporting state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dbname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relnamespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *indname;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Current index name */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber blkno;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* used only for heap operations */<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber offnum;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* used only for heap operations */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L134" title="access/heap/vacuumlazy.c:134">VacErrPhase</a> phase;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; verbose;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* VACUUM VERBOSE? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dead_items stores TIDs whose index tuples are deleted by index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming. Each TID points to an LP_DEAD line pointer from a heap page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that has been processed by <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>.&nbsp; Also needed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2103" title="access/heap/vacuumlazy.c:2103">lazy_vacuum_heap_rel</a>, which marks the same LP_DEAD line pointers as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LP_UNUSED during second heap pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both dead_items and dead_items_info are allocated in shared memory in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *dead_items;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* TIDs whose index tuples we'll delete */<br/></li>
<li></span>&nbsp; &nbsp; VacDeadItemsInfo *dead_items_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; BlockNumber rel_pages;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* total number of pages */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber scanned_pages;&nbsp; &nbsp; <span class="Comment">/* # pages examined (not skipped via VM) */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber removed_pages;&nbsp; &nbsp; <span class="Comment">/* # pages removed by relation truncation */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber frozen_pages;&nbsp; &nbsp; <span class="Comment">/* # pages with newly frozen tuples */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber lpdead_item_pages;&nbsp; &nbsp; <span class="Comment">/* # pages with LP_DEAD items */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber missed_dead_pages;&nbsp; &nbsp; <span class="Comment">/* # pages with missed dead tuples */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber nonempty_pages; <span class="Comment">/* actually, last nonempty page + 1 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Statistics output by us, for table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; new_rel_tuples; <span class="Comment">/* new estimated total # of tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; new_live_tuples;&nbsp; &nbsp; <span class="Comment">/* new estimated total # of live tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Statistics output by index AMs */<br/></li>
<li></span>&nbsp; &nbsp; IndexBulkDeleteResult **indstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Instrumentation counters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_index_scans;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Counters that follow are only for scanned_pages */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuples_deleted; <span class="Comment">/* # deleted from table */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuples_frozen;&nbsp; &nbsp; <span class="Comment">/* # newly frozen */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; lpdead_items;&nbsp; &nbsp; <span class="Comment">/* # deleted from indexes */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; live_tuples;&nbsp; &nbsp; <span class="Comment">/* # live tuples remaining */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; recently_dead_tuples;&nbsp; &nbsp; <span class="Comment">/* # dead, but not yet removable */<br/></li>
<li></span>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; missed_dead_tuples; <span class="Comment">/* # removable, but not removed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* State maintained by <a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>() */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber current_block;&nbsp; &nbsp; <span class="Comment">/* last block returned */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber next_unskippable_block; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> unskippable block */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; next_unskippable_allvis;&nbsp; &nbsp; <span class="Comment">/* its visibility status */<br/></li>
<li></span>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; next_unskippable_vmbuffer;&nbsp; &nbsp; <span class="Comment">/* buffer containing its VM <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li><a id="L219">&#x200c;</a></span>} <span class="linkable">LVRelState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Struct for saving and restoring <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> error information. */<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">LVSavedErrInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; <a href="#L134" title="access/heap/vacuumlazy.c:134">VacErrPhase</a> phase;<br/></li>
<li><a id="L227">&#x200c;</a>} <span class="linkable">LVSavedErrInfo</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* non-export function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, BlockNumber *blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *all_visible_according_to_vm);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1186" title="access/heap/vacuumlazy.c:1186">find_next_unskippable_block</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *skipsallvis);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1285" title="access/heap/vacuumlazy.c:1285">lazy_scan_new_or_empty</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber blkno, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sharelock, Buffer vmbuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer vmbuffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_visible_according_to_vm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_lpdead_items);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_lpdead_items);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1986" title="access/heap/vacuumlazy.c:1986">lazy_vacuum_all_indexes</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2103" title="access/heap/vacuumlazy.c:2103">lazy_vacuum_heap_rel</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2191" title="access/heap/vacuumlazy.c:2191">lazy_vacuum_heap_page</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buffer, OffsetNumber *offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> num_offsets, Buffer vmbuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2296" title="access/heap/vacuumlazy.c:2296">lazy_check_wraparound_failsafe</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2349" title="access/heap/vacuumlazy.c:2349">lazy_cleanup_all_indexes</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> IndexBulkDeleteResult *<a href="#L2417" title="access/heap/vacuumlazy.c:2417">lazy_vacuum_one_index</a>(Relation indrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteResult *istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> reltuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> IndexBulkDeleteResult *<a href="#L2466" title="access/heap/vacuumlazy.c:2466">lazy_cleanup_one_index</a>(Relation indrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteResult *istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> reltuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> estimated_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2526" title="access/heap/vacuumlazy.c:2526">should_attempt_truncation</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2546" title="access/heap/vacuumlazy.c:2546">lazy_truncate_heap</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L2677" title="access/heap/vacuumlazy.c:2677">count_nondeletable_pages</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *lock_waiter_detected);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2819" title="access/heap/vacuumlazy.c:2819">dead_items_alloc</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, <span class="Type">int</span> nworkers);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2884" title="access/heap/vacuumlazy.c:2884">dead_items_add</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, BlockNumber blkno, OffsetNumber *offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_offsets);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2901" title="access/heap/vacuumlazy.c:2901">dead_items_reset</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2923" title="access/heap/vacuumlazy.c:2923">dead_items_cleanup</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2948" title="access/heap/vacuumlazy.c:2948">heap_page_is_all_visible</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *visibility_cutoff_xid, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *all_frozen);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3064" title="access/heap/vacuumlazy.c:3064">update_relstats_all_indexes</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3099" title="access/heap/vacuumlazy.c:3099">vacuum_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> *saved_vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> phase, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3182" title="access/heap/vacuumlazy.c:3182">restore_vacuum_error_info</a>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> *saved_vacrel);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L295" title="access/heap/vacuumlazy.c:295">heap_vacuum_rel</a>() -- perform VACUUM for one heap relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine sets things up for and then calls <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>, where<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; almost all work actually takes place.&nbsp; Finalizes everything after call<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; returns by managing relation truncation and updating rel's pg_class<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; entry. (Also updates pg_class entries for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes that need it.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; At entry, we have already established a transaction and opened<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and locked the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L295">&#x200c;</a></span><span class="linkable">heap_vacuum_rel</span>(Relation rel, VacuumParams *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy bstrategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; verbose,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instrument,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipwithvm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frozenxid_updated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minmulti_updated;<br/></li>
<li>&nbsp; &nbsp; BlockNumber orig_rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rel_allvisible;<br/></li>
<li>&nbsp; &nbsp; PGRUsage&nbsp; &nbsp; ru0;<br/></li>
<li>&nbsp; &nbsp; TimestampTz starttime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; PgStat_Counter startreadtime = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startwritetime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp; &nbsp; startwalusage = <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; StartPageHit = <a href="../../utils/init/globals.c.html#L154" title="utils/init/globals.c:154">VacuumPageHit</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StartPageMiss = <a href="../../utils/init/globals.c.html#L155" title="utils/init/globals.c:155">VacuumPageMiss</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StartPageDirty = <a href="../../utils/init/globals.c.html#L156" title="utils/init/globals.c:156">VacuumPageDirty</a>;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback errcallback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **indnames = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; verbose = (params-&gt;options &amp; VACOPT_VERBOSE) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; instrument = (verbose || (AmAutoVacuumWorkerProcess() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;log_min_duration &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (instrument)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/pg_rusage.c.html#L27" title="utils/misc/pg_rusage.c:27">pg_rusage_init</a>(&amp;ru0);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; starttime = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startreadtime = <a href="../../utils/activity/pgstat_database.c.html#L28" title="utils/activity/pgstat_database.c:28">pgStatBlockReadTime</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startwritetime = <a href="../../utils/activity/pgstat_database.c.html#L29" title="utils/activity/pgstat_database.c:29">pgStatBlockWriteTime</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L28" title="utils/activity/backend_progress.c:28">pgstat_progress_start_command</a>(PROGRESS_COMMAND_VACUUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup error traceback support for ereport() first.&nbsp; The idea is to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up an error context callback to display additional information on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error during a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; During different phases of <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, we update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the state so that the error context callback always display current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the names of heap rel into local memory for error reporting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purposes, too.&nbsp; It isn't always safe to assume that we can get the name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of each rel.&nbsp; It's convenient for code in <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a> to always use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these temp copies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vacrel = (<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a>));<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;dbname = <a href="../../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;relnamespace = <a href="../../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel));<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;relname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;indname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;phase = VACUUM_ERRCB_PHASE_UNKNOWN;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;verbose = verbose;<br/></li>
<li>&nbsp; &nbsp; errcallback.callback = <a href="#L3099" title="access/heap/vacuumlazy.c:3099">vacuum_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; errcallback.arg = vacrel;<br/></li>
<li>&nbsp; &nbsp; errcallback.previous = <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;errcallback;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up high level stuff about rel and its indexes */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;rel = rel;<br/></li>
<li>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2272" title="commands/vacuum.c:2272">vac_open_indexes</a>(vacrel-&gt;rel, RowExclusiveLock, &amp;vacrel-&gt;nindexes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vacrel-&gt;indrels);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;bstrategy = bstrategy;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (instrument &amp;&amp; vacrel-&gt;nindexes &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy index names used by instrumentation (not error reporting) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indnames = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">char</span> *) * vacrel-&gt;nindexes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; vacrel-&gt;nindexes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnames[i] = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(vacrel-&gt;indrels[i]));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The index_cleanup param either disables index vacuuming and <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forces it to go ahead when we would otherwise apply the index bypass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization.&nbsp; The default is 'auto', which leaves the final decision<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up to <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The truncate param allows user to avoid attempting relation truncation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though it can't force truncation to happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(params-&gt;index_cleanup != VACOPTVALUE_UNSPECIFIED);<br/></li>
<li>&nbsp; &nbsp; Assert(params-&gt;truncate != VACOPTVALUE_UNSPECIFIED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; params-&gt;truncate != VACOPTVALUE_AUTO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While VacuumFailSafeActive is reset to false <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still need to reset it here due to recursive calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;consider_bypass_optimization = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;do_index_vacuuming = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;do_index_cleanup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;do_rel_truncate = (params-&gt;truncate != VACOPTVALUE_DISABLED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;index_cleanup == VACOPTVALUE_DISABLED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force disable index vacuuming up-front */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;do_index_vacuuming = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;do_index_cleanup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (params-&gt;index_cleanup == VACOPTVALUE_ENABLED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Force index vacuuming.&nbsp; Note that failsafe can still bypass. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;consider_bypass_optimization = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Default/auto, make all decisions dynamically */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(params-&gt;index_cleanup == VACOPTVALUE_AUTO);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize page counters explicitly (be tidy) */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;scanned_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;removed_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;frozen_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;lpdead_item_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;missed_dead_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;nonempty_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L2819" title="access/heap/vacuumlazy.c:2819">dead_items_alloc</a> allocates vacrel-&gt;dead_items later on */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate/<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> output statistics state */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;new_rel_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;new_live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;indstats = (IndexBulkDeleteResult **)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(vacrel-&gt;nindexes * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult *));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize remaining counters (be tidy) */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;num_index_scans = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;tuples_deleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;tuples_frozen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;lpdead_items = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;recently_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;missed_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get cutoffs that determine which deleted tuples are considered DEAD,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not just RECENTLY_DEAD, and which XIDs/MXIDs to freeze.&nbsp; Then determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the extent of the blocks that we'll scan in <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>.&nbsp; It has to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen in this order to ensure that the OldestXmin cutoff field works<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as an <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound on the XIDs stored in the pages we'll actually scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (NewRelfrozenXid tracking must never be allowed to <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> unfrozen XIDs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next acquire vistest, a related cutoff that's used in pruning.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expect vistest will always make <a href="pruneheap.c.html#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() remove <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleted tuple whose xmax is &lt; OldestXmin.&nbsp; <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> must never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * become confused about whether a tuple should be frozen or removed.&nbsp; (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the future we might want to teach <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> to recompute vistest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from time to time, to increase the number of dead tuples it can prune<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;aggressive = <a href="../../commands/vacuum.c.html#L1072" title="commands/vacuum.c:1072">vacuum_get_cutoffs</a>(rel, params, &amp;vacrel-&gt;cutoffs);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;rel_pages = orig_rel_pages = RelationGetNumberOfBlocks(rel);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;vistest = <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize state used to track oldest extant XID/MXID */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;NewRelfrozenXid = vacrel-&gt;cutoffs.OldestXmin;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;NewRelminMxid = vacrel-&gt;cutoffs.OldestMxact;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;skippedallvis = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; skipwithvm = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (params-&gt;options &amp; VACOPT_DISABLE_PAGE_SKIPPING)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force aggressive mode, and disable skipping blocks using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visibility map (even those set all-frozen)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;aggressive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skipwithvm = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;skipwithvm = skipwithvm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;aggressive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(INFO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aggressively vacuuming </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dbname, vacrel-&gt;relnamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(INFO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;vacuuming </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dbname, vacrel-&gt;relnamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate dead_items memory using <a href="#L2819" title="access/heap/vacuumlazy.c:2819">dead_items_alloc</a>.&nbsp; This handles<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel VACUUM initialization as part of allocating shared memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space used for dead_items.&nbsp; (But do a failsafe precheck first, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that parallel VACUUM won't be attempted at all when relfrozenxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is already dangerously old.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2296" title="access/heap/vacuumlazy.c:2296">lazy_check_wraparound_failsafe</a>(vacrel);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2819" title="access/heap/vacuumlazy.c:2819">dead_items_alloc</a>(vacrel, params-&gt;nworkers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a> to perform all required heap pruning, index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming, and heap vacuuming (plus related processing)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>(vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free resources managed by <a href="#L2819" title="access/heap/vacuumlazy.c:2819">dead_items_alloc</a>.&nbsp; This ends parallel mode in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passing when necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2923" title="access/heap/vacuumlazy.c:2923">dead_items_cleanup</a>(vacrel);<br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_class entries for each of rel's indexes where appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike the later update to rel's pg_class entry, this is not critical.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maintains relpages/reltuples statistics used by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> only.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;do_index_cleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3064" title="access/heap/vacuumlazy.c:3064">update_relstats_all_indexes</a>(vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with rel's indexes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2315" title="commands/vacuum.c:2315">vac_close_indexes</a>(vacrel-&gt;nindexes, vacrel-&gt;indrels, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Optionally truncate rel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2526" title="access/heap/vacuumlazy.c:2526">should_attempt_truncation</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2546" title="access/heap/vacuumlazy.c:2546">lazy_truncate_heap</a>(vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = errcallback.previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report that we are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> doing final <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_VACUUM_PHASE_FINAL_CLEANUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to update rel's pg_class entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aggressive VACUUMs must always be able to advance relfrozenxid to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value &gt;= FreezeLimit, and relminmxid to a value &gt;= MultiXactCutoff.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Non-aggressive VACUUMs may advance them by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> amount, or not at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(vacrel-&gt;NewRelfrozenXid == vacrel-&gt;cutoffs.OldestXmin ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(vacrel-&gt;aggressive ? vacrel-&gt;cutoffs.FreezeLimit :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;cutoffs.relfrozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;NewRelfrozenXid));<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;NewRelminMxid == vacrel-&gt;cutoffs.OldestMxact ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../transam/multixact.c.html#L3274" title="access/transam/multixact.c:3274">MultiXactIdPrecedesOrEquals</a>(vacrel-&gt;aggressive ? vacrel-&gt;cutoffs.MultiXactCutoff :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;cutoffs.relminmxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;NewRelminMxid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;skippedallvis)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must keep original relfrozenxid in a non-aggressive VACUUM that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chose to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> an all-visible page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; The state that tracks new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> will have missed unfrozen XIDs from the pages we skipped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!vacrel-&gt;aggressive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;NewRelfrozenXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;NewRelminMxid = InvalidMultiXactId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For safety, clamp relallvisible to be not more than what we're setting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_class.relpages to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_rel_pages = vacrel-&gt;rel_pages;&nbsp; &nbsp; <span class="Comment">/* After possible rel truncation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="visibilitymap.c.html#L384" title="access/heap/visibilitymap.c:384">visibilitymap_count</a>(rel, &amp;new_rel_allvisible, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_rel_allvisible &gt; new_rel_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_rel_allvisible = new_rel_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now actually update rel's pg_class entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In principle new_live_tuples could be -1 indicating that we (still)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't know the tuple count.&nbsp; In practice that can't happen, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan every page that isn't skipped using the visibility map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L1398" title="commands/vacuum.c:1398">vac_update_relstats</a>(rel, new_rel_pages, vacrel-&gt;new_live_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_rel_allvisible, vacrel-&gt;nindexes &gt; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;NewRelfrozenXid, vacrel-&gt;NewRelminMxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;frozenxid_updated, &amp;minmulti_updated, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report results to the cumulative stats system, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deliberately avoid telling the stats system about LP_DEAD items that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remain in the table due to VACUUM bypassing index and heap vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ANALYZE will consider the remaining LP_DEAD items to be dead &quot;tuples&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It seems like a good idea to err on the side of not vacuuming again too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * soon in cases where the failsafe prevented significant amounts of heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L211" title="utils/activity/pgstat_relation.c:211">pgstat_report_vacuum</a>(RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relisshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Max(vacrel-&gt;new_live_tuples, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;recently_dead_tuples +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;missed_dead_tuples);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L151" title="utils/activity/backend_progress.c:151">pgstat_progress_end_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (instrument)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz endtime = <a href="../../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (verbose || params-&gt;log_min_duration == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(starttime, endtime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; params-&gt;log_min_duration))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs_dur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs_dur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalUsage&nbsp; &nbsp; walusage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *msgfmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; diff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; PageHitOp = <a href="../../utils/init/globals.c.html#L154" title="utils/init/globals.c:154">VacuumPageHit</a> - StartPageHit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageMissOp = <a href="../../utils/init/globals.c.html#L155" title="utils/init/globals.c:155">VacuumPageMiss</a> - StartPageMiss,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageDirtyOp = <a href="../../utils/init/globals.c.html#L156" title="utils/init/globals.c:156">VacuumPageDirty</a> - StartPageDirty;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; read_rate = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_rate = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(starttime, endtime, &amp;secs_dur, &amp;usecs_dur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;walusage, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L286" title="executor/instrument.c:286">WalUsageAccumDiff</a>(&amp;walusage, &amp;<a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>, &amp;startwalusage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (verbose)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Aggressiveness already reported earlier, in dedicated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VACUUM VERBOSE ereport<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!params-&gt;is_wraparound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;finished vacuuming </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">: index scans: </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (params-&gt;is_wraparound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While it's possible for a VACUUM to be both is_wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and !aggressive, that's just a corner-case -- is_wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implies aggressive.&nbsp; Produce distinct output for the corner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case all the same, just in case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;aggressive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;automatic aggressive <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> to prevent wraparound of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">: index scans: </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;automatic <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> to prevent wraparound of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">: index scans: </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;aggressive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;automatic aggressive <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">: index scans: </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;automatic <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">: index scans: </span><span class="Special">%d\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, msgfmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;dbname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;relnamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;num_index_scans);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;pages: </span><span class="Special">%u</span><span class="Constant"> removed, </span><span class="Special">%u</span><span class="Constant"> remain, </span><span class="Special">%u</span><span class="Constant"> scanned (</span><span class="Special">%.2f%%</span><span class="Constant"> of total)</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;removed_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;scanned_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orig_rel_pages == <span class="Constant">0</span> ? <span class="Constant">100.0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">100.0</span> * vacrel-&gt;scanned_pages / orig_rel_pages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;tuples: </span><span class="Special">%lld</span><span class="Constant"> removed, </span><span class="Special">%lld</span><span class="Constant"> remain, </span><span class="Special">%lld</span><span class="Constant"> are dead but not yet removable</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;tuples_deleted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;new_rel_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;recently_dead_tuples);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;missed_dead_tuples &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;tuples missed: </span><span class="Special">%lld</span><span class="Constant"> dead from </span><span class="Special">%u</span><span class="Constant"> pages not removed due to <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock contention</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;missed_dead_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;missed_dead_pages);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff = (int32) (ReadNextTransactionId() -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;cutoffs.OldestXmin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;removable cutoff: </span><span class="Special">%u</span><span class="Constant">, which was </span><span class="Special">%d</span><span class="Constant"> XIDs old when operation ended</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;cutoffs.OldestXmin, diff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frozenxid_updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff = (int32) (vacrel-&gt;NewRelfrozenXid -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;cutoffs.relfrozenxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;new relfrozenxid: </span><span class="Special">%u</span><span class="Constant">, which is </span><span class="Special">%d</span><span class="Constant"> XIDs ahead of previous value</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;NewRelfrozenXid, diff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minmulti_updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff = (int32) (vacrel-&gt;NewRelminMxid -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;cutoffs.relminmxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;new relminmxid: </span><span class="Special">%u</span><span class="Constant">, which is </span><span class="Special">%d</span><span class="Constant"> MXIDs ahead of previous value</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;NewRelminMxid, diff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;frozen: </span><span class="Special">%u</span><span class="Constant"> pages from table (</span><span class="Special">%.2f%%</span><span class="Constant"> of total) had </span><span class="Special">%lld</span><span class="Constant"> tuples frozen</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;frozen_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orig_rel_pages == <span class="Constant">0</span> ? <span class="Constant">100.0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">100.0</span> * vacrel-&gt;frozen_pages / orig_rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;tuples_frozen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;do_index_vacuuming)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;nindexes == <span class="Constant">0</span> || vacrel-&gt;num_index_scans == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;index scan not needed: &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;index scan needed: &quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> pages from table (</span><span class="Special">%.2f%%</span><span class="Constant"> of total) had </span><span class="Special">%lld</span><span class="Constant"> dead item identifiers removed</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;index scan bypassed: &quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoString(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;index scan bypassed by failsafe: &quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msgfmt = <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;</span><span class="Special">%u</span><span class="Constant"> pages from table (</span><span class="Special">%.2f%%</span><span class="Constant"> of total) have </span><span class="Special">%lld</span><span class="Constant"> dead item identifiers</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, msgfmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;lpdead_item_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orig_rel_pages == <span class="Constant">0</span> ? <span class="Constant">100.0</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">100.0</span> * vacrel-&gt;lpdead_item_pages / orig_rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;lpdead_items);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; vacrel-&gt;nindexes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteResult *istat = vacrel-&gt;indstats[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!istat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: pages: </span><span class="Special">%u</span><span class="Constant"> in total, </span><span class="Special">%u</span><span class="Constant"> newly deleted, </span><span class="Special">%u</span><span class="Constant"> currently deleted, </span><span class="Special">%u</span><span class="Constant"> reusable</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indnames[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;num_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;pages_newly_deleted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;pages_deleted,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istat-&gt;pages_free);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L142" title="storage/buffer/bufmgr.c:142">track_io_timing</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; read_ms = (<span class="Type">double</span>) (<a href="../../utils/activity/pgstat_database.c.html#L28" title="utils/activity/pgstat_database.c:28">pgStatBlockReadTime</a> - startreadtime) / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; write_ms = (<span class="Type">double</span>) (<a href="../../utils/activity/pgstat_database.c.html#L29" title="utils/activity/pgstat_database.c:29">pgStatBlockWriteTime</a> - startwritetime) / <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;I/O timings: read: </span><span class="Special">%.3f</span><span class="Constant"> ms, write: </span><span class="Special">%.3f</span><span class="Constant"> ms</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; read_ms, write_ms);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secs_dur &gt; <span class="Constant">0</span> || usecs_dur &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; read_rate = (<span class="Type">double</span>) BLCKSZ * PageMissOp / (<span class="Constant">1024</span> * <span class="Constant">1024</span>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (secs_dur + usecs_dur / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; write_rate = (<span class="Type">double</span>) BLCKSZ * PageDirtyOp / (<span class="Constant">1024</span> * <span class="Constant">1024</span>) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (secs_dur + usecs_dur / <span class="Constant">1000000.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;avg read rate: </span><span class="Special">%.3f</span><span class="Constant"> MB/s, avg write rate: </span><span class="Special">%.3f</span><span class="Constant"> MB/s</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; read_rate, write_rate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;buffer usage: </span><span class="Special">%lld</span><span class="Constant"> hits, </span><span class="Special">%lld</span><span class="Constant"> misses, </span><span class="Special">%lld</span><span class="Constant"> dirtied</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) PageHitOp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) PageMissOp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) PageDirtyOp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;WAL usage: </span><span class="Special">%lld</span><span class="Constant"> <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, </span><span class="Special">%lld</span><span class="Constant"> full page images, </span><span class="Special">%llu</span><span class="Constant"> bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) walusage.wal_records,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span> <span class="Type">long</span>) walusage.wal_fpi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) walusage.wal_bytes);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <a href="../../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;system usage: </span><span class="Special">%s</span><span class="Constant">&quot;</span>), <a href="../../utils/misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;ru0));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(verbose ? INFO : LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, buf.data)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(buf.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup index statistics and index names */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; vacrel-&gt;nindexes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;indstats[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacrel-&gt;indstats[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (instrument)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(indnames[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>() -- workhorse function for VACUUM<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine prunes each page in the heap, and considers the need to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; freeze remaining tuples with storage (not including pages that can be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; skipped using the visibility map).&nbsp; Also performs related maintenance<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the FSM and visibility map.&nbsp; These steps all take place during an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; initial pass over the target heap relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also invokes <a href="#L1986" title="access/heap/vacuumlazy.c:1986">lazy_vacuum_all_indexes</a> to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> indexes, which largely<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; consists of deleting index tuples that point to LP_DEAD items left in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heap pages following pruning.&nbsp; Earlier initial pass over the heap will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; have collected the TIDs whose index tuples need to be removed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Finally, invokes <a href="#L2103" title="access/heap/vacuumlazy.c:2103">lazy_vacuum_heap_rel</a> to <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> heap pages, which<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; largely consists of marking LP_DEAD items (from vacrel-&gt;dead_items)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as LP_UNUSED.&nbsp; This has to happen in a second, final pass over the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heap, to preserve a basic invariant that all index AMs rely on: no<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; extant index tuple can ever be allowed to contain a TID that points to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; an LP_UNUSED line pointer in the heap.&nbsp; We must disallow premature<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; recycling of line pointers to avoid index scans that get confused<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; about which TID points to which tuple immediately after recycling.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (Actually, this isn't a concern when target heap relation happens to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; have no indexes, which allows us to safely apply the one-pass strategy<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as an optimization).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; In practice we often have enough space to fit all TIDs, and so won't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; need to call <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a> more than once, after our initial pass over<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the heap has totally finished.&nbsp; Otherwise things are slightly more<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; complicated: our &quot;initial pass&quot; over the heap applies only to those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pages that were pruned <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we needed to call <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a>, and our<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &quot;final pass&quot; over the heap only vacuums these same heap pages.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; However, we process indexes in full every time <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a> is called,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; which makes index processing very inefficient when memory is in short<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; supply.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L818">&#x200c;</a></span><span class="linkable">lazy_scan_heap</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber rel_pages = vacrel-&gt;rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_fsm_block_to_vacuum = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_according_to_vm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *dead_items = vacrel-&gt;dead_items;<br/></li>
<li>&nbsp; &nbsp; VacDeadItemsInfo *dead_items_info = vacrel-&gt;dead_items_info;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; initprog_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_TOTAL_HEAP_BLKS,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_MAX_DEAD_TUPLE_BYTES<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; initprog_val[<span class="Constant">3</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report that we're scanning the heap, advertising total # of blocks */<br/></li>
<li></span>&nbsp; &nbsp; initprog_val[<span class="Constant">0</span>] = PROGRESS_VACUUM_PHASE_SCAN_HEAP;<br/></li>
<li>&nbsp; &nbsp; initprog_val[<span class="Constant">1</span>] = rel_pages;<br/></li>
<li>&nbsp; &nbsp; initprog_val[<span class="Constant">2</span>] = dead_items_info-&gt;max_bytes;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">3</span>, initprog_index, initprog_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize for the first <a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>() call */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;current_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;next_unskippable_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;next_unskippable_allvis = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;next_unskippable_vmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>(vacrel, &amp;blkno, &amp;all_visible_according_to_vm))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_lpdead_items;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; got_cleanup_lock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;scanned_pages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report as block scanned, update error traceback information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_HEAP_BLKS_SCANNED, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(vacrel, <span class="Constant">NULL</span>, VACUUM_ERRCB_PHASE_SCAN_HEAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Regularly check if wraparound failsafe should <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is a similar check inside <a href="#L1986" title="access/heap/vacuumlazy.c:1986">lazy_vacuum_all_indexes</a>(), but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfrozenxid might start to look dangerously old <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we reach<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that point.&nbsp; This check also provides failsafe coverage for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one-pass strategy, and the two-pass strategy with the index_cleanup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * param set to 'off'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;scanned_pages % <a href="#L95" title="access/heap/vacuumlazy.c:95">FAILSAFE_EVERY_PAGES</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2296" title="access/heap/vacuumlazy.c:2296">lazy_check_wraparound_failsafe</a>(vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider if we definitely have enough space to process TIDs on page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already.&nbsp; If we are close to overrunning the available space for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dead_items TIDs, pause and do a cycle of vacuuming <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we tackle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../common/tidstore.c.html#L551" title="access/common/tidstore.c:551">TidStoreMemoryUsage</a>(dead_items) &gt; dead_items_info-&gt;max_bytes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before beginning index vacuuming, we release <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pin we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hold on the visibility map page.&nbsp; This isn't necessary for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctness, but we do it anyway to avoid holding the pin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * across a lengthy, unrelated operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perform a round of index and heap vacuuming */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;consider_bypass_optimization = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a>(vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Vacuum the Free Space Map to make newly-freed space visible on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level FSM pages.&nbsp; Note we have not yet processed blkno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(vacrel-&gt;rel, next_fsm_block_to_vacuum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_fsm_block_to_vacuum = blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report that we are once again scanning the heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_VACUUM_PHASE_SCAN_HEAP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pin the visibility map page in case we need to mark the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-visible.&nbsp; In most cases this will be very cheap, because we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already have the correct page pinned anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(vacrel-&gt;rel, blkno, &amp;vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(vacrel-&gt;rel, MAIN_FORKNUM, blkno, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;bstrategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a buffer <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock to prune HOT chains and defragment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page in <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>.&nbsp; But when it's not possible to acquire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock right away, we may be able to settle for reduced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing using <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; got_cleanup_lock = <a href="../../storage/buffer/bufmgr.c.html#L5326" title="storage/buffer/bufmgr.c:5326">ConditionalLockBufferForCleanup</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!got_cleanup_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for new or empty pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> lazy_scan_[no]prune call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1285" title="access/heap/vacuumlazy.c:1285">lazy_scan_new_or_empty</a>(vacrel, buf, blkno, page, !got_cleanup_lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Processed as new/empty page (lock and pin released) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't get the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, we can still collect LP_DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items in the dead_items area for later vacuuming, count live and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recently dead tuples for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> logging, and determine if this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block could later be truncated. If we encounter <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xid/mxids that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * require advancing the relfrozenxid/relminxid, we'll have to wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock and call <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!got_cleanup_lock &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>(vacrel, buf, blkno, page, &amp;has_lpdead_items))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a> could not do all required processing.&nbsp; Wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, and call <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> in the usual way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(vacrel-&gt;aggressive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; got_cleanup_lock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, we must <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> prune, freeze, and count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples. We may have acquired the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock originally, or we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have gone back and acquired it after <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>() returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * false. Either way, the page hasn't been processed yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>(), <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>() will count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recently_dead_tuples and live tuples for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> logging, determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the block can later be truncated, and accumulate the details of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining LP_DEAD line pointers on the page into dead_items. These<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dead items include those pruned by <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>() as well as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * line pointers previously marked LP_DEAD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (got_cleanup_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>(vacrel, buf, blkno, page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, all_visible_according_to_vm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;has_lpdead_items);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now drop the buffer lock and, potentially, update the FSM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our goal is to update the freespace map the last time we touch the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page. If we'll process a block in the second pass, we may free up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional space on the page, so it is better to update the FSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after the second pass. If the relation has no indexes, or if index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * vacuuming is disabled, there will be no second heap pass; if this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * particular page has no dead items, the second heap pass will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * touch this page. So, in those cases, update the FSM <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: In corner cases, it's possible to <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> updating the FSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely. If index vacuuming is currently enabled, we'll <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FSM update <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. But if failsafe mode is later activated, or there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are so few dead tuples that index vacuuming is bypassed, there will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also be no opportunity to update the FSM later, because we'll never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * revisit this page. Since updating the FSM is desirable but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * absolutely required, that's OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;nindexes == <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !vacrel-&gt;do_index_vacuuming<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !has_lpdead_items)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(vacrel-&gt;rel, blkno, freespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Periodically perform FSM vacuuming to make newly-freed space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visible on <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> FSM pages. This is done after vacuuming if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table has indexes. There will only be newly-freed space if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * held the <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock and <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>() was called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (got_cleanup_lock &amp;&amp; vacrel-&gt;nindexes == <span class="Constant">0</span> &amp;&amp; has_lpdead_items &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno - next_fsm_block_to_vacuum &gt;= <a href="#L104" title="access/heap/vacuumlazy.c:104">VACUUM_FSM_EVERY_PAGES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(vacrel-&gt;rel, next_fsm_block_to_vacuum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_fsm_block_to_vacuum = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;blkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report that everything is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> scanned */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_HEAP_BLKS_SCANNED, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can compute the new value for pg_class.reltuples */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;new_live_tuples = <a href="../../commands/vacuum.c.html#L1302" title="commands/vacuum.c:1302">vac_estimate_reltuples</a>(vacrel-&gt;rel, rel_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;scanned_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;live_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also compute the total number of surviving heap entries.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (unlikely) scenario that new_live_tuples is -1, take it as zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;new_rel_tuples =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Max(vacrel-&gt;new_live_tuples, <span class="Constant">0</span>) + vacrel-&gt;recently_dead_tuples +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;missed_dead_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do index vacuuming (call each index's ambulkdelete routine), then do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * related heap vacuuming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dead_items_info-&gt;num_items &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1861" title="access/heap/vacuumlazy.c:1861">lazy_vacuum</a>(vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vacuum the remainder of the Free Space Map.&nbsp; We must do this whether or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not there were indexes, and whether or not we bypassed index vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt; next_fsm_block_to_vacuum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(vacrel-&gt;rel, next_fsm_block_to_vacuum, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* report all blocks vacuumed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_HEAP_BLKS_VACUUMED, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do final index <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> (call each index's amvacuumcleanup routine) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;nindexes &gt; <span class="Constant">0</span> &amp;&amp; vacrel-&gt;do_index_cleanup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2349" title="access/heap/vacuumlazy.c:2349">lazy_cleanup_all_indexes</a>(vacrel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>() -- get <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> to process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>() calls here every time it needs to get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block to<br/></li>
<li></span><span class="Comment"> * prune and <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; The function uses the visibility map, <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> options,<br/></li>
<li></span><span class="Comment"> * and various thresholds to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> blocks which do not need to be processed and<br/></li>
<li></span><span class="Comment"> * sets blkno to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block to process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The block number and visibility status of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block to process are set<br/></li>
<li></span><span class="Comment"> * in *blkno and *all_visible_according_to_vm.&nbsp; The return value is false if<br/></li>
<li></span><span class="Comment"> * there are no further blocks to process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * vacrel is an in/out parameter here.&nbsp; Vacuum options and information about<br/></li>
<li></span><span class="Comment"> * the relation are read.&nbsp; vacrel-&gt;skippedallvis is set if we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a block<br/></li>
<li></span><span class="Comment"> * that's all-visible but not all-frozen, to ensure that we don't update<br/></li>
<li></span><span class="Comment"> * relfrozenxid in that case.&nbsp; vacrel also holds information about the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * unskippable block, as bookkeeping for this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1088">&#x200c;</a></span><span class="linkable">heap_vac_scan_next_block</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, BlockNumber *blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *all_visible_according_to_vm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber next_block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* relies on InvalidBlockNumber + 1 overflowing to 0 on first call */<br/></li>
<li></span>&nbsp; &nbsp; next_block = vacrel-&gt;current_block + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Have we reached the end of the relation? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (next_block &gt;= vacrel-&gt;rel_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vacrel-&gt;next_unskippable_vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vacrel-&gt;next_unskippable_vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;next_unskippable_vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *blkno = vacrel-&gt;rel_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must be in one of the three following states:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (next_block &gt; vacrel-&gt;next_unskippable_block ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;next_unskippable_block == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1. We have just processed an unskippable block (or we're at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beginning of the scan).&nbsp; Find the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> unskippable block using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visibility map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipsallvis;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1186" title="access/heap/vacuumlazy.c:1186">find_next_unskippable_block</a>(vacrel, &amp;skipsallvis);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> know the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block that we must process.&nbsp; It can be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block after the one we just processed, or something further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ahead.&nbsp; If it's further ahead, we can jump to it, but we choose to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do so only if we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> at least <a href="#L111" title="access/heap/vacuumlazy.c:111">SKIP_PAGES_THRESHOLD</a> consecutive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages.&nbsp; Since we're reading sequentially, the OS should be doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * readahead for us, so there's no gain in skipping a page <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then.&nbsp; Skipping such a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> might even discourage sequential<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detection.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This test also enables more frequent relfrozenxid advancement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during non-aggressive VACUUMs.&nbsp; If the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> has <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> all-visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages then skipping makes updating relfrozenxid unsafe, which is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * real downside.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;next_unskippable_block - next_block &gt;= <a href="#L111" title="access/heap/vacuumlazy.c:111">SKIP_PAGES_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_block = vacrel-&gt;next_unskippable_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skipsallvis)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;skippedallvis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we must be in one of the two remaining states: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (next_block &lt; vacrel-&gt;next_unskippable_block)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 2. We are processing a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of blocks that we could have skipped<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but chose not to.&nbsp; We know that they are all-visible in the VM,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise they would've been unskippable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *blkno = vacrel-&gt;current_block = next_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *all_visible_according_to_vm = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 3. We reached the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> unskippable block.&nbsp; Process it.&nbsp; On <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration, we will be back in state 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(next_block == vacrel-&gt;next_unskippable_block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *blkno = vacrel-&gt;current_block = next_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *all_visible_according_to_vm = vacrel-&gt;next_unskippable_allvis;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> unskippable block in a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> scan using the visibility map.<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> unskippable block and its visibility information is updated in<br/></li>
<li></span><span class="Comment"> * vacrel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: our opinion of which blocks can be skipped can go stale immediately.<br/></li>
<li></span><span class="Comment"> * It's okay if caller &quot;misses&quot; a page whose all-visible or all-frozen marking<br/></li>
<li></span><span class="Comment"> * was concurrently cleared, though.&nbsp; All that matters is that caller scan all<br/></li>
<li></span><span class="Comment"> * pages whose tuples might contain XIDs &lt; OldestXmin, or MXIDs &lt; OldestMxact.<br/></li>
<li></span><span class="Comment"> * (Actually, non-aggressive VACUUMs can choose to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all-visible pages with<br/></li>
<li></span><span class="Comment"> * older XIDs/MXIDs.&nbsp; The *skippedallvis flag will be set here when the choice<br/></li>
<li></span><span class="Comment"> * to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> such a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is actually made, making everything safe.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1186">&#x200c;</a></span><span class="linkable">find_next_unskippable_block</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *skipsallvis)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber rel_pages = vacrel-&gt;rel_pages;<br/></li>
<li>&nbsp; &nbsp; BlockNumber next_unskippable_block = vacrel-&gt;next_unskippable_block + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; next_unskippable_vmbuffer = vacrel-&gt;next_unskippable_vmbuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; next_unskippable_allvis;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *skipsallvis = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; mapbits = <a href="visibilitymap.c.html#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a>(vacrel-&gt;rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_unskippable_block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;next_unskippable_vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_unskippable_allvis = (mapbits &amp; VISIBILITYMAP_ALL_VISIBLE) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A block is unskippable if it is not all visible according to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visibility map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!next_unskippable_allvis)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((mapbits &amp; VISIBILITYMAP_ALL_FROZEN) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller must scan the last page to determine whether it has tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (caller must have the opportunity to set vacrel-&gt;nonempty_pages).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This rule avoids having <a href="#L2546" title="access/heap/vacuumlazy.c:2546">lazy_truncate_heap</a>() take access-exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on rel to attempt a truncation that fails anyway, just because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there are tuples on the last page (it is likely that there will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples on other nearby pages as well, but those can be skipped).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Implement this by always treating the last block as unsafe to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (next_unskippable_block == rel_pages - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* DISABLE_PAGE_SKIPPING makes all skipping unsafe */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vacrel-&gt;skipwithvm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Aggressive VACUUM caller can't <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> pages just because they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-visible.&nbsp; They may still <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> all-frozen pages, which can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain XIDs &lt; OldestXmin (XIDs that aren't already frozen by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((mapbits &amp; VISIBILITYMAP_ALL_FROZEN) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;aggressive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All-visible block is safe to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> in non-aggressive case.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remember that the final <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> contains such a block for later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *skipsallvis = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_unskippable_block++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write the local variables back to vacrel */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;next_unskippable_block = next_unskippable_block;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;next_unskippable_allvis = next_unskippable_allvis;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;next_unskippable_vmbuffer = next_unskippable_vmbuffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1285" title="access/heap/vacuumlazy.c:1285">lazy_scan_new_or_empty</a>() -- <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>() new/empty page handling.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must call here to handle both new and empty pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling<br/></li>
<li></span><span class="Comment"> * <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> or <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>, since they're not prepared to deal<br/></li>
<li></span><span class="Comment"> * with new or empty pages.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's necessary to consider new pages as a special case, since the rules for<br/></li>
<li></span><span class="Comment"> * maintaining the visibility map and FSM with empty pages are a little<br/></li>
<li></span><span class="Comment"> * different (though new pages can be truncated away during rel truncation).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Empty pages are not really a special case -- they're just heap pages that<br/></li>
<li></span><span class="Comment"> * have no allocated tuples (including even LP_UNUSED items).&nbsp; You might<br/></li>
<li></span><span class="Comment"> * wonder why we need to handle them here all the same.&nbsp; It's only necessary<br/></li>
<li></span><span class="Comment"> * because of a corner-case involving a hard crash during heap relation<br/></li>
<li></span><span class="Comment"> * extension.&nbsp; If we ever make relation-extension crash safe, then it should<br/></li>
<li></span><span class="Comment"> * no longer be necessary to deal with empty pages here (or new pages, for<br/></li>
<li></span><span class="Comment"> * that matter).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold at least a shared lock.&nbsp; We might need to escalate the<br/></li>
<li></span><span class="Comment"> * lock in that case, so the type of lock caller holds needs to be specified<br/></li>
<li></span><span class="Comment"> * using 'sharelock' argument.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false in common case where caller should go on to call<br/></li>
<li></span><span class="Comment"> * <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> (or <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>).&nbsp; Otherwise returns true, indicating<br/></li>
<li></span><span class="Comment"> * that <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a> is done processing the page, releasing lock on caller's<br/></li>
<li></span><span class="Comment"> * behalf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1285">&#x200c;</a></span><span class="linkable">lazy_scan_new_or_empty</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, Buffer buf, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page page, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sharelock, Buffer vmbuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All-zeroes pages can be left over if either a backend extends the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation by a single page, but crashes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the newly initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page has been written out, or when bulk-extending the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which creates a number of empty pages at the tail end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation), and then enters them into the FSM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we do not enter the page into the visibilitymap. That has the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downside that we repeatedly visit this page in subsequent vacuums,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but otherwise we'll never discover the space on a promoted standby.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The harm of repeated checking ought to normally not be too bad. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space usually should be used at some point, otherwise there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> regular vacuums.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure these pages are in the FSM, to ensure they can be reused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do that by testing if there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> space recorded for the page. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not, enter it. We do so after releasing the lock on the heap page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the FSM is approximate, after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/freespace/freespace.c.html#L244" title="storage/freespace/freespace.c:244">GetRecordedFreeSpace</a>(vacrel-&gt;rel, blkno) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freespace = BLCKSZ - SizeOfPageHeaderData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(vacrel-&gt;rel, blkno, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It seems likely that caller will always be able to get a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock on an empty page.&nbsp; But don't take <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> chances -- escalate to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an exclusive lock (still don't need a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, though).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sharelock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page isn't new or empty -- keep lock and pin for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already have a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock (which is more than enough) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlike new pages, empty pages are always set all-visible and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark buffer dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing a WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that another backend has extended the heap,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initialized the page, and then failed to WAL-log the page due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to an ERROR.&nbsp; Since heap extension is not WAL-logged, recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might try to replay our record setting the page all-visible and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that the page isn't initialized, which will cause a PANIC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To prevent that, check whether the page has been previously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logged, and if not, do that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(vacrel-&gt;rel) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetLSN(page) == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a>(buf, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(vacrel-&gt;rel, blkno, buf, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_VISIBLE | VISIBILITYMAP_ALL_FROZEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(vacrel-&gt;rel, blkno, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* page isn't new or empty -- keep lock and pin */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* qsort comparator for sorting OffsetNumbers */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1389">&#x200c;</a></span><span class="linkable">cmpOffsetNumbers</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u16(*(<span class="Type">const</span> OffsetNumber *) a, *(<span class="Type">const</span> OffsetNumber *) b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>() -- <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a>() pruning and freezing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold pin and buffer <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on the buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * vmbuffer is the buffer containing the VM block with visibility information<br/></li>
<li></span><span class="Comment"> * for the heap block, blkno. all_visible_according_to_vm is the saved<br/></li>
<li></span><span class="Comment"> * visibility status of the heap block looked up earlier by the caller. We<br/></li>
<li></span><span class="Comment"> * won't rely entirely on this status, as it may be out of date.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *has_lpdead_items is set to true or false depending on whether, upon return<br/></li>
<li></span><span class="Comment"> * from this function, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items are still present on the page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1408">&#x200c;</a></span><span class="linkable">lazy_scan_prune</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_visible_according_to_vm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_lpdead_items)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = vacrel-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; PruneFreezeResult presult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prune_options = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf) == blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prune all HOT-update chains and potentially freeze tuples on this page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation has no indexes, we can immediately mark would-be dead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items LP_UNUSED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The number of tuples removed from the page is returned in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * presult.ndeleted.&nbsp; It should not be confused with presult.lpdead_items;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * presult.lpdead_items's final value can be thought of as the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples that were deleted from indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will update the VM after collecting LP_DEAD items and freezing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples. Pruning will have determined whether or not the page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all-visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prune_options = HEAP_PAGE_PRUNE_FREEZE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;nindexes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prune_options |= HEAP_PAGE_PRUNE_MARK_UNUSED_NOW;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pruneheap.c.html#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>(rel, buf, vacrel-&gt;vistest, prune_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vacrel-&gt;cutoffs, &amp;presult, PRUNE_VACUUM_SCAN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vacrel-&gt;offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vacrel-&gt;NewRelfrozenXid, &amp;vacrel-&gt;NewRelminMxid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(MultiXactIdIsValid(vacrel-&gt;NewRelminMxid));<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(vacrel-&gt;NewRelfrozenXid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (presult.nfrozen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't increment the frozen_pages instrumentation counter when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nfrozen == 0, since it only counts pages with newly frozen tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (don't confuse that with pages newly set all-frozen in VM).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;frozen_pages++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM will call <a href="#L2948" title="access/heap/vacuumlazy.c:2948">heap_page_is_all_visible</a>() during the second pass over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the heap to determine all_visible and all_frozen for the page -- this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a specialized version of the logic from this function.&nbsp; Now that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've finished pruning and freezing, make sure that we're in total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * agreement with <a href="#L2948" title="access/heap/vacuumlazy.c:2948">heap_page_is_all_visible</a>() using an assertion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Note that all_frozen value does not matter when !all_visible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (presult.all_visible)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId debug_cutoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; debug_all_frozen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(presult.lpdead_items == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2948" title="access/heap/vacuumlazy.c:2948">heap_page_is_all_visible</a>(vacrel, buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;debug_cutoff, &amp;debug_all_frozen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(presult.all_frozen == debug_all_frozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(debug_cutoff) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; debug_cutoff == presult.vm_conflict_horizon);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now save details of the LP_DEAD items from the page in vacrel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (presult.lpdead_items &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;lpdead_item_pages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadoffsets are collected incrementally in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="pruneheap.c.html#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() as each dead line pointer is recorded,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with an indeterminate order, but <a href="#L2884" title="access/heap/vacuumlazy.c:2884">dead_items_add</a> requires them to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sorted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(presult.deadoffsets, presult.lpdead_items, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1389" title="access/heap/vacuumlazy.c:1389">cmpOffsetNumbers</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2884" title="access/heap/vacuumlazy.c:2884">dead_items_add</a>(vacrel, blkno, presult.deadoffsets, presult.lpdead_items);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, add page-local counts to whole-VACUUM counts */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;tuples_deleted += presult.ndeleted;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;tuples_frozen += presult.nfrozen;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;lpdead_items += presult.lpdead_items;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;live_tuples += presult.live_tuples;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;recently_dead_tuples += presult.recently_dead_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't truncate this page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (presult.hastup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;nonempty_pages = blkno + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> LP_DEAD items? */<br/></li>
<li></span>&nbsp; &nbsp; *has_lpdead_items = (presult.lpdead_items &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!presult.all_visible || !(*has_lpdead_items));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle setting visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> based on information from the VM (as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of last <a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>() call), and from all_visible and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all_frozen variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!all_visible_according_to_vm &amp;&amp; presult.all_visible)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = VISIBILITYMAP_ALL_VISIBLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presult.all_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(presult.vm_conflict_horizon));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= VISIBILITYMAP_ALL_FROZEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It should never be the case that the visibility map page is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while the page-level <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is clear, but the reverse is allowed (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checksums are not enabled).&nbsp; Regardless, set both bits so that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get back in sync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: If the heap page is all-visible but the VM <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is not set, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need to dirty the heap page.&nbsp; However, if checksums are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enabled, we do need to make sure that the heap page is dirtied<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> passing it to <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(), because it may be logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Given that this situation should only happen in rare cases after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash, it is not worth optimizing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(vacrel-&gt;rel, blkno, buf, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, presult.vm_conflict_horizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As of PostgreSQL 9.2, the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> should never be set if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page-level <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is clear.&nbsp; However, it's possible that the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleared after <a href="#L1088" title="access/heap/vacuumlazy.c:1088">heap_vac_scan_next_block</a>() was called, so we must recheck<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with buffer lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> concluding that the VM is corrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (all_visible_according_to_vm &amp;&amp; !PageIsAllVisible(page) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="visibilitymap.c.html#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a>(vacrel-&gt;rel, blkno, &amp;vmbuffer) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;page is not marked all-visible but visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> page </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;relname, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(vacrel-&gt;rel, blkno, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible for the value returned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>() to move backwards, so it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong for us to see tuples that appear to not be visible to everyone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * yet, while PD_ALL_VISIBLE is already set. The real safe xmin value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never moves backwards, but <a href="../../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>() is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conservative and sometimes returns a value that's unnecessarily small,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so if we see that contradiction it just means that the tuples that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think are not visible to everyone yet actually are, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PD_ALL_VISIBLE flag is correct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There should never be LP_DEAD items on a page with PD_ALL_VISIBLE set,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (presult.lpdead_items &gt; <span class="Constant">0</span> &amp;&amp; PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;page containing LP_DEAD items is marked as all-visible in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> page </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;relname, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(vacrel-&gt;rel, blkno, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the all-visible page is all-frozen but not marked as such yet, mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it as all-frozen.&nbsp; Note that all_frozen is only valid if all_visible is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true, so we must check both all_visible and all_frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (all_visible_according_to_vm &amp;&amp; presult.all_visible &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; presult.all_frozen &amp;&amp; !VM_ALL_FROZEN(vacrel-&gt;rel, blkno, &amp;vmbuffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid relying on all_visible_according_to_vm as a proxy for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page-level PD_ALL_VISIBLE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> being set, since it might have become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stale -- even when all_visible is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the page all-frozen (and all-visible) in the VM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can pass InvalidTransactionId as our cutoff_xid, since a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshotConflictHorizon sufficient to make everything safe for REDO<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was logged when the page's tuples were frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(presult.vm_conflict_horizon));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(vacrel-&gt;rel, blkno, buf, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_VISIBLE |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_FROZEN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1650" title="access/heap/vacuumlazy.c:1650">lazy_scan_noprune</a>() -- <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>() without pruning or freezing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller need only hold a pin and share lock on the buffer, unlike<br/></li>
<li></span><span class="Comment"> * <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>, which requires a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock.&nbsp; While pruning isn't<br/></li>
<li></span><span class="Comment"> * performed here, it's quite possible that an earlier opportunistic pruning<br/></li>
<li></span><span class="Comment"> * operation left LP_DEAD items behind.&nbsp; We'll at least collect <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such items<br/></li>
<li></span><span class="Comment"> * in dead_items for removal from indexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For aggressive VACUUM callers, we may return false to indicate that a full<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock is required for processing by <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>.&nbsp; This is only<br/></li>
<li></span><span class="Comment"> * necessary when the aggressive VACUUM needs to freeze some tuple XIDs from<br/></li>
<li></span><span class="Comment"> * one or more tuples on the page.&nbsp; We always return true for non-aggressive<br/></li>
<li></span><span class="Comment"> * callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If this function returns true, *has_lpdead_items gets set to true or false<br/></li>
<li></span><span class="Comment"> * depending on whether, upon return from this function, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items are<br/></li>
<li></span><span class="Comment"> * present on the page. If this function returns false, *has_lpdead_items<br/></li>
<li></span><span class="Comment"> * is not updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1650">&#x200c;</a></span><span class="linkable">lazy_scan_noprune</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_lpdead_items)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpdead_items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; live_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recently_dead_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missed_dead_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hastup;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader tupleheader;<br/></li>
<li>&nbsp; &nbsp; TransactionId NoFreezePageRelfrozenXid = vacrel-&gt;NewRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId NoFreezePageRelminMxid = vacrel-&gt;NewRelminMxid;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber deadoffsets[MaxHeapTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf) == blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hastup = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; lpdead_items = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; recently_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; missed_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;offnum = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hastup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsDead(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deliberately don't set hastup=true here.&nbsp; See same point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> for an explanation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deadoffsets[lpdead_items++] = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hastup = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page prevents rel truncation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupleheader = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="heapam.c.html#L7374" title="access/heap/heapam.c:7374">heap_tuple_should_freeze</a>(tupleheader, &amp;vacrel-&gt;cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;NoFreezePageRelfrozenXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;NoFreezePageRelminMxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple with XID &lt; FreezeLimit (or MXID &lt; MultiXactCutoff) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;aggressive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Aggressive VACUUMs must always be able to advance rel's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfrozenxid to a value &gt;= FreezeLimit (and be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance rel's relminmxid to a value &gt;= MultiXactCutoff).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The ongoing aggressive VACUUM won't be able to do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unless it can freeze an XID (or MXID) from this tuple <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only safe option is to have caller perform processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of this page using <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>.&nbsp; Caller might have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wait a while for a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, but it can't be helped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;offnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-aggressive VACUUMs are under no obligation to advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relfrozenxid (even by one XID).&nbsp; We can be much laxer here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently we always just <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> an older final relfrozenxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and/or relminmxid value.&nbsp; We never make caller wait or work a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * little harder, even when it likely makes sense to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;(tuple.t_self), blkno, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_data = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_len = ItemIdGetLength(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_tableOid = RelationGetRelid(vacrel-&gt;rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>(&amp;tuple, vacrel-&gt;cutoffs.OldestXmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DELETE_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_LIVE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count both cases as live, just like <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; live_tuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DEAD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is some useful work for pruning to do, that won't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done due to failure to get a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missed_dead_tuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_RECENTLY_DEAD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count in recently_dead_tuples, just like <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recently_dead_tuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_INSERT_IN_PROGRESS:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not count these rows as live, just like <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a> result&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;offnum = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here we know for sure that caller can put off freezing and pruning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this particular page until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> VACUUM.&nbsp; Remember its details <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (<a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> expects a clean slate, so we have to do this last.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;NewRelfrozenXid = NoFreezePageRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;NewRelminMxid = NoFreezePageRelminMxid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items found on the page in dead_items */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;nindexes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Using one-pass strategy (since table has no indexes) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lpdead_items &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perfunctory handling for the corner case where a single pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy VACUUM cannot get a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, and it turns out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that there is one or more LP_DEAD items: just count the LP_DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items as missed_dead_tuples instead. (This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> dishonest,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it beats having to maintain specialized heap vacuuming code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forever, for vanishingly little benefit.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hastup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missed_dead_tuples += lpdead_items;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (lpdead_items &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Page has LP_DEAD items, and so <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> references/TIDs that remain in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes will be deleted during index vacuuming (and then marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LP_UNUSED in the heap)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;lpdead_item_pages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2884" title="access/heap/vacuumlazy.c:2884">dead_items_add</a>(vacrel, blkno, deadoffsets, lpdead_items);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;lpdead_items += lpdead_items;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, add relevant page-local counts to whole-VACUUM counts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;live_tuples += live_tuples;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;recently_dead_tuples += recently_dead_tuples;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;missed_dead_tuples += missed_dead_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (missed_dead_tuples &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;missed_dead_pages++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't truncate this page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hastup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;nonempty_pages = blkno + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> LP_DEAD items? */<br/></li>
<li></span>&nbsp; &nbsp; *has_lpdead_items = (lpdead_items &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller won't need to call <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> with same page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point for index vacuuming and heap vacuuming.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Removes items collected in dead_items from table's indexes, then marks the<br/></li>
<li></span><span class="Comment"> * same items LP_UNUSED in the heap.&nbsp; See the comments above <a href="#L818" title="access/heap/vacuumlazy.c:818">lazy_scan_heap</a><br/></li>
<li></span><span class="Comment"> * for full details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also empties dead_items, freeing up space for later TIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We may choose to bypass index vacuuming at this point, though only when the<br/></li>
<li></span><span class="Comment"> * ongoing VACUUM operation will definitely only have one index scan/round of<br/></li>
<li></span><span class="Comment"> * index vacuuming.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1861">&#x200c;</a></span><span class="linkable">lazy_vacuum</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bypass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not end up here with no indexes */<br/></li>
<li></span>&nbsp; &nbsp; Assert(vacrel-&gt;nindexes &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;lpdead_item_pages &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!vacrel-&gt;do_index_vacuuming)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!vacrel-&gt;do_index_cleanup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2901" title="access/heap/vacuumlazy.c:2901">dead_items_reset</a>(vacrel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider bypassing index vacuuming (and heap vacuuming) entirely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We currently only do this in cases where the number of LP_DEAD items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the entire VACUUM operation is close to zero.&nbsp; This avoids sharp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * discontinuities in the duration and overhead of successive VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operations that run against the same table with a fixed workload.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ideally, successive VACUUM operations will behave as if there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly zero LP_DEAD items in cases where there are close to zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is likely to be helpful with a table that is continually affected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by UPDATEs that can mostly apply the HOT optimization, but occasionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have small aberrations that lead to just a few heap pages retaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only one or two LP_DEAD items.&nbsp; This is pretty common; even when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DBA goes out of their way to make UPDATEs use HOT, it is practically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * impossible to predict whether HOT will be applied in 100% of cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's far easier to ensure that 99%+ of all UPDATEs against a table use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HOT through careful tuning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bypass = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vacrel-&gt;consider_bypass_optimization &amp;&amp; vacrel-&gt;rel_pages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber threshold;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vacrel-&gt;num_index_scans == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vacrel-&gt;lpdead_items == vacrel-&gt;dead_items_info-&gt;num_items);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vacrel-&gt;do_index_vacuuming);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(vacrel-&gt;do_index_cleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This crossover point at which we'll start to do index vacuuming is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressed as a percentage of the total number of heap pages in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table that are known to have at least one LP_DEAD item.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much more important than the total number of LP_DEAD items, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's a proxy for the number of heap pages whose visibility map bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot be set on account of bypassing index and heap vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We apply one further precautionary test: the space currently used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to store the TIDs (TIDs that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> all point to LP_DEAD items) must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not exceed 32MB.&nbsp; This limits the risk that we will bypass index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * vacuuming again and again until eventually there is a VACUUM whose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dead_items space is not CPU cache resident.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't take <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> special steps to remember the LP_DEAD items (such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as counting them in our final update to the stats system) when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimization is applied.&nbsp; Though the accounting used in <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/analyze.c.html#L1153" title="commands/analyze.c:1153">acquire_sample_rows</a>() will recognize the same LP_DEAD items as dead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows in its own stats report, that's okay. The discrepancy should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be negligible.&nbsp; If this optimization is ever expanded to cover more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases then this may need to be reconsidered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; threshold = (<span class="Type">double</span>) vacrel-&gt;rel_pages * <a href="#L89" title="access/heap/vacuumlazy.c:89">BYPASS_THRESHOLD_PAGES</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bypass = (vacrel-&gt;lpdead_item_pages &lt; threshold &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../common/tidstore.c.html#L551" title="access/common/tidstore.c:551">TidStoreMemoryUsage</a>(vacrel-&gt;dead_items) &lt; (<span class="Constant">32L</span> * <span class="Constant">1024L</span> * <span class="Constant">1024L</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bypass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are almost zero TIDs.&nbsp; Behave as if there were precisely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zero: bypass index vacuuming, but do index <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect that the ongoing VACUUM operation will finish very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quickly, so there is no point in considering speeding up as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failsafe against wraparound failure. (Index <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is expected to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finish very quickly in cases where there were no ambulkdelete()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calls.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;do_index_vacuuming = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1986" title="access/heap/vacuumlazy.c:1986">lazy_vacuum_all_indexes</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We successfully completed a round of index vacuuming.&nbsp; Do related<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap vacuuming <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2103" title="access/heap/vacuumlazy.c:2103">lazy_vacuum_heap_rel</a>(vacrel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failsafe case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We attempted index vacuuming, but didn't finish a full round/full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index scan.&nbsp; This happens when relfrozenxid or relminmxid is too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far in the past.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * From this point on the VACUUM operation will do no further index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * vacuuming or heap vacuuming.&nbsp; This VACUUM operation won't end up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back here again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forget the LP_DEAD items that we just vacuumed (or just decided to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2901" title="access/heap/vacuumlazy.c:2901">dead_items_reset</a>(vacrel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1986" title="access/heap/vacuumlazy.c:1986">lazy_vacuum_all_indexes</a>() -- Main entry for index vacuuming<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true in the common case when all indexes were successfully<br/></li>
<li></span><span class="Comment"> * vacuumed.&nbsp; Returns false in rare cases where we determined that the ongoing<br/></li>
<li></span><span class="Comment"> * VACUUM operation is at risk of taking too long to finish, leading to<br/></li>
<li></span><span class="Comment"> * wraparound failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1986">&#x200c;</a></span><span class="linkable">lazy_vacuum_all_indexes</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allindexes = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; old_live_tuples = vacrel-&gt;rel-&gt;rd_rel-&gt;reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_start_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_TOTAL<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_end_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_PROCESSED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_NUM_INDEX_VACUUMS<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; progress_start_val[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; progress_end_val[<span class="Constant">3</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;nindexes &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_vacuuming);<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_cleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Precheck for XID wraparound emergencies */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2296" title="access/heap/vacuumlazy.c:2296">lazy_check_wraparound_failsafe</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wraparound emergency -- don't even start an index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report that we are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> vacuuming indexes and the number of indexes to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; progress_start_val[<span class="Constant">0</span>] = PROGRESS_VACUUM_PHASE_VACUUM_INDEX;<br/></li>
<li>&nbsp; &nbsp; progress_start_val[<span class="Constant">1</span>] = vacrel-&gt;nindexes;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">2</span>, progress_start_index, progress_start_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L123" title="access/heap/vacuumlazy.c:123">ParallelVacuumIsActive</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> idx = <span class="Constant">0</span>; idx &lt; vacrel-&gt;nindexes; idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indrel = vacrel-&gt;indrels[idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteResult *istat = vacrel-&gt;indstats[idx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;indstats[idx] = <a href="#L2417" title="access/heap/vacuumlazy.c:2417">lazy_vacuum_one_index</a>(indrel, istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_live_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the number of indexes vacuumed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_INDEXES_PROCESSED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2296" title="access/heap/vacuumlazy.c:2296">lazy_check_wraparound_failsafe</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wraparound emergency -- end current index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allindexes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Outsource everything to parallel variant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuumparallel.c.html#L499" title="commands/vacuumparallel.c:499">parallel_vacuum_bulkdel_all_indexes</a>(vacrel-&gt;pvs, old_live_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;num_index_scans);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do a postcheck to consider applying wraparound failsafe <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that parallel VACUUM only gets the precheck and this postcheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2296" title="access/heap/vacuumlazy.c:2296">lazy_check_wraparound_failsafe</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allindexes = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We delete all LP_DEAD items from the first heap pass in all indexes on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each call here (except calls where we choose to do the failsafe). This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * makes the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L2103" title="access/heap/vacuumlazy.c:2103">lazy_vacuum_heap_rel</a>() safe (except in the event<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the failsafe triggering, which prevents the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call from taking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * place).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(vacrel-&gt;num_index_scans &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;dead_items_info-&gt;num_items == vacrel-&gt;lpdead_items);<br/></li>
<li>&nbsp; &nbsp; Assert(allindexes || <a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Increase and report the number of index scans.&nbsp; Also, we reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PROGRESS_VACUUM_INDEXES_TOTAL and PROGRESS_VACUUM_INDEXES_PROCESSED.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We deliberately include the case where we started a round of bulk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deletes that we weren't able to finish due to the failsafe triggering.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;num_index_scans++;<br/></li>
<li>&nbsp; &nbsp; progress_end_val[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; progress_end_val[<span class="Constant">1</span>] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; progress_end_val[<span class="Constant">2</span>] = vacrel-&gt;num_index_scans;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">3</span>, progress_end_index, progress_end_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> allindexes;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2103" title="access/heap/vacuumlazy.c:2103">lazy_vacuum_heap_rel</a>() -- second pass over the heap for two pass strategy<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine marks LP_DEAD items in vacrel-&gt;dead_items as LP_UNUSED. Pages<br/></li>
<li></span><span class="Comment"> * that never had <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> record LP_DEAD items are not visited at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We may also be able to truncate the line pointer array of the heap pages we<br/></li>
<li></span><span class="Comment"> * visit.&nbsp; If there is a contiguous group of LP_UNUSED items at the end of the<br/></li>
<li></span><span class="Comment"> * array, it can be reclaimed as free space.&nbsp; These LP_UNUSED items usually<br/></li>
<li></span><span class="Comment"> * start out as LP_DEAD items recorded by <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> (we set items from<br/></li>
<li></span><span class="Comment"> * each page to LP_UNUSED, and then consider if it's possible to truncate the<br/></li>
<li></span><span class="Comment"> * page's line pointer array).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the reason for doing this as a second pass is we cannot remove the<br/></li>
<li></span><span class="Comment"> * tuples until we've removed their index entries, and we want to process<br/></li>
<li></span><span class="Comment"> * index entry removal in batches as large as possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2103">&#x200c;</a></span><span class="linkable">lazy_vacuum_heap_rel</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber vacuumed_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> saved_err_info;<br/></li>
<li>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L135" title="access/common/tidstore.c:135">TidStoreIter</a> *iter;<br/></li>
<li>&nbsp; &nbsp; TidStoreIterResult *iter_result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_vacuuming);<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_cleanup);<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;num_index_scans &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report that we are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> vacuuming the heap */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_VACUUM_PHASE_VACUUM_HEAP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update error traceback information */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(vacrel, &amp;saved_err_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACUUM_ERRCB_PHASE_VACUUM_HEAP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iter = <a href="../common/tidstore.c.html#L482" title="access/common/tidstore.c:482">TidStoreBeginIterate</a>(vacrel-&gt;dead_items);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((iter_result = <a href="../common/tidstore.c.html#L511" title="access/common/tidstore.c:511">TidStoreIterateNext</a>(iter)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = iter_result-&gt;blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;blkno = blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pin the visibility map page in case we need to mark the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-visible.&nbsp; In most cases this will be very cheap, because we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already have the correct page pinned anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(vacrel-&gt;rel, blkno, &amp;vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We need a non-<a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> exclusive lock to mark dead_items unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(vacrel-&gt;rel, MAIN_FORKNUM, blkno, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;bstrategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2191" title="access/heap/vacuumlazy.c:2191">lazy_vacuum_heap_page</a>(vacrel, blkno, buf, iter_result-&gt;offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter_result-&gt;num_offsets, vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now that we've vacuumed the page, record its available space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(vacrel-&gt;rel, blkno, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacuumed_pages++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L536" title="access/common/tidstore.c:536">TidStoreEndIterate</a>(iter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;blkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We set all LP_DEAD items from the first heap pass to LP_UNUSED during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the second heap pass.&nbsp; No more, no less.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(vacrel-&gt;num_index_scans &gt; <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (vacrel-&gt;dead_items_info-&gt;num_items == vacrel-&gt;lpdead_items &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacuumed_pages == vacrel-&gt;lpdead_item_pages));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: removed </span><span class="Special">%lld</span><span class="Constant"> dead item identifiers in </span><span class="Special">%u</span><span class="Constant"> pages&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname, (<span class="Type">long</span> <span class="Type">long</span>) vacrel-&gt;dead_items_info-&gt;num_items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacuumed_pages)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Revert to the previous phase information for error traceback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3182" title="access/heap/vacuumlazy.c:3182">restore_vacuum_error_info</a>(vacrel, &amp;saved_err_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2191" title="access/heap/vacuumlazy.c:2191">lazy_vacuum_heap_page</a>() -- free page's LP_DEAD items listed in the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dead_items store.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have an exclusive buffer lock on the buffer (though a full<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock is also acceptable).&nbsp; vmbuffer must be valid and already have<br/></li>
<li></span><span class="Comment"> * a pin on blkno's visibility map page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2191">&#x200c;</a></span><span class="linkable">lazy_vacuum_heap_page</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, BlockNumber blkno, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *deadoffsets, <span class="Type">int</span> num_offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer vmbuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber unused[MaxHeapTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunused = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId visibility_cutoff_xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_frozen;<br/></li>
<li>&nbsp; &nbsp; <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> saved_err_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_vacuuming);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_HEAP_BLKS_VACUUMED, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update error traceback information */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(vacrel, &amp;saved_err_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACUUM_ERRCB_PHASE_VACUUM_HEAP, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; num_offsets; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber toff = deadoffsets[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, toff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsDead(itemid) &amp;&amp; !ItemIdHasStorage(itemid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetUnused(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unused[nunused++] = toff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nunused &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attempt to truncate line pointer array <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L835" title="storage/page/bufpage.c:835">PageTruncateLinePointerArray</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark buffer dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we write WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(vacrel-&gt;rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pruneheap.c.html#L2032" title="access/heap/pruneheap.c:2032">log_heap_prune_and_freeze</a>(vacrel-&gt;rel, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* no <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PRUNE_VACUUM_CLEANUP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,&nbsp; &nbsp; <span class="Comment">/* frozen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,&nbsp; &nbsp; <span class="Comment">/* redirected */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>,&nbsp; &nbsp; <span class="Comment">/* dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unused, nunused);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * End critical section, so we safely can do visibility tests (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly need to perform IO and allocate memory!). If we crash <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page (including the corresponding vm <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>) might not be marked all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible, but that's fine. A later <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> will fix that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have removed the LP_DEAD items from the page, once again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check if the page has become all-visible.&nbsp; The page is already marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dirty, exclusively locked, and, if needed, a full page image has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emitted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!PageIsAllVisible(page));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2948" title="access/heap/vacuumlazy.c:2948">heap_page_is_all_visible</a>(vacrel, buffer, &amp;visibility_cutoff_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;all_frozen))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags = VISIBILITYMAP_ALL_VISIBLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(visibility_cutoff_xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= VISIBILITYMAP_ALL_FROZEN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(vacrel-&gt;rel, blkno, buffer, InvalidXLogRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, visibility_cutoff_xid, flags);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Revert to the previous phase information for error traceback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3182" title="access/heap/vacuumlazy.c:3182">restore_vacuum_error_info</a>(vacrel, &amp;saved_err_info);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Trigger the failsafe to avoid wraparound failure when vacrel table has a<br/></li>
<li></span><span class="Comment"> * relfrozenxid and/or relminmxid that is dangerously far in the past.<br/></li>
<li></span><span class="Comment"> * Triggering the failsafe makes the ongoing VACUUM bypass <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further index<br/></li>
<li></span><span class="Comment"> * vacuuming and heap vacuuming.&nbsp; Truncating the heap is also bypassed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any remaining work (work that VACUUM cannot just bypass) is typically sped<br/></li>
<li></span><span class="Comment"> * up when the failsafe triggers.&nbsp; VACUUM stops applying <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cost-based delay<br/></li>
<li></span><span class="Comment"> * that it started out with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true when failsafe has been triggered.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2296">&#x200c;</a></span><span class="linkable">lazy_check_wraparound_failsafe</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't warn more than once per VACUUM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(<a href="../../commands/vacuum.c.html#L1240" title="commands/vacuum.c:1240">vacuum_xid_failsafe_check</a>(&amp;vacrel-&gt;cutoffs)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_PROCESSED<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; progress_val[<span class="Constant">2</span>] = {<span class="Constant">0</span>, <span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abandon use of a buffer access strategy to allow use of all of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared buffers.&nbsp; We assume the caller who allocated the memory for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the BufferAccessStrategy will free it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;bstrategy = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Disable index vacuuming, index <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, and heap rel truncation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;do_index_vacuuming = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;do_index_cleanup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;do_rel_truncate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the progress counters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">2</span>, progress_index, progress_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;bypassing nonessential maintenance of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> as a failsafe after </span><span class="Special">%d</span><span class="Constant"> index scans&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dbname, vacrel-&gt;relnamespace, vacrel-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;num_index_scans),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The table's relfrozenxid or relminmxid is too far in the past.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Consider increasing configuration parameter <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> or <a href="../../postmaster/autovacuum.c.html#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a>.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might also need to consider other ways for VACUUM to keep up with the allocation of transaction IDs.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Stop applying cost limits from this point on */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2349" title="access/heap/vacuumlazy.c:2349">lazy_cleanup_all_indexes</a>() -- <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> all indexes of relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2349">&#x200c;</a></span><span class="linkable">lazy_cleanup_all_indexes</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = vacrel-&gt;new_rel_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; estimated_count = vacrel-&gt;scanned_pages &lt; vacrel-&gt;rel_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_start_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_TOTAL<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_end_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_VACUUM_INDEXES_PROCESSED<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; progress_start_val[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; progress_end_val[<span class="Constant">2</span>] = {<span class="Constant">0</span>, <span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_cleanup);<br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;nindexes &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report that we are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> cleaning up indexes and the number of indexes to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; progress_start_val[<span class="Constant">0</span>] = PROGRESS_VACUUM_PHASE_INDEX_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; progress_start_val[<span class="Constant">1</span>] = vacrel-&gt;nindexes;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">2</span>, progress_start_index, progress_start_val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L123" title="access/heap/vacuumlazy.c:123">ParallelVacuumIsActive</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> idx = <span class="Constant">0</span>; idx &lt; vacrel-&gt;nindexes; idx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indrel = vacrel-&gt;indrels[idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteResult *istat = vacrel-&gt;indstats[idx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;indstats[idx] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2466" title="access/heap/vacuumlazy.c:2466">lazy_cleanup_one_index</a>(indrel, istat, reltuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estimated_count, vacrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the number of indexes cleaned up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_INDEXES_PROCESSED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idx + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Outsource everything to parallel variant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuumparallel.c.html#L518" title="commands/vacuumparallel.c:518">parallel_vacuum_cleanup_all_indexes</a>(vacrel-&gt;pvs, reltuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;num_index_scans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estimated_count);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the progress counters */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">2</span>, progress_end_index, progress_end_val);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2417" title="access/heap/vacuumlazy.c:2417">lazy_vacuum_one_index</a>() -- <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> index relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> all the index tuples containing a TID collected in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dead_items.&nbsp; Also update running statistics. Exact<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; details depend on index AM's ambulkdelete routine.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reltuples is the number of heap tuples to be passed to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bulkdelete callback.&nbsp; It's always assumed to be estimated.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; See indexam.sgml for more info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns bulk delete stats derived from input stats<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexBulkDeleteResult *<br/></li>
<li><a id="L2417">&#x200c;</a><span class="linkable">lazy_vacuum_one_index</span>(Relation indrel, IndexBulkDeleteResult *istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span> reltuples, <a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexVacuumInfo ivinfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> saved_err_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ivinfo.index = indrel;<br/></li>
<li>&nbsp; &nbsp; ivinfo.heaprel = vacrel-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; ivinfo.analyze_only = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.report_progress = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.estimated_count = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.message_level = DEBUG2;<br/></li>
<li>&nbsp; &nbsp; ivinfo.num_heap_tuples = reltuples;<br/></li>
<li>&nbsp; &nbsp; ivinfo.strategy = vacrel-&gt;bstrategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update error traceback information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The index name is saved during this phase and restored immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after this phase.&nbsp; See <a href="#L3099" title="access/heap/vacuumlazy.c:3099">vacuum_error_callback</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(vacrel-&gt;indname == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;indname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(indrel));<br/></li>
<li>&nbsp; &nbsp; <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(vacrel, &amp;saved_err_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACUUM_ERRCB_PHASE_VACUUM_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do bulk deletion */<br/></li>
<li></span>&nbsp; &nbsp; istat = <a href="../../commands/vacuum.c.html#L2490" title="commands/vacuum.c:2490">vac_bulkdel_one_index</a>(&amp;ivinfo, istat, (<span class="Type">void</span> *) vacrel-&gt;dead_items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dead_items_info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Revert to the previous phase information for error traceback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3182" title="access/heap/vacuumlazy.c:3182">restore_vacuum_error_info</a>(vacrel, &amp;saved_err_info);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacrel-&gt;indname);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;indname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> istat;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2466" title="access/heap/vacuumlazy.c:2466">lazy_cleanup_one_index</a>() -- do post-<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for index relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Calls index AM's amvacuumcleanup routine.&nbsp; reltuples is the number<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of heap tuples and estimated_count is true if reltuples is an<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; estimated value.&nbsp; See indexam.sgml for more info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns bulk delete stats derived from input stats<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexBulkDeleteResult *<br/></li>
<li><a id="L2466">&#x200c;</a><span class="linkable">lazy_cleanup_one_index</span>(Relation indrel, IndexBulkDeleteResult *istat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> reltuples, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> estimated_count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexVacuumInfo ivinfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> saved_err_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ivinfo.index = indrel;<br/></li>
<li>&nbsp; &nbsp; ivinfo.heaprel = vacrel-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; ivinfo.analyze_only = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.report_progress = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.estimated_count = estimated_count;<br/></li>
<li>&nbsp; &nbsp; ivinfo.message_level = DEBUG2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ivinfo.num_heap_tuples = reltuples;<br/></li>
<li>&nbsp; &nbsp; ivinfo.strategy = vacrel-&gt;bstrategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update error traceback information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The index name is saved during this phase and restored immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after this phase.&nbsp; See <a href="#L3099" title="access/heap/vacuumlazy.c:3099">vacuum_error_callback</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(vacrel-&gt;indname == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;indname = <a href="../../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(RelationGetRelationName(indrel));<br/></li>
<li>&nbsp; &nbsp; <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(vacrel, &amp;saved_err_info,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACUUM_ERRCB_PHASE_INDEX_CLEANUP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBlockNumber, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; istat = <a href="../../commands/vacuum.c.html#L2511" title="commands/vacuum.c:2511">vac_cleanup_one_index</a>(&amp;ivinfo, istat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Revert to the previous phase information for error traceback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3182" title="access/heap/vacuumlazy.c:3182">restore_vacuum_error_info</a>(vacrel, &amp;saved_err_info);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacrel-&gt;indname);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;indname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> istat;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2526" title="access/heap/vacuumlazy.c:2526">should_attempt_truncation</a> - should we attempt to truncate the heap?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't even think about it unless we have a shot at releasing a goodly<br/></li>
<li></span><span class="Comment"> * number of pages.&nbsp; Otherwise, the time taken isn't worth it, mainly because<br/></li>
<li></span><span class="Comment"> * an AccessExclusive lock must be replayed on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> hot standby, where it can<br/></li>
<li></span><span class="Comment"> * be particularly disruptive.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also don't attempt it if wraparound failsafe is in effect.&nbsp; The entire<br/></li>
<li></span><span class="Comment"> * system might be refusing to allocate new XIDs at this point.&nbsp; The system<br/></li>
<li></span><span class="Comment"> * definitely won't return to normal unless and until VACUUM actually advances<br/></li>
<li></span><span class="Comment"> * the oldest relfrozenxid -- which hasn't happened for target rel just yet.<br/></li>
<li></span><span class="Comment"> * If <a href="#L2546" title="access/heap/vacuumlazy.c:2546">lazy_truncate_heap</a> attempted to acquire an AccessExclusiveLock to<br/></li>
<li></span><span class="Comment"> * truncate the table under these circumstances, an XID exhaustion error might<br/></li>
<li></span><span class="Comment"> * make it impossible for VACUUM to fix the underlying XID exhaustion problem.<br/></li>
<li></span><span class="Comment"> * There is very little chance of truncation working out when the failsafe is<br/></li>
<li></span><span class="Comment"> * in effect in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case.&nbsp; <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a> makes the optimistic assumption<br/></li>
<li></span><span class="Comment"> * that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items it encounters will always be LP_UNUSED by the time<br/></li>
<li></span><span class="Comment"> * we're called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2526">&#x200c;</a></span><span class="linkable">should_attempt_truncation</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber possibly_freeable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!vacrel-&gt;do_rel_truncate || <a href="../../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; possibly_freeable = vacrel-&gt;rel_pages - vacrel-&gt;nonempty_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (possibly_freeable &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (possibly_freeable &gt;= <a href="#L71" title="access/heap/vacuumlazy.c:71">REL_TRUNCATE_MINIMUM</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; possibly_freeable &gt;= vacrel-&gt;rel_pages / <a href="#L72" title="access/heap/vacuumlazy.c:72">REL_TRUNCATE_FRACTION</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2546" title="access/heap/vacuumlazy.c:2546">lazy_truncate_heap</a> - try to truncate off <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> empty pages at the end<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2546">&#x200c;</a></span><span class="linkable">lazy_truncate_heap</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber orig_rel_pages = vacrel-&gt;rel_pages;<br/></li>
<li>&nbsp; &nbsp; BlockNumber new_rel_pages;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lock_waiter_detected;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_retry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report that we are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> truncating */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_VACUUM_PHASE_TRUNCATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update error traceback information one last time */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>(vacrel, <span class="Constant">NULL</span>, VACUUM_ERRCB_PHASE_TRUNCATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;nonempty_pages, InvalidOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop until no more truncating can be done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need full exclusive lock on the relation in order to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncation. If we can't get it, give up rather than <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> --- we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want to block other backends, and we don't want to deadlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which is quite possible considering we already hold a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-grade<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lock_waiter_detected = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lock_retry = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lmgr.c.html#L275" title="storage/lmgr/lmgr.c:275">ConditionalLockRelation</a>(vacrel-&gt;rel, AccessExclusiveLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for interrupts while trying to (re-)acquire the exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++lock_retry &gt; (<a href="#L83" title="access/heap/vacuumlazy.c:83">VACUUM_TRUNCATE_LOCK_TIMEOUT</a> /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="access/heap/vacuumlazy.c:82">VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We failed to establish the lock in the specified number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retries. This means we give up truncating.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(vacrel-&gt;verbose ? INFO : DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: stopping truncate due to conflicting lock request&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L82" title="access/heap/vacuumlazy.c:82">VACUUM_TRUNCATE_LOCK_WAIT_INTERVAL</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_VACUUM_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we have exclusive lock, look to see if the rel has grown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whilst we were vacuuming with non-exclusive lock.&nbsp; If so, give up;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the newly added pages presumably contain non-deletable tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_rel_pages = RelationGetNumberOfBlocks(vacrel-&gt;rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_rel_pages != orig_rel_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we intentionally don't update vacrel-&gt;rel_pages with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new rel size here.&nbsp; If we did, it would amount to assuming that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new pages are empty, which is unlikely. Leaving the numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alone amounts to assuming that the new pages have the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple density as existing ones, which is less unlikely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L310" title="storage/lmgr/lmgr.c:310">UnlockRelation</a>(vacrel-&gt;rel, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan backwards from the end to verify that the end pages actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain no tuples.&nbsp; This is *necessary*, not optional, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other backends could have added tuples to these pages whilst we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_rel_pages = <a href="#L2677" title="access/heap/vacuumlazy.c:2677">count_nondeletable_pages</a>(vacrel, &amp;lock_waiter_detected);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;blkno = new_rel_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_rel_pages &gt;= orig_rel_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't do anything after all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L310" title="storage/lmgr/lmgr.c:310">UnlockRelation</a>(vacrel-&gt;rel, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Okay to truncate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/storage.c.html#L288" title="catalog/storage.c:288">RelationTruncate</a>(vacrel-&gt;rel, new_rel_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can release the exclusive lock as soon as we have truncated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Other backends can't safely access the relation until they have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processed the smgr invalidation that <a href="../../storage/smgr/smgr.c.html#L703" title="storage/smgr/smgr.c:703">smgrtruncate</a> sent out ... but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that should happen as part of standard invalidation processing once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they acquire lock on the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L310" title="storage/lmgr/lmgr.c:310">UnlockRelation</a>(vacrel-&gt;rel, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update statistics.&nbsp; Here, it *is* correct to adjust rel_pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without also touching reltuples, since the tuple count wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed by the truncation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;removed_pages += orig_rel_pages - new_rel_pages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;rel_pages = new_rel_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(vacrel-&gt;verbose ? INFO : DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: truncated </span><span class="Special">%u</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant"> pages&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_rel_pages, new_rel_pages)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_rel_pages = new_rel_pages;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (new_rel_pages &gt; vacrel-&gt;nonempty_pages &amp;&amp; lock_waiter_detected);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Rescan end pages to verify that they are (still) empty of tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of nondeletable pages (last nonempty page + 1).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L2677">&#x200c;</a><span class="linkable">count_nondeletable_pages</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *lock_waiter_detected)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber prefetchedUntil;<br/></li>
<li>&nbsp; &nbsp; instr_time&nbsp; &nbsp; starttime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the starttime if we check for conflicting lock requests */<br/></li>
<li></span>&nbsp; &nbsp; INSTR_TIME_SET_CURRENT(starttime);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start checking blocks at what we believe relation end to be and move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backwards.&nbsp; (Strange coding of loop control is needed because blkno is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unsigned.)&nbsp; To make the scan faster, we prefetch a few blocks at a time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in forward direction, so that OS-level readahead can kick in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blkno = vacrel-&gt;rel_pages;<br/></li>
<li>&nbsp; &nbsp; StaticAssertStmt((<a href="#L117" title="access/heap/vacuumlazy.c:117">PREFETCH_SIZE</a> &amp; (<a href="#L117" title="access/heap/vacuumlazy.c:117">PREFETCH_SIZE</a> - <span class="Constant">1</span>)) == <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;prefetch size must be power of 2&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; prefetchedUntil = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (blkno &gt; vacrel-&gt;nonempty_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hastup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if another process requests a lock on our relation. We are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding an AccessExclusiveLock here, so they will be <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only do this once per <a href="#L81" title="access/heap/vacuumlazy.c:81">VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL</a>, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only check if that interval has elapsed once every 32 blocks to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keep the number of system calls and actual shared lock table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lookups to a minimum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((blkno % <span class="Constant">32</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; currenttime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instr_time&nbsp; &nbsp; elapsed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SET_CURRENT(currenttime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed = currenttime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INSTR_TIME_SUBTRACT(elapsed, starttime);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((INSTR_TIME_GET_MICROSEC(elapsed) / <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;= <a href="#L81" title="access/heap/vacuumlazy.c:81">VACUUM_TRUNCATE_LOCK_CHECK_INTERVAL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lmgr.c.html#L373" title="storage/lmgr/lmgr.c:373">LockHasWaitersRelation</a>(vacrel-&gt;rel, AccessExclusiveLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(vacrel-&gt;verbose ? INFO : DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: suspending truncate due to conflicting lock request&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lock_waiter_detected = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; starttime = currenttime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't insert a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> delay point here, because we have an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusive lock on the table which we want to hold for as short a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time as possible.&nbsp; We still need to check for interrupts however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we haven't prefetched this lot yet, do so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefetchedUntil &gt; blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber prefetchStart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetchStart = blkno &amp; ~(<a href="#L117" title="access/heap/vacuumlazy.c:117">PREFETCH_SIZE</a> - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pblkno = prefetchStart; pblkno &lt;= blkno; pblkno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a>(vacrel-&gt;rel, MAIN_FORKNUM, pblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetchedUntil = prefetchStart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(vacrel-&gt;rel, MAIN_FORKNUM, blkno, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;bstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In this phase we only need shared access to the buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page) || PageIsEmpty(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hastup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-unused item should be taken as a reason to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this page.&nbsp; Even an LP_DEAD item makes truncation unsafe, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must not have cleaned out its index entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsUsed(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hastup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can stop scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan along page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done scanning if we found a tuple here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hastup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> blkno + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we fall out of the loop, all the previously-thought-to-be-empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages still are; we need not bother to look at the last known-nonempty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> vacrel-&gt;nonempty_pages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate dead_items and dead_items_info (either using <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>, or in dynamic<br/></li>
<li></span><span class="Comment"> * shared memory). Sets both in vacrel for caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also handles parallel initialization as part of allocating dead_items in<br/></li>
<li></span><span class="Comment"> * DSM when required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2819">&#x200c;</a></span><span class="linkable">dead_items_alloc</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, <span class="Type">int</span> nworkers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; VacDeadItemsInfo *dead_items_info;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac_work_mem = AmAutoVacuumWorkerProcess() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/autovacuum.c.html#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a> != -<span class="Constant">1</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../postmaster/autovacuum.c.html#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a> : <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize state for a parallel <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; As of <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, only one worker can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be used for an index, so we invoke parallelism only if there are at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least two indexes on a table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nworkers &gt;= <span class="Constant">0</span> &amp;&amp; vacrel-&gt;nindexes &gt; <span class="Constant">1</span> &amp;&amp; vacrel-&gt;do_index_vacuuming)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since parallel workers cannot access data in temporary tables, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't perform parallel <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> on them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationUsesLocalBuffers(vacrel-&gt;rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give warning only if the user explicitly tries to perform a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> on the temporary table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nworkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;disabling parallel option of <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> on </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> --- cannot <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> temporary tables in parallel&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;pvs = <a href="../../commands/vacuumparallel.c.html#L242" title="commands/vacuumparallel.c:242">parallel_vacuum_init</a>(vacrel-&gt;rel, vacrel-&gt;indrels,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;nindexes, nworkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vac_work_mem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;verbose ? INFO : DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;bstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If parallel mode started, dead_items and dead_items_info spaces are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocated in DSM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="access/heap/vacuumlazy.c:123">ParallelVacuumIsActive</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;dead_items = <a href="../../commands/vacuumparallel.c.html#L465" title="commands/vacuumparallel.c:465">parallel_vacuum_get_dead_items</a>(vacrel-&gt;pvs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vacrel-&gt;dead_items_info);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Serial VACUUM case. Allocate both dead_items and dead_items_info<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dead_items_info = (VacDeadItemsInfo *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(VacDeadItemsInfo));<br/></li>
<li>&nbsp; &nbsp; dead_items_info-&gt;max_bytes = vac_work_mem * <span class="Constant">1024L</span>;<br/></li>
<li>&nbsp; &nbsp; dead_items_info-&gt;num_items = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;dead_items_info = dead_items_info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;dead_items = <a href="../common/tidstore.c.html#L165" title="access/common/tidstore.c:165">TidStoreCreateLocal</a>(dead_items_info-&gt;max_bytes, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add the given block number and offset numbers to dead_items.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2884">&#x200c;</a></span><span class="linkable">dead_items_add</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, BlockNumber blkno, OffsetNumber *offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> num_offsets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *dead_items = vacrel-&gt;dead_items;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L356" title="access/common/tidstore.c:356">TidStoreSetBlockOffsets</a>(dead_items, blkno, offsets, num_offsets);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;dead_items_info-&gt;num_items += num_offsets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the memory usage report */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_VACUUM_DEAD_TUPLE_BYTES,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../common/tidstore.c.html#L551" title="access/common/tidstore.c:551">TidStoreMemoryUsage</a>(dead_items));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Forget all collected dead items.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2901">&#x200c;</a></span><span class="linkable">dead_items_reset</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L114" title="access/common/tidstore.c:114">TidStore</a>&nbsp;&nbsp; *dead_items = vacrel-&gt;dead_items;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L123" title="access/heap/vacuumlazy.c:123">ParallelVacuumIsActive</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuumparallel.c.html#L473" title="commands/vacuumparallel.c:473">parallel_vacuum_reset_dead_items</a>(vacrel-&gt;pvs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recreate the tidstore with the same max_bytes limitation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/tidstore.c.html#L328" title="access/common/tidstore.c:328">TidStoreDestroy</a>(dead_items);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;dead_items = <a href="../common/tidstore.c.html#L165" title="access/common/tidstore.c:165">TidStoreCreateLocal</a>(vacrel-&gt;dead_items_info-&gt;max_bytes, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset the counter */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;dead_items_info-&gt;num_items = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> for resources allocated in <a href="#L2819" title="access/heap/vacuumlazy.c:2819">dead_items_alloc</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2923">&#x200c;</a></span><span class="linkable">dead_items_cleanup</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L123" title="access/heap/vacuumlazy.c:123">ParallelVacuumIsActive</a>(vacrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't bother with <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* End parallel mode */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuumparallel.c.html#L434" title="commands/vacuumparallel.c:434">parallel_vacuum_end</a>(vacrel-&gt;pvs, vacrel-&gt;indstats);<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;pvs = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if every tuple in the given page is visible to all current and future<br/></li>
<li></span><span class="Comment"> * transactions. Also return the visibility_cutoff_xid which is the highest<br/></li>
<li></span><span class="Comment"> * xmin amongst the visible tuples.&nbsp; Set *all_frozen to true if every tuple<br/></li>
<li></span><span class="Comment"> * on this page is frozen.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a stripped down version of <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>().&nbsp; If you change<br/></li>
<li></span><span class="Comment"> * anything here, make sure that everything stays in sync.&nbsp; Note that an<br/></li>
<li></span><span class="Comment"> * assertion calls us to verify that everybody still agrees.&nbsp; Be sure to avoid<br/></li>
<li></span><span class="Comment"> * introducing new side-effects here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2948">&#x200c;</a></span><span class="linkable">heap_page_is_all_visible</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *visibility_cutoff_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *all_frozen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; BlockNumber blockno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *visibility_cutoff_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; *all_frozen = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff &amp;&amp; all_visible;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the offset number so that we can display it along with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error that occurred while processing this tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacrel-&gt;offnum = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unused or redirect line pointers are of no interest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(itemid) || ItemIdIsRedirected(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;(tuple.t_self), blockno, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Dead line pointers can have index pointers pointing to them. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they can't be treated as visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsDead(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(itemid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_data = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_len = ItemIdGetLength(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple.t_tableOid = RelationGetRelid(vacrel-&gt;rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>(&amp;tuple, vacrel-&gt;cutoffs.OldestXmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_LIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check comments in <a href="#L1408" title="access/heap/vacuumlazy.c:1408">lazy_scan_prune</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderXminCommitted(tuple.t_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The inserter definitely committed. But is it old enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that everyone sees it as committed?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmin = HeapTupleHeaderGetXmin(tuple.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacrel-&gt;cutoffs.OldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Track newest xmin on page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xmin, *visibility_cutoff_xid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsNormal(xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *visibility_cutoff_xid = xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check whether this tuple is already frozen or not */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_visible &amp;&amp; *all_frozen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam.c.html#L7319" title="access/heap/heapam.c:7319">heap_tuple_needs_eventual_freeze</a>(tuple.t_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_RECENTLY_DEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_INSERT_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DELETE_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a> result&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan along page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear the offset information once we have processed the given page. */<br/></li>
<li></span>&nbsp; &nbsp; vacrel-&gt;offnum = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> all_visible;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update index statistics in pg_class if the statistics are accurate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3064">&#x200c;</a></span><span class="linkable">update_relstats_all_indexes</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *indrels = vacrel-&gt;indrels;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nindexes = vacrel-&gt;nindexes;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult **indstats = vacrel-&gt;indstats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(vacrel-&gt;do_index_cleanup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> idx = <span class="Constant">0</span>; idx &lt; nindexes; idx++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; indrel = indrels[idx];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexBulkDeleteResult *istat = indstats[idx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (istat == <span class="Constant">NULL</span> || istat-&gt;estimated_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update index statistics */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L1398" title="commands/vacuum.c:1398">vac_update_relstats</a>(indrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istat-&gt;num_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istat-&gt;num_index_tuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidMultiXactId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error context callback for errors occurring during <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; The error<br/></li>
<li></span><span class="Comment"> * context messages for index phases should match the messages set in parallel<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; If you change this function for those phases, change<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuumparallel.c.html#L1106" title="commands/vacuumparallel.c:1106">parallel_vacuum_error_callback</a>() as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3099">&#x200c;</a></span><span class="linkable">vacuum_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *errinfo = arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (errinfo-&gt;phase)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VACUUM_ERRCB_PHASE_SCAN_HEAP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(errinfo-&gt;blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OffsetNumberIsValid(errinfo-&gt;offnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while scanning block </span><span class="Special">%u</span><span class="Constant"> offset </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;blkno, errinfo-&gt;offnum, errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while scanning block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;blkno, errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while scanning relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VACUUM_ERRCB_PHASE_VACUUM_HEAP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(errinfo-&gt;blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OffsetNumberIsValid(errinfo-&gt;offnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while vacuuming block </span><span class="Special">%u</span><span class="Constant"> offset </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;blkno, errinfo-&gt;offnum, errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while vacuuming block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;blkno, errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while vacuuming relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VACUUM_ERRCB_PHASE_VACUUM_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while vacuuming index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;indname, errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VACUUM_ERRCB_PHASE_INDEX_CLEANUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while cleaning up index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;indname, errinfo-&gt;relnamespace, errinfo-&gt;relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VACUUM_ERRCB_PHASE_TRUNCATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(errinfo-&gt;blkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;while truncating relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant"> blocks&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; errinfo-&gt;relnamespace, errinfo-&gt;relname, errinfo-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> VACUUM_ERRCB_PHASE_UNKNOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do nothing; the errinfo may not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initialized */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Updates the information required for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> error callback.&nbsp; This also saves<br/></li>
<li></span><span class="Comment"> * the current information which can be later restored via <a href="#L3182" title="access/heap/vacuumlazy.c:3182">restore_vacuum_error_info</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3163">&#x200c;</a></span><span class="linkable">update_vacuum_error_info</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel, <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> *saved_vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> phase, BlockNumber blkno, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (saved_vacrel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_vacrel-&gt;offnum = vacrel-&gt;offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_vacrel-&gt;blkno = vacrel-&gt;blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_vacrel-&gt;phase = vacrel-&gt;phase;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;offnum = offnum;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;phase = phase;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Restores the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> information saved via a prior call to <a href="#L3163" title="access/heap/vacuumlazy.c:3163">update_vacuum_error_info</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3182">&#x200c;</a></span><span class="linkable">restore_vacuum_error_info</span>(<a href="#L136" title="access/heap/vacuumlazy.c:136">LVRelState</a> *vacrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <a href="#L222" title="access/heap/vacuumlazy.c:222">LVSavedErrInfo</a> *saved_vacrel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;blkno = saved_vacrel-&gt;blkno;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;offnum = saved_vacrel-&gt;offnum;<br/></li>
<li>&nbsp; &nbsp; vacrel-&gt;phase = saved_vacrel-&gt;phase;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
