<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/heaptoast.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/heaptoast.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L626">heap_fetch_toast_slice</a></li>
<li><a href="#L43">heap_toast_delete</a></li>
<li><a href="#L96">heap_toast_insert_or_update</a></li>
<li><a href="#L563">toast_build_flattened_tuple</a></li>
<li><a href="#L350">toast_flatten_tuple</a></li>
<li><a href="#L449">toast_flatten_tuple_to_datum</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heaptoast.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Heap-specific definitions for external and compressed storage<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; of variable size attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2000-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/heaptoast.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L96" title="access/heap/heaptoast.c:96">heap_toast_insert_or_update</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Try to make a given tuple fit into one page by compressing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; or moving off attributes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L43" title="access/heap/heaptoast.c:43">heap_toast_delete</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Reclaim toast storage when a tuple is deleted<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/detoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_helper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L43" title="access/heap/heaptoast.c:43">heap_toast_delete</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Cascaded delete toast-entries on DELETE<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L43">&#x200c;</a></span><span class="linkable">heap_toast_delete</span>(Relation rel, HeapTuple oldtup, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_speculative)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; toast_values[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_isnull[MaxHeapAttributeNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should only ever be called for tuples of plain relations or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materialized views --- recursing on a toast rel is bad news.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_MATVIEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the tuple descriptor and break down the tuple into fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it's debatable whether to use <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>() here or just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap_getattr() only the varlena columns.&nbsp; The latter could win if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are few varlena columns and many non-varlena ones. However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a> costs only O(N) while the heap_getattr way would cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * O(N^2) if there are many varlena columns, so it seems better to err on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the side of linear cost.&nbsp; (We won't even be here unless there's at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * least one varlena column, by the way.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupleDesc = rel-&gt;rd_att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tupleDesc-&gt;natts &lt;= MaxHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(oldtup, tupleDesc, toast_values, toast_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the real work. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../table/toast_helper.c.html#L318" title="access/table/toast_helper.c:318">toast_delete_external</a>(rel, toast_values, toast_isnull, is_speculative);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L96" title="access/heap/heaptoast.c:96">heap_toast_insert_or_update</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> no-longer-used toast-entries and create new ones to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; make the new tuple fit on INSERT or UPDATE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Inputs:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; newtup: the candidate new tuple to be inserted<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; oldtup: the old row version for UPDATE, or NULL for INSERT<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; options: options to be passed to <a href="heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a>() for toast rows<br/></li>
<li></span><span class="Comment"> * Result:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; either newtup if no toasting is needed, or a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d modified tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; that is what should actually get stored<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: neither newtup nor oldtup will be modified.&nbsp; This is a change<br/></li>
<li></span><span class="Comment"> * from the pre-8.1 API of this routine.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L96">&#x200c;</a><span class="linkable">heap_toast_insert_or_update</span>(Relation rel, HeapTuple newtup, HeapTuple oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; result_tuple;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAttrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; maxDataLen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_isnull[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_oldisnull[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; toast_values[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; toast_oldvalues[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; ToastAttrInfo toast_attr[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; ToastTupleContext ttc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore the INSERT_SPECULATIVE option. Speculative insertions/super<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deletions just normally insert/delete the toast <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. It seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * easiest to deal with that here, instead on, potentially, multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; options &amp;= ~HEAP_INSERT_SPECULATIVE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should only ever be called for tuples of plain relations or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * materialized views --- recursing on a toast rel is bad news.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;relkind == RELKIND_MATVIEW);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the tuple descriptor and break down the tuple(s) into fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tupleDesc = rel-&gt;rd_att;<br/></li>
<li>&nbsp; &nbsp; numAttrs = tupleDesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(numAttrs &lt;= MaxHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(newtup, tupleDesc, toast_values, toast_isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldtup != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(oldtup, tupleDesc, toast_oldvalues, toast_oldisnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare for toasting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ttc.ttc_rel = rel;<br/></li>
<li>&nbsp; &nbsp; ttc.ttc_values = toast_values;<br/></li>
<li>&nbsp; &nbsp; ttc.ttc_isnull = toast_isnull;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldtup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ttc.ttc_oldvalues = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ttc.ttc_oldisnull = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ttc.ttc_oldvalues = toast_oldvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ttc.ttc_oldisnull = toast_oldisnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ttc.ttc_attr = toast_attr;<br/></li>
<li>&nbsp; &nbsp; <a href="../table/toast_helper.c.html#L41" title="access/table/toast_helper.c:41">toast_tuple_init</a>(&amp;ttc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compress and/or save external until data fits into target length<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 1: Inline compress attributes with attstorage EXTENDED, and store very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; large attributes with attstorage EXTENDED or EXTERNAL external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp;&nbsp; immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 2: Store attributes with attstorage EXTENDED or EXTERNAL external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 3: Inline compress attributes with attstorage MAIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; 4: Store attributes with attstorage MAIN external<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute header overhead --- this should match <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>() */<br/></li>
<li></span>&nbsp; &nbsp; hoff = SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((ttc.ttc_flags &amp; TOAST_HAS_NULLS) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hoff += BITMAPLEN(numAttrs);<br/></li>
<li>&nbsp; &nbsp; hoff = MAXALIGN(hoff);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> convert to a limit on the tuple data size */<br/></li>
<li></span>&nbsp; &nbsp; maxDataLen = RelationGetToastTupleTarget(rel, TOAST_TUPLE_TARGET) - hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for attributes with attstorage EXTENDED to compress.&nbsp; Also <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * large attributes with attstorage EXTENDED or EXTERNAL, and store them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * external.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values, toast_isnull) &gt; maxDataLen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; biggest_attno = <a href="../table/toast_helper.c.html#L181" title="access/table/toast_helper.c:181">toast_tuple_find_biggest_attribute</a>(&amp;ttc, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (biggest_attno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Attempt to compress it inline, if it has attstorage EXTENDED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TupleDescAttr(tupleDesc, biggest_attno)-&gt;attstorage == TYPSTORAGE_EXTENDED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/toast_helper.c.html#L227" title="access/table/toast_helper.c:227">toast_tuple_try_compression</a>(&amp;ttc, biggest_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has attstorage EXTERNAL, ignore on subsequent compression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_attr[biggest_attno].tai_colflags |= TOASTCOL_INCOMPRESSIBLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this value is by itself more than maxDataLen (after compression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>), <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it out to the toast table immediately, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This avoids uselessly compressing other fields in the common case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where we have one long field and several short ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> maybe the threshold should be less than maxDataLen?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toast_attr[biggest_attno].tai_size &gt; maxDataLen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;reltoastrelid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/toast_helper.c.html#L256" title="access/table/toast_helper.c:256">toast_tuple_externalize</a>(&amp;ttc, biggest_attno, options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Second we look for attributes of attstorage EXTENDED or EXTERNAL that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are still inline, and make them external.&nbsp; But <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this if there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toast table to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> them to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values, toast_isnull) &gt; maxDataLen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;reltoastrelid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; biggest_attno = <a href="../table/toast_helper.c.html#L181" title="access/table/toast_helper.c:181">toast_tuple_find_biggest_attribute</a>(&amp;ttc, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (biggest_attno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/toast_helper.c.html#L256" title="access/table/toast_helper.c:256">toast_tuple_externalize</a>(&amp;ttc, biggest_attno, options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Round 3 - this time we take attributes with storage MAIN into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values, toast_isnull) &gt; maxDataLen)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; biggest_attno = <a href="../table/toast_helper.c.html#L181" title="access/table/toast_helper.c:181">toast_tuple_find_biggest_attribute</a>(&amp;ttc, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (biggest_attno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/toast_helper.c.html#L227" title="access/table/toast_helper.c:227">toast_tuple_try_compression</a>(&amp;ttc, biggest_attno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally we store attributes of type MAIN externally.&nbsp; At this point we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increase the target tuple size, so that MAIN attributes aren't stored<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * externally unless really necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maxDataLen = TOAST_TUPLE_TARGET_MAIN - hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values, toast_isnull) &gt; maxDataLen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_rel-&gt;reltoastrelid != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; biggest_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; biggest_attno = <a href="../table/toast_helper.c.html#L181" title="access/table/toast_helper.c:181">toast_tuple_find_biggest_attribute</a>(&amp;ttc, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (biggest_attno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/toast_helper.c.html#L256" title="access/table/toast_helper.c:256">toast_tuple_externalize</a>(&amp;ttc, biggest_attno, options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the case we toasted <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we need to build a new heap tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the changed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((ttc.ttc_flags &amp; TOAST_NEEDS_CHANGE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader olddata = newtup-&gt;t_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader new_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_header_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_data_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_tuple_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate the new size of the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we used to assume here that the old tuple's t_hoff must <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new_header_len value, but that was incorrect.&nbsp; The old tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might have a smaller-than-current natts, if there's been an ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TABLE ADD COLUMN since it was stored; and that would lead to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * different conclusion about the size of the null bitmap, or even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether there needs to be one at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_header_len = SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((ttc.ttc_flags &amp; TOAST_HAS_NULLS) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_header_len += BITMAPLEN(numAttrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_header_len = MAXALIGN(new_header_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_data_len = <a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values, toast_isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_tuple_len = new_header_len + new_data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate and zero the space needed, and fill HeapTupleData fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_tuple = (HeapTuple) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(HEAPTUPLESIZE + new_tuple_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_tuple-&gt;t_len = new_tuple_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_tuple-&gt;t_self = newtup-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_tuple-&gt;t_tableOid = newtup-&gt;t_tableOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_data = (HeapTupleHeader) ((<span class="Type">char</span> *) result_tuple + HEAPTUPLESIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_tuple-&gt;t_data = new_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the existing tuple header, but adjust natts and t_hoff.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(new_data, olddata, SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetNatts(new_data, numAttrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_data-&gt;t_hoff = new_header_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy over the data, and fill the null bitmap if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) new_data + new_header_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(new_data-&gt;t_infomask),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((ttc.ttc_flags &amp; TOAST_HAS_NULLS) != <span class="Constant">0</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_data-&gt;t_bits : <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_tuple = newtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../table/toast_helper.c.html#L275" title="access/table/toast_helper.c:275">toast_tuple_cleanup</a>(&amp;ttc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result_tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L350" title="access/heap/heaptoast.c:350">toast_flatten_tuple</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Flatten&quot; a tuple to contain no out-of-line toasted fields.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (This does not eliminate compressed or short-header datums.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note: we expect the caller already checked HeapTupleHasExternal(tup),<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; so there is no need for a short-circuit path.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L350">&#x200c;</a><span class="linkable">toast_flatten_tuple</span>(HeapTuple tup, TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; new_tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAttrs = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; toast_values[MaxTupleAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_isnull[MaxTupleAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_free[MaxTupleAttributeNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Break down the tuple into fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(numAttrs &lt;= MaxTupleAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tup, tupleDesc, toast_values, toast_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(toast_free, <span class="Constant">0</span>, numAttrs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look at non-null varlena attributes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!toast_isnull[i] &amp;&amp; TupleDescAttr(tupleDesc, i)-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *new_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_value = (<span class="Type">struct</span> varlena *) DatumGetPointer(toast_values[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(new_value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_value = <a href="../common/detoast.c.html#L45" title="access/common/detoast.c:45">detoast_external_attr</a>(new_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values[i] = PointerGetDatum(new_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_free[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form the reconfigured tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_tuple = <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupleDesc, toast_values, toast_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be sure to copy the tuple's identity fields.&nbsp; We also make a point of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copying visibility info, just in case anybody looks at those fields in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a syscache entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_tuple-&gt;t_self = tup-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_tableOid = tup-&gt;t_tableOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_choice = tup-&gt;t_data-&gt;t_choice;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_ctid = tup-&gt;t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask &amp;= ~HEAP_XACT_MASK;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask |=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup-&gt;t_data-&gt;t_infomask &amp; HEAP_XACT_MASK;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask2 &amp;= ~HEAP2_XACT_MASK;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask2 |=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup-&gt;t_data-&gt;t_infomask2 &amp; HEAP2_XACT_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free allocated temp <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toast_free[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(toast_values[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L449" title="access/heap/heaptoast.c:449">toast_flatten_tuple_to_datum</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &quot;Flatten&quot; a tuple containing out-of-line toasted fields into a Datum.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The result is always <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d in the current memory context.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We have a general rule that Datums of container types (rows, arrays,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ranges, etc) must not contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external TOAST pointers.&nbsp; Without<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; this rule, we'd have to look inside each Datum when preparing a tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for storage, which would be expensive and would fail to extend cleanly<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to new sorts of container types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; However, we don't want to say that tuples represented as HeapTuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; can't contain toasted fields, so instead this routine should be called<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; when such a HeapTuple is being converted into a Datum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; While we're at it, we decompress <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> compressed fields too.&nbsp; This is not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; necessary for correctness, but reflects an expectation that compression<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; will be more effective if applied to the whole tuple not individual<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; fields.&nbsp; We are not so concerned about that that we want to deconstruct<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and reconstruct tuples just to get rid of compressed fields, however.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; So callers typically won't call this unless they see that the tuple has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; at least one external field.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; On the other hand, in-line short-header varlena fields are left alone.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If we &quot;untoasted&quot; them here, they'd just get changed back to short-header<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; format anyway within <a href="../common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L449">&#x200c;</a><span class="linkable">toast_flatten_tuple_to_datum</span>(HeapTupleHeader tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 tup_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupleDesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader new_data;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_header_len;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_data_len;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; new_tuple_len;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tmptup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAttrs = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_nulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; toast_values[MaxTupleAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_isnull[MaxTupleAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; toast_free[MaxTupleAttributeNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build a temporary HeapTuple control structure */<br/></li>
<li></span>&nbsp; &nbsp; tmptup.t_len = tup_len;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;(tmptup.t_self));<br/></li>
<li>&nbsp; &nbsp; tmptup.t_tableOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; tmptup.t_data = tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Break down the tuple into fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(numAttrs &lt;= MaxTupleAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(&amp;tmptup, tupleDesc, toast_values, toast_isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(toast_free, <span class="Constant">0</span>, numAttrs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look at non-null varlena attributes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toast_isnull[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_nulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TupleDescAttr(tupleDesc, i)-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *new_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_value = (<span class="Type">struct</span> varlena *) DatumGetPointer(toast_values[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(new_value) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VARATT_IS_COMPRESSED(new_value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_value = <a href="../common/detoast.c.html#L116" title="access/common/detoast.c:116">detoast_attr</a>(new_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values[i] = PointerGetDatum(new_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_free[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the new size of the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should match the reconstruction code in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L96" title="access/heap/heaptoast.c:96">heap_toast_insert_or_update</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_header_len = SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (has_nulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_header_len += BITMAPLEN(numAttrs);<br/></li>
<li>&nbsp; &nbsp; new_header_len = MAXALIGN(new_header_len);<br/></li>
<li>&nbsp; &nbsp; new_data_len = <a href="../common/heaptuple.c.html#L215" title="access/common/heaptuple.c:215">heap_compute_data_size</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values, toast_isnull);<br/></li>
<li>&nbsp; &nbsp; new_tuple_len = new_header_len + new_data_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_data = (HeapTupleHeader) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(new_tuple_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the existing tuple header, but adjust natts and t_hoff.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(new_data, tup, SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetNatts(new_data, numAttrs);<br/></li>
<li>&nbsp; &nbsp; new_data-&gt;t_hoff = new_header_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the composite-Datum header fields correctly */<br/></li>
<li></span>&nbsp; &nbsp; HeapTupleHeaderSetDatumLength(new_data, new_tuple_len);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypeId(new_data, tupleDesc-&gt;tdtypeid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetTypMod(new_data, tupleDesc-&gt;tdtypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy over the data, and fill the null bitmap if needed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/heaptuple.c.html#L400" title="access/common/heaptuple.c:400">heap_fill_tuple</a>(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) new_data + new_header_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_data_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(new_data-&gt;t_infomask),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_nulls ? new_data-&gt;t_bits : <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free allocated temp <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (toast_free[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(toast_values[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> PointerGetDatum(new_data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * <a href="#L563" title="access/heap/heaptoast.c:563">toast_build_flattened_tuple</a> -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Build a tuple containing no out-of-line toasted fields.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (This does not eliminate compressed or short-header datums.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is essentially just like <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>, except that it will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; expand <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external-data pointers beforehand.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; It's not very clear whether it would be preferable to decompress<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in-line compressed datums while at it.&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>HeapTuple<br/></li>
<li><a id="L563">&#x200c;</a><span class="linkable">toast_build_flattened_tuple</span>(TupleDesc tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; new_tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAttrs = tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_to_free;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; new_values[MaxTupleAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; freeable_values[MaxTupleAttributeNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can pass the caller's isnull array directly to <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we potentially need to modify the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(numAttrs &lt;= MaxTupleAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; memcpy(new_values, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, numAttrs * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; num_to_free = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look at non-null varlena attributes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isnull[i] &amp;&amp; TupleDescAttr(tupleDesc, i)-&gt;attlen == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> varlena *new_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_value = (<span class="Type">struct</span> varlena *) DatumGetPointer(new_values[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL(new_value))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_value = <a href="../common/detoast.c.html#L45" title="access/common/detoast.c:45">detoast_external_attr</a>(new_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_values[i] = PointerGetDatum(new_value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeable_values[num_to_free++] = (Pointer) new_value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Form the reconfigured tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_tuple = <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupleDesc, new_values, isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free allocated temp <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_to_free; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(freeable_values[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> new_tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch a TOAST slice from a heap table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * toastrel is the relation from which chunks are to be fetched.<br/></li>
<li></span><span class="Comment"> * valueid identifies the TOAST value from which chunks are being fetched.<br/></li>
<li></span><span class="Comment"> * attrsize is the total size of the TOAST value.<br/></li>
<li></span><span class="Comment"> * sliceoffset is the byte offset within the TOAST value from which to fetch.<br/></li>
<li></span><span class="Comment"> * slicelength is the number of bytes to be fetched from the TOAST value.<br/></li>
<li></span><span class="Comment"> * result is the varlena into which the results should be written.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L626">&#x200c;</a></span><span class="linkable">heap_fetch_toast_slice</span>(Relation toastrel, Oid valueid, int32 attrsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 sliceoffset, int32 slicelength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> varlena *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp;&nbsp; *toastidxs;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData toastkey[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; toasttupDesc = toastrel-&gt;rd_att;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nscankeys;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc toastscan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ttup;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; expectedchunk;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; totalchunks = ((attrsize - <span class="Constant">1</span>) / TOAST_MAX_CHUNK_SIZE) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startchunk;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; endchunk;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_indexes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; validIndex;<br/></li>
<li>&nbsp; &nbsp; SnapshotData SnapshotToast;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for the valid index of toast relation */<br/></li>
<li></span>&nbsp; &nbsp; validIndex = <a href="../common/toast_internals.c.html#L564" title="access/common/toast_internals.c:564">toast_open_indexes</a>(toastrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;toastidxs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_indexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; startchunk = sliceoffset / TOAST_MAX_CHUNK_SIZE;<br/></li>
<li>&nbsp; &nbsp; endchunk = (sliceoffset + slicelength - <span class="Constant">1</span>) / TOAST_MAX_CHUNK_SIZE;<br/></li>
<li>&nbsp; &nbsp; Assert(endchunk &lt;= totalchunks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up a scan key to fetch from the index. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;toastkey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(valueid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No additional condition if fetching all chunks. Otherwise, use an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality condition for one chunk, and a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> condition otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (startchunk == <span class="Constant">0</span> &amp;&amp; endchunk == totalchunks - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nscankeys = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (startchunk == endchunk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;toastkey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_INT4EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(startchunk));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nscankeys = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;toastkey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterEqualStrategyNumber, F_INT4GE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(startchunk));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;toastkey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessEqualStrategyNumber, F_INT4LE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(endchunk));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nscankeys = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare for scan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/toast_internals.c.html#L641" title="access/common/toast_internals.c:641">init_toast_snapshot</a>(&amp;SnapshotToast);<br/></li>
<li>&nbsp; &nbsp; toastscan = <a href="../index/genam.c.html#L643" title="access/index/genam.c:643">systable_beginscan_ordered</a>(toastrel, toastidxs[validIndex],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;SnapshotToast, nscankeys, toastkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the chunks by index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The index is on (valueid, chunkidx) so they will come in order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; expectedchunk = startchunk;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((ttup = <a href="../index/genam.c.html#L710" title="access/index/genam.c:710">systable_getnext_ordered</a>(toastscan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; curchunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Pointer&nbsp; &nbsp; &nbsp; &nbsp; chunk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *chunkdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chunksize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; expected_size;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chcpystrt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; chcpyend;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have a chunk, extract the sequence number and the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curchunk = DatumGetInt32(fastgetattr(ttup, <span class="Constant">2</span>, toasttupDesc, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chunk = DatumGetPointer(fastgetattr(ttup, <span class="Constant">3</span>, toasttupDesc, &amp;isnull));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!VARATT_IS_EXTENDED(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunksize = VARSIZE(chunk) - VARHDRSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunkdata = VARDATA(chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (VARATT_IS_SHORT(chunk))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could happen due to <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a> doing its thing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunksize = VARSIZE_SHORT(chunk) - VARHDRSZ_SHORT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunkdata = VARDATA_SHORT(chunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* should never happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;found toasted toast chunk for toast value </span><span class="Special">%u</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; valueid, RelationGetRelationName(toastrel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunksize = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunkdata = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some checks on the data we've found<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curchunk != expectedchunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected chunk number </span><span class="Special">%d</span><span class="Constant"> (expected </span><span class="Special">%d</span><span class="Constant">) for toast value </span><span class="Special">%u</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curchunk, expectedchunk, valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(toastrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curchunk &gt; endchunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected chunk number </span><span class="Special">%d</span><span class="Constant"> (out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> </span><span class="Special">%d</span><span class="Constant">..</span><span class="Special">%d</span><span class="Constant">) for toast value </span><span class="Special">%u</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curchunk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; startchunk, endchunk, valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(toastrel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expected_size = curchunk &lt; totalchunks - <span class="Constant">1</span> ? TOAST_MAX_CHUNK_SIZE<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : attrsize - ((totalchunks - <span class="Constant">1</span>) * TOAST_MAX_CHUNK_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chunksize != expected_size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected chunk size </span><span class="Special">%d</span><span class="Constant"> (expected </span><span class="Special">%d</span><span class="Constant">) in chunk </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%d</span><span class="Constant"> for toast value </span><span class="Special">%u</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chunksize, expected_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curchunk, totalchunks, valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(toastrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the data into proper place in our result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chcpystrt = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chcpyend = chunksize - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curchunk == startchunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chcpystrt = sliceoffset % TOAST_MAX_CHUNK_SIZE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curchunk == endchunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chcpyend = (sliceoffset + slicelength - <span class="Constant">1</span>) % TOAST_MAX_CHUNK_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(VARDATA(result) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (curchunk * TOAST_MAX_CHUNK_SIZE - sliceoffset) + chcpystrt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; chunkdata + chcpystrt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (chcpyend - chcpystrt) + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expectedchunk++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Final checks that we successfully fetched the datum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (expectedchunk != (endchunk + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;missing chunk number </span><span class="Special">%d</span><span class="Constant"> for toast value </span><span class="Special">%u</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; expectedchunk, valueid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(toastrel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* End scan and close indexes. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../index/genam.c.html#L735" title="access/index/genam.c:735">systable_endscan_ordered</a>(toastscan);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/toast_internals.c.html#L623" title="access/common/toast_internals.c:623">toast_close_indexes</a>(toastidxs, num_indexes, AccessShareLock);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
