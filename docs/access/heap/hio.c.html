<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/hio.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/hio.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L140">GetVisibilityMapPins</a></li>
<li><a href="#L88">ReadBufferBI</a></li>
<li><a href="#L238">RelationAddBlocks</a></li>
<li><a href="#L502">RelationGetBufferForTuple</a></li>
<li><a href="#L35">RelationPutHeapTuple</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L241">MAX_BUFFERS_TO_EXTEND_BY</a></li>
<li><a href="#L433">MAX_BUFFERS_TO_EXTEND_BY</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hio.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES heap access method input/output code.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/hio.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/hio.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/freespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L35" title="access/heap/hio.c:35">RelationPutHeapTuple</a> - place tuple at specified page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * !!! EREPORT(ERROR) IS DISALLOWED HERE !!!&nbsp; Must PANIC on failure!!!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note - caller must hold BUFFER_LOCK_EXCLUSIVE on the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L35">&#x200c;</a></span><span class="linkable">RelationPutHeapTuple</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> token)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; pageHeader;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A tuple that's being inserted speculatively should already have its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * token set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!token || HeapTupleHeaderIsSpeculative(tuple-&gt;t_data));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do not allow tuples with invalid combinations of hint bits to be placed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on a page.&nbsp; This combination is detected as corruption by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contrib/amcheck logic, so if you disable this assertion, make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding changes there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!((tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_COMMITTED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the tuple to the page */<br/></li>
<li></span>&nbsp; &nbsp; pageHeader = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offnum = PageAddItem(pageHeader, (Item) tuple-&gt;t_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple-&gt;t_len, InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offnum == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add tuple to page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update tuple-&gt;t_self to the actual position where it was stored */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSet(&amp;(tuple-&gt;t_self), <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer), offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the correct position into CTID of the stored tuple, too (unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is a speculative insertion, in which case the token is held in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CTID field instead)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!token)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemId = PageGetItemId(pageHeader, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader item = (HeapTupleHeader) PageGetItem(pageHeader, itemId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;t_ctid = tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read in a buffer in mode, using bulk-insert strategy if bistate isn't NULL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L88">&#x200c;</a><span class="linkable">ReadBufferBI</span>(Relation relation, BlockNumber targetBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ReadBufferMode mode, BulkInsertState bistate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If not bulk-insert, exactly like <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bistate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(relation, MAIN_FORKNUM, targetBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have the desired block already pinned, re-pin and return it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bistate-&gt;current_buf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(bistate-&gt;current_buf) == targetBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently the LOCK variants are only used for extending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation, which should never reach this branch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(mode != RBM_ZERO_AND_LOCK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mode != RBM_ZERO_AND_CLEANUP_LOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(bistate-&gt;current_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> bistate-&gt;current_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... else drop the old buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bistate-&gt;current_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;current_buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform a read using the buffer strategy */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(relation, MAIN_FORKNUM, targetBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode, bistate-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save the selected block as target for future inserts */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;current_buf = buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For each heap page which is all-visible, acquire a pin on the appropriate<br/></li>
<li></span><span class="Comment"> * visibility map page, if we haven't already got one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid complexity in the callers, either buffer1 or buffer2 may be<br/></li>
<li></span><span class="Comment"> * InvalidBuffer if only one buffer is involved. For the same reason, block2<br/></li>
<li></span><span class="Comment"> * may be smaller than block1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns whether buffer locks were temporarily released.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L140">&#x200c;</a></span><span class="linkable">GetVisibilityMapPins</span>(Relation relation, Buffer buffer1, Buffer buffer2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber block1, BlockNumber block2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *vmbuffer1, Buffer *vmbuffer2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_to_pin_buffer1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_to_pin_buffer2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; released_locks = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Swap buffers around to handle case of a single block/buffer, and to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle if lock ordering rules require to lock block2 first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buffer1) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (BufferIsValid(buffer2) &amp;&amp; block1 &gt; block2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a> = buffer1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp;&nbsp; *tmpvmbuf = vmbuffer1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber tmpblock = block1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer1 = buffer2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer1 = vmbuffer2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block1 = block2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer2 = <a href="../../replication/walsender.c.html#L170" title="replication/walsender.c:170">tmpbuf</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer2 = tmpvmbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block2 = tmpblock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(buffer1));<br/></li>
<li>&nbsp; &nbsp; Assert(buffer2 == InvalidBuffer || block1 &lt;= block2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Figure out which pins we need but don't have. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; need_to_pin_buffer1 = PageIsAllVisible(BufferGetPage(buffer1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="visibilitymap.c.html#L215" title="access/heap/visibilitymap.c:215">visibilitymap_pin_ok</a>(block1, *vmbuffer1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_to_pin_buffer2 = buffer2 != InvalidBuffer<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; PageIsAllVisible(BufferGetPage(buffer2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !<a href="visibilitymap.c.html#L215" title="access/heap/visibilitymap.c:215">visibilitymap_pin_ok</a>(block2, *vmbuffer2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!need_to_pin_buffer1 &amp;&amp; !need_to_pin_buffer2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We must unlock both buffers <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; released_locks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer1, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer2 != InvalidBuffer &amp;&amp; buffer2 != buffer1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer2, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get pins. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need_to_pin_buffer1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block1, vmbuffer1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need_to_pin_buffer2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block2, vmbuffer2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relock buffers. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer1, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer2 != InvalidBuffer &amp;&amp; buffer2 != buffer1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer2, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are two buffers involved and we pinned just one of them,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's possible that the second one became all-visible while we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * busy pinning the first one.&nbsp; If it looks like that's a possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scenario, we'll need to make a second pass through this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buffer2 == InvalidBuffer || buffer1 == buffer2<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || (need_to_pin_buffer1 &amp;&amp; need_to_pin_buffer2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> released_locks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extend the relation. By multiple pages, if beneficial.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the caller needs multiple pages (num_pages &gt; 1), we always try to extend<br/></li>
<li></span><span class="Comment"> * by at least that much.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is contention on the extension lock, we don't just extend &quot;for<br/></li>
<li></span><span class="Comment"> * ourselves&quot;, but we try to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> others. We can do so by adding empty pages<br/></li>
<li></span><span class="Comment"> * into the FSM. Typically there is no contention when we can't use the FSM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do have to limit the number of pages to extend by to some value, as the<br/></li>
<li></span><span class="Comment"> * buffers for all the extended pages need to, temporarily, be pinned. For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * we define <a href="#L241" title="access/heap/hio.c:241">MAX_BUFFERS_TO_EXTEND_BY</a> to be 64 buffers, it's hard to see<br/></li>
<li></span><span class="Comment"> * benefits with higher numbers. This partially is because copyfrom.c's<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/copyfrom.c.html#L63" title="commands/copyfrom.c:63">MAX_BUFFERED_TUPLES</a> / <a href="../../commands/copyfrom.c.html#L69" title="commands/copyfrom.c:69">MAX_BUFFERED_BYTES</a> prevents larger multi_inserts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a buffer for a newly extended block. If possible, the buffer is<br/></li>
<li></span><span class="Comment"> * returned exclusively locked. *did_unlock is set to true if the lock had to<br/></li>
<li></span><span class="Comment"> * be released, false otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment">: It would likely be beneficial for some workloads to extend more<br/></li>
<li></span><span class="Comment"> * aggressively, e.g. using a heuristic based on the relation size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L238">&#x200c;</a><span class="linkable">RelationAddBlocks</span>(Relation relation, BulkInsertState bistate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> num_pages, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> use_fsm, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *did_unlock)<br/></li>
<li>{<br/></li>
<li><a id="L241">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_BUFFERS_TO_EXTEND_BY</span> </span><span class="Constant">64<br/></li>
<li></span>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; victim_buffers[<a href="#L241" title="access/heap/hio.c:241">MAX_BUFFERS_TO_EXTEND_BY</a>];<br/></li>
<li>&nbsp; &nbsp; BlockNumber first_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; BlockNumber last_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; not_in_fsm_pages;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine by how many pages to try to extend by.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bistate == <span class="Constant">NULL</span> &amp;&amp; !use_fsm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have neither bistate, nor can use the FSM, we can't bulk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extend - there'd be no way to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the additional pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; waitcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to extend at least by the number of pages the caller needs. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can remember the additional pages (either via FSM or bistate).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages = num_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RELATION_IS_LOCAL(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitcount = <a href="../../storage/lmgr/lmgr.c.html#L465" title="storage/lmgr/lmgr.c:465">RelationExtensionLockWaiterCount</a>(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waitcount = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Multiply the number of pages to extend by the number of waiters. Do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this even if we're not using the FSM, as it still relieves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contention, by deferring the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time this backend needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extend. In that case the extended pages will be found via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bistate-&gt;next_free.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages += extend_by_pages * waitcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we previously extended using the same bistate, it's very likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll extend some more. Try to extend by as many pages as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>. This can be important for performance for several reasons,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * including:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - It prevents <a href="../../storage/smgr/md.c.html#L525" title="storage/smgr/md.c:525">mdzeroextend</a>() switching between extending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; relation in different ways, which is inefficient for some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; filesystems.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * - Contention is often intermittent. Even if we currently don't see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; other waiters (see above), extending by larger amounts can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp;&nbsp; prevent future contention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bistate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages = Max(extend_by_pages, bistate-&gt;already_extended_by);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can't extend by more than <a href="#L241" title="access/heap/hio.c:241">MAX_BUFFERS_TO_EXTEND_BY</a>, we need to pin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them all concurrently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(extend_by_pages, <a href="#L241" title="access/heap/hio.c:241">MAX_BUFFERS_TO_EXTEND_BY</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * How many of the extended pages should be entered into the FSM?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a bistate, only enter pages that we don't need ourselves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the FSM.&nbsp; Otherwise every other backend will immediately try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use the pages this backend needs for itself, causing unnecessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contention.&nbsp; If we don't have a bistate, we can't avoid the FSM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Never enter the page returned into the FSM, we'll immediately use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_pages &gt; <span class="Constant">1</span> &amp;&amp; bistate == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; not_in_fsm_pages = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; not_in_fsm_pages = num_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* prepare to put another buffer into the bistate */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bistate &amp;&amp; bistate-&gt;current_buf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bistate-&gt;current_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;current_buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extend the relation. We ask for the first returned page to be locked,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that we are sure that nobody has inserted into the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With the current <a href="#L241" title="access/heap/hio.c:241">MAX_BUFFERS_TO_EXTEND_BY</a> there's no danger of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * [auto]<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> trying to truncate later pages as <a href="vacuumlazy.c.html#L71" title="access/heap/vacuumlazy.c:71">REL_TRUNCATE_MINIMUM</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way larger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; first_block = <a href="../../storage/buffer/bufmgr.c.html#L877" title="storage/buffer/bufmgr.c:877">ExtendBufferedRelBy</a>(BMR_REL(relation), MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate ? bistate-&gt;strategy : <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_LOCK_FIRST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; extend_by_pages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; victim_buffers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;extend_by_pages);<br/></li>
<li>&nbsp; &nbsp; buffer = victim_buffers[<span class="Constant">0</span>]; <span class="Comment">/* the buffer the function will return */<br/></li>
<li></span>&nbsp; &nbsp; last_block = first_block + (extend_by_pages - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(first_block == <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relation is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> extended. Initialize the page. We do this here, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * potentially releasing the lock on the page, because it allows us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double check that the page contents are empty (this should never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen, but if it does we don't want to risk wiping out valid data).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;page </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> should be empty but is not&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; first_block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BufferGetPageSize(buffer), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we decided to put pages into the FSM, release the buffer lock (but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not pin), we don't want to do IO while holding a buffer lock. This will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessitate a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more extensive checking in our caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_fsm &amp;&amp; not_in_fsm_pages &lt; extend_by_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *did_unlock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *did_unlock = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Relation is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> extended. Release pins on all buffers, except for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first (which we'll return).&nbsp; If we decided to put pages into the FSM,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can do that as part of the same loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (uint32 i = <span class="Constant">1</span>; i &lt; extend_by_pages; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber curBlock = first_block + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(curBlock == <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(victim_buffers[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BlockNumberIsValid(curBlock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(victim_buffers[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_fsm &amp;&amp; i &gt;= not_in_fsm_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = BufferGetPageSize(victim_buffers[i]) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SizeOfPageHeaderData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(relation, curBlock, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_fsm &amp;&amp; not_in_fsm_pages &lt; extend_by_pages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber first_fsm_block = first_block + not_in_fsm_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(relation, first_fsm_block, last_block);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bistate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the additional pages we extended by, so we later can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them without looking into the FSM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extend_by_pages &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;next_free = first_block + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;last_free = last_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;next_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;last_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* maintain bistate-&gt;current_buf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;current_buf = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;already_extended_by += extend_by_pages;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li><a id="L433">&#x200c;</a><span class="PreProc">#undef <span class="linkable">MAX_BUFFERS_TO_EXTEND_BY</span><br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns pinned and exclusive-locked buffer of a page in given relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; with free space &gt;= given len.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If num_pages is &gt; 1, we will try to extend the relation by at least that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; many pages when we decide to extend the relation. This is more efficient<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for callers that know they will need multiple pages<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; (e.g. <a href="heapam.c.html#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; If otherBuffer is not InvalidBuffer, then it references a previously<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; pinned buffer of another page in the same relation; on return, this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; buffer will also be exclusive-locked.&nbsp; (This case is used by <a href="heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a>;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the otherBuffer contains the tuple being updated.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The reason for passing otherBuffer is that if two backends are doing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; concurrent <a href="heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a> operations, a deadlock could occur if they try<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; to lock the same two buffers in opposite orders.&nbsp; To ensure that this<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; can't happen, we impose the rule that buffers of a relation must be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; locked in increasing page number order.&nbsp; This is most conveniently done<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; by having <a href="#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a> lock them both, with suitable care<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for ordering.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: it is unlikely, but not quite impossible, for otherBuffer to be the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; same buffer we <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> for insertion of the new tuple (this could only<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; happen if space is freed in that page after <a href="heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a> finds there's not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; enough there).&nbsp; In that case, the page will be pinned and locked only once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We also handle the possibility that the all-visible flag will need to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cleared on one or both pages.&nbsp; If so, pin on the associated visibility map<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; page must be acquired <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring buffer lock(s), to avoid possibly<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; doing I/O while holding buffer locks.&nbsp; The pins are passed back to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; caller using the input-output arguments vmbuffer and vmbuffer_other.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Note that in some cases the caller might have already acquired such pins,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; which is indicated by these arguments not being InvalidBuffer on entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We normally use FSM to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> us <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> free space.&nbsp; However,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if HEAP_INSERT_SKIP_FSM is specified, we just append a new empty page to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the end of the relation if the tuple won't fit on the current target page.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This can save some cycles when we know the relation is new and doesn't<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; contain useful amounts of free space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; HEAP_INSERT_SKIP_FSM is also useful for non-WAL-logged additions to a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation, if the caller holds exclusive lock and is careful to invalidate<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation's smgr_targblock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first insertion --- that ensures that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; all insertions will occur into newly added pages and not be intermixed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; with tuples from other transactions.&nbsp; That way, a crash can't risk losing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> committed data of other transactions.&nbsp; (See <a href="heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a>'s comments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; for additional constraints needed for safe usage of this behavior.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The caller can also provide a BulkInsertState object to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> many<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; insertions into the same relation.&nbsp; This keeps a pin on the current<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; insertion target page (to save pin/unpin cycles) and also passes a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; BULKWRITE buffer selection strategy object to the buffer manager.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Passing NULL for bistate selects the default behavior.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; We don't fill existing pages further than the fillfactor, except for large<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tuples in nearly-empty pages.&nbsp; This is OK since this routine is not<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; consulted when updating a tuple and keeping it on the same page, which is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the scenario fillfactor is meant to reserve space for.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ereport(ERROR) is allowed here, so this routine *must* be called<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (unlogged) changes are made in buffer pool.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L502">&#x200c;</a><span class="linkable">RelationGetBufferForTuple</span>(Relation relation, Size len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer otherBuffer, <span class="Type">int</span> options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BulkInsertState bistate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *vmbuffer, Buffer *vmbuffer_other,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> num_pages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_fsm = !(options &amp; HEAP_INSERT_SKIP_FSM);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nearlyEmptyFreeSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saveFreeSpace = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetFreeSpace = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; BlockNumber targetBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherBlock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; unlockedTargetBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recheckVmPins;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = MAXALIGN(len);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be conservative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if the caller doesn't know by how many pages to extend, extend by 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_pages &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_pages = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Bulk insert is not supported for updates, only inserts. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(otherBuffer == InvalidBuffer || !bistate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're gonna fail for oversize tuple, do it right away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; MaxHeapTupleSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;row is too big: size </span><span class="Special">%zu</span><span class="Constant">, maximum size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len, MaxHeapTupleSize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute desired extra freespace due to fillfactor option */<br/></li>
<li></span>&nbsp; &nbsp; saveFreeSpace = RelationGetTargetPageFreeSpace(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_DEFAULT_FILLFACTOR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since pages without tuples can still have line pointers, we consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages &quot;empty&quot; when the unavailable space is slight.&nbsp; This threshold is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somewhat arbitrary, but it should prevent most unnecessary relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extensions while inserting large tuples into low-fillfactor tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nearlyEmptyFreeSpace = MaxHeapTupleSize -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (MaxHeapTuplesPerPage / <span class="Constant">8</span> * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len + saveFreeSpace &gt; nearlyEmptyFreeSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetFreeSpace = Max(len, nearlyEmptyFreeSpace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetFreeSpace = len + saveFreeSpace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (otherBuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherBlock = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(otherBuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; otherBlock = InvalidBlockNumber;&nbsp; &nbsp; <span class="Comment">/* just to keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We first try to put the tuple on the same page we last inserted a tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on, as cached in the BulkInsertState or relcache entry.&nbsp; If that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't work, we ask the Free Space Map to locate a suitable page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the FSM's info might be out of date, we have to be prepared to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop around and retry multiple times. (To ensure this isn't an infinite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop, we must update the FSM with the correct amount of free space on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each page that proves not to be suitable.)&nbsp; If the FSM has no record of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a page with enough free space, we give up and extend the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When use_fsm is false, we either put the tuple onto the existing target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page or extend the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bistate &amp;&amp; bistate-&gt;current_buf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetBlock = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(bistate-&gt;current_buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetBlock = RelationGetTargetBlock(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (targetBlock == InvalidBlockNumber &amp;&amp; use_fsm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have no cached target page, so ask the FSM for an initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; targetBlock = <a href="../../storage/freespace/freespace.c.html#L137" title="storage/freespace/freespace.c:137">GetPageWithFreeSpace</a>(relation, targetFreeSpace);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the FSM knows nothing of the rel, try the last page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we give<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up and extend.&nbsp; This avoids one-tuple-per-page syndrome during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bootstrapping or in a recently-started system.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetBlock == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks = RelationGetNumberOfBlocks(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBlock = nblocks - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">loop</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (targetBlock != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read and exclusive-lock the target block, as well as the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block if one was given, taking suitable care with lock ordering and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the possibility they are the same block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the page-level all-visible flag is set, caller will need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clear both that and the corresponding visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by the time we return, we'll have x-locked the buffer, and we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O while in that state.&nbsp; So we check the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> taking the lock, and pin the page if it appears necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Checking without the lock creates a risk of getting the wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * answer, so we'll have to recheck after acquiring the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherBuffer == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="#L88" title="access/heap/hio.c:88">ReadBufferBI</a>(relation, targetBlock, RBM_NORMAL, bistate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, targetBlock, vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the page is empty, pin vmbuffer to set all_frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((options &amp; HEAP_INSERT_FROZEN) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (PageGetMaxOffsetNumber(BufferGetPage(buffer)) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, targetBlock, vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (otherBlock == targetBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* also easy case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = otherBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, targetBlock, vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (otherBlock &lt; targetBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock other buffer first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, targetBlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, targetBlock, vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(otherBuffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lock target buffer first */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, targetBlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, targetBlock, vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(otherBuffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have the target page (and the other buffer, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) pinned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and locked.&nbsp; However, since our initial PageIsAllVisible checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were performed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring the lock, the results might <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out of date, either for the selected victim buffer, or for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other buffer passed by the caller.&nbsp; In that case, we'll need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * give up our locks, go get the pin(s) we failed to get earlier, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-lock.&nbsp; That's pretty painful, but hopefully shouldn't happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that there's a small possibility that we didn't pin the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above but still have the correct page pinned anyway, either because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we've already made a previous pass through this loop, or because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller passed us the right page anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note also that it's possible that by the time we get the pin and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * retake the buffer locks, the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> will have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleared by some other backend anyway.&nbsp; In that case, we'll have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of extra work for no gain, but there's no real harm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="access/heap/hio.c:140">GetVisibilityMapPins</a>(relation, buffer, otherBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetBlock, otherBlock, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vmbuffer_other);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we can check to see if there's enough free space here. If so,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If necessary <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> page, it'll be used soon.&nbsp; We could avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dirtying the buffer here, and rely on the caller to do so whenever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it puts a tuple onto the page, but there seems not much benefit in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BufferGetPageSize(buffer), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetFreeSpace &lt;= pageFreeSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use this page as future insert target, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationSetTargetBlock(relation, targetBlock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not enough space, so we must give up our page locks and pin (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) and prepare to look elsewhere.&nbsp; We don't care which order we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlock the two buffers in, so this can be slightly simpler than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherBuffer == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (otherBlock != targetBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(otherBuffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Is there an ongoing bulk extension? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bistate &amp;&amp; bistate-&gt;next_free != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bistate-&gt;next_free &lt;= bistate-&gt;last_free);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We bulk extended the relation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, and there are still some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unused pages from that extension, so we don't need to look in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the FSM for a new page. But do record the free space from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last page, somebody might insert narrower tuples later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_fsm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(relation, targetBlock, pageFreeSpace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBlock = bistate-&gt;next_free;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bistate-&gt;next_free &gt;= bistate-&gt;last_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;next_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;last_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bistate-&gt;next_free++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!use_fsm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Without FSM, always fall out of the loop and extend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update FSM as to condition of this page, and ask for another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page to try.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBlock = <a href="../../storage/freespace/freespace.c.html#L154" title="storage/freespace/freespace.c:154">RecordAndGetPageWithFreeSpace</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetBlock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetFreeSpace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Have to extend the relation */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="#L238" title="access/heap/hio.c:238">RelationAddBlocks</a>(relation, bistate, num_pages, use_fsm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;unlockedTargetBuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; targetBlock = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The page is empty, pin vmbuffer to set all_frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>. We don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do IO while the buffer is locked, so we unlock the page first if IO is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed (necessitating checks below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (options &amp; HEAP_INSERT_FROZEN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PageGetMaxOffsetNumber(page) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="visibilitymap.c.html#L215" title="access/heap/visibilitymap.c:215">visibilitymap_pin_ok</a>(targetBlock, *vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!unlockedTargetBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlockedTargetBuffer = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, targetBlock, vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reacquire locks if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the target buffer was unlocked above, or is unlocked while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reacquiring the lock on otherBuffer below, it's unlikely, but possible,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that another backend used space on this page. We check for that below,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and retry if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; recheckVmPins = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlockedTargetBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* released lock on target buffer above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherBuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(otherBuffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recheckVmPins = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (otherBuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We did not release the target buffer, and otherBuffer is valid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to lock the other buffer. It's guaranteed to be of a <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page number than the new page.&nbsp; To conform with the deadlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prevent rules, we ought to lock otherBuffer first, but that would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * give other backends a chance to put tuples on our page. To reduce<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the likelihood of that, attempt to lock the other buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conditionally, that's very likely to work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Alternatively, we could acquire the lock on otherBuffer <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extending the relation, but that'd require holding the lock while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performing IO, which seems worse than an unlikely retry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(otherBuffer != buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(targetBlock &gt; otherBlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!<a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(otherBuffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlockedTargetBuffer = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(otherBuffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recheckVmPins = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If one of the buffers was unlocked (always the case if otherBuffer is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid), it's possible, although unlikely, that an all-visible flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * became set.&nbsp; We can use <a href="#L140" title="access/heap/hio.c:140">GetVisibilityMapPins</a> to deal with that. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible that <a href="#L140" title="access/heap/hio.c:140">GetVisibilityMapPins</a>() might need to temporarily release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer locks, in which case we'll need to check if there's still enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space on the page below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (recheckVmPins)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L140" title="access/heap/hio.c:140">GetVisibilityMapPins</a>(relation, otherBuffer, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherBlock, targetBlock, vmbuffer_other,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unlockedTargetBuffer = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the target buffer was temporarily unlocked since the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extension, it's possible, although unlikely, that all the space on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page was already used. If so, we just retry from the start.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * didn't unlock, something has gone wrong if there's not enough space -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the test at the top should have prevented reaching this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pageFreeSpace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; pageFreeSpace)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlockedTargetBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (otherBuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(otherBuffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> loop;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;tuple is too big: size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>, len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember the new page as our target for future insertions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should we enter the new page into the free space map immediately,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or just keep it for this backend's exclusive use in the short run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (until VACUUM sees it)?&nbsp; &nbsp; Seems to depend on whether you expect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current backend to make more insertions or not, which is probably a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * good bet most of the time.&nbsp; So for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, don't add it to FSM yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; RelationSetTargetBlock(relation, targetBlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buffer;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
