<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/rewriteheap.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/rewriteheap.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L185">OldToNewMapping</a></li>
<li><a href="#L183">OldToNewMappingData</a></li>
<li><a href="#L204">RewriteMappingDataEntry</a></li>
<li><a href="#L209">RewriteMappingDataEntry</a></li>
<li><a href="#L191">RewriteMappingFile</a></li>
<li><a href="#L198">RewriteMappingFile</a></li>
<li><a href="#L130">RewriteStateData</a></li>
<li><a href="#L153">RewriteStateData</a></li>
<li><a href="#L165">TidHashKey</a></li>
<li><a href="#L177">UnresolvedTup</a></li>
<li><a href="#L175">UnresolvedTupData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1155">CheckPointLogicalRewriteHeap</a></li>
<li><a href="#L234">begin_heap_rewrite</a></li>
<li><a href="#L297">end_heap_rewrite</a></li>
<li><a href="#L1073">heap_xlog_logical_rewrite</a></li>
<li><a href="#L759">logical_begin_heap_rewrite</a></li>
<li><a href="#L905">logical_end_heap_rewrite</a></li>
<li><a href="#L807">logical_heap_rewrite_flush_mappings</a></li>
<li><a href="#L999">logical_rewrite_heap_tuple</a></li>
<li><a href="#L935">logical_rewrite_log_mapping</a></li>
<li><a href="#L593">raw_heap_insert</a></li>
<li><a href="#L543">rewrite_heap_dead_tuple</a></li>
<li><a href="#L341">rewrite_heap_tuple</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * rewriteheap.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to rewrite tables.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> provide a facility to completely rewrite a heap, while<br/></li>
<li></span><span class="Comment"> * preserving visibility information and update chains.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for creating the new heap, all catalog<br/></li>
<li></span><span class="Comment"> * changes, supplying the tuples to be written to the new heap, and<br/></li>
<li></span><span class="Comment"> * rebuilding indexes.&nbsp; The caller must hold AccessExclusiveLock on the<br/></li>
<li></span><span class="Comment"> * target table, because we assume no one else is writing into it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To use the facility:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L234" title="access/heap/rewriteheap.c:234">begin_heap_rewrite</a><br/></li>
<li></span><span class="Comment"> * while (fetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple)<br/></li>
<li></span><span class="Comment"> * {<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; if (tuple is dead)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L543" title="access/heap/rewriteheap.c:543">rewrite_heap_dead_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; else<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; {<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; // do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transformations here if required<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L341" title="access/heap/rewriteheap.c:341">rewrite_heap_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; }<br/></li>
<li></span><span class="Comment"> * }<br/></li>
<li></span><span class="Comment"> * <a href="#L297" title="access/heap/rewriteheap.c:297">end_heap_rewrite</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The contents of the new relation shouldn't be relied on until after<br/></li>
<li></span><span class="Comment"> * <a href="#L297" title="access/heap/rewriteheap.c:297">end_heap_rewrite</a> is called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IMPLEMENTATION<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This would be a fairly trivial affair, except that we need to maintain<br/></li>
<li></span><span class="Comment"> * the ctid chains that link versions of an updated tuple together.<br/></li>
<li></span><span class="Comment"> * Since the newly stored tuples will have tids different from the original<br/></li>
<li></span><span class="Comment"> * ones, if we just copied t_ctid fields to the new table the links would<br/></li>
<li></span><span class="Comment"> * be wrong.&nbsp; When we are required to copy a (presumably recently-dead or<br/></li>
<li></span><span class="Comment"> * delete-in-progress) tuple whose ctid doesn't point to itself, we have<br/></li>
<li></span><span class="Comment"> * to substitute the correct ctid instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each ctid reference from A -&gt; B, we might encounter either A first<br/></li>
<li></span><span class="Comment"> * or B first.&nbsp; (Note that a tuple in the middle of a chain is both A and B<br/></li>
<li></span><span class="Comment"> * of different pairs.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we encounter A first, we'll store the tuple in the unresolved_tups<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. When we later encounter B, we remove A from the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table,<br/></li>
<li></span><span class="Comment"> * fix the ctid to point to the new location of B, and insert both A and B<br/></li>
<li></span><span class="Comment"> * to the new heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If we encounter B first, we can insert B to the new heap right away.<br/></li>
<li></span><span class="Comment"> * We then add an entry to the old_new_tid_map <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table showing B's<br/></li>
<li></span><span class="Comment"> * original tid (in the old heap) and new tid (in the new heap).<br/></li>
<li></span><span class="Comment"> * When we later encounter A, we get the new location of B from the table,<br/></li>
<li></span><span class="Comment"> * and can write A immediately with the correct ctid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Entries in the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables can be removed as soon as the later tuple<br/></li>
<li></span><span class="Comment"> * is encountered.&nbsp; That helps to keep the memory usage down.&nbsp; At the end,<br/></li>
<li></span><span class="Comment"> * both tables are usually empty; we should have encountered both A and B<br/></li>
<li></span><span class="Comment"> * of each pair.&nbsp; However, it's possible for A to be RECENTLY_DEAD and B<br/></li>
<li></span><span class="Comment"> * entirely DEAD according to <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>, because the test<br/></li>
<li></span><span class="Comment"> * for deadness using OldestXmin is not exact.&nbsp; In such a case we might<br/></li>
<li></span><span class="Comment"> * encounter B first, and <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it, and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> A later.&nbsp; Then A would be added<br/></li>
<li></span><span class="Comment"> * to unresolved_tups, and stay there until end of the rewrite.&nbsp; Since<br/></li>
<li></span><span class="Comment"> * this case is very unusual, we don't worry about the memory usage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Using in-memory <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables means that we use some memory for each live<br/></li>
<li></span><span class="Comment"> * update chain in the table, from the time we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one end of the<br/></li>
<li></span><span class="Comment"> * reference until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the other end.&nbsp; That shouldn't be a problem in<br/></li>
<li></span><span class="Comment"> * practice, but if you do something like an UPDATE without a where-clause<br/></li>
<li></span><span class="Comment"> * on a large table, and then run CLUSTER in the same transaction, you<br/></li>
<li></span><span class="Comment"> * could run out of memory.&nbsp; It doesn't seem worthwhile to add support for<br/></li>
<li></span><span class="Comment"> * spill-to-disk, as there shouldn't be that many RECENTLY_DEAD tuples in a<br/></li>
<li></span><span class="Comment"> * table under normal circumstances.&nbsp; Furthermore, in the typical scenario<br/></li>
<li></span><span class="Comment"> * of CLUSTERing on an unchanging key column, we'll see all the versions<br/></li>
<li></span><span class="Comment"> * of a given tuple together anyway, and so the peak memory usage is only<br/></li>
<li></span><span class="Comment"> * proportional to the number of RECENTLY_DEAD versions of a single row, not<br/></li>
<li></span><span class="Comment"> * in the whole table.&nbsp; Note that if we do fail halfway through a CLUSTER,<br/></li>
<li></span><span class="Comment"> * the old table is still valid, so failure is not catastrophic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We can't use the normal <a href="heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a> function to insert into the new<br/></li>
<li></span><span class="Comment"> * heap, because <a href="heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a> overwrites the visibility information.<br/></li>
<li></span><span class="Comment"> * We use a special-purpose <a href="#L593" title="access/heap/rewriteheap.c:593">raw_heap_insert</a> function instead, which<br/></li>
<li></span><span class="Comment"> * is optimized for bulk inserting a lot of tuples, knowing that we have<br/></li>
<li></span><span class="Comment"> * exclusive access to the heap.&nbsp; <a href="#L593" title="access/heap/rewriteheap.c:593">raw_heap_insert</a> builds new pages in<br/></li>
<li></span><span class="Comment"> * local storage.&nbsp; When a page is full, or at the end of the process,<br/></li>
<li></span><span class="Comment"> * we insert it to WAL as a single record and then write it to disk with<br/></li>
<li></span><span class="Comment"> * the bulk smgr writer.&nbsp; Note, however, that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data sent to the new<br/></li>
<li></span><span class="Comment"> * heap's TOAST table will go through the normal bufmgr.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994-5, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/rewriteheap.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/rewriteheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bulk_write.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * State associated with a rewrite operation. This is opaque to the user<br/></li>
<li></span><span class="Comment"> * of the rewrite facility.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L130">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RewriteStateData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rs_old_rel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* source heap */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; rs_new_rel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* destination heap */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *rs_bulkstate;&nbsp; &nbsp; <span class="Comment">/* writer for the destination */<br/></li>
<li></span>&nbsp; &nbsp; BulkWriteBuffer rs_buffer;&nbsp; &nbsp; <span class="Comment">/* page currently being built */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber rs_blockno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* block where page will go */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rs_logical_rewrite; <span class="Comment">/* do we need to do logical rewriting */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId rs_oldest_xmin;&nbsp; &nbsp; <span class="Comment">/* oldest xmin used by caller to determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple visibility */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId rs_freeze_xid;&nbsp; &nbsp; <span class="Comment">/* Xid that will be used as freeze cutoff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId rs_logical_xmin;&nbsp; &nbsp; <span class="Comment">/* Xid that will be used as cutoff point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for logical rewrites */<br/></li>
<li></span>&nbsp; &nbsp; MultiXactId rs_cutoff_multi;&nbsp; &nbsp; <span class="Comment">/* MultiXactId that will be used as cutoff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point for multixacts */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext rs_cxt;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables and entries and tuples in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; rs_begin_lsn;&nbsp; &nbsp; <span class="Comment">/* XLogInsertLsn when starting the rewrite */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *rs_unresolved_tups; <span class="Comment">/* unmatched A tuples */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *rs_old_new_tid_map; <span class="Comment">/* unmatched B tuples */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *rs_logical_mappings;&nbsp; &nbsp; <span class="Comment">/* logical remapping files */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; rs_num_rewrite_mappings;&nbsp; &nbsp; <span class="Comment">/* # in memory mappings */<br/></li>
<li><a id="L153">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">RewriteStateData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The lookup keys for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables are tuple TID and xmin (we must check<br/></li>
<li></span><span class="Comment"> * both to avoid false matches from dead tuples).&nbsp; Beware that there is<br/></li>
<li></span><span class="Comment"> * probably some padding space in this struct; it must be zeroed out for<br/></li>
<li></span><span class="Comment"> * correct hashtable operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple xmin */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerData tid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple location in old heap */<br/></li>
<li><a id="L165">&#x200c;</a></span>} <span class="linkable">TidHashKey</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entry structures for the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="access/heap/rewriteheap.c:165">TidHashKey</a>&nbsp; &nbsp; key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expected xmin/old location of B tuple */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerData old_tid;&nbsp; &nbsp; <span class="Comment">/* A's location in the old heap */<br/></li>
<li></span>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A's tuple contents */<br/></li>
<li><a id="L175">&#x200c;</a></span>} <span class="linkable">UnresolvedTupData</span>;<br/></li>
<li><br/></li>
<li><a id="L177">&#x200c;</a><span class="Type">typedef</span> <a href="#L175" title="access/heap/rewriteheap.c:175">UnresolvedTupData</a> *<span class="linkable">UnresolvedTup</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="access/heap/rewriteheap.c:165">TidHashKey</a>&nbsp; &nbsp; key;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* actual xmin/old location of B tuple */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerData new_tid;&nbsp; &nbsp; <span class="Comment">/* where we put it in the new heap */<br/></li>
<li><a id="L183">&#x200c;</a></span>} <span class="linkable">OldToNewMappingData</span>;<br/></li>
<li><br/></li>
<li><a id="L185">&#x200c;</a><span class="Type">typedef</span> <a href="#L183" title="access/heap/rewriteheap.c:183">OldToNewMappingData</a> *<span class="linkable">OldToNewMapping</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In-Memory data for an xid that might need logical remapping entries<br/></li>
<li></span><span class="Comment"> * to be logged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RewriteMappingFile</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xid that might need to see the row */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fd of mappings file */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">off_t</span>&nbsp; &nbsp; &nbsp; &nbsp; off;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* how far have we written yet */<br/></li>
<li></span>&nbsp; &nbsp; dclist_head mappings;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list of in-memory mappings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];&nbsp; &nbsp; <span class="Comment">/* path, for error messages */<br/></li>
<li><a id="L198">&#x200c;</a></span>} <span class="linkable">RewriteMappingFile</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A single In-Memory logical rewrite mapping, hanging off<br/></li>
<li></span><span class="Comment"> * <a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a>-&gt;mappings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L204">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">RewriteMappingDataEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LogicalRewriteMappingData map;&nbsp; &nbsp; <span class="Comment">/* map between old and new location of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple */<br/></li>
<li></span>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; node;<br/></li>
<li><a id="L209">&#x200c;</a>} <span class="linkable">RewriteMappingDataEntry</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* prototypes for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L593" title="access/heap/rewriteheap.c:593">raw_heap_insert</a>(RewriteState state, HeapTuple tup);<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> logical remapping prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L759" title="access/heap/rewriteheap.c:759">logical_begin_heap_rewrite</a>(RewriteState state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L999" title="access/heap/rewriteheap.c:999">logical_rewrite_heap_tuple</a>(RewriteState state, ItemPointerData old_tid, HeapTuple new_tuple);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L905" title="access/heap/rewriteheap.c:905">logical_end_heap_rewrite</a>(RewriteState state);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin a rewrite of a table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * old_heap&nbsp; &nbsp; &nbsp; &nbsp; old, locked heap relation tuples will be read from<br/></li>
<li></span><span class="Comment"> * new_heap&nbsp; &nbsp; &nbsp; &nbsp; new, locked heap relation to insert tuples to<br/></li>
<li></span><span class="Comment"> * oldest_xmin&nbsp; &nbsp; xid used by the caller to determine which tuples are dead<br/></li>
<li></span><span class="Comment"> * freeze_xid&nbsp; &nbsp; xid <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> which tuples will be frozen<br/></li>
<li></span><span class="Comment"> * cutoff_multi&nbsp; &nbsp; multixact <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> which multis will be removed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an opaque RewriteState, allocated in current memory context,<br/></li>
<li></span><span class="Comment"> * to be used in subsequent calls to the other <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RewriteState<br/></li>
<li><a id="L234">&#x200c;</a><span class="linkable">begin_heap_rewrite</span>(Relation old_heap, Relation new_heap, TransactionId oldest_xmin,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId freeze_xid, MultiXactId cutoff_multi)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RewriteState state;<br/></li>
<li>&nbsp; &nbsp; MemoryContext rw_cxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To ease <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>, make a separate context that will contain the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RewriteState struct itself plus all subsidiary data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rw_cxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Table rewrite&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(rw_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and fill in the state struct */<br/></li>
<li></span>&nbsp; &nbsp; state = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L130" title="access/heap/rewriteheap.c:130">RewriteStateData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_old_rel = old_heap;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_new_rel = new_heap;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* new_heap needn't be empty, just locked */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;rs_blockno = RelationGetNumberOfBlocks(new_heap);<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_oldest_xmin = oldest_xmin;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_freeze_xid = freeze_xid;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_cutoff_multi = cutoff_multi;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_cxt = rw_cxt;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_bulkstate = <a href="../../storage/smgr/bulk_write.c.html#L86" title="storage/smgr/bulk_write.c:86">smgr_bulk_start_rel</a>(new_heap, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables used to track update chains */<br/></li>
<li></span>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L165" title="access/heap/rewriteheap.c:165">TidHashKey</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L175" title="access/heap/rewriteheap.c:175">UnresolvedTupData</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = state-&gt;rs_cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_unresolved_tups =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Rewrite / Unresolved ctids&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">128</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arbitrary initial size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L183" title="access/heap/rewriteheap.c:183">OldToNewMappingData</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_old_new_tid_map =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Rewrite / Old to new tid map&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">128</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arbitrary initial size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L759" title="access/heap/rewriteheap.c:759">logical_begin_heap_rewrite</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * End a rewrite.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * state and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other resources are freed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="linkable">end_heap_rewrite</span>(RewriteState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seq_status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="access/heap/rewriteheap.c:177">UnresolvedTup</a> unresolved;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining tuples in the UnresolvedTups table. If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left, they should in fact be dead, but let's err on the safe side.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seq_status, state-&gt;rs_unresolved_tups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((unresolved = <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seq_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(&amp;unresolved-&gt;tuple-&gt;t_data-&gt;t_ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L593" title="access/heap/rewriteheap.c:593">raw_heap_insert</a>(state, unresolved-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Write the last page, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_buffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(state-&gt;rs_bulkstate, state-&gt;rs_blockno, state-&gt;rs_buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L129" title="storage/smgr/bulk_write.c:129">smgr_bulk_finish</a>(state-&gt;rs_bulkstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L905" title="access/heap/rewriteheap.c:905">logical_end_heap_rewrite</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deleting the context frees everything */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(state-&gt;rs_cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a tuple to the new heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Visibility information is copied from the original tuple, except that<br/></li>
<li></span><span class="Comment"> * we &quot;freeze&quot; very-old tuples.&nbsp; Note that since we scribble on new_tuple,<br/></li>
<li></span><span class="Comment"> * it had better be temp storage not a pointer to the original tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * state&nbsp; &nbsp; &nbsp; &nbsp; opaque state as returned by <a href="#L234" title="access/heap/rewriteheap.c:234">begin_heap_rewrite</a><br/></li>
<li></span><span class="Comment"> * old_tuple&nbsp; &nbsp; original tuple in the old heap<br/></li>
<li></span><span class="Comment"> * new_tuple&nbsp; &nbsp; new, rewritten tuple to be inserted to new heap<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L341">&#x200c;</a></span><span class="linkable">rewrite_heap_tuple</span>(RewriteState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple old_tuple, HeapTuple new_tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext old_cxt;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData old_tid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="access/heap/rewriteheap.c:165">TidHashKey</a>&nbsp; &nbsp; hashkey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; free_new;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_cxt = MemoryContextSwitchTo(state-&gt;rs_cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the original tuple's visibility information into new_tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> we might later need to copy some t_infomask2 bits, too? Right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we intentionally clear the HOT status bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(&amp;new_tuple-&gt;t_data-&gt;t_choice.t_heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;old_tuple-&gt;t_data-&gt;t_choice.t_heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleFields));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask &amp;= ~HEAP_XACT_MASK;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask2 &amp;= ~HEAP2_XACT_MASK;<br/></li>
<li>&nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_infomask |=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XACT_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While we have our hands on the tuple, we may as well freeze <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eligible xmin or xmax, so that future VACUUM effort can be saved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="heapam.c.html#L6913" title="access/heap/heapam.c:6913">heap_freeze_tuple</a>(new_tuple-&gt;t_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_old_rel-&gt;rd_rel-&gt;relfrozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_old_rel-&gt;rd_rel-&gt;relminmxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_freeze_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_cutoff_multi);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalid ctid means that ctid should point to the tuple itself. We'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * override it later if the tuple is part of an update chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;new_tuple-&gt;t_data-&gt;t_ctid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple has been updated, check the old-to-new mapping <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!((old_tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L1520" title="access/heap/heapam_visibility.c:1520">HeapTupleHeaderIsOnlyLocked</a>(old_tuple-&gt;t_data)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !HeapTupleHeaderIndicatesMovedPartitions(old_tuple-&gt;t_data) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;(old_tuple-&gt;t_self),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(old_tuple-&gt;t_data-&gt;t_ctid))))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L185" title="access/heap/rewriteheap.c:185">OldToNewMapping</a> mapping;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hashkey, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hashkey));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashkey.xmin = HeapTupleHeaderGetUpdateXid(old_tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashkey.tid = old_tuple-&gt;t_data-&gt;t_ctid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapping = (<a href="#L185" title="access/heap/rewriteheap.c:185">OldToNewMapping</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_old_new_tid_map, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mapping != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We've already copied the tuple that t_ctid points to, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set the ctid of this tuple to point to the new location, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert it right away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_ctid = mapping-&gt;new_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't need the mapping entry anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_old_new_tid_map, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We haven't seen the tuple t_ctid points to yet. Stash this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple into unresolved_tups to be written later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="access/heap/rewriteheap.c:177">UnresolvedTup</a> unresolved;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unresolved = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_unresolved_tups, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unresolved-&gt;old_tid = old_tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unresolved-&gt;tuple = <a href="../common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(new_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't do anything more <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, since we don't know where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple will be written.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we will write the tuple, and then check to see if it is the B tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new or known pair.&nbsp; When we resolve a known pair, we will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * able to write that pair's A tuple, and then we have to check if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * resolves some other pair.&nbsp; Hence, we need a loop here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_tid = old_tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; free_new = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData new_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the tuple and <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out where it's put in new_heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L593" title="access/heap/rewriteheap.c:593">raw_heap_insert</a>(state, new_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_tid = new_tuple-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L999" title="access/heap/rewriteheap.c:999">logical_rewrite_heap_tuple</a>(state, old_tid, new_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple is the updated version of a row, and the prior version<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wouldn't be DEAD yet, then we need to either resolve the prior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * version (if it's <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> in rs_unresolved_tups), or make an entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in rs_old_new_tid_map (so we can resolve it when we do see it). The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous tuple's xmax would <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> this one's xmin, so it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RECENTLY_DEAD if and only if the xmin is not <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> OldestXmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((new_tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_UPDATED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(HeapTupleHeaderGetXmin(new_tuple-&gt;t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;rs_oldest_xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Okay, this is B in an update pair.&nbsp; See if we've seen A.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="access/heap/rewriteheap.c:177">UnresolvedTup</a> unresolved;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;hashkey, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hashkey));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashkey.xmin = HeapTupleHeaderGetXmin(new_tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashkey.tid = old_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unresolved = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_unresolved_tups, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unresolved != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have seen and memorized the previous tuple already. Now<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we know where we inserted the tuple its t_ctid points<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to, fix its t_ctid and insert it to the new heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (free_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(new_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tuple = unresolved-&gt;tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_new = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_tid = unresolved-&gt;old_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_tuple-&gt;t_data-&gt;t_ctid = new_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> entry anymore, but don't free its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple just yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_unresolved_tups, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop back to insert the previous tuple in the chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the new tid of this tuple. We'll use it to set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ctid when we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the previous tuple in the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L185" title="access/heap/rewriteheap.c:185">OldToNewMapping</a> mapping;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapping = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_old_new_tid_map, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapping-&gt;new_tid = new_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done with this (chain of) tuples, for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (free_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(new_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(old_cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a dead tuple with an ongoing rewrite. Dead tuples are not<br/></li>
<li></span><span class="Comment"> * copied to the new table, but we still make note of them so that we<br/></li>
<li></span><span class="Comment"> * can release some resources earlier.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if a tuple was removed from the unresolved_tups table.<br/></li>
<li></span><span class="Comment"> * This indicates that that tuple, previously thought to be &quot;recently dead&quot;,<br/></li>
<li></span><span class="Comment"> * is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> known really dead and won't be written to the output.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L543">&#x200c;</a></span><span class="linkable">rewrite_heap_dead_tuple</span>(RewriteState state, HeapTuple old_tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have already seen an earlier tuple in the update chain that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * points to this tuple, let's forget about that earlier tuple. It's in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fact dead as well, our simple xmax &lt; OldestXmin test in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a> just wasn't enough to detect it. It happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when xmin of a tuple is greater than xmax, which sounds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * counter-intuitive but is perfectly valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to try to detect the situation the other way round,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when we encounter the dead tuple first and then the recently dead one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that points to it. If that happens, we'll have some unmatched entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the UnresolvedTups <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table at the end. That can happen anyway,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> might have removed the dead tuple in the chain <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L177" title="access/heap/rewriteheap.c:177">UnresolvedTup</a> unresolved;<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="access/heap/rewriteheap.c:165">TidHashKey</a>&nbsp; &nbsp; hashkey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memset(&amp;hashkey, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(hashkey));<br/></li>
<li>&nbsp; &nbsp; hashkey.xmin = HeapTupleHeaderGetXmin(old_tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; hashkey.tid = old_tuple-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; unresolved = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_unresolved_tups, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unresolved != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to free the contained tuple as well as the hashtable entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(unresolved-&gt;tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_unresolved_tups, &amp;hashkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a tuple to the new relation.&nbsp; This has to track <a href="heapam.c.html#L1990" title="access/heap/heapam.c:1990">heap_insert</a><br/></li>
<li></span><span class="Comment"> * and its subsidiary <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * t_self of the tuple is set to the new TID of the tuple. If t_ctid of the<br/></li>
<li></span><span class="Comment"> * tuple is invalid on entry, it's replaced with the new TID as well (in<br/></li>
<li></span><span class="Comment"> * the inserted data only, not in the caller's copy).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L593">&#x200c;</a></span><span class="linkable">raw_heap_insert</span>(RewriteState state, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saveFreeSpace;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber newoff;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heaptup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the new tuple is too big for storage or contains already toasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out-of-line attributes from some other relation, invoke the toaster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: below this point, heaptup is the data we actually intend to store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the relation; tup is the caller's original untoasted data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_new_rel-&gt;rd_rel-&gt;relkind == RELKIND_TOASTVALUE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* toast table entries should never be recursively toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHasExternal(tup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heaptup = tup;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HeapTupleHasExternal(tup) || tup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options = HEAP_INSERT_SKIP_FSM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While rewriting the heap for VACUUM FULL / CLUSTER, make sure data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the TOAST table are not logically decoded.&nbsp; The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> heap is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logged as XLOG FPI <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, which are not logically decoded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; options |= HEAP_INSERT_NO_LOGICAL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heaptup = <a href="heaptoast.c.html#L96" title="access/heap/heaptoast.c:96">heap_toast_insert_or_update</a>(state-&gt;rs_new_rel, tup, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; heaptup = tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = MAXALIGN(heaptup-&gt;t_len); <span class="Comment">/* be conservative */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're gonna fail for oversize tuple, do it right away<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; MaxHeapTupleSize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;row is too big: size </span><span class="Special">%zu</span><span class="Constant">, maximum size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len, MaxHeapTupleSize)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute desired extra freespace due to fillfactor option */<br/></li>
<li></span>&nbsp; &nbsp; saveFreeSpace = RelationGetTargetPageFreeSpace(state-&gt;rs_new_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_DEFAULT_FILLFACTOR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can check to see if there's enough free space already. */<br/></li>
<li></span>&nbsp; &nbsp; page = (Page) state-&gt;rs_buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (page)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageFreeSpace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len + saveFreeSpace &gt; pageFreeSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doesn't fit, so write out the existing page.&nbsp; It always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains a tuple.&nbsp; Hence, unlike <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>(),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enforce saveFreeSpace unconditionally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(state-&gt;rs_bulkstate, state-&gt;rs_blockno, state-&gt;rs_buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_buffer = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_blockno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!page)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize a new empty page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_buffer = <a href="../../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(state-&gt;rs_bulkstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) state-&gt;rs_buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BLCKSZ, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can insert the tuple into the page */<br/></li>
<li></span>&nbsp; &nbsp; newoff = PageAddItem(page, (Item) heaptup-&gt;t_data, heaptup-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOffsetNumber, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newoff == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add tuple&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update caller's t_self to the actual position where it was stored */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSet(&amp;(tup-&gt;t_self), state-&gt;rs_blockno, newoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the correct position into CTID of the stored tuple, too, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller didn't supply a valid CTID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ItemPointerIsValid(&amp;tup-&gt;t_data-&gt;t_ctid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; newitemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader onpage_tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newitemid = PageGetItemId(page, newoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; onpage_tup = (HeapTupleHeader) PageGetItem(page, newitemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; onpage_tup-&gt;t_ctid = tup-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If heaptup is a private copy, release it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heaptup != tup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(heaptup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * Logical rewrite support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When doing logical decoding - which relies on using cmin/cmax of catalog<br/></li>
<li></span><span class="Comment"> * tuples, via xl_heap_new_cid <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> - heap rewrites have to log enough<br/></li>
<li></span><span class="Comment"> * information to allow the decoding backend to update its <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> mapping<br/></li>
<li></span><span class="Comment"> * of (relfilelocator,ctid) =&gt; (cmin, cmax) to be correct for the rewritten heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For that, every time we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a tuple that's been modified in a catalog<br/></li>
<li></span><span class="Comment"> * relation within the xmin horizon of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> decoding slot, we log a mapping<br/></li>
<li></span><span class="Comment"> * from the old to the new location.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To deal with rewrites that abort the filename of a mapping file contains<br/></li>
<li></span><span class="Comment"> * the xid of the transaction performing the rewrite, which then can be<br/></li>
<li></span><span class="Comment"> * checked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> being read in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For efficiency we don't immediately spill every single map mapping for a<br/></li>
<li></span><span class="Comment"> * row to disk but only do so in batches when we've collected several of them<br/></li>
<li></span><span class="Comment"> * in memory or when <a href="#L297" title="access/heap/rewriteheap.c:297">end_heap_rewrite</a>() has been called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Crash-Safety: This module diverts from the usual patterns of doing WAL<br/></li>
<li></span><span class="Comment"> * since it cannot rely on checkpoint flushing out all buffers and thus<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for exclusive locks on buffers. Usually the <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>() covering<br/></li>
<li></span><span class="Comment"> * buffer modifications is performed while the buffer(s) that are being<br/></li>
<li></span><span class="Comment"> * modified are exclusively locked guaranteeing that both the WAL record and<br/></li>
<li></span><span class="Comment"> * the modified heap are on either side of the checkpoint. But since the<br/></li>
<li></span><span class="Comment"> * mapping files we log aren't in shared_buffers that interlock doesn't work.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Instead we simply write the mapping files out to disk, *<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>* the<br/></li>
<li></span><span class="Comment"> * <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>() is performed. That guarantees that either the <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>() is<br/></li>
<li></span><span class="Comment"> * inserted after the checkpoint's redo pointer or that the checkpoint (via<br/></li>
<li></span><span class="Comment"> * <a href="#L1155" title="access/heap/rewriteheap.c:1155">CheckPointLogicalRewriteHeap</a>()) has flushed the (partial) mapping file to<br/></li>
<li></span><span class="Comment"> * disk. That leaves the tail end that has not yet been flushed open to<br/></li>
<li></span><span class="Comment"> * corruption, which is solved by including the current offset in the<br/></li>
<li></span><span class="Comment"> * xl_heap_rewrite_mapping <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> and truncating the mapping file to it<br/></li>
<li></span><span class="Comment"> * during replay. Every time a rewrite is finished all generated mapping files<br/></li>
<li></span><span class="Comment"> * are synced to disk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we were only concerned about crash safety we wouldn't have to<br/></li>
<li></span><span class="Comment"> * deal with WAL logging at all - an fsync() at the end of a rewrite would be<br/></li>
<li></span><span class="Comment"> * sufficient for crash safety. Any mapping that hasn't been safely flushed to<br/></li>
<li></span><span class="Comment"> * disk has to be by an aborted (explicitly or via a crash) transaction and is<br/></li>
<li></span><span class="Comment"> * ignored by virtue of the xid in its name being subject to a<br/></li>
<li></span><span class="Comment"> * TransactionDidCommit() check. But we want to support having standbys via<br/></li>
<li></span><span class="Comment"> * physical replication, both for availability and to do logical decoding<br/></li>
<li></span><span class="Comment"> * there.<br/></li>
<li></span><span class="Comment"> * ------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do preparations for logging logical mappings during a rewrite if<br/></li>
<li></span><span class="Comment"> * necessary. If we detect that we don't need to log anything we'll prevent<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further action by the various logical rewrite <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L759">&#x200c;</a></span><span class="linkable">logical_begin_heap_rewrite</span>(RewriteState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hash_ctl;<br/></li>
<li>&nbsp; &nbsp; TransactionId logical_xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only need to persist these mappings if the rewritten table can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accessed during logical decoding, if not, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * additional work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;rs_logical_rewrite =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelationIsAccessibleInLogicalDecoding(state-&gt;rs_old_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;rs_logical_rewrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L3952" title="storage/ipc/procarray.c:3952">ProcArrayGetReplicationSlotXmin</a>(<span class="Constant">NULL</span>, &amp;logical_xmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no logical slots in progress we don't need to do anything,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there cannot be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remappings for relevant rows yet. The relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock protects us against races.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (logical_xmin == InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_logical_rewrite = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_logical_xmin = logical_xmin;<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_begin_lsn = <a href="../transam/xlog.c.html#L9355" title="access/transam/xlog.c:9355">GetXLogInsertRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_num_rewrite_mappings = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hash_ctl.keysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.entrysize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a>);<br/></li>
<li>&nbsp; &nbsp; hash_ctl.hcxt = state-&gt;rs_cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_logical_mappings =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Logical rewrite mapping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">128</span>,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arbitrary initial size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hash_ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flush all logical in-memory mappings to disk, but don't fsync them yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L807">&#x200c;</a></span><span class="linkable">logical_heap_rewrite_flush_mappings</span>(RewriteState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seq_status;<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *src;<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;rs_logical_rewrite);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no logical rewrite in progress, no need to iterate over mappings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_num_rewrite_mappings == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;flushing </span><span class="Special">%u</span><span class="Constant"> logical rewrite mapping entries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;rs_num_rewrite_mappings);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seq_status, state-&gt;rs_logical_mappings);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((src = (<a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seq_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *waldata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *waldata_start;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_rewrite_mapping xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; num_mappings = dclist_count(&amp;src-&gt;mappings);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this file hasn't got <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new mappings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_mappings == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_old_rel-&gt;rd_rel-&gt;relisshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.num_mappings = num_mappings;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.mapped_rel = RelationGetRelid(state-&gt;rs_old_rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.mapped_xid = src-&gt;xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.mapped_db = dboid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offset = src-&gt;off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.start_lsn = state-&gt;rs_begin_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write all mappings consecutively */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; len = num_mappings * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRewriteMappingData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; waldata_start = waldata = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collect data we need to write out, but don't modify ondisk data yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dclist_foreach_modify(iter, &amp;src-&gt;mappings)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L204" title="access/heap/rewriteheap.c:204">RewriteMappingDataEntry</a> *pmap;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pmap = dclist_container(<a href="#L204" title="access/heap/rewriteheap.c:204">RewriteMappingDataEntry</a>, node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(waldata, &amp;pmap-&gt;map, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pmap-&gt;map));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waldata += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pmap-&gt;map);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove from the list and free */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dclist_delete_from(&amp;src-&gt;mappings, &amp;pmap-&gt;node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update bookkeeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;rs_num_rewrite_mappings--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(dclist_count(&amp;src-&gt;mappings) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(waldata == waldata_start + len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we deviate from the usual WAL coding practices here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check the above &quot;Logical rewrite support&quot; comment for reasoning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; written = FileWrite(src-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>, waldata_start, len, src-&gt;off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_LOGICAL_REWRITE_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (written != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">, wrote </span><span class="Special">%d</span><span class="Constant"> of </span><span class="Special">%d</span><span class="Constant">: %m&quot;</span>, src-&gt;path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; written, len)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src-&gt;off += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) (&amp;xlrec), <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>(waldata_start, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write xlog record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP2_ID, XLOG_HEAP2_REWRITE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(waldata_start);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;rs_num_rewrite_mappings == <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Logical remapping part of <a href="#L297" title="access/heap/rewriteheap.c:297">end_heap_rewrite</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L905">&#x200c;</a></span><span class="linkable">logical_end_heap_rewrite</span>(RewriteState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS seq_status;<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *src;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done, no logical rewrite in progress */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;rs_logical_rewrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* writeout remaining in-memory entries */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_num_rewrite_mappings &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L807" title="access/heap/rewriteheap.c:807">logical_heap_rewrite_flush_mappings</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate over all mappings we have written and fsync the files. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seq_status, state-&gt;rs_logical_mappings);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((src = (<a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *) <a href="../../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seq_status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2297" title="storage/file/fd.c:2297">FileSync</a>(src-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>, WAIT_EVENT_LOGICAL_REWRITE_SYNC) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../storage/file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, src-&gt;path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(src-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* memory context <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> will deal with the rest */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log a single (old-&gt;new) mapping for 'xid'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L935">&#x200c;</a></span><span class="linkable">logical_rewrite_log_mapping</span>(RewriteState state, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LogicalRewriteMappingData *map)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../replication/logical/reorderbuffer.c.html#L5016" title="replication/logical/reorderbuffer.c:5016">RewriteMappingFile</a> *src;<br/></li>
<li>&nbsp; &nbsp; <a href="#L204" title="access/heap/rewriteheap.c:204">RewriteMappingDataEntry</a> *pmap;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relid = RelationGetRelid(state-&gt;rs_old_rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* look for existing mappings for this 'mapped' xid */<br/></li>
<li></span>&nbsp; &nbsp; src = <a href="../../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(state-&gt;rs_logical_mappings, &amp;xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We haven't yet had the need to map anything for this xid, create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-xid data structures.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_old_rel-&gt;rd_rel-&gt;relisshared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid = <a href="../../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, MAXPGPATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;pg_logical/mappings/&quot;</span> LOGICAL_REWRITE_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dboid, relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(state-&gt;rs_begin_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dclist_init(&amp;src-&gt;mappings);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src-&gt;off = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(src-&gt;path, path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; src-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a> = <a href="../../storage/file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; O_CREAT | O_EXCL | O_WRONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (src-&gt;<a href="../../storage/file/fd.c.html#L196" title="storage/file/fd.c:196">vfd</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pmap = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(state-&gt;rs_cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L204" title="access/heap/rewriteheap.c:204">RewriteMappingDataEntry</a>));<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;pmap-&gt;map, map, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRewriteMappingData));<br/></li>
<li>&nbsp; &nbsp; dclist_push_tail(&amp;src-&gt;mappings, &amp;pmap-&gt;node);<br/></li>
<li>&nbsp; &nbsp; state-&gt;rs_num_rewrite_mappings++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write out buffer every time we've too many in-memory entries across all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mapping files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;rs_num_rewrite_mappings &gt;= <span class="Constant">1000</span> <span class="Comment">/* arbitrary number */</span> )<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L807" title="access/heap/rewriteheap.c:807">logical_heap_rewrite_flush_mappings</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform logical remapping for a tuple that's mapped from old_tid to<br/></li>
<li></span><span class="Comment"> * new_tuple-&gt;t_self by <a href="#L341" title="access/heap/rewriteheap.c:341">rewrite_heap_tuple</a>() if necessary for the tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L999">&#x200c;</a></span><span class="linkable">logical_rewrite_heap_tuple</span>(RewriteState state, ItemPointerData old_tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple new_tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointerData new_tid = new_tuple-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; TransactionId cutoff = state-&gt;rs_logical_xmin;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_log_xmin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_log_xmax = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; LogicalRewriteMappingData map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no logical rewrite in progress, we don't need to log anything */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;rs_logical_rewrite)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmin = HeapTupleHeaderGetXmin(new_tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use *GetUpdateXid to correctly deal with multixacts */<br/></li>
<li></span>&nbsp; &nbsp; xmax = HeapTupleHeaderGetUpdateXid(new_tuple-&gt;t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Log the mapping iff the tuple has been created recently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xmin) &amp;&amp; !<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xmin, cutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; do_log_xmin = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xmax))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no xmax is set, can't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> permanent ones, so this check is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(new_tuple-&gt;t_data-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only locked, we don't care */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xmax, cutoff))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple has been deleted recently, log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; do_log_xmax = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if neither needs to be logged, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!do_log_xmin &amp;&amp; !do_log_xmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill out mapping information */<br/></li>
<li></span>&nbsp; &nbsp; map.old_locator = state-&gt;rs_old_rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; map.old_tid = old_tid;<br/></li>
<li>&nbsp; &nbsp; map.new_locator = state-&gt;rs_new_rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; map.new_tid = new_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now persist the mapping for the individual xids that are affected. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to log for both xmin and xmax if they aren't the same transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since the mapping files are per &quot;affected&quot; xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't muster all that much effort detecting whether xmin and xmax<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are actually the same transaction, we just check whether the xid is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same disregarding subtransactions. Logging too much is relatively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * harmless and we could never do the check fully since subtransaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data is thrown away during restarts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (do_log_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L935" title="access/heap/rewriteheap.c:935">logical_rewrite_log_mapping</a>(state, xmin, &amp;map);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* separately log mapping for xmax unless it'd be redundant */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (do_log_xmax &amp;&amp; !TransactionIdEquals(xmin, xmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L935" title="access/heap/rewriteheap.c:935">logical_rewrite_log_mapping</a>(state, xmax, &amp;map);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replay XLOG_HEAP2_REWRITE <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1073">&#x200c;</a></span><span class="linkable">heap_xlog_logical_rewrite</span>(XLogReaderState *r)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li>&nbsp; &nbsp; xl_heap_rewrite_mapping *xlrec;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec = (xl_heap_rewrite_mapping *) XLogRecGetData(r);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, MAXPGPATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;pg_logical/mappings/&quot;</span> LOGICAL_REWRITE_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;mapped_db, xlrec-&gt;mapped_rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(xlrec-&gt;start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;mapped_xid, XLogRecGetXid(r));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; O_CREAT | O_WRONLY | PG_BINARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncate all data that's not guaranteed to have been safely fsynced (by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous record or by the last checkpoint).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOGICAL_REWRITE_TRUNCATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ftruncate(fd, xlrec-&gt;offset) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not truncate file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path, (uint32) xlrec-&gt;offset)));<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; data = XLogRecGetData(r) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*xlrec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = xlrec-&gt;num_mappings * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(LogicalRewriteMappingData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write out tail end of mapping file (again) */<br/></li>
<li></span>&nbsp; &nbsp; errno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOGICAL_REWRITE_MAPPING_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pg_pwrite(fd, data, len, xlrec-&gt;offset) != len)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if write didn't set errno, assume problem is no disk space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">ENOSPC</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write to file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now fsync all previously written data. We could improve things and only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this for the last write to a file, but the required bookkeeping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't seem worth the trouble.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOGICAL_REWRITE_MAPPING_SYNC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../storage/file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ---<br/></li>
<li></span><span class="Comment"> * Perform a checkpoint for logical rewrite mappings<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This serves two tasks:<br/></li>
<li></span><span class="Comment"> * 1) Remove all mappings not needed anymore based on the logical restart LSN<br/></li>
<li></span><span class="Comment"> * 2) Flush all remaining mappings to disk, so that replay after a checkpoint<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; only has to deal with the parts of a mapping that have been written out<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; after the checkpoint started.<br/></li>
<li></span><span class="Comment"> * ---<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1155">&#x200c;</a></span><span class="linkable">CheckPointLogicalRewriteHeap</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; cutoff;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; redo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *mappings_dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *mapping_de;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH + <span class="Constant">20</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We start of with a minimum of the last redo pointer. No new decoding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slot will start <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> that, so that's a safe <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound for removal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; redo = <a href="../transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> check for the restart ptrs from existing slots */<br/></li>
<li></span>&nbsp; &nbsp; cutoff = <a href="../../replication/slot.c.html#L1154" title="replication/slot.c:1154">ReplicationSlotsComputeLogicalRestartLSN</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't start earlier than the restart lsn */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cutoff != InvalidXLogRecPtr &amp;&amp; redo &lt; cutoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cutoff = redo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mappings_dir = <a href="../../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<span class="Constant">&quot;pg_logical/mappings&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((mapping_de = <a href="../../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(mappings_dir, <span class="Constant">&quot;pg_logical/mappings&quot;</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId rewrite_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId create_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PGFileType&nbsp; &nbsp; de_type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(mapping_de-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(mapping_de-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <span class="Constant">&quot;pg_logical/mappings/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, mapping_de-&gt;d_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; de_type = get_dirent_type(path, mapping_de, <span class="Constant">false</span>, DEBUG1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (de_type != PGFILETYPE_ERROR &amp;&amp; de_type != PGFILETYPE_REG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip over files that cannot be ours. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strncmp(mapping_de-&gt;d_name, <span class="Constant">&quot;map-&quot;</span>, <span class="Constant">4</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sscanf(mapping_de-&gt;d_name, LOGICAL_REWRITE_FORMAT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;dboid, &amp;relid, &amp;hi, &amp;lo, &amp;rewrite_xid, &amp;create_xid) != <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> filename </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, mapping_de-&gt;d_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn = ((uint64) hi) &lt;&lt; <span class="Constant">32</span> | lo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lsn &lt; cutoff || cutoff == InvalidXLogRecPtr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;removing logical rewrite file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(path) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* on some operating systems fsyncing a file requires O_RDWR */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = <a href="../../storage/file/fd.c.html#L2633" title="storage/file/fd.c:2633">OpenTransientFile</a>(path, O_RDWR | PG_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The file cannot vanish due to concurrency since this function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is the only one removing logical mappings and only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint can be in progress at a time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could try to avoid fsyncing files that either haven't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed or have only been created since the checkpoint's start,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it's currently not deemed worth the effort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_start(WAIT_EVENT_LOGICAL_REWRITE_CHECKPOINT_SYNC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L386" title="storage/file/fd.c:386">pg_fsync</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(<a href="../../storage/file/fd.c.html#L3936" title="storage/file/fd.c:3936">data_sync_elevel</a>(ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fsync file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/file/fd.c.html#L2809" title="storage/file/fd.c:2809">CloseTransientFile</a>(fd) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not close file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, path)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(mappings_dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* persist directory entries to disk */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/file/fd.c.html#L756" title="storage/file/fd.c:756">fsync_fname</a>(<span class="Constant">&quot;pg_logical/mappings&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
