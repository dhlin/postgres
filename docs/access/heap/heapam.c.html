<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/heapam.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/heapam.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L207">MultiXactStatusLock</a></li>
<li><a href="#L134">tupleLockExtraInfo</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L196">IndexDeleteCounts</a></li>
<li><a href="#L201">IndexDeleteCounts</a></li>
<li><a href="#L185">IndexDeletePrefetchState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L7305">ConditionalMultiXactIdWait</a></li>
<li><a href="#L7205">Do_MultiXactIdWait</a></li>
<li><a href="#L7106">DoesMultiXactIdConflict</a></li>
<li><a href="#L8651">ExtractReplicaIdentity</a></li>
<li><a href="#L1940">FreeBulkInsertState</a></li>
<li><a href="#L6191">FreezeMultiXactId</a></li>
<li><a href="#L1923">GetBulkInsertState</a></li>
<li><a href="#L6957">GetMultiXactIdHintBits</a></li>
<li><a href="#L10052">HeapCheckForSerializableConflictOut</a></li>
<li><a href="#L4127">HeapDetermineColumnsInfo</a></li>
<li><a href="#L7090">HeapTupleGetUpdateXid</a></li>
<li><a href="#L7482">HeapTupleHeaderAdvanceConflictHorizon</a></li>
<li><a href="#L7038">MultiXactIdGetUpdateXid</a></li>
<li><a href="#L7283">MultiXactIdWait</a></li>
<li><a href="#L1952">ReleaseBulkInsertStatePin</a></li>
<li><a href="#L1901">UpdateXmaxHintBits</a></li>
<li><a href="#L8069">bottomup_nblocksfavorable</a></li>
<li><a href="#L8185">bottomup_sort_and_shrink</a></li>
<li><a href="#L8112">bottomup_sort_and_shrink_cmp</a></li>
<li><a href="#L2634">compute_infobits</a></li>
<li><a href="#L5053">compute_new_xmax_infomask</a></li>
<li><a href="#L9030">fix_infomask_from_infobits</a></li>
<li><a href="#L4258">get_mxact_status_for_lock</a></li>
<li><a href="#L9917">heap2_redo</a></li>
<li><a href="#L5902">heap_abort_speculative</a></li>
<li><a href="#L5004">heap_acquire_tuplock</a></li>
<li><a href="#L4076">heap_attr_equals</a></li>
<li><a href="#L1037">heap_beginscan</a></li>
<li><a href="#L2679">heap_delete</a></li>
<li><a href="#L1204">heap_endscan</a></li>
<li><a href="#L6815">heap_execute_freeze_tuple</a></li>
<li><a href="#L1507">heap_fetch</a></li>
<li><a href="#L584">heap_fetch_next_buffer</a></li>
<li><a href="#L5815">heap_finish_speculative</a></li>
<li><a href="#L6891">heap_freeze_prepared_tuples</a></li>
<li><a href="#L6913">heap_freeze_tuple</a></li>
<li><a href="#L1779">heap_get_latest_tid</a></li>
<li><a href="#L1248">heap_getnext</a></li>
<li><a href="#L1297">heap_getnextslot</a></li>
<li><a href="#L1400">heap_getnextslot_tidrange</a></li>
<li><a href="#L1627">heap_hot_search_buffer</a></li>
<li><a href="#L7627">heap_index_delete_tuples</a></li>
<li><a href="#L6055">heap_inplace_update</a></li>
<li><a href="#L1990">heap_insert</a></li>
<li><a href="#L4306">heap_lock_tuple</a></li>
<li><a href="#L5770">heap_lock_updated_tuple</a></li>
<li><a href="#L5425">heap_lock_updated_tuple_rec</a></li>
<li><a href="#L9956">heap_mask</a></li>
<li><a href="#L2259">heap_multi_insert</a></li>
<li><a href="#L2227">heap_multi_insert_pages</a></li>
<li><a href="#L6838">heap_pre_freeze_checks</a></li>
<li><a href="#L6541">heap_prepare_freeze_tuple</a></li>
<li><a href="#L2179">heap_prepare_insert</a></li>
<li><a href="#L493">heap_prepare_pagescan</a></li>
<li><a href="#L9871">heap_redo</a></li>
<li><a href="#L1151">heap_rescan</a></li>
<li><a href="#L231">heap_scan_stream_read_next_parallel</a></li>
<li><a href="#L269">heap_scan_stream_read_next_serial</a></li>
<li><a href="#L1327">heap_set_tidrange</a></li>
<li><a href="#L421">heap_setscanlimits</a></li>
<li><a href="#L7319">heap_tuple_needs_eventual_freeze</a></li>
<li><a href="#L7374">heap_tuple_should_freeze</a></li>
<li><a href="#L3146">heap_update</a></li>
<li><a href="#L9663">heap_xlog_confirm</a></li>
<li><a href="#L9051">heap_xlog_delete</a></li>
<li><a href="#L9830">heap_xlog_inplace</a></li>
<li><a href="#L9124">heap_xlog_insert</a></li>
<li><a href="#L9699">heap_xlog_lock</a></li>
<li><a href="#L9770">heap_xlog_lock_updated</a></li>
<li><a href="#L9244">heap_xlog_multi_insert</a></li>
<li><a href="#L8743">heap_xlog_prune_freeze</a></li>
<li><a href="#L9391">heap_xlog_update</a></li>
<li><a href="#L8895">heap_xlog_visible</a></li>
<li><a href="#L837">heapgettup</a></li>
<li><a href="#L753">heapgettup_advance_block</a></li>
<li><a href="#L707">heapgettup_continue_page</a></li>
<li><a href="#L629">heapgettup_initial_block</a></li>
<li><a href="#L947">heapgettup_pagemode</a></li>
<li><a href="#L676">heapgettup_start_page</a></li>
<li><a href="#L7567">index_delete_check_htid</a></li>
<li><a href="#L7522">index_delete_prefetch_buffer</a></li>
<li><a href="#L7972">index_delete_sort</a></li>
<li><a href="#L7936">index_delete_sort_cmp</a></li>
<li><a href="#L293">initscan</a></li>
<li><a href="#L8570">log_heap_new_cid</a></li>
<li><a href="#L8348">log_heap_update</a></li>
<li><a href="#L8314">log_heap_visible</a></li>
<li><a href="#L443">page_collect_tuples</a></li>
<li><a href="#L3100">simple_heap_delete</a></li>
<li><a href="#L2621">simple_heap_insert</a></li>
<li><a href="#L4217">simple_heap_update</a></li>
<li><a href="#L5334">test_lockmode_for_conflict</a></li>
<li><a href="#L2656">xmax_infomask_changed</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L189">BOTTOMUP_MAX_NBLOCKS</a></li>
<li><a href="#L190">BOTTOMUP_TOLERANCE_NBLOCKS</a></li>
<li><a href="#L171">ConditionalLockTupleTuplock</a></li>
<li><a href="#L6139">FRM_INVALIDATE_XMAX</a></li>
<li><a href="#L6142">FRM_MARK_COMMITTED</a></li>
<li><a href="#L6138">FRM_NOOP</a></li>
<li><a href="#L6141">FRM_RETURN_IS_MULTI</a></li>
<li><a href="#L6140">FRM_RETURN_IS_XID</a></li>
<li><a href="#L159">LOCKMODE_from_mxstatus</a></li>
<li><a href="#L167">LockTupleTuplock</a></li>
<li><a href="#L218">TUPLOCK_from_mxstatus</a></li>
<li><a href="#L169">UnlockTupleTuplock</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heapam.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; heap access method code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/heapam.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1037" title="access/heap/heapam.c:1037">heap_beginscan</a>&nbsp; &nbsp; - begin relation scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1151" title="access/heap/heapam.c:1151">heap_rescan</a>&nbsp; &nbsp; &nbsp; &nbsp; - restart a relation scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1204" title="access/heap/heapam.c:1204">heap_endscan</a>&nbsp; &nbsp; - end relation scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>&nbsp; &nbsp; - retrieve <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in scan<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1507" title="access/heap/heapam.c:1507">heap_fetch</a>&nbsp; &nbsp; &nbsp; &nbsp; - retrieve tuple with given tid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>&nbsp; &nbsp; &nbsp; &nbsp; - insert tuple into a relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a> - insert multiple tuples into a relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a>&nbsp; &nbsp; &nbsp; &nbsp; - delete a tuple from a relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a>&nbsp; &nbsp; &nbsp; &nbsp; - replace a tuple in a relation with another tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains the heap_ routines which implement<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the POSTGRES heap access method used for all POSTGRES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; relations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/bufmask.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heaptoast.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/hio.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/subtrans.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/syncscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/valid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/freespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/relcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/spccache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> HeapTuple <a href="#L2179" title="access/heap/heapam.c:2179">heap_prepare_insert</a>(Relation relation, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId xid, CommandId cid, <span class="Type">int</span> options);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L8348" title="access/heap/heapam.c:8348">log_heap_update</a>(Relation reln, Buffer oldbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer newbuf, HeapTuple oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple newtup, HeapTuple old_key_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_visible_cleared, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> new_all_visible_cleared);<br/></li>
<li><span class="Type">static</span> Bitmapset *<a href="#L4127" title="access/heap/heapam.c:4127">HeapDetermineColumnsInfo</a>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *interesting_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *external_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple oldtup, HeapTuple newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_external);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L5004" title="access/heap/heapam.c:5004">heap_acquire_tuplock</a>(Relation relation, ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockTupleMode mode, LockWaitPolicy wait_policy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_tuple_lock);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> BlockNumber <a href="#L753" title="access/heap/heapam.c:753">heapgettup_advance_block</a>(HeapScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection dir);<br/></li>
<li><span class="Type">static</span> pg_noinline BlockNumber <a href="#L629" title="access/heap/heapam.c:629">heapgettup_initial_block</a>(HeapScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5053" title="access/heap/heapam.c:5053">compute_new_xmax_infomask</a>(TransactionId xmax, uint16 old_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 old_infomask2, TransactionId add_to_xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode mode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_update,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *result_xmax, uint16 *result_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 *result_infomask2);<br/></li>
<li><span class="Type">static</span> TM_Result <a href="#L5770" title="access/heap/heapam.c:5770">heap_lock_updated_tuple</a>(Relation rel, HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer ctid, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockTupleMode mode);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(MultiXactId multi, uint16 *new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 *new_infomask2);<br/></li>
<li><span class="Type">static</span> TransactionId <a href="#L7038" title="access/heap/heapam.c:7038">MultiXactIdGetUpdateXid</a>(TransactionId xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 t_infomask);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7106" title="access/heap/heapam.c:7106">DoesMultiXactIdConflict</a>(MultiXactId multi, uint16 infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *current_is_member);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a>(MultiXactId multi, MultiXactStatus status, uint16 infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, ItemPointer ctid, XLTW_Oper <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *remaining);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L7305" title="access/heap/heapam.c:7305">ConditionalMultiXactIdWait</a>(MultiXactId multi, MultiXactStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 infomask, Relation rel, <span class="Type">int</span> *remaining);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L7972" title="access/heap/heapam.c:7972">index_delete_sort</a>(TM_IndexDeleteOp *delstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L8185" title="access/heap/heapam.c:8185">bottomup_sort_and_shrink</a>(TM_IndexDeleteOp *delstate);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(Relation relation, HeapTuple tup);<br/></li>
<li><span class="Type">static</span> HeapTuple <a href="#L8651" title="access/heap/heapam.c:8651">ExtractReplicaIdentity</a>(Relation relation, HeapTuple tp, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> key_required,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *copy);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Each tuple lock mode has a corresponding heavyweight lock, and one or two<br/></li>
<li></span><span class="Comment"> * corresponding MultiXactStatuses (one to merely lock tuples, another one to<br/></li>
<li></span><span class="Comment"> * update them).&nbsp; This table (and the macros below) helps us determine the<br/></li>
<li></span><span class="Comment"> * heavyweight lock mode and MultiXactStatus <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to use for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular<br/></li>
<li></span><span class="Comment"> * tuple lock strength.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Don't look at lockstatus/updstatus directly!&nbsp; Use <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a><br/></li>
<li></span><span class="Comment"> * instead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; hwlock;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lockstatus;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updstatus;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L134">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">tupleLockExtraInfo</span>[MaxLockTupleMode + <span class="Constant">1</span>] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LockTupleKeyShare */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatusForKeyShare,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* KeyShare does not allow updating tuples */<br/></li>
<li></span>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LockTupleShare */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RowShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatusForShare,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Share does not allow updating tuples */<br/></li>
<li></span>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LockTupleNoKeyExclusive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatusForNoKeyUpdate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatusNoKeyUpdate<br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* LockTupleExclusive */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AccessExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatusForUpdate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatusUpdate<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Get the LOCKMODE for a given MultiXactStatus */<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LOCKMODE_from_mxstatus</span>(status) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[<a href="#L218" title="access/heap/heapam.c:218">TUPLOCK_from_mxstatus</a>((status))].hwlock)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire heavyweight locks on tuples, using a LockTupleMode strength value.<br/></li>
<li></span><span class="Comment"> * This is more readable than having every caller <a href="../../utils/adt/oracle_compat.c.html#L797" title="utils/adt/oracle_compat.c:797">translate</a> it to lock.h's<br/></li>
<li></span><span class="Comment"> * LOCKMODE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LockTupleTuplock</span>(rel, tup, mode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L568" title="storage/lmgr/lmgr.c:568">LockTuple</a>((rel), (tup), <a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[mode].hwlock)<br/></li>
<li><a id="L169">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">UnlockTupleTuplock</span>(rel, tup, mode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L605" title="storage/lmgr/lmgr.c:605">UnlockTuple</a>((rel), (tup), <a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[mode].hwlock)<br/></li>
<li><a id="L171">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ConditionalLockTupleTuplock</span>(rel, tup, mode) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L588" title="storage/lmgr/lmgr.c:588">ConditionalLockTuple</a>((rel), (tup), <a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[mode].hwlock)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a> and <a href="#L7522" title="access/heap/heapam.c:7522">index_delete_prefetch_buffer</a> use this<br/></li>
<li></span><span class="Comment"> * structure to coordinate prefetching activity<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber cur_hblkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeltids;<br/></li>
<li>&nbsp; &nbsp; TM_IndexDelete *deltids;<br/></li>
<li><a id="L185">&#x200c;</a>} <span class="linkable">IndexDeletePrefetchState</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a> bottom-up index deletion costing constants */<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BOTTOMUP_MAX_NBLOCKS</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">6<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BOTTOMUP_TOLERANCE_NBLOCKS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a> uses this when determining which heap blocks it<br/></li>
<li></span><span class="Comment"> * must visit to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> its bottom-up index deletion caller<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">IndexDeleteCounts</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; npromisingtids; <span class="Comment">/* Number of &quot;promising&quot; TIDs in group */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; ntids;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of TIDs in group */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; ifirsttid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Offset to group's first deltid */<br/></li>
<li><a id="L201">&#x200c;</a></span>} <span class="linkable">IndexDeleteCounts</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This table <a href="../../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> tuple lock strength <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for each particular<br/></li>
<li></span><span class="Comment"> * MultiXactStatus value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L207">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">int</span> <span class="linkable">MultiXactStatusLock</span>[MaxMultiXactStatus + <span class="Constant">1</span>] =<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockTupleKeyShare,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ForKeyShare */<br/></li>
<li></span>&nbsp; &nbsp; LockTupleShare,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ForShare */<br/></li>
<li></span>&nbsp; &nbsp; LockTupleNoKeyExclusive,&nbsp; &nbsp; <span class="Comment">/* ForNoKeyUpdate */<br/></li>
<li></span>&nbsp; &nbsp; LockTupleExclusive,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ForUpdate */<br/></li>
<li></span>&nbsp; &nbsp; LockTupleNoKeyExclusive,&nbsp; &nbsp; <span class="Comment">/* NoKeyUpdate */<br/></li>
<li></span>&nbsp; &nbsp; LockTupleExclusive&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Get the LockTupleMode for a given MultiXactStatus */<br/></li>
<li><a id="L218">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">TUPLOCK_from_mxstatus</span>(status) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L207" title="access/heap/heapam.c:207">MultiXactStatusLock</a>[(status)])<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heap support routines<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Streaming read API callback for parallel sequential scans. Returns the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * block the caller wants from the read stream or InvalidBlockNumber when done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L231">&#x200c;</a><span class="linkable">heap_scan_stream_read_next_parallel</span>(<a href="../../storage/aio/read_stream.c.html#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *callback_private_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *per_buffer_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) callback_private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ScanDirectionIsForward(scan-&gt;rs_dir));<br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_base.rs_parallel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!scan-&gt;rs_inited))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parallel scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/tableam.c.html#L421" title="access/table/tableam.c:421">table_block_parallelscan_startblock_init</a>(scan-&gt;rs_base.rs_rd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_parallelworkerdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ParallelBlockTableScanDesc) scan-&gt;rs_base.rs_parallel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* may return InvalidBlockNumber if there are no more blocks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_prefetch_block = <a href="../table/tableam.c.html#L491" title="access/table/tableam.c:491">table_block_parallelscan_nextpage</a>(scan-&gt;rs_base.rs_rd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_parallelworkerdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ParallelBlockTableScanDesc) scan-&gt;rs_base.rs_parallel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_inited = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_prefetch_block = <a href="../table/tableam.c.html#L491" title="access/table/tableam.c:491">table_block_parallelscan_nextpage</a>(scan-&gt;rs_base.rs_rd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_parallelworkerdata, (ParallelBlockTableScanDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_parallel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan-&gt;rs_prefetch_block;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Streaming read API callback for serial sequential and TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> scans.<br/></li>
<li></span><span class="Comment"> * Returns the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block the caller wants from the read stream or<br/></li>
<li></span><span class="Comment"> * InvalidBlockNumber when done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L269">&#x200c;</a><span class="linkable">heap_scan_stream_read_next_serial</span>(<a href="../../storage/aio/read_stream.c.html#L109" title="storage/aio/read_stream.c:109">ReadStream</a> *stream,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *callback_private_data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *per_buffer_data)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) callback_private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!scan-&gt;rs_inited))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_prefetch_block = <a href="#L629" title="access/heap/heapam.c:629">heapgettup_initial_block</a>(scan, scan-&gt;rs_dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_inited = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_prefetch_block = <a href="#L753" title="access/heap/heapam.c:753">heapgettup_advance_block</a>(scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_prefetch_block,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan-&gt;rs_prefetch_block;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L293" title="access/heap/heapam.c:293">initscan</a> - scan code common to <a href="#L1037" title="access/heap/heapam.c:1037">heap_beginscan</a> and <a href="#L1151" title="access/heap/heapam.c:1151">heap_rescan</a><br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L293">&#x200c;</a></span><span class="linkable">initscan</span>(HeapScanDesc scan, ScanKey key, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> keep_startblock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelBlockTableScanDesc bpscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_strat;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_sync;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the number of blocks we have to scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is sufficient to do this once at scan start, since <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while the scan is in progress will be invisible to my snapshot anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (That is not true when using a non-MVCC snapshot.&nbsp; However, we couldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guarantee to return tuples added after scan start anyway, since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might go into pages we already scanned.&nbsp; To guarantee consistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results for a non-MVCC snapshot, the caller must hold some higher-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock that ensures the interesting tuple(s) won't change.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_parallel != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bpscan = (ParallelBlockTableScanDesc) scan-&gt;rs_base.rs_parallel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_nblocks = bpscan-&gt;phs_nblocks;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_nblocks = RelationGetNumberOfBlocks(scan-&gt;rs_base.rs_rd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the table is large relative to <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>, use a bulk-read access<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy and enable synchronized scanning (see syncscan.c).&nbsp; Although<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the thresholds for these features could be different, we make them the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same so that there are only two behaviors to tune rather than four.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (However, some callers need to be able to disable one or both of these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behaviors, independently of the size of the table; also there is a GUC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable that can disable synchronized scanning.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="../table/tableam.c.html#L388" title="access/table/tableam.c:388">table_block_parallelscan_initialize</a> has a very similar test;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if you change this, consider changing that one, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationUsesLocalBuffers(scan-&gt;rs_base.rs_rd) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_nblocks &gt; <a href="../../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a> / <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allow_strat = (scan-&gt;rs_base.rs_flags &amp; SO_ALLOW_STRAT) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; allow_sync = (scan-&gt;rs_base.rs_flags &amp; SO_ALLOW_SYNC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; allow_strat = allow_sync = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (allow_strat)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* During a rescan, keep the previous strategy object. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_strategy == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_strategy = <a href="../../storage/buffer/freelist.c.html#L541" title="storage/buffer/freelist.c:541">GetAccessStrategy</a>(BAS_BULKREAD);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/freelist.c.html#L681" title="storage/buffer/freelist.c:681">FreeAccessStrategy</a>(scan-&gt;rs_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_strategy = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_parallel != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For parallel scan, believe whatever ParallelTableScanDesc says. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_parallel-&gt;phs_syncscan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags |= SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keep_startblock)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When rescanning, we want to keep the previous startblock setting,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that rewinding a cursor doesn't generate surprising results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the active syncscan setting, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allow_sync &amp;&amp; <a href="../table/tableam.c.html#L49" title="access/table/tableam.c:49">synchronize_seqscans</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags |= SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (allow_sync &amp;&amp; <a href="../table/tableam.c.html#L49" title="access/table/tableam.c:49">synchronize_seqscans</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags |= SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_startblock = <a href="../common/syncscan.c.html#L254" title="access/common/syncscan.c:254">ss_get_location</a>(scan-&gt;rs_base.rs_rd, scan-&gt;rs_nblocks);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_startblock = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_numblocks = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_inited = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_ctup.t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;scan-&gt;rs_ctup.t_self);<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cblock = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize to ForwardScanDirection because it is most common and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because heap scans go forward <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> going backward (e.g. CURSORs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;rs_dir = ForwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_prefetch_block = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* page-at-a-time fields are always invalid when not rs_inited */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copy the scan key, if appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (key != <span class="Constant">NULL</span> &amp;&amp; scan-&gt;rs_base.rs_nkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(scan-&gt;rs_base.rs_key, key, scan-&gt;rs_base.rs_nkeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, we only have a stats counter for sequential heap scans (but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * e.g for bitmap scans the underlying bitmap index scans will be counted,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and for sample scans we update stats for tuple fetches).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_flags &amp; SO_TYPE_SEQSCAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_count_heap_scan(scan-&gt;rs_base.rs_rd);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a> - restrict <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of a heapscan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * startBlk is the page to start at<br/></li>
<li></span><span class="Comment"> * numBlks is number of pages to scan (InvalidBlockNumber means &quot;all&quot;)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L421">&#x200c;</a></span><span class="linkable">heap_setscanlimits</span>(TableScanDesc sscan, BlockNumber startBlk, BlockNumber numBlks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!scan-&gt;rs_inited);&nbsp; &nbsp; <span class="Comment">/* else too late to change */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* else rs_startblock is significant */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(scan-&gt;rs_base.rs_flags &amp; SO_ALLOW_SYNC));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check startBlk is valid (but allow case of zero blocks...) */<br/></li>
<li></span>&nbsp; &nbsp; Assert(startBlk == <span class="Constant">0</span> || startBlk &lt; scan-&gt;rs_nblocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_startblock = startBlk;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_numblocks = numBlks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-tuple loop for <a href="#L493" title="access/heap/heapam.c:493">heap_prepare_pagescan</a>(). Pulled out so it can be called<br/></li>
<li></span><span class="Comment"> * multiple times, with constant arguments for all_visible,<br/></li>
<li></span><span class="Comment"> * check_serializable.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_attribute_always_inline<br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L443">&#x200c;</a></span><span class="linkable">page_collect_tuples</span>(HeapScanDesc scan, Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber block, <span class="Type">int</span> lines,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_visible, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> check_serializable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntup = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber lineoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (lineoff = FirstOffsetNumber; lineoff &lt;= lines; lineoff++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lpp = PageGetItemId(page, lineoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData loctup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lpp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; loctup.t_data = (HeapTupleHeader) PageGetItem(page, lpp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; loctup.t_len = ItemIdGetLength(lpp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; loctup.t_tableOid = RelationGetRelid(scan-&gt;rs_base.rs_rd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;(loctup.t_self), block, lineoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_visible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid = <a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(&amp;loctup, snapshot, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (check_serializable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10052" title="access/heap/heapam.c:10052">HeapCheckForSerializableConflictOut</a>(valid, scan-&gt;rs_base.rs_rd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;loctup, buffer, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_vistuples[ntup] = lineoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntup++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ntup &lt;= MaxHeapTuplesPerPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ntup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L493" title="access/heap/heapam.c:493">heap_prepare_pagescan</a> - Prepare current scan page to be scanned in pagemode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Preparation currently consists of 1. prune the scan's rs_cbuf page, and 2.<br/></li>
<li></span><span class="Comment"> * fill the rs_vistuples[] array with the OffsetNumbers of visible tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L493">&#x200c;</a></span><span class="linkable">heap_prepare_pagescan</span>(TableScanDesc sscan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer = scan-&gt;rs_cbuf;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block = scan-&gt;rs_cblock;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lines;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; check_serializable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer) == block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure we're not accidentally being used when not in pagemode */<br/></li>
<li></span>&nbsp; &nbsp; Assert(scan-&gt;rs_base.rs_flags &amp; SO_ALLOW_PAGEMODE);<br/></li>
<li>&nbsp; &nbsp; snapshot = scan-&gt;rs_base.rs_snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prune and repair fragmentation for the whole page, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pruneheap.c.html#L193" title="access/heap/pruneheap.c:193">heap_page_prune_opt</a>(scan-&gt;rs_base.rs_rd, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must hold share lock on the buffer content while examining tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visibility.&nbsp; Afterwards, however, the tuples we have found to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible are guaranteed good as long as we hold the buffer pin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; lines = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the all-visible flag indicates that all tuples on the page are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible to everyone, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the per-tuple visibility tests.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: In hot standby, a tuple that's already visible to all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions on the primary might still be invisible to a read-only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction in the standby. We partly handle this problem by tracking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the minimum xmin of visible tuples as the cut-off XID while marking a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page all-visible on the primary and WAL log that along with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visibility map <a href="../../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> operation. In hot standby, we wait for (or abort)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all transactions that can potentially may not see one or more tuples on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page. That's how index-only scans work fine in hot standby. A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crucial difference between index-only scans and heap scans is that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index-only scan completely relies on the visibility map where as heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan looks at the page-level PD_ALL_VISIBLE flag. We are not sure if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page-level flag can be trusted in the same way, because it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get propagated somehow without being explicitly WAL-logged, e.g. via a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full page write. Until we can prove that beyond doubt, let's check each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple for visibility the hard way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; all_visible = PageIsAllVisible(page) &amp;&amp; !snapshot-&gt;takenDuringRecovery;<br/></li>
<li>&nbsp; &nbsp; check_serializable =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L3976" title="storage/lmgr/predicate.c:3976">CheckForSerializableConflictOutNeeded</a>(scan-&gt;rs_base.rs_rd, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We call <a href="#L443" title="access/heap/heapam.c:443">page_collect_tuples</a>() with constant arguments, to get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compiler to constant fold the constant arguments. Separate calls with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constant arguments, rather than variables, are needed on several<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compilers to actually perform constant folding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (likely(all_visible))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(!check_serializable))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_ntuples = <a href="#L443" title="access/heap/heapam.c:443">page_collect_tuples</a>(scan, snapshot, page, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block, lines, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_ntuples = <a href="#L443" title="access/heap/heapam.c:443">page_collect_tuples</a>(scan, snapshot, page, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block, lines, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(!check_serializable))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_ntuples = <a href="#L443" title="access/heap/heapam.c:443">page_collect_tuples</a>(scan, snapshot, page, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block, lines, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_ntuples = <a href="#L443" title="access/heap/heapam.c:443">page_collect_tuples</a>(scan, snapshot, page, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block, lines, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L584" title="access/heap/heapam.c:584">heap_fetch_next_buffer</a> - read and pin the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block from MAIN_FORKNUM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Read the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block of the scan relation from the read stream and save it<br/></li>
<li></span><span class="Comment"> * in the scan descriptor.&nbsp; It is already pinned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L584">&#x200c;</a></span><span class="linkable">heap_fetch_next_buffer</span>(HeapScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_read_stream);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release previous scan buffer, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_cbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be sure to check for interrupts at least once per page.&nbsp; Checks at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * higher code levels won't be able to stop a seqscan that encounters many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages' worth of consecutive dead tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the scan direction is changing, reset the prefetch block to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current block. Otherwise, we will incorrectly prefetch the blocks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between the prefetch block and the current block again <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefetching blocks in the new, correct scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(scan-&gt;rs_dir != dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_prefetch_block = scan-&gt;rs_cblock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/aio/read_stream.c.html#L773" title="storage/aio/read_stream.c:773">read_stream_reset</a>(scan-&gt;rs_read_stream);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_dir = dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cbuf = <a href="../../storage/aio/read_stream.c.html#L570" title="storage/aio/read_stream.c:570">read_stream_next_buffer</a>(scan-&gt;rs_read_stream, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_cblock = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(scan-&gt;rs_cbuf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L629" title="access/heap/heapam.c:629">heapgettup_initial_block</a> - return the first BlockNumber to scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidBlockNumber when there are no blocks to scan.&nbsp; This can<br/></li>
<li></span><span class="Comment"> * occur with empty tables and in parallel scans when parallel workers get all<br/></li>
<li></span><span class="Comment"> * of the pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can get a chance to get our first page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pg_noinline BlockNumber<br/></li>
<li><a id="L629">&#x200c;</a><span class="linkable">heapgettup_initial_block</span>(HeapScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!scan-&gt;rs_inited);<br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_base.rs_parallel == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When there are no pages to scan, return InvalidBlockNumber */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_nblocks == <span class="Constant">0</span> || scan-&gt;rs_numblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> scan-&gt;rs_startblock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable reporting to syncscan logic in a backwards scan; it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very likely anyone else is doing the same thing at the same time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and much more likely that we'll just bollix things for forward<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanners.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_SYNC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start from last page of the scan.&nbsp; Ensure we take into account<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rs_numblocks if it's been adjusted by <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_numblocks != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (scan-&gt;rs_startblock + scan-&gt;rs_numblocks - <span class="Constant">1</span>) % scan-&gt;rs_nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_startblock &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> scan-&gt;rs_startblock - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> scan-&gt;rs_nblocks - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L676" title="access/heap/heapam.c:676">heapgettup_start_page</a> - helper function for <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page to scan based on the scan-&gt;rs_cbuf and set *linesleft<br/></li>
<li></span><span class="Comment"> * to the number of tuples on this page.&nbsp; Also set *lineoff to the first<br/></li>
<li></span><span class="Comment"> * offset to scan with forward scans getting the first offset and backward<br/></li>
<li></span><span class="Comment"> * getting the final offset on the page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Page<br/></li>
<li><a id="L676">&#x200c;</a><span class="linkable">heapgettup_start_page</span>(HeapScanDesc scan, ScanDirection dir, <span class="Type">int</span> *linesleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *lineoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_inited);<br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(scan-&gt;rs_cbuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller is responsible for ensuring buffer is locked if needed */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *linesleft = PageGetMaxOffsetNumber(page) - FirstOffsetNumber + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lineoff = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *lineoff = (OffsetNumber) (*linesleft);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lineoff <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> references the physically previous or <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L707" title="access/heap/heapam.c:707">heapgettup_continue_page</a> - helper function for <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page to scan based on the scan-&gt;rs_cbuf and set *linesleft<br/></li>
<li></span><span class="Comment"> * to the number of tuples left to scan on this page.&nbsp; Also set *lineoff to<br/></li>
<li></span><span class="Comment"> * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> offset to scan according to the ScanDirection in 'dir'.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> Page<br/></li>
<li><a id="L707">&#x200c;</a><span class="linkable">heapgettup_continue_page</span>(HeapScanDesc scan, ScanDirection dir, <span class="Type">int</span> *linesleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *lineoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_inited);<br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(scan-&gt;rs_cbuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller is responsible for ensuring buffer is locked if needed */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lineoff = OffsetNumberNext(scan-&gt;rs_coffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *linesleft = PageGetMaxOffsetNumber(page) - (*lineoff) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The previous returned tuple may have been vacuumed since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous scan when we use a non-MVCC snapshot, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-establish the lineoff &lt;= PageGetMaxOffsetNumber(page) invariant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *lineoff = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(PageGetMaxOffsetNumber(page), OffsetNumberPrev(scan-&gt;rs_coffset));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *linesleft = *lineoff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lineoff <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> references the physically previous or <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L753" title="access/heap/heapam.c:753">heapgettup_advance_block</a> - helper for <a href="#L584" title="access/heap/heapam.c:584">heap_fetch_next_buffer</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given the current block number, the scan direction, and various information<br/></li>
<li></span><span class="Comment"> * contained in the scan descriptor, calculate the BlockNumber to scan <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * and return it.&nbsp; If there are no further blocks to scan, return<br/></li>
<li></span><span class="Comment"> * InvalidBlockNumber to indicate this fact to the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should not be called to determine the initial block number -- only for<br/></li>
<li></span><span class="Comment"> * subsequent blocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also adjusts rs_numblocks when a limit has been imposed by<br/></li>
<li></span><span class="Comment"> * <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> BlockNumber<br/></li>
<li><a id="L753">&#x200c;</a><span class="linkable">heapgettup_advance_block</span>(HeapScanDesc scan, BlockNumber block, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_base.rs_parallel == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(ScanDirectionIsForward(dir)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrap back to the start of the heap */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block &gt;= scan-&gt;rs_nblocks)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report our new scan position for synchronization purposes. We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do that when moving backwards, however. That would just mess up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other forward-moving scanners.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking for end of scan so that the final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state of the position hint is back at the start of the rel.&nbsp; That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not strictly necessary, but otherwise when you run the same query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple times the starting position would shift a little <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backwards on every invocation, which is confusing. We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantee <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> specific ordering in general, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_flags &amp; SO_ALLOW_SYNC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/syncscan.c.html#L289" title="access/common/syncscan.c:289">ss_report_location</a>(scan-&gt;rs_base.rs_rd, block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're done if we're back at where we started */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block == scan-&gt;rs_startblock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if the limit imposed by <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a>() is met */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_numblocks != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--scan-&gt;rs_numblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> block;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we're done if the last block is the start position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block == scan-&gt;rs_startblock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check if the limit imposed by <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a>() is met */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_numblocks != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--scan-&gt;rs_numblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wrap to the end of the heap when the last page was page 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (block == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block = scan-&gt;rs_nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> block;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a> - fetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Initialize the scan if not already done; then advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple as indicated by &quot;dir&quot;; return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in scan-&gt;rs_ctup,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or set scan-&gt;rs_ctup.t_data = NULL if no more tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the reason nkeys/key are passed separately, even though they are<br/></li>
<li></span><span class="Comment"> * kept in the scan descriptor, is that the caller may not want us to check<br/></li>
<li></span><span class="Comment"> * the scankeys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when we fall off the end of the scan in either direction, we<br/></li>
<li></span><span class="Comment"> * reset rs_inited.&nbsp; This means that a further request with the same<br/></li>
<li></span><span class="Comment"> * scan direction will restart the scan, which is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> odd, but a<br/></li>
<li></span><span class="Comment"> * request with the opposite scan direction will start a fresh scan<br/></li>
<li></span><span class="Comment"> * in the proper direction.&nbsp; The latter is required behavior for cursors,<br/></li>
<li></span><span class="Comment"> * while the former case is generally undefined behavior in Postgres<br/></li>
<li></span><span class="Comment"> * so we don't care too much.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L837">&#x200c;</a></span><span class="linkable">heapgettup</span>(HeapScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;(scan-&gt;rs_ctup);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber lineoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linesleft;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(scan-&gt;rs_inited))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue from previously returned page/tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(scan-&gt;rs_cbuf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = <a href="#L707" title="access/heap/heapam.c:707">heapgettup_continue_page</a>(scan, dir, &amp;linesleft, &amp;lineoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> continue_page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance the scan until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a qualifying tuple or run out of stuff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L584" title="access/heap/heapam.c:584">heap_fetch_next_buffer</a>(scan, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* did we run out of blocks to scan? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(scan-&gt;rs_cbuf) == scan-&gt;rs_cblock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(scan-&gt;rs_cbuf, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = <a href="#L676" title="access/heap/heapam.c:676">heapgettup_start_page</a>(scan, dir, &amp;linesleft, &amp;lineoff);<br/></li>
<li><span class="Statement">continue_page</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only continue scanning the page while we have lines left.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this protects us from accessing line pointers past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PageGetMaxOffsetNumber(); both for forward scans when we resume the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table scan, and for when we start scanning a new page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; linesleft &gt; <span class="Constant">0</span>; linesleft--, lineoff += dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; visible;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lpp = PageGetItemId(page, lineoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lpp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data = (HeapTupleHeader) PageGetItem(page, lpp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_len = ItemIdGetLength(lpp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;(tuple-&gt;t_self), scan-&gt;rs_cblock, lineoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visible = <a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_base.rs_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10052" title="access/heap/heapam.c:10052">HeapCheckForSerializableConflictOut</a>(visible, scan-&gt;rs_base.rs_rd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple, scan-&gt;rs_cbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> tuples not visible to this snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!visible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples that don't match the scan key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !HeapKeyTest(tuple, RelationGetDescr(scan-&gt;rs_base.rs_rd),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nkeys, key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(scan-&gt;rs_cbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_coffset = lineoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we get here, it means we've exhausted the items on this page and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's time to move to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(scan-&gt;rs_cbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* end of scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cblock = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_prefetch_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_inited = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L947" title="access/heap/heapam.c:947">heapgettup_pagemode</a> - fetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap tuple in page-at-a-time mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Same API as <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>, but used in page-at-a-time mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> logic is much the same as <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>'s too, but there are some<br/></li>
<li></span><span class="Comment"> * differences: we do not take the buffer content lock (that only needs to<br/></li>
<li></span><span class="Comment"> * happen inside <a href="#L493" title="access/heap/heapam.c:493">heap_prepare_pagescan</a>), and we iterate through just the<br/></li>
<li></span><span class="Comment"> * tuples listed in rs_vistuples[] rather than all tuples on the page.&nbsp; Notice<br/></li>
<li></span><span class="Comment"> * that lineindex is 0-based, where the corresponding loop variable lineoff in<br/></li>
<li></span><span class="Comment"> * <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a> is 1-based.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L947">&#x200c;</a></span><span class="linkable">heapgettup_pagemode</span>(HeapScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple = &amp;(scan-&gt;rs_ctup);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lineindex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linesleft;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (likely(scan-&gt;rs_inited))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue from previously returned page/tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lineindex = scan-&gt;rs_cindex + dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linesleft = scan-&gt;rs_ntuples - lineindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linesleft = scan-&gt;rs_cindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lineindex <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> references the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> or previous visible tid */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> continue_page;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance the scan until we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a qualifying tuple or run out of stuff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L584" title="access/heap/heapam.c:584">heap_fetch_next_buffer</a>(scan, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* did we run out of blocks to scan? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(scan-&gt;rs_cbuf) == scan-&gt;rs_cblock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prune the page and determine visible tuple offsets */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L493" title="access/heap/heapam.c:493">heap_prepare_pagescan</a>((TableScanDesc) scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(scan-&gt;rs_cbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; linesleft = scan-&gt;rs_ntuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lineindex = ScanDirectionIsForward(dir) ? <span class="Constant">0</span> : linesleft - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* lineindex <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> references the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> or previous visible tid */<br/></li>
<li></span><span class="Statement">continue_page</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; linesleft &gt; <span class="Constant">0</span>; linesleft--, lineindex += dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lpp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber lineoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lineoff = scan-&gt;rs_vistuples[lineindex];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpp = PageGetItemId(page, lineoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(lpp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data = (HeapTupleHeader) PageGetItem(page, lpp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_len = ItemIdGetLength(lpp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;(tuple-&gt;t_self), scan-&gt;rs_cblock, lineoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples that don't match the scan key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !HeapKeyTest(tuple, RelationGetDescr(scan-&gt;rs_base.rs_rd),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nkeys, key))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_cindex = lineindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* end of scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_cbuf);<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_cblock = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_prefetch_block = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_inited = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heap access method interface<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>TableScanDesc<br/></li>
<li><a id="L1037">&#x200c;</a><span class="linkable">heap_beginscan</span>(Relation relation, Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> nkeys, ScanKey key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParallelTableScanDesc parallel_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint32 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increment relation ref count while scanning relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is just to make really sure the relcache entry won't go away while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scan has a pointer to it.&nbsp; Caller should be holding the rel open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway, so this is redundant in all normal scenarios...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2160" title="utils/cache/relcache.c:2160">RelationIncrementReferenceCount</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> scan descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; scan = (HeapScanDesc) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapScanDescData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_base.rs_rd = relation;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_base.rs_snapshot = snapshot;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_base.rs_nkeys = nkeys;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_base.rs_flags = flags;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_base.rs_parallel = parallel_scan;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_strategy = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* set in <a href="#L293" title="access/heap/heapam.c:293">initscan</a> */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;rs_vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_empty_tuples_pending = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disable page-at-a-time mode if it's not a MVCC-safe snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(snapshot &amp;&amp; IsMVCCSnapshot(snapshot)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_PAGEMODE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For seqscan and sample scans in a serializable transaction, acquire a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicate lock on the entire relation. This is required not only to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock all the matching tuples, but also to conflict with new insertions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the table. In an indexscan, we take page locks on the index pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * covering the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> specified in the scan qual, but in a heap scan there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is nothing more fine-grained to lock. A bitmap scan is a different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * story, there we have already scanned the index and locked the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages covering the predicate. But in that case we still have to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching heap tuples. For sample scan we could <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be at least page-level granularity, but we'd need to add per-tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * locking for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_flags &amp; (SO_TYPE_SEQSCAN | SO_TYPE_SAMPLESCAN))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ensure a missing snapshot is noticed reliably, even if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isolation mode means predicate locking isn't performed (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * therefore the snapshot isn't used here).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a>(relation, snapshot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we only need to set this up once */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;rs_ctup.t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate memory to keep track of page allocation for parallel workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when doing a parallel scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_parallelworkerdata = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParallelBlockTableScanWorkerData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_parallelworkerdata = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we do this here instead of in <a href="#L293" title="access/heap/heapam.c:293">initscan</a>() because <a href="#L1151" title="access/heap/heapam.c:1151">heap_rescan</a> also calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L293" title="access/heap/heapam.c:293">initscan</a>() and we don't want to allocate memory again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nkeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_key = (ScanKey) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData) * nkeys);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_key = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L293" title="access/heap/heapam.c:293">initscan</a>(scan, key, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;rs_read_stream = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up a read stream for sequential scans and TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> scans. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be done after <a href="#L293" title="access/heap/heapam.c:293">initscan</a>() because <a href="#L293" title="access/heap/heapam.c:293">initscan</a>() allocates the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BufferAccessStrategy object passed to the read stream API.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_flags &amp; SO_TYPE_SEQSCAN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp; SO_TYPE_TIDRANGESCAN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ReadStreamBlockNumberCB cb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_parallel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cb = <a href="#L231" title="access/heap/heapam.c:231">heap_scan_stream_read_next_parallel</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cb = <a href="#L269" title="access/heap/heapam.c:269">heap_scan_stream_read_next_serial</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_read_stream = <a href="../../storage/aio/read_stream.c.html#L410" title="storage/aio/read_stream.c:410">read_stream_begin_relation</a>(READ_STREAM_SEQUENTIAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_strategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_rd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cb,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (TableScanDesc) scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1151">&#x200c;</a></span><span class="linkable">heap_rescan</span>(TableScanDesc sscan, ScanKey key, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> set_params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_strat, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_sync, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_pagemode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (set_params)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allow_strat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags |= SO_ALLOW_STRAT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_STRAT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allow_sync)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags |= SO_ALLOW_SYNC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_SYNC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allow_pagemode &amp;&amp; scan-&gt;rs_base.rs_snapshot &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsMVCCSnapshot(scan-&gt;rs_base.rs_snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags |= SO_ALLOW_PAGEMODE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_flags &amp;= ~SO_ALLOW_PAGEMODE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unpin scan buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_vmbuffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_empty_tuples_pending == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The read stream is reset on rescan. This must be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L293" title="access/heap/heapam.c:293">initscan</a>(), as some state referred to by <a href="../../storage/aio/read_stream.c.html#L773" title="storage/aio/read_stream.c:773">read_stream_reset</a>() is reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="#L293" title="access/heap/heapam.c:293">initscan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_read_stream)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/aio/read_stream.c.html#L773" title="storage/aio/read_stream.c:773">read_stream_reset</a>(scan-&gt;rs_read_stream);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reinitialize scan descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L293" title="access/heap/heapam.c:293">initscan</a>(scan, key, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1204">&#x200c;</a></span><span class="linkable">heap_endscan</span>(TableScanDesc sscan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: no locking manipulations needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unpin scan buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_cbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_cbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(scan-&gt;rs_vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(scan-&gt;rs_vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(scan-&gt;rs_empty_tuples_pending == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must free the read stream <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> freeing the BufferAccessStrategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_read_stream)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/aio/read_stream.c.html#L800" title="storage/aio/read_stream.c:800">read_stream_end</a>(scan-&gt;rs_read_stream);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decrement relation reference count and free scan descriptor storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/relcache.c.html#L2173" title="utils/cache/relcache.c:2173">RelationDecrementReferenceCount</a>(scan-&gt;rs_base.rs_rd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(scan-&gt;rs_base.rs_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_strategy != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/freelist.c.html#L681" title="storage/buffer/freelist.c:681">FreeAccessStrategy</a>(scan-&gt;rs_strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_parallelworkerdata != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(scan-&gt;rs_parallelworkerdata);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_flags &amp; SO_TEMP_SNAPSHOT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(scan-&gt;rs_base.rs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>HeapTuple<br/></li>
<li><a id="L1248">&#x200c;</a><span class="linkable">heap_getnext</span>(TableScanDesc sscan, ScanDirection direction)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is still widely used directly, without going through table AM, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add a safety check.&nbsp; It's possible we should, at a later point,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downgrade this to an assert. The reason for checking the AM routine,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than the AM oid, is that this allows to write regression tests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that create another AM reusing the heap handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(sscan-&gt;rs_rd-&gt;rd_tableam != <a href="heapam_handler.c.html#L2653" title="access/heap/heapam_handler.c:2653">GetHeapamTableAmRoutine</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;only heap AM is supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't expect direct calls to <a href="#L1248" title="access/heap/heapam.c:1248">heap_getnext</a> with valid <a href="../transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for catalog or regular tables.&nbsp; See detailed comments in xact.c where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these variables are declared.&nbsp; Normally we have such a check at tableam<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level API but this is called from many places so we need to ensure it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(TransactionIdIsValid(<a href="../transam/xact.c.html#L97" title="access/transam/xact.c:97">CheckXidAlive</a>) &amp;&amp; !<a href="../transam/xact.c.html#L98" title="access/transam/xact.c:98">bsysscan</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="#L1248" title="access/heap/heapam.c:1248">heap_getnext</a> call during logical decoding&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: no locking manipulations needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_base.rs_flags &amp; SO_ALLOW_PAGEMODE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L947" title="access/heap/heapam.c:947">heapgettup_pagemode</a>(scan, direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;rs_base.rs_nkeys, scan-&gt;rs_base.rs_key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>(scan, direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_base.rs_nkeys, scan-&gt;rs_base.rs_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_ctup.t_data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get here it means we have a new current scan tuple, so point to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the proper return buffer and return the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pgstat_count_heap_getnext(scan-&gt;rs_base.rs_rd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;scan-&gt;rs_ctup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1297">&#x200c;</a></span><span class="linkable">heap_getnextslot</span>(TableScanDesc sscan, ScanDirection direction, TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: no locking manipulations needed */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sscan-&gt;rs_flags &amp; SO_ALLOW_PAGEMODE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L947" title="access/heap/heapam.c:947">heapgettup_pagemode</a>(scan, direction, sscan-&gt;rs_nkeys, sscan-&gt;rs_key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>(scan, direction, sscan-&gt;rs_nkeys, sscan-&gt;rs_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_ctup.t_data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get here it means we have a new current scan tuple, so point to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the proper return buffer and return the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pgstat_count_heap_getnext(scan-&gt;rs_base.rs_rd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1479" title="executor/execTuples.c:1479">ExecStoreBufferHeapTuple</a>(&amp;scan-&gt;rs_ctup, slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scan-&gt;rs_cbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1327">&#x200c;</a></span><span class="linkable">heap_set_tidrange</span>(TableScanDesc sscan, ItemPointer mintid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer maxtid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li>&nbsp; &nbsp; BlockNumber startBlk;<br/></li>
<li>&nbsp; &nbsp; BlockNumber numBlks;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData highestItem;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData lowestItem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For relations without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages, we can simply leave the TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unset.&nbsp; There will be no tuples to scan, therefore no tuples outside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the given TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_nblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up some ItemPointers which point to the first and last possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples in the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSet(&amp;highestItem, scan-&gt;rs_nblocks - <span class="Constant">1</span>, MaxOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSet(&amp;lowestItem, <span class="Constant">0</span>, FirstOffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the given maximum TID is below the highest possible TID in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, then restrict the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to that, otherwise we scan to the end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(maxtid, &amp;highestItem) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(maxtid, &amp;highestItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the given minimum TID is above the lowest possible TID in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, then restrict the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to only scan for TIDs above that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(mintid, &amp;lowestItem) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(mintid, &amp;lowestItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and protect from would be negative results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the numBlks calculation below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(&amp;highestItem, &amp;lowestItem) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of blocks to scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a>(sscan, <span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the first block and the number of blocks we must scan. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could be more aggressive here and perform some more validation to try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and further narrow the scope of blocks to scan by checking if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lowestItem has an offset above MaxOffsetNumber.&nbsp; In this case, we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advance startBlk by one.&nbsp; Likewise, if highestItem has an offset of 0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we could scan one fewer blocks.&nbsp; However, such an optimization does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seem worth troubling over, currently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; startBlk = ItemPointerGetBlockNumberNoCheck(&amp;lowestItem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; numBlks = ItemPointerGetBlockNumberNoCheck(&amp;highestItem) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumberNoCheck(&amp;lowestItem) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set the start block and number of blocks to scan */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a>(sscan, startBlk, numBlks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, set the TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in sscan */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerCopy(&amp;lowestItem, &amp;sscan-&gt;rs_mintid);<br/></li>
<li>&nbsp; &nbsp; ItemPointerCopy(&amp;highestItem, &amp;sscan-&gt;rs_maxtid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1400">&#x200c;</a></span><span class="linkable">heap_getnextslot_tidrange</span>(TableScanDesc sscan, ScanDirection direction,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleTableSlot *slot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapScanDesc scan = (HeapScanDesc) sscan;<br/></li>
<li>&nbsp; &nbsp; ItemPointer mintid = &amp;sscan-&gt;rs_mintid;<br/></li>
<li>&nbsp; &nbsp; ItemPointer maxtid = &amp;sscan-&gt;rs_maxtid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: no locking manipulations needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sscan-&gt;rs_flags &amp; SO_ALLOW_PAGEMODE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L947" title="access/heap/heapam.c:947">heapgettup_pagemode</a>(scan, direction, sscan-&gt;rs_nkeys, sscan-&gt;rs_key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L837" title="access/heap/heapam.c:837">heapgettup</a>(scan, direction, sscan-&gt;rs_nkeys, sscan-&gt;rs_key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;rs_ctup.t_data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1327" title="access/heap/heapam.c:1327">heap_set_tidrange</a> will have used <a href="#L421" title="access/heap/heapam.c:421">heap_setscanlimits</a> to limit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pages we scan to only ones that can contain the TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're scanning for.&nbsp; Here we must filter out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples from these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages that are outside of that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(&amp;scan-&gt;rs_ctup.t_self, mintid) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When scanning backwards, the TIDs will be in descending order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Future tuples in this direction will be <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> still, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just return false to indicate there will be no more tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(direction))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise for the final page, we must filter out TIDs greater than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maxtid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(&amp;scan-&gt;rs_ctup.t_self, maxtid) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When scanning forward, the TIDs will be in ascending order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Future tuples in this direction will be higher still, so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just return false to indicate there will be no more tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(direction))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we get here it means we have a new current scan tuple, so point to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the proper return buffer and return the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pgstat_count_heap_getnext(scan-&gt;rs_base.rs_rd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/execTuples.c.html#L1479" title="executor/execTuples.c:1479">ExecStoreBufferHeapTuple</a>(&amp;scan-&gt;rs_ctup, slot, scan-&gt;rs_cbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1507" title="access/heap/heapam.c:1507">heap_fetch</a>&nbsp; &nbsp; &nbsp; &nbsp; - retrieve tuple with given tid<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, tuple-&gt;t_self is the TID to fetch.&nbsp; We pin the buffer holding<br/></li>
<li></span><span class="Comment"> * the tuple, fill in the remaining fields of *tuple, and check the tuple<br/></li>
<li></span><span class="Comment"> * against the specified snapshot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If successful (tuple found and passes snapshot time qual), then *userbuf<br/></li>
<li></span><span class="Comment"> * is set to the buffer holding the tuple and true is returned.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * must unpin the buffer when done with the tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the tuple is not found (ie, item number references a deleted slot),<br/></li>
<li></span><span class="Comment"> * then tuple-&gt;t_data is set to NULL, *userbuf is set to InvalidBuffer,<br/></li>
<li></span><span class="Comment"> * and false is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the tuple is found but fails the time qual check, then the behavior<br/></li>
<li></span><span class="Comment"> * depends on the keep_buf parameter.&nbsp; If keep_buf is false, the results<br/></li>
<li></span><span class="Comment"> * are the same as for the tuple-not-found case.&nbsp; If keep_buf is true,<br/></li>
<li></span><span class="Comment"> * then tuple-&gt;t_data and *userbuf are returned as for the success case,<br/></li>
<li></span><span class="Comment"> * and again the caller must unpin the buffer; but false is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1507" title="access/heap/heapam.c:1507">heap_fetch</a> does not follow HOT chains: only the exact TID requested will<br/></li>
<li></span><span class="Comment"> * be fetched.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is somewhat inconsistent that we ereport() on invalid block number but<br/></li>
<li></span><span class="Comment"> * return false on invalid item number.&nbsp; There are a couple of reasons though.<br/></li>
<li></span><span class="Comment"> * One is that the caller can relatively easily check the block number for<br/></li>
<li></span><span class="Comment"> * validity, but cannot check the item number without reading the page<br/></li>
<li></span><span class="Comment"> * himself.&nbsp; Another is that when we are following a t_ctid link, we can be<br/></li>
<li></span><span class="Comment"> * reasonably confident that the page number is valid (since VACUUM shouldn't<br/></li>
<li></span><span class="Comment"> * truncate off the destination page without having killed the referencing<br/></li>
<li></span><span class="Comment"> * tuple first), but the item number might well not be good.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1507">&#x200c;</a></span><span class="linkable">heap_fetch</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *userbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> keep_buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointer tid = &amp;(tuple-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch and pin the appropriate page of the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, ItemPointerGetBlockNumber(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need share lock on buffer to examine tuple commit status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'd better check for out-of-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> offnum in case of VACUUM since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TID was obtained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(tid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; FirstOffsetNumber || offnum &gt; PageGetMaxOffsetNumber(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *userbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get the item line pointer corresponding to the requested tid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must check for deleted tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *userbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fill in *tuple fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check tuple visibility, then release lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; valid = <a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(tuple, snapshot, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2606" title="storage/lmgr/predicate.c:2606">PredicateLockTID</a>(relation, &amp;(tuple-&gt;t_self), snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetXmin(tuple-&gt;t_data));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L10052" title="access/heap/heapam.c:10052">HeapCheckForSerializableConflictOut</a>(valid, relation, tuple, buffer, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All checks passed, so return the tuple as valid. Caller is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * responsible for releasing the buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *userbuf = buffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tuple failed time qual, but maybe caller wants to see it anyway. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (keep_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *userbuf = buffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *userbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1627" title="access/heap/heapam.c:1627">heap_hot_search_buffer</a>&nbsp; &nbsp; - search HOT chain for tuple satisfying snapshot<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, *tid is the TID of a tuple (either a simple tuple, or the root<br/></li>
<li></span><span class="Comment"> * of a HOT chain), and buffer is the buffer holding this tuple.&nbsp; We search<br/></li>
<li></span><span class="Comment"> * for the first chain member satisfying the given snapshot.&nbsp; If one is<br/></li>
<li></span><span class="Comment"> * found, we update *tid to reference that tuple's offset number, and<br/></li>
<li></span><span class="Comment"> * return true.&nbsp; If no match, return false without modifying *tid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heapTuple is a caller-supplied buffer.&nbsp; When a match is found, we return<br/></li>
<li></span><span class="Comment"> * the tuple here, in addition to updating *tid.&nbsp; If no match is found, the<br/></li>
<li></span><span class="Comment"> * contents of this buffer on return are undefined.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If all_dead is not NULL, we check non-visible tuples to see if they are<br/></li>
<li></span><span class="Comment"> * globally dead; *all_dead is set true if all members of the HOT chain<br/></li>
<li></span><span class="Comment"> * are vacuumable, false if not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L1507" title="access/heap/heapam.c:1507">heap_fetch</a>, the caller must already have pin and (at least) share<br/></li>
<li></span><span class="Comment"> * lock on the buffer; it is still pinned/locked at exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1627">&#x200c;</a></span><span class="linkable">heap_hot_search_buffer</span>(ItemPointer tid, Relation relation, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Snapshot snapshot, HeapTuple heapTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *all_dead, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first_call)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; TransactionId prev_xmax = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; at_chain_start;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *vistest = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If this is not the first call, previous call returned a (live!) tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (all_dead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *all_dead = first_call;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = ItemPointerGetBlockNumber(tid);<br/></li>
<li>&nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(tid);<br/></li>
<li>&nbsp; &nbsp; at_chain_start = first_call;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = !first_call;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment">: we should assert that a snapshot is pushed or registered */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="../../utils/time/snapmgr.c.html#L99" title="utils/time/snapmgr.c:99">RecentXmin</a>));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer) == blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scan through possible multiple members of HOT-chain */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for bogus TID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; FirstOffsetNumber || offnum &gt; PageGetMaxOffsetNumber(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for unused, dead, or redirected items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We should only see a redirect at start of chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(lp) &amp;&amp; at_chain_start)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Follow the redirect */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemIdGetRedirect(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at_chain_start = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else must be end of chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update heapTuple to point to the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of the HOT chain we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * currently investigating. Having t_self set correctly is important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the SSI checks and the *Satisfies routine for historical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MVCC snapshots need the correct tid to decide about the visibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; heapTuple-&gt;t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapTuple-&gt;t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapTuple-&gt;t_tableOid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;heapTuple-&gt;t_self, blkno, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Shouldn't see a HEAP_ONLY tuple at chain start.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (at_chain_start &amp;&amp; HeapTupleIsHeapOnly(heapTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The xmin should match the previous xmax value, else chain is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * broken.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(prev_xmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(prev_xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetXmin(heapTuple-&gt;t_data)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When first_call is true (and thus, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> is initially false) we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return the first tuple we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>.&nbsp; But on later passes, heapTuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will initially be pointing to the tuple we returned last time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Returning it again would be incorrect (and would loop forever), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it and return the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> match we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's visible per the snapshot, we must return it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valid = <a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(heapTuple, snapshot, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10052" title="access/heap/heapam.c:10052">HeapCheckForSerializableConflictOut</a>(valid, relation, heapTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer, snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetOffsetNumber(tid, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2606" title="storage/lmgr/predicate.c:2606">PredicateLockTID</a>(relation, &amp;heapTuple-&gt;t_self, snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetXmin(heapTuple-&gt;t_data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_dead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_dead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can't see it, maybe no one else can either.&nbsp; At caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request, check whether all chain members are dead to all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: if you change the criterion here for what is &quot;dead&quot;, fix the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>'s <a href="../../utils/adt/selfuncs.c.html#L6087" title="utils/adt/selfuncs.c:6087">get_actual_variable_range</a>() function to match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_dead &amp;&amp; *all_dead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vistest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vistest = <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="heapam_visibility.c.html#L1465" title="access/heap/heapam_visibility.c:1465">HeapTupleIsSurelyDead</a>(heapTuple, vistest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *all_dead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if HOT chain continues past this tuple; if so fetch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> offnum and loop around.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsHotUpdated(heapTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerGetBlockNumber(&amp;heapTuple-&gt;t_data-&gt;t_ctid) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(&amp;heapTuple-&gt;t_data-&gt;t_ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at_chain_start = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev_xmax = HeapTupleHeaderGetUpdateXid(heapTuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of chain */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1779" title="access/heap/heapam.c:1779">heap_get_latest_tid</a> -&nbsp; get the latest tid of a specified tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Actually, this gets the latest version that is visible according to the<br/></li>
<li></span><span class="Comment"> * scan's snapshot.&nbsp; Create a scan using SnapshotDirty to get the very latest,<br/></li>
<li></span><span class="Comment"> * possibly uncommitted version.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *tid is both an input and an output parameter: it is updated to<br/></li>
<li></span><span class="Comment"> * show the latest version of the row.&nbsp; Note that it will not be changed<br/></li>
<li></span><span class="Comment"> * if no version of the row passes the snapshot test.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1779">&#x200c;</a></span><span class="linkable">heap_get_latest_tid</span>(TableScanDesc sscan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation = sscan-&gt;rs_rd;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot = sscan-&gt;rs_snapshot;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData ctid;<br/></li>
<li>&nbsp; &nbsp; TransactionId priorXmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../table/tableam.c.html#L235" title="access/table/tableam.c:235">table_tuple_get_latest_tid</a>() verified that the passed in tid is valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume that t_ctid links are valid however - there shouldn't be invalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ones in the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ItemPointerIsValid(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop to chase down t_ctid links.&nbsp; At top of loop, ctid is the tuple we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to examine, and *tid is the TID we will return if ctid turns out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be bogus.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we will loop until we reach the end of the t_ctid chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Depending on the snapshot passed, there might be at most one visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * version of the row, but we don't try to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctid = *tid;<br/></li>
<li>&nbsp; &nbsp; priorXmax = InvalidTransactionId;&nbsp; &nbsp; <span class="Comment">/* cannot check first XMIN */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; valid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read, pin, and lock the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, ItemPointerGetBlockNumber(&amp;ctid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for bogus item number.&nbsp; This is not treated as an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition because it can happen while following a t_ctid link. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just assume that the prior tid is OK and return it unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(&amp;ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; FirstOffsetNumber || offnum &gt; PageGetMaxOffsetNumber(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to access the tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tp.t_self = ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp.t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp.t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp.t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After following a t_ctid link, we might arrive at an unrelated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.&nbsp; Check for XMIN match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(priorXmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(priorXmax, HeapTupleHeaderGetXmin(tp.t_data)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check tuple visibility; if visible, set it as the new result<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * candidate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; valid = <a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(&amp;tp, snapshot, buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L10052" title="access/heap/heapam.c:10052">HeapCheckForSerializableConflictOut</a>(valid, relation, &amp;tp, buffer, snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tid = ctid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's a valid t_ctid link, follow it, else we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((tp.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L1520" title="access/heap/heapam_visibility.c:1520">HeapTupleHeaderIsOnlyLocked</a>(tp.t_data) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderIndicatesMovedPartitions(tp.t_data) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tp.t_self, &amp;tp.t_data-&gt;t_ctid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctid = tp.t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; priorXmax = HeapTupleHeaderGetUpdateXid(tp.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of loop */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1901" title="access/heap/heapam.c:1901">UpdateXmaxHintBits</a> - update tuple hint bits after xmax transaction ends<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called after we have waited for the XMAX transaction to terminate.<br/></li>
<li></span><span class="Comment"> * If the transaction aborted, we guarantee the XMAX_INVALID hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> will<br/></li>
<li></span><span class="Comment"> * be set on exit.&nbsp; If the transaction committed, we set the XMAX_COMMITTED<br/></li>
<li></span><span class="Comment"> * hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if possible --- but beware that that may not yet be possible,<br/></li>
<li></span><span class="Comment"> * if the transaction committed asynchronously.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if the transaction was a locker only, we set HEAP_XMAX_INVALID<br/></li>
<li></span><span class="Comment"> * even if it commits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Hence callers should look only at XMAX_INVALID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note this is not allowed for tuples whose xmax is a multixact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1901">&#x200c;</a></span><span class="linkable">UpdateXmaxHintBits</span>(HeapTupleHeader tuple, Buffer buffer, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdEquals(HeapTupleHeaderGetRawXmax(tuple), xid));<br/></li>
<li>&nbsp; &nbsp; Assert(!(tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(tuple-&gt;t_infomask &amp; (HEAP_XMAX_COMMITTED | HEAP_XMAX_INVALID)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L141" title="access/heap/heapam_visibility.c:141">HeapTupleSetHintBits</a>(tuple, buffer, HEAP_XMAX_COMMITTED,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L141" title="access/heap/heapam_visibility.c:141">HeapTupleSetHintBits</a>(tuple, buffer, HEAP_XMAX_INVALID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1923" title="access/heap/heapam.c:1923">GetBulkInsertState</a> - prepare status object for a bulk insert<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BulkInsertState<br/></li>
<li><a id="L1923">&#x200c;</a><span class="linkable">GetBulkInsertState</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BulkInsertState bistate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bistate = (BulkInsertState) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BulkInsertStateData));<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;strategy = <a href="../../storage/buffer/freelist.c.html#L541" title="storage/buffer/freelist.c:541">GetAccessStrategy</a>(BAS_BULKWRITE);<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;current_buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;next_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;last_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;already_extended_by = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bistate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1940" title="access/heap/heapam.c:1940">FreeBulkInsertState</a> - clean up after finishing a bulk insert<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1940">&#x200c;</a></span><span class="linkable">FreeBulkInsertState</span>(BulkInsertState bistate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bistate-&gt;current_buf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bistate-&gt;current_buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/freelist.c.html#L681" title="storage/buffer/freelist.c:681">FreeAccessStrategy</a>(bistate-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bistate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1952" title="access/heap/heapam.c:1952">ReleaseBulkInsertStatePin</a> - release a buffer currently held in bistate<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1952">&#x200c;</a></span><span class="linkable">ReleaseBulkInsertStatePin</span>(BulkInsertState bistate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bistate-&gt;current_buf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(bistate-&gt;current_buf);<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;current_buf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Despite the name, we also reset bulk relation extension state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise we can end up erroring out due to looking for free space in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -&gt;next_free of one partition, even though -&gt;next_free was set when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extending another partition. It could obviously also be bad for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficiency to look at existing blocks at offsets from another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition, even if we don't error out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bistate-&gt;next_free = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;last_free = InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>&nbsp; &nbsp; &nbsp; &nbsp; - insert tuple into a heap<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The new tuple is stamped with current transaction ID and the specified<br/></li>
<li></span><span class="Comment"> * command ID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See table_tuple_insert for comments about most of the input flags, except<br/></li>
<li></span><span class="Comment"> * that this routine directly takes a tuple rather than a slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There's corresponding HEAP_INSERT_ options to all the TABLE_INSERT_<br/></li>
<li></span><span class="Comment"> * options, and there additionally is HEAP_INSERT_SPECULATIVE which is used to<br/></li>
<li></span><span class="Comment"> * implement table_tuple_insert_speculative().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return the header fields of *tup are updated to match the stored tuple;<br/></li>
<li></span><span class="Comment"> * in particular tup-&gt;t_self receives the actual TID where the tuple was<br/></li>
<li></span><span class="Comment"> * stored.&nbsp; But note that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> toasting of fields within the tuple data is NOT<br/></li>
<li></span><span class="Comment"> * reflected into *tup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1990">&#x200c;</a></span><span class="linkable">heap_insert</span>(Relation relation, HeapTuple tup, CommandId cid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> options, BulkInsertState bistate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heaptup;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cheap, simplistic check that the tuple matches the rel's rowtype. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(HeapTupleHeaderGetNatts(tup-&gt;t_data) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNumberOfAttributes(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in tuple header fields and toast the tuple if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: below this point, heaptup is the data we actually intend to store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the relation; tup is the caller's original untoasted data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heaptup = <a href="#L2179" title="access/heap/heapam.c:2179">heap_prepare_insert</a>(relation, tup, xid, cid, options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find buffer to insert this tuple into.&nbsp; If the page is all visible,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this will also pin the requisite visibility map page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>(relation, heaptup-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBuffer, options, bistate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vmbuffer, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're about to do the actual insert -- but check for conflict first, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid possibly having to roll back work we've just done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is safe without a recheck as long as there is no possibility of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another process scanning the page between this check and the insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being visible to the scan (i.e., an exclusive buffer content lock is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continuously held from this point until the tuple insert is visible).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a heap insert, we only need to check for table-level SSI locks. Our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new tuple can't possibly conflict with existing tuple locks, and heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page locks are only consolidated versions of tuple locks; they do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock &quot;gaps&quot; as index page locks do.&nbsp; So we don't need to specify a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer when making the call, which makes for a faster check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(relation, <span class="Constant">NULL</span>, InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hio.c.html#L35" title="access/heap/hio.c:35">RelationPutHeapTuple</a>(relation, buffer, heaptup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (options &amp; HEAP_INSERT_SPECULATIVE) != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(BufferGetPage(buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(&amp;(heaptup-&gt;t_self)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Should we set PageSetPrunable on this page ?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The inserting transaction may eventually abort thus making this tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DEAD and hence available for pruning. Though we don't want to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for aborts, if no other tuple in this page is UPDATEd/DELETEd, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aborted tuple will never be pruned until <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> is triggered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you do add PageSetPrunable here, add it in <a href="#L9124" title="access/heap/heapam.c:9124">heap_xlog_insert</a> too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_insert xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_header xlhdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP_INSERT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a catalog, we need to transmit combo CIDs to properly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decode, so log that as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsAccessibleInLogicalDecoding(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(relation, heaptup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the single and first tuple on page, we can reinit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page instead of restoring the whole thing.&nbsp; Set flag, and hide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer references from <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetOffsetNumber(&amp;(heaptup-&gt;t_self)) == FirstOffsetNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetMaxOffsetNumber(page) == FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info |= XLOG_HEAP_INIT_PAGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags |= REGBUF_WILL_INIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;heaptup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_visible_cleared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_INSERT_ALL_VISIBLE_CLEARED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (options &amp; HEAP_INSERT_SPECULATIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_INSERT_IS_SPECULATIVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerGetBlockNumber(&amp;heaptup-&gt;t_self) == <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For logical decoding, we need the tuple even if we're doing a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page write, so make sure it's included even if we take a full-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * image. (</span><span class="Todo">XXX</span><span class="Comment"> We could alternatively store a pointer into the FPW).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsLogicallyLogged(relation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(options &amp; HEAP_INSERT_NO_LOGICAL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_INSERT_CONTAINS_NEW_TUPLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags |= REGBUF_KEEP_DATA;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L145" title="catalog/catalog.c:145">IsToastRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_INSERT_ON_TOAST_RELATION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapInsert);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlhdr.t_infomask2 = heaptup-&gt;t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlhdr.t_infomask = heaptup-&gt;t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlhdr.t_hoff = heaptup-&gt;t_data-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * note we mark xlhdr as belonging to buffer; if <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> decides to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * write the whole page to the xlog, we don't need to store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xl_heap_header in the xlog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD | bufflags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;xlhdr, SizeOfHeapHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG73FORMAT: write bitmap [+ padding] [+ oid] + data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) heaptup-&gt;t_data + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaptup-&gt;t_len - SizeofHeapTupleHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* filtering by origin on a row level is much more efficient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If tuple is cachable, mark it for invalidation from the caches in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we abort.&nbsp; Note it is OK to do this after releasing the buffer, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the heaptup data structure is all in local memory, not in the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>(relation, heaptup, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note: speculative insertions are counted too, even if aborted later */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L360" title="utils/activity/pgstat_relation.c:360">pgstat_count_heap_insert</a>(relation, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If heaptup is a private copy, release it.&nbsp; Don't forget to copy t_self<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to the caller's image, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heaptup != tup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup-&gt;t_self = heaptup-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(heaptup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>(). Prepares a tuple for insertion. This sets the<br/></li>
<li></span><span class="Comment"> * tuple header fields and toasts the tuple if necessary.&nbsp; Returns a toasted<br/></li>
<li></span><span class="Comment"> * version of the tuple if it was toasted, or the original tuple if not. Note<br/></li>
<li></span><span class="Comment"> * that in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, the header fields are also set in the original tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L2179">&#x200c;</a><span class="linkable">heap_prepare_insert</span>(Relation relation, HeapTuple tup, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, <span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To allow parallel inserts, we need to ensure that they are safe to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * performed in workers. We have the infrastructure to allow parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserts in general except for the cases where inserts generate a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CommandId (eg. inserts into a table having a foreign key column).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsParallelWorker())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert tuples in a parallel worker&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup-&gt;t_data-&gt;t_infomask &amp;= ~(HEAP_XACT_MASK);<br/></li>
<li>&nbsp; &nbsp; tup-&gt;t_data-&gt;t_infomask2 &amp;= ~(HEAP2_XACT_MASK);<br/></li>
<li>&nbsp; &nbsp; tup-&gt;t_data-&gt;t_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmin(tup-&gt;t_data, xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (options &amp; HEAP_INSERT_FROZEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXminFrozen(tup-&gt;t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetCmin(tup-&gt;t_data, cid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(tup-&gt;t_data, <span class="Constant">0</span>); <span class="Comment">/* for cleanliness */<br/></li>
<li></span>&nbsp; &nbsp; tup-&gt;t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the new tuple is too big for storage or contains already toasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out-of-line attributes from some other relation, invoke the toaster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* toast table entries should never be recursively toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHasExternal(tup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HeapTupleHasExternal(tup) || tup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="heaptoast.c.html#L96" title="access/heap/heaptoast.c:96">heap_toast_insert_or_update</a>(relation, tup, <span class="Constant">NULL</span>, options);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper for <a href="#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a>() that computes the number of entire pages<br/></li>
<li></span><span class="Comment"> * that inserting the remaining heaptuples requires. Used to determine how<br/></li>
<li></span><span class="Comment"> * much the relation needs to be extended by.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2227">&#x200c;</a></span><span class="linkable">heap_multi_insert_pages</span>(HeapTuple *heaptuples, <span class="Type">int</span> done, <span class="Type">int</span> ntuples, Size saveFreeSpace)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; page_avail = BLCKSZ - SizeOfPageHeaderData - saveFreeSpace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = done; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; tup_sz = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData) + MAXALIGN(heaptuples[i]-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (page_avail &lt; tup_sz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_avail = BLCKSZ - SizeOfPageHeaderData - saveFreeSpace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page_avail -= tup_sz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> npages;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a>&nbsp; &nbsp; - insert multiple tuples into a heap<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>(), but inserts multiple tuples in one operation.<br/></li>
<li></span><span class="Comment"> * That's faster than calling <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>() in a loop, because when multiple<br/></li>
<li></span><span class="Comment"> * tuples can be inserted on a single page, we can write just a single WAL<br/></li>
<li></span><span class="Comment"> * record covering all of them, and only need to lock/unlock the page once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this leaks memory into the current memory context. You can create a<br/></li>
<li></span><span class="Comment"> * temporary context <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this, if that's a problem.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2259">&#x200c;</a></span><span class="linkable">heap_multi_insert</span>(Relation relation, TupleTableSlot **slots, <span class="Type">int</span> ntuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, <span class="Type">int</span> options, BulkInsertState bistate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; *heaptuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndone;<br/></li>
<li>&nbsp; &nbsp; PGAlignedBlock scratch;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needwal;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; saveFreeSpace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_tuple_data = RelationIsLogicallyLogged(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_cids = RelationIsAccessibleInLogicalDecoding(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; starting_with_empty_page = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages_used = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* currently not needed (thus unsupported) for <a href="#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a>() */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!(options &amp; HEAP_INSERT_NO_LOGICAL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; needwal = RelationNeedsWAL(relation);<br/></li>
<li>&nbsp; &nbsp; saveFreeSpace = RelationGetTargetPageFreeSpace(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_DEFAULT_FILLFACTOR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Toast and set header data in all the slots */<br/></li>
<li></span>&nbsp; &nbsp; heaptuples = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ntuples * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTuple));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../executor/execTuples.c.html#L1731" title="executor/execTuples.c:1731">ExecFetchSlotHeapTuple</a>(slots[i], <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slots[i]-&gt;tts_tableOid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_tableOid = slots[i]-&gt;tts_tableOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heaptuples[i] = <a href="#L2179" title="access/heap/heapam.c:2179">heap_prepare_insert</a>(relation, tuple, xid, cid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're about to do the actual inserts -- but check for conflict first,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to minimize the possibility of having to roll back work we've just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A check here does not definitively prevent a serialization anomaly;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that check MUST be done at least past the point of acquiring an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exclusive buffer content lock on every buffer that will be affected,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and MAY be done after all inserts are reflected in the buffers and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those locks are released; otherwise there is a race condition.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * multiple buffers can be locked and unlocked in the loop below, and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would not be feasible to identify and lock all of those buffers <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the loop, we must do a final check at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The check here could be omitted with no loss of correctness; it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present strictly as an optimization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For heap inserts, we only need to check for table-level SSI locks. Our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new tuples can't possibly conflict with existing tuple locks, and heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page locks are only consolidated versions of tuple locks; they do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock &quot;gaps&quot; as index page locks do.&nbsp; So we don't need to specify a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer when making the call, which makes for a faster check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(relation, <span class="Constant">NULL</span>, InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndone = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (ndone &lt; ntuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_frozen_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nthispage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute number of pages needed to fit the to-be-inserted tuples in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the worst case.&nbsp; This will be used to determine how much to extend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation by in <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>(), if needed.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * filled a prior page from scratch, we can just update our last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * computation, but if we started with a partially filled page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recompute from scratch, the number of potentially required pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can vary due to tuples needing to fit onto the page, page headers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndone == <span class="Constant">0</span> || !starting_with_empty_page)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages = <a href="#L2227" title="access/heap/heapam.c:2227">heap_multi_insert_pages</a>(heaptuples, ndone, ntuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; saveFreeSpace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages_used = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; npages_used++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find buffer where at least the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple will fit.&nbsp; If the page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-visible, this will also pin the requisite visibility map page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also pin visibility map page if COPY FREEZE inserts tuples into an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty page. See all_frozen_set below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>(relation, heaptuples[ndone]-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBuffer, options, bistate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vmbuffer, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; npages - npages_used);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; starting_with_empty_page = PageGetMaxOffsetNumber(page) == <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (starting_with_empty_page &amp;&amp; (options &amp; HEAP_INSERT_FROZEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_frozen_set = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a> has ensured that the first tuple fits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Put that on the page, and then as many other tuples as fit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="hio.c.html#L35" title="access/heap/hio.c:35">RelationPutHeapTuple</a>(relation, buffer, heaptuples[ndone], <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For logical decoding we need combo CIDs to properly decode the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needwal &amp;&amp; need_cids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(relation, heaptuples[ndone]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (nthispage = <span class="Constant">1</span>; ndone + nthispage &lt; ntuples; nthispage++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heaptup = heaptuples[ndone + nthispage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page) &lt; MAXALIGN(heaptup-&gt;t_len) + saveFreeSpace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="hio.c.html#L35" title="access/heap/hio.c:35">RelationPutHeapTuple</a>(relation, buffer, heaptup, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For logical decoding we need combo CIDs to properly decode the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needwal &amp;&amp; need_cids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(relation, heaptup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the page is all visible, need to clear that, unless we're only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going to add further frozen rows to it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're only adding already frozen rows to a previously empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page, mark it as all-visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(page) &amp;&amp; !(options &amp; HEAP_INSERT_FROZEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (all_frozen_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Should we set PageSetPrunable on this page ? See <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needwal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_heap_multi_insert *xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP2_MULTI_INSERT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tupledata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totaldatalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *scratchptr = scratch.data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; init;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the page was previously empty, we can reinit the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * instead of restoring the whole thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; init = starting_with_empty_page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate xl_heap_multi_insert struct from the scratch area */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec = (xl_heap_multi_insert *) scratchptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratchptr += SizeOfHeapMultiInsert;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate offsets array. Unless we're reinitializing the page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in that case the tuples are stored in order starting at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FirstOffsetNumber and we don't need to store the offsets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explicitly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!init)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratchptr += nthispage * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the rest of the scratch space is used for tuple data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupledata = scratchptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check that the mutually exclusive flags are not both set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(all_visible_cleared &amp;&amp; all_frozen_set));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_visible_cleared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;flags = XLH_INSERT_ALL_VISIBLE_CLEARED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_frozen_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;flags = XLH_INSERT_ALL_FROZEN_SET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;ntuples = nthispage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write out an xl_multi_insert_tuple and the tuple data itself<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for each tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nthispage; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heaptup = heaptuples[ndone + i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_multi_insert_tuple *tuphdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!init)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;offsets[i] = ItemPointerGetOffsetNumber(&amp;heaptup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xl_multi_insert_tuple needs two-byte alignment. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuphdr = (xl_multi_insert_tuple *) SHORTALIGN(scratchptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratchptr = ((<span class="Type">char</span> *) tuphdr) + SizeOfMultiInsertTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuphdr-&gt;t_infomask2 = heaptup-&gt;t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuphdr-&gt;t_infomask = heaptup-&gt;t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuphdr-&gt;t_hoff = heaptup-&gt;t_data-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* write bitmap [+ padding] [+ oid] + data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen = heaptup-&gt;t_len - SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(scratchptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) heaptup-&gt;t_data + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; datalen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuphdr-&gt;datalen = datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scratchptr += datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totaldatalen = scratchptr - tupledata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((scratchptr - scratch.data) &lt; BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need_tuple_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;flags |= XLH_INSERT_CONTAINS_NEW_TUPLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Signal that this is the last xl_heap_multi_insert record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitted by this call to <a href="#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a>(). Needed for logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoding so it knows when to <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> temporary data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndone + nthispage == ntuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;flags |= XLH_INSERT_LAST_IN_MULTI;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (init)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info |= XLOG_HEAP_INIT_PAGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags |= REGBUF_WILL_INIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're doing logical decoding, include the new tuple data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if we take a full-page image of the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need_tuple_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags |= REGBUF_KEEP_DATA;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) xlrec, tupledata - scratch.data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD | bufflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, tupledata, totaldatalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* filtering by origin on a row level is much more efficient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP2_ID, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've frozen everything on the page, update the visibilitymap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're already holding pin on the vmbuffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_frozen_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(PageIsAllVisible(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="visibilitymap.c.html#L215" title="access/heap/visibilitymap.c:215">visibilitymap_pin_ok</a>(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer), vmbuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's fine to use InvalidTransactionId here - this is only used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when HEAP_INSERT_FROZEN is specified, which intentionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * violates visibility rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(relation, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer), buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidXLogRecPtr, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidTransactionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_VISIBLE | VISIBILITYMAP_ALL_FROZEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndone += nthispage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: Only release vmbuffer after inserting all tuples - it's fairly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likely that we'll insert into subsequent heap pages that are likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to use the same vm page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're done with inserting all tuples, so release the last vmbuffer. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're done with the actual inserts.&nbsp; Check for conflicts again, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that all rw-conflicts in to these inserts are detected.&nbsp; Without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this final check, a sequential scan of the heap may have locked the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table after the &quot;<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>&quot; check, missing one opportunity to detect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict, and then scanned the table <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the new tuples were there,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * missing the other chance to detect the conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For heap inserts, we only need to check for table-level SSI locks. Our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new tuples can't possibly conflict with existing tuple locks, and heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page locks are only consolidated versions of tuple locks; they do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock &quot;gaps&quot; as index page locks do.&nbsp; So we don't need to specify a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer when making the call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(relation, <span class="Constant">NULL</span>, InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If tuples are cachable, mark them for invalidation from the caches in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case we abort.&nbsp; Note it is OK to do this after releasing the buffer,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the heaptuples data structure is all in local memory, not in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the shared buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>(relation, heaptuples[i], <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy t_self fields back to the caller's slots */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slots[i]-&gt;tts_tid = heaptuples[i]-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L360" title="utils/activity/pgstat_relation.c:360">pgstat_count_heap_insert</a>(relation, ntuples);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2621" title="access/heap/heapam.c:2621">simple_heap_insert</a> - insert a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, this routine differs from <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a> only in supplying<br/></li>
<li></span><span class="Comment"> * a default command ID and not allowing access to the speedup options.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used rather than using <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a> directly in most places<br/></li>
<li></span><span class="Comment"> * where we are modifying system catalogs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2621">&#x200c;</a></span><span class="linkable">simple_heap_insert</span>(Relation relation, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>(relation, tup, <a href="../transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>), <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given infomask/infomask2, compute the bits that must be saved in the<br/></li>
<li></span><span class="Comment"> * &quot;infobits&quot; field of xl_heap_delete, xl_heap_update, xl_heap_lock,<br/></li>
<li></span><span class="Comment"> * xl_heap_lock_updated WAL <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L9030" title="access/heap/heapam.c:9030">fix_infomask_from_infobits</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint8<br/></li>
<li><a id="L2634">&#x200c;</a><span class="linkable">compute_infobits</span>(uint16 infomask, uint16 infomask2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((infomask &amp; HEAP_XMAX_IS_MULTI) != <span class="Constant">0</span> ? XLHL_XMAX_IS_MULTI : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((infomask &amp; HEAP_XMAX_LOCK_ONLY) != <span class="Constant">0</span> ? XLHL_XMAX_LOCK_ONLY : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((infomask &amp; HEAP_XMAX_EXCL_LOCK) != <span class="Constant">0</span> ? XLHL_XMAX_EXCL_LOCK : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note we ignore HEAP_XMAX_SHR_LOCK here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((infomask &amp; HEAP_XMAX_KEYSHR_LOCK) != <span class="Constant">0</span> ? XLHL_XMAX_KEYSHR_LOCK : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((infomask2 &amp; HEAP_KEYS_UPDATED) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLHL_KEYS_UPDATED : <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given two versions of the same t_infomask for a tuple, <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> them and<br/></li>
<li></span><span class="Comment"> * return whether the relevant status for a tuple Xmax has changed.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * used after a buffer lock has been released and reacquired: we want to ensure<br/></li>
<li></span><span class="Comment"> * that the tuple state continues to be the same it was when we previously<br/></li>
<li></span><span class="Comment"> * examined it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note the Xmax field itself must be compared separately.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2656">&#x200c;</a></span><span class="linkable">xmax_infomask_changed</span>(uint16 new_infomask, uint16 old_infomask)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> uint16 interesting =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_MULTI | HEAP_XMAX_LOCK_ONLY | HEAP_LOCK_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((new_infomask &amp; interesting) != (old_infomask &amp; interesting))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a> - delete a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See table_tuple_delete() for an explanation of the parameters, except that<br/></li>
<li></span><span class="Comment"> * this routine directly takes a tuple rather than a slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the failure cases, the routine fills *tmfd with the tuple's t_ctid,<br/></li>
<li></span><span class="Comment"> * t_xmax (resolving a possible MultiXact, if necessary), and t_cmax (the last<br/></li>
<li></span><span class="Comment"> * only for TM_SelfModified, since we cannot obtain cmax from a combo CID<br/></li>
<li></span><span class="Comment"> * generated by another transaction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TM_Result<br/></li>
<li><a id="L2679">&#x200c;</a><span class="linkable">heap_delete</span>(Relation relation, ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, Snapshot crosscheck, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_FailureData *tmfd, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> changingPart)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_Result&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tp;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; TransactionId new_xmax;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_tuple_lock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; iscombo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; old_key_tuple = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* replica identity of the tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_key_copied = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ItemPointerIsValid(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forbid this during a parallel operation, lest it allocate a combo CID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other workers might need that combo CID for visibility checks, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no provision for broadcasting it to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot delete tuples during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block = ItemPointerGetBlockNumber(tid);<br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, block);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before locking the buffer, pin the visibility map page if it appears to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be necessary.&nbsp; Since we haven't got the lock yet, someone else might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the middle of changing this, so we'll need to recheck after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lp = PageGetItemId(page, ItemPointerGetOffsetNumber(tid));<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp.t_tableOid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; tp.t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; tp.t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; tp.t_self = *tid;<br/></li>
<li><br/></li>
<li><span class="Statement">l1</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't pin the visibility map page and the page has become all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible while we were busy locking the buffer, we'll have to unlock and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-lock, to avoid holding the buffer lock across an I/O.&nbsp; That's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unfortunate, but hopefully shouldn't happen often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a>(&amp;tp, cid, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == TM_Invisible)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;attempted to delete invisible tuple&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result == TM_BeingModified &amp;&amp; wait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xwait;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; infomask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must copy state data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> unlocking buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xwait = HeapTupleHeaderGetRawXmax(tp.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask = tp.t_data-&gt;t_infomask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep until concurrent transaction ends -- except when there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single locker and it's our own transaction.&nbsp; Note we don't care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which lock mode the locker has, because we need the strongest one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before sleeping, we need to acquire tuple lock to establish our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * priority for the tuple (see <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a>).&nbsp; <a href="../../storage/lmgr/lmgr.c.html#L568" title="storage/lmgr/lmgr.c:568">LockTuple</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release us when we are <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-in-line for the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are forced to &quot;start over&quot; below, we keep the tuple lock;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this arranges that we stay at the head of the line while rechecking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; current_is_member = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L7106" title="access/heap/heapam.c:7106">DoesMultiXactIdConflict</a>((MultiXactId) xwait, infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockTupleExclusive, &amp;current_is_member))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire the lock, if necessary (but <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it when we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requesting a lock and already have one; avoids deadlock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!current_is_member)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5004" title="access/heap/heapam.c:5004">heap_acquire_tuplock</a>(relation, &amp;(tp.t_self), LockTupleExclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockWaitBlock, &amp;have_tuple_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait for multixact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a>((MultiXactId) xwait, MultiXactStatusUpdate, infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation, &amp;(tp.t_self), XLTW_Delete,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If xwait had just locked the tuple then some other xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could update this tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to this point.&nbsp; Check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for xmax change, and start over if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We also must start over if we didn't pin the VM page, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page has become all visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(tp.t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(tp.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might think the multixact is necessarily done here, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so: it could have surviving members, namely our own xact or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other subxacts of this backend.&nbsp; It is legal for us to delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple in either case, however (the latter case is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * essentially a situation of upgrading our former shared lock to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exclusive).&nbsp; We don't bother changing the on-disk hint bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we are about to overwrite the xmax altogether.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for regular transaction to end; but first, acquire tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5004" title="access/heap/heapam.c:5004">heap_acquire_tuplock</a>(relation, &amp;(tp.t_self), LockTupleExclusive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockWaitBlock, &amp;have_tuple_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(xwait, relation, &amp;(tp.t_self), XLTW_Delete);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xwait is done, but if xwait had just locked the tuple then some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other xact could update this tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for xmax change, and start over if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We also must start over if we didn't pin the VM page, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page has become all visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(tp.t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(tp.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise check if it committed or aborted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1901" title="access/heap/heapam.c:1901">UpdateXmaxHintBits</a>(tp.t_data, buffer, xwait);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may overwrite if previous xmax aborted, or if it committed but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only locked the tuple without updating it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((tp.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_LOCKED_ONLY(tp.t_data-&gt;t_infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L1520" title="access/heap/heapam_visibility.c:1520">HeapTupleHeaderIsOnlyLocked</a>(tp.t_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tp.t_self, &amp;tp.t_data-&gt;t_ctid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Deleted;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check the result <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a>() and the logic above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result == TM_SelfModified ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Deleted ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_BeingModified);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(tp.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result != TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tp.t_self, &amp;tp.t_data-&gt;t_ctid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (crosscheck != InvalidSnapshot &amp;&amp; result == TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perform additional check for transaction-snapshot mode RI updates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(&amp;tp, crosscheck, buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Updated;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;ctid = tp.t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;xmax = HeapTupleHeaderGetUpdateXid(tp.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == TM_SelfModified)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;cmax = <a href="../../utils/time/combocid.c.html#L118" title="utils/time/combocid.c:118">HeapTupleHeaderGetCmax</a>(tp.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;cmax = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_tuple_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="access/heap/heapam.c:169">UnlockTupleTuplock</a>(relation, &amp;(tp.t_self), LockTupleExclusive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're about to do the actual delete -- check for conflict first, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid possibly having to roll back work we've just done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is safe without a recheck as long as there is no possibility of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another process scanning the page between this check and the delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being visible to the scan (i.e., an exclusive buffer content lock is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continuously held from this point until the tuple delete is visible).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(relation, tid, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* replace cid with a combo CID if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L153" title="utils/time/combocid.c:153">HeapTupleHeaderAdjustCmax</a>(tp.t_data, &amp;cid, &amp;iscombo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute replica identity tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the critical section so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't PANIC upon a memory allocation failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_key_tuple = <a href="#L8651" title="access/heap/heapam.c:8651">ExtractReplicaIdentity</a>(relation, &amp;tp, <span class="Constant">true</span>, &amp;old_key_copied);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first possibly-multixact-able operation in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, set my per-backend <a href="../transam/multixact.c.html#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> setting. We can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certain that the transaction will never become a member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXactIds than that.&nbsp; (We have to do this even if we end up just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using our own TransactionId below, since some other backend could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incorporate our XID into a MultiXact immediately afterwards.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/multixact.c.html#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L5053" title="access/heap/heapam.c:5053">compute_new_xmax_infomask</a>(HeapTupleHeaderGetRawXmax(tp.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp.t_data-&gt;t_infomask, tp.t_data-&gt;t_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid, LockTupleExclusive, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;new_xmax, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this transaction commits, the tuple will become DEAD sooner or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.&nbsp; Set flag that this page is a candidate for pruning once our xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * falls below the OldestXmin horizon.&nbsp; If the transaction finally aborts,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the subsequent page pruning will be a no-op and the hint will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PageSetPrunable(page, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store transaction information of xact deleting the tuple */<br/></li>
<li></span>&nbsp; &nbsp; tp.t_data-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; tp.t_data-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; tp.t_data-&gt;t_infomask |= new_infomask;<br/></li>
<li>&nbsp; &nbsp; tp.t_data-&gt;t_infomask2 |= new_infomask2;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderClearHotUpdated(tp.t_data);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(tp.t_data, new_xmax);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetCmax(tp.t_data, cid, iscombo);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure there is no forward chain link in t_ctid */<br/></li>
<li></span>&nbsp; &nbsp; tp.t_data-&gt;t_ctid = tp.t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Signal that this is actually a move into another partition */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (changingPart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetMovedPartitions(tp.t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG stuff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: <a href="#L5902" title="access/heap/heapam.c:5902">heap_abort_speculative</a>() uses the same xlog record and replay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_delete xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_header xlhdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For logical decode we need combo CIDs to properly decode the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsAccessibleInLogicalDecoding(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(relation, &amp;tp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_visible_cleared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_DELETE_ALL_VISIBLE_CLEARED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (changingPart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_DELETE_IS_PARTITION_MOVE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.infobits_set = <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>(tp.t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp.t_data-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;tp.t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.xmax = new_xmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_key_tuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_DELETE_CONTAINS_OLD_TUPLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_DELETE_CONTAINS_OLD_KEY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Log replica identity of the deleted tuple if there is one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_key_tuple != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlhdr.t_infomask2 = old_key_tuple-&gt;t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlhdr.t_infomask = old_key_tuple-&gt;t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlhdr.t_hoff = old_key_tuple-&gt;t_data-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlhdr, SizeOfHeapHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) old_key_tuple-&gt;t_data<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_key_tuple-&gt;t_len<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; - SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* filtering by origin on a row level is much more efficient */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple has toasted out-of-line attributes, we need to delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those items too.&nbsp; We have to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we need to look at the contents of the tuple, but it's OK to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release the content lock on the buffer first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* toast table entries should never be recursively toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHasExternal(&amp;tp));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HeapTupleHasExternal(&amp;tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="heaptoast.c.html#L43" title="access/heap/heaptoast.c:43">heap_toast_delete</a>(relation, &amp;tp, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark tuple for invalidation from system caches at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary. We have to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the buffer because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to look at the contents of the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>(relation, &amp;tp, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can release the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the lmgr tuple lock, if we had it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_tuple_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="access/heap/heapam.c:169">UnlockTupleTuplock</a>(relation, &amp;(tp.t_self), LockTupleExclusive);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L401" title="utils/activity/pgstat_relation.c:401">pgstat_count_heap_delete</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (old_key_tuple != <span class="Constant">NULL</span> &amp;&amp; old_key_copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(old_key_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3100" title="access/heap/heapam.c:3100">simple_heap_delete</a> - delete a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine may be used to delete a tuple when concurrent updates of<br/></li>
<li></span><span class="Comment"> * the target tuple are not expected (for example, because we have a lock<br/></li>
<li></span><span class="Comment"> * on the relation associated with the tuple).&nbsp; Any failure is reported<br/></li>
<li></span><span class="Comment"> * via ereport().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3100">&#x200c;</a></span><span class="linkable">simple_heap_delete</span>(Relation relation, ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_Result&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TM_FailureData tmfd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a>(relation, tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>), InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span> <span class="Comment">/* wait for commit */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmfd, <span class="Constant">false</span> <span class="Comment">/* changingPart */</span> );<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_SelfModified:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple was already updated in current command? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple already updated by self&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_Ok:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done successfully */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_Updated:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple concurrently updated&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_Deleted:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple concurrently deleted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a> status: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a> - replace a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See table_tuple_update() for an explanation of the parameters, except that<br/></li>
<li></span><span class="Comment"> * this routine directly takes a tuple rather than a slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the failure cases, the routine fills *tmfd with the tuple's t_ctid,<br/></li>
<li></span><span class="Comment"> * t_xmax (resolving a possible MultiXact, if necessary), and t_cmax (the last<br/></li>
<li></span><span class="Comment"> * only for TM_SelfModified, since we cannot obtain cmax from a combo CID<br/></li>
<li></span><span class="Comment"> * generated by another transaction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TM_Result<br/></li>
<li><a id="L3146">&#x200c;</a><span class="linkable">heap_update</span>(Relation relation, ItemPointer otid, HeapTuple newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, Snapshot crosscheck, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> wait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_FailureData *tmfd, LockTupleMode *lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TU_UpdateIndexes *update_indexes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_Result&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *hot_attrs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *sum_attrs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *key_attrs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *id_attrs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *interesting_attrs;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *modified_attrs;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData oldtup;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; heaptup;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; old_key_tuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; old_key_copied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; MultiXactStatus mxact_status;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer_new = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_toast;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newtupsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagefree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_tuple_lock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; iscombo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_hot_update = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; summarized_update = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; key_intact;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared_new = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; checked_lockers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; locker_remains;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; id_has_external = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmax_new_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmax_old_tuple;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; infomask_old_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask2_old_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask_new_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask2_new_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ItemPointerIsValid(otid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cheap, simplistic check that the tuple matches the rel's rowtype. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(HeapTupleHeaderGetNatts(newtup-&gt;t_data) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNumberOfAttributes(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forbid this during a parallel operation, lest it allocate a combo CID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other workers might need that combo CID for visibility checks, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no provision for broadcasting it to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot update tuples during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch the list of attributes to be checked for various operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For HOT considerations, this is wasted effort if we fail to update or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to put the new tuple on a different page.&nbsp; But we must compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> obtaining buffer lock --- in the worst case, if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing an update on one of the relevant system catalogs, we could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlock if we try to fetch the list later.&nbsp; In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, the relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caches the data so this is usually pretty cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also need columns used by the replica identity and columns that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered the &quot;key&quot; of rows in the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we get copies of each bitmap, so we need not worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache flush happening midway through.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hot_attrs = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_HOT_BLOCKING);<br/></li>
<li>&nbsp; &nbsp; sum_attrs = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_SUMMARIZED);<br/></li>
<li>&nbsp; &nbsp; key_attrs = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation, INDEX_ATTR_BITMAP_KEY);<br/></li>
<li>&nbsp; &nbsp; id_attrs = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_ATTR_BITMAP_IDENTITY_KEY);<br/></li>
<li>&nbsp; &nbsp; interesting_attrs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; interesting_attrs = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(interesting_attrs, hot_attrs);<br/></li>
<li>&nbsp; &nbsp; interesting_attrs = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(interesting_attrs, sum_attrs);<br/></li>
<li>&nbsp; &nbsp; interesting_attrs = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(interesting_attrs, key_attrs);<br/></li>
<li>&nbsp; &nbsp; interesting_attrs = <a href="../../nodes/bitmapset.c.html#L917" title="nodes/bitmapset.c:917">bms_add_members</a>(interesting_attrs, id_attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block = ItemPointerGetBlockNumber(otid);<br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, block);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before locking the buffer, pin the visibility map page if it appears to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be necessary.&nbsp; Since we haven't got the lock yet, someone else might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the middle of changing this, so we'll need to recheck after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lp = PageGetItemId(page, ItemPointerGetOffsetNumber(otid));<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in enough data in oldtup for <a href="#L4127" title="access/heap/heapam.c:4127">HeapDetermineColumnsInfo</a> to work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldtup.t_tableOid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; oldtup.t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; oldtup.t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; oldtup.t_self = *otid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the new tuple is ready, except for this: */<br/></li>
<li></span>&nbsp; &nbsp; newtup-&gt;t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine columns modified by the update.&nbsp; Additionally, identify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the unmodified replica identity key attributes in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old tuple is externally stored or not.&nbsp; This is required because for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such attributes the flattened value won't be WAL logged as part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new tuple so we must include it as part of the old_key_tuple.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L8651" title="access/heap/heapam.c:8651">ExtractReplicaIdentity</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; modified_attrs = <a href="#L4127" title="access/heap/heapam.c:4127">HeapDetermineColumnsInfo</a>(relation, interesting_attrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; id_attrs, &amp;oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup, &amp;id_has_external);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not updating <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;key&quot; column, we can grab a weaker lock type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This allows for more concurrency when we are running simultaneously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with foreign key checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that if a column gets detoasted while executing the update, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the value ends up being the same, this test will fail and we will use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the stronger lock.&nbsp; This is acceptable; the important case to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is updates that don't manipulate key columns, not those that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serendipitously arrive at the same key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(modified_attrs, key_attrs))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lockmode = LockTupleNoKeyExclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mxact_status = MultiXactStatusNoKeyUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key_intact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first possibly-multixact-able operation in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current transaction, set my per-backend <a href="../transam/multixact.c.html#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting. We can be certain that the transaction will never become a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> older MultiXactIds than that.&nbsp; (We have to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if we end up just using our own TransactionId below, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some other backend could incorporate our XID into a MultiXact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately afterwards.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/multixact.c.html#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lockmode = LockTupleExclusive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mxact_status = MultiXactStatusUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key_intact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: beyond this point, use oldtup not otid to refer to old tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otid may very well point at newtup-&gt;t_self, which we will overwrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the new tuple's location, so there's great risk of confusion if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use otid anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="Statement">l2</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; checked_lockers = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; locker_remains = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; result = <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a>(&amp;oldtup, cid, buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see below about the &quot;no wait&quot; case */<br/></li>
<li></span>&nbsp; &nbsp; Assert(result != TM_BeingModified || wait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == TM_Invisible)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;attempted to update invisible tuple&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result == TM_BeingModified &amp;&amp; wait)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xwait;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; can_continue = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> note that we don't consider the &quot;no wait&quot; case here.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't a problem currently because no caller uses that case, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be fixed if such a caller is introduced.&nbsp; It wasn't a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problem previously because this code would always wait, but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that some tuple locks do not conflict with one of the lock modes we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use, it is possible that this case is interesting to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * specially.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This may cause failures with third-party code that calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a> directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must copy state data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> unlocking buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xwait = HeapTupleHeaderGetRawXmax(oldtup.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask = oldtup.t_data-&gt;t_infomask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we have to do something about the existing locker.&nbsp; If it's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multi, sleep on it; we might be awakened <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is completely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gone (or even not sleep at all in some cases); we need to preserve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it as locker, unless it is gone completely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's not a multi, we need to check for sleeping conditions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually going to sleep.&nbsp; If the update doesn't conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the locks, we just continue without sleeping (but making sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it is preserved).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before sleeping, we need to acquire tuple lock to establish our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * priority for the tuple (see <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a>).&nbsp; <a href="../../storage/lmgr/lmgr.c.html#L568" title="storage/lmgr/lmgr.c:568">LockTuple</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release us when we are <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-in-line for the tuple.&nbsp; Note we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not acquire the tuple lock until we're sure we're going to sleep;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we're open for race conditions with other transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding the tuple lock which sleep on us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are forced to &quot;start over&quot; below, we keep the tuple lock;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this arranges that we stay at the head of the line while rechecking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId update_xact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; current_is_member = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L7106" title="access/heap/heapam.c:7106">DoesMultiXactIdConflict</a>((MultiXactId) xwait, infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lockmode, &amp;current_is_member))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire the lock, if necessary (but <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it when we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requesting a lock and already have one; avoids deadlock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!current_is_member)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5004" title="access/heap/heapam.c:5004">heap_acquire_tuplock</a>(relation, &amp;(oldtup.t_self), *lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockWaitBlock, &amp;have_tuple_lock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait for multixact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a>((MultiXactId) xwait, mxact_status, infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation, &amp;oldtup.t_self, XLTW_Update,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;remain);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checked_lockers = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locker_remains = remain != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If xwait had just locked the tuple then some other xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could update this tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to this point.&nbsp; Check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for xmax change, and start over if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(oldtup.t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(oldtup.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the multixact may not be done by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; It could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * surviving members; our own xact or other subxacts of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend, and also <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other concurrent transaction that locked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple with LockTupleKeyShare if we only got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LockTupleNoKeyExclusive.&nbsp; If this is the case, we have to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * careful to mark the updated tuple with the surviving members in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Xmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that there could have been another update in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MultiXact. In that case, we need to check whether it committed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or aborted. If it aborted we are safe to update it again;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise there is an update conflict, and we have to return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TableTuple{Deleted, Updated} below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the LockTupleExclusive case, we still need to preserve the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * surviving members: those would include the tuple locks we had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this one, which are important to keep in case this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subxact aborts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HEAP_XMAX_IS_LOCKED_ONLY(oldtup.t_data-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_xact = <a href="#L7090" title="access/heap/heapam.c:7090">HeapTupleGetUpdateXid</a>(oldtup.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_xact = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There was no UPDATE in the MultiXact; or it aborted. No<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>() call needed here, since we called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a>() above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(update_xact) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(update_xact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can_continue = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only locker is ourselves; we can avoid grabbing the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock here, but must preserve our locking information.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checked_lockers = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locker_remains = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can_continue = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_KEYSHR_LOCKED(infomask) &amp;&amp; key_intact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's just a key-share locker, and we're not changing the key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns, we don't need to wait for it to end; but we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserve it as locker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checked_lockers = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; locker_remains = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can_continue = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for regular transaction to end; but first, acquire tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5004" title="access/heap/heapam.c:5004">heap_acquire_tuplock</a>(relation, &amp;(oldtup.t_self), *lockmode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockWaitBlock, &amp;have_tuple_lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(xwait, relation, &amp;oldtup.t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLTW_Update);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; checked_lockers = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xwait is done, but if xwait had just locked the tuple then some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other xact could update this tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for xmax change, and start over if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(oldtup.t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(xwait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetRawXmax(oldtup.t_data)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise check if it committed or aborted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1901" title="access/heap/heapam.c:1901">UpdateXmaxHintBits</a>(oldtup.t_data, buffer, xwait);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldtup.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can_continue = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (can_continue)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;oldtup.t_self, &amp;oldtup.t_data-&gt;t_ctid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Deleted;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sanity check the result <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a>() and the logic above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result == TM_SelfModified ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Deleted ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_BeingModified);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(oldtup.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result != TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;oldtup.t_self, &amp;oldtup.t_data-&gt;t_ctid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (crosscheck != InvalidSnapshot &amp;&amp; result == TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perform additional check for transaction-snapshot mode RI updates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="heapam_visibility.c.html#L1767" title="access/heap/heapam_visibility.c:1767">HeapTupleSatisfiesVisibility</a>(&amp;oldtup, crosscheck, buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Updated;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;ctid = oldtup.t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;xmax = HeapTupleHeaderGetUpdateXid(oldtup.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == TM_SelfModified)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;cmax = <a href="../../utils/time/combocid.c.html#L118" title="utils/time/combocid.c:118">HeapTupleHeaderGetCmax</a>(oldtup.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;cmax = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (have_tuple_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="access/heap/heapam.c:169">UnlockTupleTuplock</a>(relation, &amp;(oldtup.t_self), *lockmode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *update_indexes = TU_None;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(hot_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(sum_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(key_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(id_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(modified_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(interesting_attrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't pin the visibility map page and the page has become all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible while we were busy locking the buffer, or during some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsequent window during which we had it unlocked, we'll have to unlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and re-lock, to avoid holding the buffer lock across an I/O.&nbsp; That's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> unfortunate, especially since we'll <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have to recheck whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple has been locked or updated under us, but hopefully it won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen very often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in transaction status data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple we're updating is locked, we need to preserve the locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * info in the old tuple's Xmax.&nbsp; Prepare a new Xmax value for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5053" title="access/heap/heapam.c:5053">compute_new_xmax_infomask</a>(HeapTupleHeaderGetRawXmax(oldtup.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid, *lockmode, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;xmax_old_tuple, &amp;infomask_old_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;infomask2_old_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And also prepare an Xmax value for the new copy of the tuple.&nbsp; If there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was no xmax previously, or there was one but all lockers are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> gone,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then use InvalidTransactionId; otherwise, get the xmax from the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple.&nbsp; (In rare cases that might also be InvalidTransactionId and yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not have the HEAP_XMAX_INVALID <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set; that's fine.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((oldtup.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HEAP_LOCKED_UPGRADED(oldtup.t_data-&gt;t_infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (checked_lockers &amp;&amp; !locker_remains))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmax_new_tuple = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xmax_new_tuple = HeapTupleHeaderGetRawXmax(oldtup.t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(xmax_new_tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask_new_tuple = HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask2_new_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found a valid Xmax for the new tuple, then the infomask bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to use on the new tuple depend on what was there on the old one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that since we're doing an update, the only possibility is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the lockers had FOR <a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldtup.t_data-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(xmax_new_tuple, &amp;infomask_new_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;infomask2_new_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask_new_tuple = HEAP_XMAX_KEYSHR_LOCK | HEAP_XMAX_LOCK_ONLY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask2_new_tuple = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare the new tuple with the appropriate initial <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of Xmin and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Xmax, as well as initial infomask bits as computed above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newtup-&gt;t_data-&gt;t_infomask &amp;= ~(HEAP_XACT_MASK);<br/></li>
<li>&nbsp; &nbsp; newtup-&gt;t_data-&gt;t_infomask2 &amp;= ~(HEAP2_XACT_MASK);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmin(newtup-&gt;t_data, xid);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetCmin(newtup-&gt;t_data, cid);<br/></li>
<li>&nbsp; &nbsp; newtup-&gt;t_data-&gt;t_infomask |= HEAP_UPDATED | infomask_new_tuple;<br/></li>
<li>&nbsp; &nbsp; newtup-&gt;t_data-&gt;t_infomask2 |= infomask2_new_tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(newtup-&gt;t_data, xmax_new_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace cid with a combo CID if necessary.&nbsp; Note that we already put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the plain cid into the new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/time/combocid.c.html#L153" title="utils/time/combocid.c:153">HeapTupleHeaderAdjustCmax</a>(oldtup.t_data, &amp;cid, &amp;iscombo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the toaster needs to be activated, OR if the new tuple will not fit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the same page as the old, then we need to release the content lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (but not the pin!) on the old tuple's buffer while we are off doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TOAST and/or table-file-extension work.&nbsp; We must mark the old tuple to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * show that it's locked, else other processes may try to update it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * themselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to invoke the toaster if there are already <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> out-of-line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toasted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> present, or if the new tuple is over-threshold.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* toast table entries should never be recursively toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHasExternal(&amp;oldtup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHasExternal(newtup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_toast = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; need_toast = (HeapTupleHasExternal(&amp;oldtup) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHasExternal(newtup) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup-&gt;t_len &gt; TOAST_TUPLE_THRESHOLD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pagefree = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newtupsize = MAXALIGN(newtup-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (need_toast || newtupsize &gt; pagefree)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmax_lock_old_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; infomask_lock_old_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask2_lock_old_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To prevent concurrent sessions from updating the tuple, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporarily mark it locked, while we release the page-level lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To satisfy the rule that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> xid potentially appearing in a buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * written out to disk, we unfortunately have to WAL log this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * temporary modification.&nbsp; We can reuse xl_heap_lock for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * purpose.&nbsp; If we crash/error <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> following through with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actual update, xmax will be of an aborted transaction, allowing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other sessions to proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute xmax / infomask appropriate for locking the tuple. This has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be done separately from the combo that's going to be used for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updating, because the potentially created multixact would otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5053" title="access/heap/heapam.c:5053">compute_new_xmax_infomask</a>(HeapTupleHeaderGetRawXmax(oldtup.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid, *lockmode, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;xmax_lock_old_tuple, &amp;infomask_lock_old_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;infomask2_lock_old_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(HEAP_XMAX_IS_LOCKED_ONLY(infomask_lock_old_tuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear obsolete visibility flags ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleClearHotUpdated(&amp;oldtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and store info about transaction updating this tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsValid(xmax_lock_old_tuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(oldtup.t_data, xmax_lock_old_tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask |= infomask_lock_old_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2 |= infomask2_lock_old_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmax(oldtup.t_data, cid, iscombo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* temporarily make it look not-updated, but locked */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_ctid = oldtup.t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear all-frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on visibility map if needed. We could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately reset ALL_VISIBLE, but given that the WAL logging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overhead would be unchanged, that doesn't seem necessarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worthwhile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(page) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation, block, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_FROZEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_heap_lock xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;oldtup.t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.xmax = xmax_lock_old_tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.infobits_set = <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>(oldtup.t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen ? XLH_LOCK_ALL_FROZEN_CLEARED : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_LOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Let the toaster do its thing, if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: below this point, heaptup is the data we actually intend to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * store into the relation; newtup is the caller's original untoasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need_toast)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Note we always use WAL and FSM during updates */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaptup = <a href="heaptoast.c.html#L96" title="access/heap/heaptoast.c:96">heap_toast_insert_or_update</a>(relation, newtup, &amp;oldtup, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtupsize = MAXALIGN(heaptup-&gt;t_len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaptup = newtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now, do we need a new page for the tuple, or not?&nbsp; This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tricky since someone else could have added tuples to the page while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we weren't looking.&nbsp; We have to recheck the available space after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reacquiring the buffer lock.&nbsp; But don't bother to do that if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * former amount of free space is still not enough; it's unlikely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's more free <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> than <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * What's more, if we need to get a new page, we will need to acquire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer locks on both old and new pages.&nbsp; To avoid deadlock against<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some other backend trying to get the same two locks in the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order, we must be consistent about the order we get the locks in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use the rule &quot;lock the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-numbered page of the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first&quot;.&nbsp; To implement this, we must do <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * while not holding the lock on the old page, and we must rely on it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to get the locks on both pages in the correct order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another consideration is that we need visibility map page pin(s) if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we will have to clear the all-visible flag on either page.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>, we rely on it to acquire <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pins; but if we don't, we have to handle that here.&nbsp; Hence we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtupsize &gt; pagefree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* It doesn't fit, must use <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbuf = <a href="hio.c.html#L502" title="access/heap/hio.c:502">RelationGetBufferForTuple</a>(relation, heaptup-&gt;t_len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer, <span class="Constant">0</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;vmbuffer_new, &amp;vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're all done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Acquire VM page pin if needed and we don't have it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-acquire the lock on the old tuple's page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-check using the up-to-date free space */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagefree = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtupsize &gt; pagefree ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rats, it doesn't fit anymore, or somebody just <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-visible flag.&nbsp; We must <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> unlock and loop to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock.&nbsp; Fortunately, this path should seldom be taken.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're all done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbuf = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No TOAST work needed, and it'll fit on same page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newbuf = buffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heaptup = newtup;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're about to do the actual update -- check for conflict first, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid possibly having to roll back work we've just done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is safe without a recheck as long as there is no possibility of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another process scanning the pages between this check and the update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being visible to the scan (i.e., exclusive buffer content lock(s) are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continuously held from this point until the tuple update is visible).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the new tuple the only check needed is at the relation level, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since both tuples are in the same relation and the check for oldtup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will include checking the relation level, there is no benefit to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separate check for the new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4321" title="storage/lmgr/predicate.c:4321">CheckForSerializableConflictIn</a>(relation, &amp;oldtup.t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point newbuf and buffer are both pinned and locked, and newbuf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has enough space for the new tuple.&nbsp; If they are the same buffer, only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one pin is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newbuf == buffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the new tuple is going into the same page, we might be able<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do a HOT update.&nbsp; Check if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the index columns have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(modified_attrs, hot_attrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use_hot_update = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the columns that are used in hot-blocking indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were updated, we can apply HOT, but we do still need to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we need to update the summarizing indexes, and update those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes if the columns were updated, or we may fail to detect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * e.g. value bound changes in BRIN minmax indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(modified_attrs, sum_attrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summarized_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set a hint that the old page could use prune/defrag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageSetFull(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute replica identity tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the critical section so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't PANIC upon a memory allocation failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L8651" title="access/heap/heapam.c:8651">ExtractReplicaIdentity</a>() will return NULL if nothing needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logged.&nbsp; Pass old key required as true only if the replica identity key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns are modified or it has external data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; old_key_tuple = <a href="#L8651" title="access/heap/heapam.c:8651">ExtractReplicaIdentity</a>(relation, &amp;oldtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../nodes/bitmapset.c.html#L582" title="nodes/bitmapset.c:582">bms_overlap</a>(modified_attrs, id_attrs) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; id_has_external,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;old_key_copied);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this transaction commits, the old tuple will become DEAD sooner or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later.&nbsp; Set flag that this page is a candidate for pruning once our xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * falls below the OldestXmin horizon.&nbsp; If the transaction finally aborts,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the subsequent page pruning will be a no-op and the hint will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Should we set hint on newbuf as well?&nbsp; If the transaction aborts,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there would be a prunable tuple in the newbuf; but for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we choose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> for aborts.&nbsp; Note that <a href="#L9391" title="access/heap/heapam.c:9391">heap_xlog_update</a> must be kept in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sync if this decision changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PageSetPrunable(page, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (use_hot_update)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the old tuple as HOT-updated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleSetHotUpdated(&amp;oldtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And mark the new tuple as heap-only */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleSetHeapOnly(heaptup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the caller's copy too, in case different from heaptup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleSetHeapOnly(newtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure tuples are correctly marked as not-HOT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleClearHotUpdated(&amp;oldtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleClearHeapOnly(heaptup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleClearHeapOnly(newtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="hio.c.html#L35" title="access/heap/hio.c:35">RelationPutHeapTuple</a>(relation, newbuf, heaptup, <span class="Constant">false</span>); <span class="Comment">/* insert new tuple */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear obsolete visibility flags, possibly set by ourselves above... */<br/></li>
<li></span>&nbsp; &nbsp; oldtup.t_data-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and store info about transaction updating this tuple */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(xmax_old_tuple));<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(oldtup.t_data, xmax_old_tuple);<br/></li>
<li>&nbsp; &nbsp; oldtup.t_data-&gt;t_infomask |= infomask_old_tuple;<br/></li>
<li>&nbsp; &nbsp; oldtup.t_data-&gt;t_infomask2 |= infomask2_old_tuple;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetCmax(oldtup.t_data, cid, iscombo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* record address of new tuple in t_ctid of old one */<br/></li>
<li></span>&nbsp; &nbsp; oldtup.t_data-&gt;t_ctid = heaptup-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clear PD_ALL_VISIBLE flags, reset all visibilitymap bits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buffer)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(BufferGetPage(buffer));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newbuf != buffer &amp;&amp; PageIsAllVisible(BufferGetPage(newbuf)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; all_visible_cleared_new = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(BufferGetPage(newbuf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(newbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vmbuffer_new, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newbuf != buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(newbuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For logical decoding we need combo CIDs to properly decode the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationIsAccessibleInLogicalDecoding(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(relation, &amp;oldtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8570" title="access/heap/heapam.c:8570">log_heap_new_cid</a>(relation, heaptup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="#L8348" title="access/heap/heapam.c:8348">log_heap_update</a>(relation, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newbuf, &amp;oldtup, heaptup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_key_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; all_visible_cleared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; all_visible_cleared_new);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newbuf != buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(newbuf), recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(BufferGetPage(buffer), recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newbuf != buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(newbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark old tuple for invalidation from system caches at <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * boundary, and mark the new tuple for invalidation in case we abort. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the buffer because oldtup is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer.&nbsp; (heaptup is all in local memory, but it's necessary to process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both tuple versions in one call to inval.c so we can avoid redundant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sinval messages.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>(relation, &amp;oldtup, heaptup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can release the buffer(s) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newbuf != buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(newbuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vmbuffer_new))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer_new);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the lmgr tuple lock, if we had it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_tuple_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="access/heap/heapam.c:169">UnlockTupleTuplock</a>(relation, &amp;(oldtup.t_self), *lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L375" title="utils/activity/pgstat_relation.c:375">pgstat_count_heap_update</a>(relation, use_hot_update, newbuf != buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If heaptup is a private copy, release it.&nbsp; Don't forget to copy t_self<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to the caller's image, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heaptup != newtup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newtup-&gt;t_self = heaptup-&gt;t_self;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(heaptup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it is a HOT update, the update may still need to update summarized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes, lest we fail to update those summaries and get incorrect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results (for example, minmax bounds of the block may change with this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (use_hot_update)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarized_update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *update_indexes = TU_Summarizing;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *update_indexes = TU_None;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *update_indexes = TU_All;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (old_key_tuple != <span class="Constant">NULL</span> &amp;&amp; old_key_copied)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(old_key_tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(hot_attrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(sum_attrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(key_attrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(id_attrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(modified_attrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(interesting_attrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the specified attribute's <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are the same.&nbsp; Subroutine for<br/></li>
<li></span><span class="Comment"> * <a href="#L4127" title="access/heap/heapam.c:4127">HeapDetermineColumnsInfo</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4076">&#x200c;</a></span><span class="linkable">heap_attr_equals</span>(TupleDesc tupdesc, <span class="Type">int</span> attrnum, Datum value1, Datum value2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull1, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isnull2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If one value is NULL and other is not, then they are certainly not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnull1 != isnull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If both are NULL, they can be considered <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnull1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do simple binary comparison of the two datums.&nbsp; This may be overly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strict because there can be multiple binary representations for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same logical value.&nbsp; But we should be OK as long as there are no false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positives.&nbsp; Using a type-specific equality operator is messy because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there could be multiple notions of equality in different operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * classes; furthermore, we cannot safely invoke user-defined <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while holding exclusive buffer lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (attrnum &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The only allowed system columns are OIDs, so do this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (DatumGetObjectId(value1) == DatumGetObjectId(value2));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(attrnum &lt;= tupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(tupdesc, attrnum - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/datum.c.html#L223" title="utils/adt/datum.c:223">datumIsEqual</a>(value1, value2, att-&gt;attbyval, att-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check which columns are being updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given an updated tuple, determine (and return into the output bitmapset),<br/></li>
<li></span><span class="Comment"> * from those listed as interesting, the set of columns that changed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * has_external indicates if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the unmodified attributes (from those<br/></li>
<li></span><span class="Comment"> * listed as interesting) of the old tuple is a member of external_cols and is<br/></li>
<li></span><span class="Comment"> * stored externally.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Bitmapset *<br/></li>
<li><a id="L4127">&#x200c;</a><span class="linkable">HeapDetermineColumnsInfo</span>(Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *interesting_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Bitmapset *external_cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple oldtup, HeapTuple newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *has_external)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attidx;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *modified = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attidx = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((attidx = <a href="../../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(interesting_cols, attidx)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* attidx is zero-based, attrnum is the normal attribute number */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attrnum = attidx + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isnull2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a whole-tuple reference, say &quot;not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot;.&nbsp; It's not really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worth supporting this case, since it could only succeed after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no-op update, which is hardly a case worth optimizing for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrnum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(modified, attidx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, automatically say &quot;not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>&quot; for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> system attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other than tableOID; we cannot expect these to be consistent in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HOT chain, or even to be set correctly yet in the new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrnum != TableOidAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(modified, attidx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract the corresponding <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> this is pretty inefficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there are many indexed columns.&nbsp; Should we do a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a> call on each tuple, instead?&nbsp; &nbsp; But that doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * work for system columns ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; value1 = heap_getattr(oldtup, attrnum, tupdesc, &amp;isnull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value2 = heap_getattr(newtup, attrnum, tupdesc, &amp;isnull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4076" title="access/heap/heapam.c:4076">heap_attr_equals</a>(tupdesc, attrnum, value1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value2, isnull1, isnull2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified = <a href="../../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(modified, attidx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No need to check attributes that can't be stored externally. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that system attributes can't be stored externally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrnum &lt; <span class="Constant">0</span> || isnull1 ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(tupdesc, attrnum - <span class="Constant">1</span>)-&gt;attlen != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the old tuple's attribute is stored externally and is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * member of external_cols.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (VARATT_IS_EXTERNAL((<span class="Type">struct</span> varlena *) DatumGetPointer(value1)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attidx, external_cols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *has_external = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> modified;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4217" title="access/heap/heapam.c:4217">simple_heap_update</a> - replace a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine may be used to update a tuple when concurrent updates of<br/></li>
<li></span><span class="Comment"> * the target tuple are not expected (for example, because we have a lock<br/></li>
<li></span><span class="Comment"> * on the relation associated with the tuple).&nbsp; Any failure is reported<br/></li>
<li></span><span class="Comment"> * via ereport().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4217">&#x200c;</a></span><span class="linkable">simple_heap_update</span>(Relation relation, ItemPointer otid, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TU_UpdateIndexes *update_indexes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_Result&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; TM_FailureData tmfd;<br/></li>
<li>&nbsp; &nbsp; LockTupleMode lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a>(relation, otid, tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>), InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span> <span class="Comment">/* wait for commit */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tmfd, &amp;lockmode, update_indexes);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_SelfModified:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple was already updated in current command? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple already updated by self&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_Ok:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done successfully */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_Updated:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple concurrently updated&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> TM_Deleted:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;tuple concurrently deleted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a> status: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the MultiXactStatus corresponding to the given tuple lock mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> MultiXactStatus<br/></li>
<li><a id="L4258">&#x200c;</a><span class="linkable">get_mxact_status_for_lock</span>(LockTupleMode mode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_update)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[mode].updstatus;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; retval = <a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[mode].lockstatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (retval == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid lock tuple mode </span><span class="Special">%d</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_update ? <span class="Constant">&quot;true&quot;</span> : <span class="Constant">&quot;false&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (MultiXactStatus) retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a> - lock a tuple in shared or exclusive mode<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this acquires a buffer pin, which the caller must release.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Input parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; relation: relation containing tuple (caller must hold suitable lock)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; tid: TID of tuple to lock<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; cid: current command ID (used for visibility test, and stored into<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuple's cmax if lock is successful)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; mode: indicates if shared or exclusive tuple lock is desired<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; wait_policy: what to do if tuple lock is not available<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; follow_updates: if true, follow the update chain to also lock descendant<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Output parameters:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *tuple: all fields filled in<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *buffer: set to buffer holding tuple (pinned but not locked at exit)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; *tmfd: filled in failure cases (see below)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Function results are the same as the ones for table_tuple_lock().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the failure cases other than TM_Invisible, the routine fills<br/></li>
<li></span><span class="Comment"> * *tmfd with the tuple's t_ctid, t_xmax (resolving a possible MultiXact,<br/></li>
<li></span><span class="Comment"> * if necessary), and t_cmax (the last only for TM_SelfModified,<br/></li>
<li></span><span class="Comment"> * since we cannot obtain cmax from a combo CID generated by another<br/></li>
<li></span><span class="Comment"> * transaction).<br/></li>
<li></span><span class="Comment"> * See comments for struct TM_FailureData for additional info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See README.tuplock for a thorough explanation of this mechanism.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TM_Result<br/></li>
<li><a id="L4306">&#x200c;</a><span class="linkable">heap_lock_tuple</span>(Relation relation, HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommandId cid, LockTupleMode mode, LockWaitPolicy wait_policy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> follow_updates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *buffer, TM_FailureData *tmfd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_Result&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ItemPointer tid = &amp;(tuple-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmax;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; old_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; first_time = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skip_tuple_lock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_tuple_lock = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, ItemPointerGetBlockNumber(tid));<br/></li>
<li>&nbsp; &nbsp; block = ItemPointerGetBlockNumber(tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before locking the buffer, pin the visibility map page if it appears to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be necessary.&nbsp; Since we haven't got the lock yet, someone else might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the middle of changing this, so we'll need to recheck after we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(*buffer)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(*buffer);<br/></li>
<li>&nbsp; &nbsp; lp = PageGetItemId(page, ItemPointerGetOffsetNumber(tid));<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li><span class="Statement">l3</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a>(tuple, cid, *buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == TM_Invisible)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is possible, but only when locking a tuple for ON CONFLICT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * UPDATE.&nbsp; We return this value here rather than throwing an error in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order to give that case the opportunity to throw a more specific<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = TM_Invisible;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result == TM_BeingModified ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Deleted)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xwait;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; require_sleep;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData t_ctid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must copy state data <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> unlocking buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xwait = HeapTupleHeaderGetRawXmax(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask = tuple-&gt;t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; infomask2 = tuple-&gt;t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(&amp;tuple-&gt;t_data-&gt;t_ctid, &amp;t_ctid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subtransaction of the current top transaction already holds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a lock as strong as or stronger than what we're requesting, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * effectively hold the desired lock already.&nbsp; We *must* succeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without trying to take the tuple lock, else we will deadlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against anyone wanting to acquire a stronger lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we only do this the first time we loop on the HTSU result;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is no point in testing in subsequent passes, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evidently our own transaction cannot have acquired a new lock after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the first time we checked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first_time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_time = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to allow old multixacts here; if that had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been the case, <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a> would have returned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MayBeUpdated and we wouldn't be here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(xwait, &amp;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_LOCKED_ONLY(infomask));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only consider members of our own transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(members[i].xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L218" title="access/heap/heapam.c:218">TUPLOCK_from_mxstatus</a>(members[i].status) &gt;= mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_unlocked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable acquisition of the heavyweight tuple lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, when promoting a weaker lock, we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlock with another locker that has acquired the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heavyweight tuple lock and is <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction to finish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that in this case we still need to wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the multixact if required, to avoid acquiring<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflicting locks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_tuple_lock = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleKeyShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(HEAP_XMAX_IS_KEYSHR_LOCKED(infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_IS_SHR_LOCKED(infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_IS_EXCL_LOCKED(infomask));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_unlocked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_SHR_LOCKED(infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_EXCL_LOCKED(infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_unlocked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleNoKeyExclusive:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_EXCL_LOCKED(infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_unlocked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleExclusive:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_EXCL_LOCKED(infomask) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_unlocked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initially assume that we will have to wait for the locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction(s) to finish.&nbsp; We check various cases below in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this can be turned off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; require_sleep = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == LockTupleKeyShare)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're requesting KeyShare, and there's no update present, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need to wait.&nbsp; Even if there is an update, we can still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue if the key hasn't been modified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, if there are updates, we need to walk the update chain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to mark future versions of the row as locked, too.&nbsp; That way,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if somebody deletes that future version, we're protected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against the key going away.&nbsp; This locking of future versions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could block momentarily, if a concurrent transaction is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleting a key; or it could return a value to the effect that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the transaction deleting the key has already committed.&nbsp; So we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> re-locking the buffer; otherwise this would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prone to deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the TID we're locking was grabbed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we unlocked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the buffer.&nbsp; For it to change while we're not looking, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other properties we're testing for below after re-locking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer would also change, in which case we would restart this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(infomask2 &amp; HEAP_KEYS_UPDATED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updated = !HEAP_XMAX_IS_LOCKED_ONLY(infomask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are updates, follow the update chain; bail out if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that cannot be done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (follow_updates &amp;&amp; updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_Result&nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L5770" title="access/heap/heapam.c:5770">heap_lock_updated_tuple</a>(relation, tuple, &amp;t_ctid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recovery code expects to have buffer lock held */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure it's still an appropriate lock, else start over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if it wasn't updated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we released the lock, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is updated <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we start over too; the reason is that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> need to follow the update chain to lock the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * versions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="heapam_visibility.c.html#L1520" title="access/heap/heapam_visibility.c:1520">HeapTupleHeaderIsOnlyLocked</a>(tuple-&gt;t_data) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((tuple-&gt;t_data-&gt;t_infomask2 &amp; HEAP_KEYS_UPDATED) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !updated))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Things look okay, so we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> sleeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_sleep = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we allow Xmax to change here; other updaters/lockers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could have modified it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we grabbed the buffer lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, this is not a problem, because with the recheck we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just did we ensure that they still don't conflict with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock we want.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mode == LockTupleShare)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're requesting Share, we can similarly avoid sleeping if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no update and no exclusive lock present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(infomask) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !HEAP_XMAX_IS_EXCL_LOCKED(infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure it's still an appropriate lock, else start over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See above about allowing xmax to change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_data-&gt;t_infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_EXCL_LOCKED(tuple-&gt;t_data-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_sleep = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (mode == LockTupleNoKeyExclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're requesting NoKeyExclusive, we might also be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid sleeping; just ensure that there no conflicting lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already acquired.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7106" title="access/heap/heapam.c:7106">DoesMultiXactIdConflict</a>((MultiXactId) xwait, infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mode, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No conflict, but if the xmax changed under us in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * meantime, start over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(tuple-&gt;t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(tuple-&gt;t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, we're good */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_sleep = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_KEYSHR_LOCKED(infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the xmax changed in the meantime, start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(tuple-&gt;t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(tuple-&gt;t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, we're good */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_sleep = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As a check independent from those above, we can also avoid sleeping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the current transaction is the sole locker of the tuple.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the strength of the lock already held is irrelevant; this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not about recording the lock in Xmax (which will be done regardless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of this optimization, below).&nbsp; Also, note that the cases where we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hold a lock stronger than we are requesting are already handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above by not doing anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we only deal with the non-multixact case here; <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is well equipped to deal with this situation on its own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (require_sleep &amp;&amp; !(infomask &amp; HEAP_XMAX_IS_MULTI) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... but if the xmax changed in the meantime, start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(tuple-&gt;t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(tuple-&gt;t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_data-&gt;t_infomask));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; require_sleep = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Time to sleep on the other transaction/multixact, if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the other transaction is an update/delete that's already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * committed, then sleeping cannot possibly do <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> good: if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required to sleep, get out to raise an error instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * By here, we either have already acquired the buffer exclusive lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or we must wait for the locking transaction or multixact; so below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we ensure that we grab buffer lock after the sleep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (require_sleep &amp;&amp; (result == TM_Updated || result == TM_Deleted))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (require_sleep)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Acquire tuple lock to establish our priority for the tuple, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> trying.&nbsp; <a href="../../storage/lmgr/lmgr.c.html#L568" title="storage/lmgr/lmgr.c:568">LockTuple</a> will release us when we are <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-in-line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the tuple.&nbsp; We must do this even if we are share-locking,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not if we already have a weaker lock on the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are forced to &quot;start over&quot; below, we keep the tuple lock;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this arranges that we stay at the head of the line while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rechecking tuple state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!skip_tuple_lock &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L5004" title="access/heap/heapam.c:5004">heap_acquire_tuplock</a>(relation, tid, mode, wait_policy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;have_tuple_lock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can only happen if wait_policy is Skip and the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * couldn't be obtained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_WouldBlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recovery code expects to have buffer lock held */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus status = <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a>(mode, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We only ever lock tuples, never update them */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status &gt;= MultiXactStatusNoKeyUpdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid lock mode in <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait for multixact to end, or <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> trying&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (wait_policy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitBlock:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a>((MultiXactId) xwait, status, infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relation, &amp;tuple-&gt;t_self, XLTW_Lock, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitSkip:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7305" title="access/heap/heapam.c:7305">ConditionalMultiXactIdWait</a>((MultiXactId) xwait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status, infomask, relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_WouldBlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recovery code expects to have buffer lock held */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitError:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L7305" title="access/heap/heapam.c:7305">ConditionalMultiXactIdWait</a>((MultiXactId) xwait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status, infomask, relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not obtain lock on row in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Of course, the multixact might not be done here: if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requesting a light lock mode, other transactions with light<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locks could still be alive, as well as locks owned by our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * own xact or other subxacts of this backend.&nbsp; We need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * preserve the surviving MultiXact members.&nbsp; Note that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't absolutely necessary in the latter case, but doing so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is simpler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait for regular transaction to end, or <a href="../../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> trying */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (wait_policy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitBlock:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(xwait, relation, &amp;tuple-&gt;t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLTW_Lock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitSkip:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lmgr.c.html#L740" title="storage/lmgr/lmgr.c:740">ConditionalXactLockTableWait</a>(xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_WouldBlock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recovery code expects to have buffer lock held */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitError:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lmgr.c.html#L740" title="storage/lmgr/lmgr.c:740">ConditionalXactLockTableWait</a>(xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not obtain lock on row in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if there are updates, follow the update chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (follow_updates &amp;&amp; !HEAP_XMAX_IS_LOCKED_ONLY(infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_Result&nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L5770" title="access/heap/heapam.c:5770">heap_lock_updated_tuple</a>(relation, tuple, &amp;t_ctid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = res;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* recovery code expects to have buffer lock held */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xwait is done, but if xwait had just locked the tuple then some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other xact could update this tuple <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get to this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for xmax change, and start over if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2656" title="access/heap/heapam.c:2656">xmax_infomask_changed</a>(tuple-&gt;t_data-&gt;t_infomask, infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetRawXmax(tuple-&gt;t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xwait))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(infomask &amp; HEAP_XMAX_IS_MULTI))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise check if it committed or aborted.&nbsp; Note we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be here if the tuple was only locked by somebody who didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflict with us; that would have been handled above.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that transaction must necessarily be gone by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't check for this in the multixact case, because some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locker transactions might still be running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1901" title="access/heap/heapam.c:1901">UpdateXmaxHintBits</a>(tuple-&gt;t_data, *buffer, xwait);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* By here, we're certain that we hold buffer exclusive lock again */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may lock if previous xmax aborted, or if it committed but only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locked the tuple without updating it; or if we didn't have to wait<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at all for whatever reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!require_sleep ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_data-&gt;t_infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L1520" title="access/heap/heapam_visibility.c:1520">HeapTupleHeaderIsOnlyLocked</a>(tuple-&gt;t_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tuple-&gt;t_self, &amp;tuple-&gt;t_data-&gt;t_ctid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Deleted;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">failed</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result == TM_SelfModified || result == TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result == TM_Deleted || result == TM_WouldBlock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When locking a tuple under LockWaitSkip semantics and we fail with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TM_WouldBlock above, it's possible for concurrent transactions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the lock and set HEAP_XMAX_INVALID in the meantime.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this assert is slightly different from the equivalent one in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a> and <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((result == TM_WouldBlock) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !(tuple-&gt;t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result != TM_Updated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tuple-&gt;t_self, &amp;tuple-&gt;t_data-&gt;t_ctid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;ctid = tuple-&gt;t_data-&gt;t_ctid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;xmax = HeapTupleHeaderGetUpdateXid(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == TM_SelfModified)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;cmax = <a href="../../utils/time/combocid.c.html#L118" title="utils/time/combocid.c:118">HeapTupleHeaderGetCmax</a>(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmfd-&gt;cmax = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't pin the visibility map page and the page has become all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visible while we were busy locking the buffer, or during some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subsequent window during which we had it unlocked, we'll have to unlock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and re-lock, to avoid holding the buffer lock across I/O.&nbsp; That's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unfortunate, especially since we'll <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have to recheck whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple has been locked or updated under us, but hopefully it won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen very often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer == InvalidBuffer &amp;&amp; PageIsAllVisible(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(relation, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l3;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xmax = HeapTupleHeaderGetRawXmax(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; old_infomask = tuple-&gt;t_data-&gt;t_infomask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first possibly-multixact-able operation in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, set my per-backend <a href="../transam/multixact.c.html#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a> setting. We can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certain that the transaction will never become a member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXactIds than that.&nbsp; (We have to do this even if we end up just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using our own TransactionId below, since some other backend could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incorporate our XID into a MultiXact immediately afterwards.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/multixact.c.html#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the new xmax and infomask to store into the tuple.&nbsp; Note we do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not modify the tuple just yet, because that would leave it in the wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state if multixact.c elogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5053" title="access/heap/heapam.c:5053">compute_new_xmax_infomask</a>(xmax, old_infomask, tuple-&gt;t_data-&gt;t_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>(), mode, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;xid, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store transaction information of xact locking the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: Cmax is meaningless in this context, so don't set it; this avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly generating a useless combo CID.&nbsp; Moreover, if we're locking a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previously updated tuple, it's important to preserve the Cmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also reset the HOT UPDATE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, but only if there's no update; otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we would break the HOT chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple-&gt;t_data-&gt;t_infomask &amp;= ~HEAP_XMAX_BITS;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data-&gt;t_infomask |= new_infomask;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_data-&gt;t_infomask2 |= new_infomask2;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(new_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderClearHotUpdated(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(tuple-&gt;t_data, xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure there is no forward chain link in t_ctid.&nbsp; Note that in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases where the tuple has been updated, we must not overwrite t_ctid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because it was set by the updater.&nbsp; Moreover, if the tuple has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated, we need to follow the update chain to lock the new versions of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tuple as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(new_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data-&gt;t_ctid = *tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear only the all-frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on visibility map if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(page) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(relation, block, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_FROZEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(*buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG stuff.&nbsp; You might think that we don't need an XLOG record because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there is no state change worth restoring after a crash.&nbsp; You would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong however: we have just written either a TransactionId or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MultiXactId that may never have been seen on disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, and we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to make sure that there are XLOG entries covering those ID numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Else the same IDs might be re-used after a crash, which would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disastrous if this page made it to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the crash.&nbsp; Essentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to enforce the WAL log-<a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>-data rule even in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Also, in a PITR log-shipping or 2PC environment, we have to have XLOG<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entries for everything anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_lock xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, *buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;tuple-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.xmax = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.infobits_set = <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>(new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_data-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = cleared_all_frozen ? XLH_LOCK_ALL_FROZEN_CLEARED : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we don't decode row locks atm, so no need to log the origin */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_LOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = TM_Ok;<br/></li>
<li><br/></li>
<li><span class="Statement">out_locked</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li><span class="Statement">out_unlocked</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't update the visibility map here. Locking a tuple doesn't change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visibility info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have successfully marked the tuple as locked, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release the lmgr tuple lock, if we had it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (have_tuple_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="access/heap/heapam.c:169">UnlockTupleTuplock</a>(relation, tid, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Acquire heavyweight lock on the given tuple, in preparation for acquiring<br/></li>
<li></span><span class="Comment"> * its normal, Xmax-based tuple lock.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * have_tuple_lock is an input and output parameter: on input, it indicates<br/></li>
<li></span><span class="Comment"> * whether the lock has previously been acquired (and this function does<br/></li>
<li></span><span class="Comment"> * nothing in that case).&nbsp; If this function returns success, have_tuple_lock<br/></li>
<li></span><span class="Comment"> * has been flipped to true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if it was unable to obtain the lock; this can only happen if<br/></li>
<li></span><span class="Comment"> * wait_policy is Skip.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5004">&#x200c;</a></span><span class="linkable">heap_acquire_tuplock</span>(Relation relation, ItemPointer tid, LockTupleMode mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockWaitPolicy wait_policy, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *have_tuple_lock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*have_tuple_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (wait_policy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitBlock:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="access/heap/heapam.c:167">LockTupleTuplock</a>(relation, tid, mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitSkip:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L171" title="access/heap/heapam.c:171">ConditionalLockTupleTuplock</a>(relation, tid, mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockWaitError:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L171" title="access/heap/heapam.c:171">ConditionalLockTupleTuplock</a>(relation, tid, mode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not obtain lock on row in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *have_tuple_lock = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an original set of Xmax and infomask, and a transaction (identified by<br/></li>
<li></span><span class="Comment"> * add_to_xmax) acquiring a new lock of some mode, compute the new Xmax and<br/></li>
<li></span><span class="Comment"> * corresponding infomasks to use on the tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this might have side effects such as creating a new MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Most callers will have called <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this function;<br/></li>
<li></span><span class="Comment"> * that will have set the HEAP_XMAX_INVALID <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> if the xmax was a MultiXactId<br/></li>
<li></span><span class="Comment"> * but it was not running anymore. There is a race condition, which is that the<br/></li>
<li></span><span class="Comment"> * MultiXactId may have finished since then, but that uncommon case is handled<br/></li>
<li></span><span class="Comment"> * either here, or within <a href="../transam/multixact.c.html#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is a similar race condition possible when the old xmax was a regular<br/></li>
<li></span><span class="Comment"> * TransactionId.&nbsp; We test <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> again just to narrow the<br/></li>
<li></span><span class="Comment"> * window, but it's still possible to end up creating an unnecessary<br/></li>
<li></span><span class="Comment"> * MultiXactId.&nbsp; Fortunately this is harmless.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5053">&#x200c;</a></span><span class="linkable">compute_new_xmax_infomask</span>(TransactionId xmax, uint16 old_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 old_infomask2, TransactionId add_to_xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode mode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_update,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *result_xmax, uint16 *result_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 *result_infomask2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId new_xmax;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(add_to_xmax));<br/></li>
<li><br/></li>
<li><span class="Statement">l5</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; new_infomask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; new_infomask2 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (old_infomask &amp; HEAP_XMAX_INVALID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No previous locker; we just insert our own TransactionId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that it's critical that this case be the first one checked,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because there are several blocks below that come back to this one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to implement certain optimizations; old_infomask might contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other dirty bits in those cases, but we don't really care.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax = add_to_xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == LockTupleExclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask2 |= HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask |= HEAP_XMAX_LOCK_ONLY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleKeyShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax = add_to_xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask |= HEAP_XMAX_KEYSHR_LOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax = add_to_xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask |= HEAP_XMAX_SHR_LOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleNoKeyExclusive:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax = add_to_xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask |= HEAP_XMAX_EXCL_LOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LockTupleExclusive:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax = add_to_xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask |= HEAP_XMAX_EXCL_LOCK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask2 |= HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax = InvalidTransactionId;&nbsp; &nbsp; <span class="Comment">/* silence compiler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid lock mode&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (old_infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus new_status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently we don't allow XMAX_COMMITTED to be set for multis, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross-check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(old_infomask &amp; HEAP_XMAX_COMMITTED));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A multixact together with LOCK_ONLY set but neither lock <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (i.e. a pg_upgraded share locked tuple) cannot possibly be running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore.&nbsp; This check is critical for databases upgraded by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_upgrade; both <a href="../transam/multixact.c.html#L557" title="access/transam/multixact.c:557">MultiXactIdIsRunning</a> and <a href="../transam/multixact.c.html#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a> assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that such multis are never passed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_LOCKED_UPGRADED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask &amp;= ~HEAP_XMAX_IS_MULTI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l5;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the XMAX is already a MultiXactId, then we need to expand it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * include add_to_xmax; but if all the members were lockers and are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all gone, we can do away with the <a href="../../utils/adt/formatting.c.html#L334" title="utils/adt/formatting.c:334">IS_MULTI</a> <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> and just set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add_to_xmax as the only locker/updater.&nbsp; If all lockers are gone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we have an updater that aborted, we can also do without a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multi.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The cost of doing <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a> would be paid by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../transam/multixact.c.html#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a> if we weren't to do this, so this check is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incurring extra work anyhow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../transam/multixact.c.html#L557" title="access/transam/multixact.c:557">MultiXactIdIsRunning</a>(xmax, HEAP_XMAX_IS_LOCKED_ONLY(old_infomask)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(old_infomask) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(<a href="#L7038" title="access/heap/heapam.c:7038">MultiXactIdGetUpdateXid</a>(xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset these bits and restart; otherwise fall through to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create a new multi below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask &amp;= ~HEAP_XMAX_IS_MULTI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l5;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_status = <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a>(mode, is_update);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_xmax = <a href="../transam/multixact.c.html#L445" title="access/transam/multixact.c:445">MultiXactIdExpand</a>((MultiXactId) xmax, add_to_xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; new_status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(new_xmax, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (old_infomask &amp; HEAP_XMAX_COMMITTED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a committed update, so we need to preserve him as updater of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus new_status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusNoKeyUpdate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_status = <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a>(mode, is_update);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it's not running, it's obviously impossible for the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updater to be identical to the current one, so we need not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for that case as we do in the block above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_xmax = <a href="../transam/multixact.c.html#L392" title="access/transam/multixact.c:392">MultiXactIdCreate</a>(xmax, status, add_to_xmax, new_status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(new_xmax, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xmax))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the XMAX is a valid, in-progress TransactionId, then we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create a new MultiXactId that includes both the old locker or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updater and our own TransactionId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus new_status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus old_status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode old_mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_KEYSHR_LOCKED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = MultiXactStatusForKeyShare;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_SHR_LOCKED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = MultiXactStatusForShare;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_EXCL_LOCKED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = MultiXactStatusForUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = MultiXactStatusForNoKeyUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LOCK_ONLY can be present alone only when a page has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * upgraded by pg_upgrade.&nbsp; But in that case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>() should have returned false.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume it's no longer locked in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;LOCK_ONLY found for Xid in progress </span><span class="Special">%u</span><span class="Constant">&quot;</span>, xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask &amp;= ~HEAP_XMAX_LOCK_ONLY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l5;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's an update, but which kind? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = MultiXactStatusUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_status = MultiXactStatusNoKeyUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_mode = <a href="#L218" title="access/heap/heapam.c:218">TUPLOCK_from_mxstatus</a>(old_status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the lock to be acquired is for the same TransactionId as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing lock, there's an optimization possible: consider only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strongest of both locks as the only one present, and restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmax == add_to_xmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that it's not possible for the original tuple to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updated: we wouldn't be here because the tuple would have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * invisible and we wouldn't try to update it.&nbsp; As a subtlety,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this code can also run when traversing an update chain to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * future versions of a tuple.&nbsp; But we wouldn't be here either,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the add_to_xmax would be different from the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updater.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(HEAP_XMAX_IS_LOCKED_ONLY(old_infomask));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* acquire the strongest of both */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode &lt; old_mode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode = old_mode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mustn't touch is_update */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l5;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, just fall back to creating a new multixact */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_status = <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a>(mode, is_update);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_xmax = <a href="../transam/multixact.c.html#L392" title="access/transam/multixact.c:392">MultiXactIdCreate</a>(xmax, old_status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; add_to_xmax, new_status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(new_xmax, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!HEAP_XMAX_IS_LOCKED_ONLY(old_infomask) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xmax))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's a committed update, so we gotta preserve him as updater of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus status;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus new_status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusNoKeyUpdate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_status = <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a>(mode, is_update);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since it's not running, it's obviously impossible for the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updater to be identical to the current one, so we need not check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for that case as we do in the block above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_xmax = <a href="../transam/multixact.c.html#L392" title="access/transam/multixact.c:392">MultiXactIdCreate</a>(xmax, status, add_to_xmax, new_status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(new_xmax, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can get here iff the locking/updating transaction was running when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the infomask was extracted from the tuple, but finished <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> got to run.&nbsp; Deal with it as if there was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no locker at all in the first place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; old_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l5;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *result_infomask = new_infomask;<br/></li>
<li>&nbsp; &nbsp; *result_infomask2 = new_infomask2;<br/></li>
<li>&nbsp; &nbsp; *result_xmax = new_xmax;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L5425" title="access/heap/heapam.c:5425">heap_lock_updated_tuple_rec</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a hypothetical multixact status held by the transaction identified<br/></li>
<li></span><span class="Comment"> * with the given xid, does the current transaction need to wait, fail, or can<br/></li>
<li></span><span class="Comment"> * it continue if it wanted to acquire a lock of the given mode?&nbsp; &quot;needwait&quot;<br/></li>
<li></span><span class="Comment"> * is set to true if <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> is necessary; if it can continue, then TM_Ok is<br/></li>
<li></span><span class="Comment"> * returned.&nbsp; If the lock is already held by the current transaction, return<br/></li>
<li></span><span class="Comment"> * TM_SelfModified.&nbsp; In case of a conflict with another transaction, a<br/></li>
<li></span><span class="Comment"> * different <a href="heapam_visibility.c.html#L458" title="access/heap/heapam_visibility.c:458">HeapTupleSatisfiesUpdate</a> return code is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The held status is said to be hypothetical because it might correspond to a<br/></li>
<li></span><span class="Comment"> * lock held by a single Xid, i.e. not a real MultiXactId; we express it this<br/></li>
<li></span><span class="Comment"> * way for simplicity of API.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TM_Result<br/></li>
<li><a id="L5334">&#x200c;</a><span class="linkable">test_lockmode_for_conflict</span>(MultiXactStatus status, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockTupleMode mode, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *needwait)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MultiXactStatus wantedstatus;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *needwait = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; wantedstatus = <a href="#L4258" title="access/heap/heapam.c:4258">get_mxact_status_for_lock</a>(mode, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we *must* check <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>/Commit; see comment at top of heapam_visibility.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for an explanation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple has already been locked by our own transaction.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very rare but can happen if multiple transactions are trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock an ancient version of the same tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_SelfModified;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the locking transaction is running, what we do depends on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the lock modes conflict: if they do, then we must wait for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it to finish; otherwise we can fall through to lock this tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * version without <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lock.c.html#L570" title="storage/lmgr/lock.c:570">DoLockModesConflict</a>(<a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(status),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(wantedstatus)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *needwait = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we set needwait above, then this value doesn't matter;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise, this value signals to caller that it's okay to proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The other transaction committed.&nbsp; If it was only a locker, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock is completely gone <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and we can return success; but if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was an update, then what we do depends on whether the two lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modes conflict.&nbsp; If they conflict, then we must report error to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller. But if they don't, we can fall through to allow the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction to lock the tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the reason we worry about ISUPDATE here is because as soon as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a transaction ends, all its locks are gone and meaningless, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * thus we can ignore them; whereas its updates persist.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> case, above, we don't need to check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we know the lock is still &quot;alive&quot; and thus a conflict needs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always be checked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ISUPDATE_from_mxstatus(status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/lmgr/lock.c.html#L570" title="storage/lmgr/lock.c:570">DoLockModesConflict</a>(<a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(status),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(wantedstatus)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bummer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tup-&gt;t_self, &amp;tup-&gt;t_data-&gt;t_ctid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_Updated;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_Deleted;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Not in progress, not aborted, not committed -- must have crashed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Recursive part of <a href="#L5770" title="access/heap/heapam.c:5770">heap_lock_updated_tuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fetch the tuple pointed to by tid in rel, and mark it as locked by the given<br/></li>
<li></span><span class="Comment"> * xid with the given mode; if this tuple is updated, recurse to lock the new<br/></li>
<li></span><span class="Comment"> * version as well.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TM_Result<br/></li>
<li><a id="L5425">&#x200c;</a><span class="linkable">heap_lock_updated_tuple_rec</span>(Relation rel, ItemPointer tid, TransactionId xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_Result&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData tupid;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData mytup;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_infomask2;<br/></li>
<li>&nbsp; &nbsp; TransactionId xmax,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_xmax;<br/></li>
<li>&nbsp; &nbsp; TransactionId priorXmax = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; pinned_desired_page;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerCopy(tid, &amp;tupid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_infomask = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_xmax = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; block = ItemPointerGetBlockNumber(&amp;tupid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(&amp;tupid, &amp;(mytup.t_self));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1507" title="access/heap/heapam.c:1507">heap_fetch</a>(rel, SnapshotAny, &amp;mytup, &amp;buf, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the updated version of the tuple, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it was vacuumed/pruned away after its creator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction aborted.&nbsp; So behave as if we got to the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chain, and there's no further tuple to lock: return success to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_unlocked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">l4</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before locking the buffer, pin the visibility map page if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appears to be necessary.&nbsp; Since we haven't got the lock yet,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * someone else might be in the middle of changing this, so we'll need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to recheck after we have the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(rel, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pinned_desired_page = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pinned_desired_page = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't pin the visibility map page and the page has become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all visible while we were busy locking the buffer, we'll have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlock and re-lock, to avoid holding the buffer lock across I/O.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> unfortunate, but hopefully shouldn't happen often.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: in some paths through this function, we will reach here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * holding a pin on a vm page that may or may not be the one matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this page.&nbsp; If this page isn't all-visible, we won't use the vm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page, but we hold onto such a pin till the end of the function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pinned_desired_page &amp;&amp; PageIsAllVisible(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(rel, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the tuple XMIN against prior XMAX, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; If we reached the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end of the chain, we're done, so return success.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(priorXmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetXmin(mytup.t_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; priorXmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also check Xmin: if this tuple was created by an aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (sub)transaction, then we already locked the last live one in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chain, thus we're done, so return success.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(HeapTupleHeaderGetXmin(mytup.t_data)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_infomask = mytup.t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; old_infomask2 = mytup.t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmax = HeapTupleHeaderGetRawXmax(mytup.t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this tuple version has been updated or locked by some concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction(s), what we do depends on whether our lock mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflicts with what those other transactions hold, and also on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * status of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(old_infomask &amp; HEAP_XMAX_INVALID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId rawxmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needwait;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rawxmax = HeapTupleHeaderGetRawXmax(mytup.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need a test for pg_upgrade'd tuples: this is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applied to tuples after the first in an update chain.&nbsp; Said<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first tuple in the chain may well be locked-in-9.2-and-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_upgraded, but that one was already locked by our caller,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not us; and <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequent ones cannot be because our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller must necessarily have obtained a snapshot later than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pg_upgrade itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!HEAP_LOCKED_UPGRADED(mytup.t_data-&gt;t_infomask));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers = <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(rawxmax, &amp;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_IS_LOCKED_ONLY(old_infomask));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L5334" title="access/heap/heapam.c:5334">test_lockmode_for_conflict</a>(members[i].status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; members[i].xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mytup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;needwait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple was already locked by ourselves in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous iteration of this (say <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a> was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forced to restart the locking loop because of a change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in xmax), then we hold the lock already on this tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * version and we don't need to do anything; and this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not an error condition either.&nbsp; We just need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this tuple and continue locking the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> version in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == TM_SelfModified)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(members[i].xid, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mytup.t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLTW_LockUpdated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l4;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (members)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a non-multi Xmax, we first need to compute the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * corresponding MultiXactStatus by using the infomask bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_KEYSHR_LOCKED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusForKeyShare;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_SHR_LOCKED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusForShare;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_XMAX_IS_EXCL_LOCKED(old_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusForUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusForNoKeyUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LOCK_ONLY present alone (a pg_upgraded tuple marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as share-locked in the old <a href="../../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>) shouldn't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seen in the middle of an update chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid lock status in tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's an update, but which kind? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_infomask2 &amp; HEAP_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = MultiXactStatusNoKeyUpdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L5334" title="access/heap/heapam.c:5334">test_lockmode_for_conflict</a>(status, rawxmax, mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;mytup, &amp;needwait);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple was already locked by ourselves in a previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iteration of this (say <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a> was forced to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart the locking loop because of a change in xmax), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we hold the lock already on this tuple version and we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to do anything; and this is not an error condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either.&nbsp; We just need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this tuple and continue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locking the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> version in the update chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == TM_SelfModified)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needwait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(rawxmax, rel, &amp;mytup.t_self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLTW_LockUpdated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> l4;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != TM_Ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute the new Xmax and infomask <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the tuple ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5053" title="access/heap/heapam.c:5053">compute_new_xmax_infomask</a>(xmax, old_infomask, mytup.t_data-&gt;t_infomask2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid, mode, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;new_xmax, &amp;new_infomask, &amp;new_infomask2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsAllVisible(BufferGetPage(buf)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(rel, block, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; VISIBILITYMAP_ALL_FROZEN))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and set them */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(mytup.t_data, new_xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mytup.t_data-&gt;t_infomask &amp;= ~HEAP_XMAX_BITS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mytup.t_data-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mytup.t_data-&gt;t_infomask |= new_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mytup.t_data-&gt;t_infomask2 |= new_infomask2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_heap_lock_updated xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;mytup.t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.xmax = new_xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.infobits_set = <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>(new_infomask, new_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cleared_all_frozen ? XLH_LOCK_ALL_FROZEN_CLEARED : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapLockUpdated);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP2_ID, XLOG_HEAP2_LOCK_UPDATED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li><span class="Statement"><a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a></span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the end of update chain, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mytup.t_data-&gt;t_infomask &amp; HEAP_XMAX_INVALID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderIndicatesMovedPartitions(mytup.t_data) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;mytup.t_self, &amp;mytup.t_data-&gt;t_ctid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam_visibility.c.html#L1520" title="access/heap/heapam_visibility.c:1520">HeapTupleHeaderIsOnlyLocked</a>(mytup.t_data))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = TM_Ok;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> out_locked;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tail recursion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; priorXmax = HeapTupleHeaderGetUpdateXid(mytup.t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(&amp;(mytup.t_data-&gt;t_ctid), &amp;tupid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = TM_Ok;<br/></li>
<li><br/></li>
<li><span class="Statement">out_locked</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li><span class="Statement">out_unlocked</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vmbuffer != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L5770" title="access/heap/heapam.c:5770">heap_lock_updated_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Follow update chain when locking an updated tuple, acquiring locks (row<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; marks) on the updated versions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The initial tuple is assumed to be already locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function doesn't check visibility, it just unconditionally marks the<br/></li>
<li></span><span class="Comment"> * tuple(s) as locked.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple in the updated chain is being deleted<br/></li>
<li></span><span class="Comment"> * concurrently (or updated with the key being modified), sleep until the<br/></li>
<li></span><span class="Comment"> * transaction doing it is finished.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we don't acquire heavyweight tuple locks on the tuples we walk<br/></li>
<li></span><span class="Comment"> * when we have to wait for other transactions to release them, as opposed to<br/></li>
<li></span><span class="Comment"> * what <a href="#L4306" title="access/heap/heapam.c:4306">heap_lock_tuple</a> does.&nbsp; The reason is that having more than one<br/></li>
<li></span><span class="Comment"> * transaction walking the chain is probably uncommon enough that risk of<br/></li>
<li></span><span class="Comment"> * starvation is not likely: one of the preconditions for being here is that<br/></li>
<li></span><span class="Comment"> * the snapshot in use predates the update that created this tuple (because we<br/></li>
<li></span><span class="Comment"> * started at an earlier version of the tuple), but at the same time such a<br/></li>
<li></span><span class="Comment"> * transaction cannot be using repeatable read or serializable isolation<br/></li>
<li></span><span class="Comment"> * levels, because that would lead to a serializability failure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TM_Result<br/></li>
<li><a id="L5770">&#x200c;</a><span class="linkable">heap_lock_updated_tuple</span>(Relation rel, HeapTuple tuple, ItemPointer ctid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid, LockTupleMode mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple has not been updated, or has moved into another partition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (effectively a delete) stop here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderIndicatesMovedPartitions(tuple-&gt;t_data) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;tuple-&gt;t_self, ctid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first possibly-multixact-able operation in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current transaction, set my per-backend <a href="../transam/multixact.c.html#L299" title="access/transam/multixact.c:299">OldestMemberMXactId</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * setting. We can be certain that the transaction will never become a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * member of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> older MultiXactIds than that.&nbsp; (We have to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if we end up just using our own TransactionId below, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some other backend could incorporate our XID into a MultiXact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately afterwards.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/multixact.c.html#L631" title="access/transam/multixact.c:631">MultiXactIdSetOldestMember</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L5425" title="access/heap/heapam.c:5425">heap_lock_updated_tuple_rec</a>(rel, ctid, xid, mode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing to lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> TM_Ok;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L5815" title="access/heap/heapam.c:5815">heap_finish_speculative</a> - mark speculative insertion as successful<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To successfully finish a speculative insertion we have to clear speculative<br/></li>
<li></span><span class="Comment"> * token from tuple.&nbsp; To do so the t_ctid field, which will contain a<br/></li>
<li></span><span class="Comment"> * speculative token value, is modified in place to point to the tuple itself,<br/></li>
<li></span><span class="Comment"> * which is characteristic of a newly inserted ordinary tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: It is not ok to commit without either finishing or aborting a<br/></li>
<li></span><span class="Comment"> * speculative insertion.&nbsp; We could treat speculative tuples of committed<br/></li>
<li></span><span class="Comment"> * transactions implicitly as completed, but then we would have to be prepared<br/></li>
<li></span><span class="Comment"> * to deal with speculative tokens on committed tuples.&nbsp; That wouldn't be<br/></li>
<li></span><span class="Comment"> * difficult - no-one looks at the ctid field of a tuple with invalid xmax -<br/></li>
<li></span><span class="Comment"> * but clearing the token at completion isn't very expensive either.<br/></li>
<li></span><span class="Comment"> * An explicit confirmation WAL record also makes logical decoding simpler.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5815">&#x200c;</a></span><span class="linkable">heap_finish_speculative</span>(Relation relation, ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, ItemPointerGetBlockNumber(tid));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(tid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(HeapTupleHeaderIsSpeculative(htup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Replace the speculative insertion token with a real t_ctid, pointing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself like it does on regular tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; htup-&gt;t_ctid = *tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_confirm xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We want the same filtering on this as on a plain insert */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapConfirm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_CONFIRM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L5902" title="access/heap/heapam.c:5902">heap_abort_speculative</a> - kill a speculatively inserted tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Marks a tuple that was speculatively inserted in the same command as dead,<br/></li>
<li></span><span class="Comment"> * by setting its xmin as invalid.&nbsp; That makes it immediately appear as dead<br/></li>
<li></span><span class="Comment"> * to all transactions, including our own.&nbsp; In particular, it makes<br/></li>
<li></span><span class="Comment"> * <a href="heapam_visibility.c.html#L743" title="access/heap/heapam_visibility.c:743">HeapTupleSatisfiesDirty</a>() regard the tuple as dead, so that another backend<br/></li>
<li></span><span class="Comment"> * inserting a duplicate key value won't unnecessarily wait for our whole<br/></li>
<li></span><span class="Comment"> * transaction to finish (it'll just wait for our speculative insertion to<br/></li>
<li></span><span class="Comment"> * finish).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Killing the tuple prevents &quot;unprincipled deadlocks&quot;, which are deadlocks<br/></li>
<li></span><span class="Comment"> * that arise due to a mutual dependency that is not user visible.&nbsp; By<br/></li>
<li></span><span class="Comment"> * definition, unprincipled deadlocks cannot be prevented by the user<br/></li>
<li></span><span class="Comment"> * reordering lock acquisition in client code, because the implementation level<br/></li>
<li></span><span class="Comment"> * lock acquisitions are not under the user's direct control.&nbsp; If speculative<br/></li>
<li></span><span class="Comment"> * inserters did not take this precaution, then under high concurrency they<br/></li>
<li></span><span class="Comment"> * could deadlock with each other, which would not be acceptable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is somewhat redundant with <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a>, but we prefer to have a<br/></li>
<li></span><span class="Comment"> * dedicated routine with stripped down requirements.&nbsp; Note that this is also<br/></li>
<li></span><span class="Comment"> * used to delete the TOAST tuples created during speculative insertion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine does not affect logical decoding as it only looks at<br/></li>
<li></span><span class="Comment"> * confirmation <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5902">&#x200c;</a></span><span class="linkable">heap_abort_speculative</span>(Relation relation, ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid = <a href="../transam/xact.c.html#L451" title="access/transam/xact.c:451">GetCurrentTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tp;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; TransactionId prune_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ItemPointerIsValid(tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; block = ItemPointerGetBlockNumber(tid);<br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, block);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Page can't be all visible, we just inserted into it, and are still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!PageIsAllVisible(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lp = PageGetItemId(page, ItemPointerGetOffsetNumber(tid));<br/></li>
<li>&nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tp.t_tableOid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; tp.t_data = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; tp.t_len = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; tp.t_self = *tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity check that the tuple really is a speculatively inserted tuple,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserted by us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tp.t_data-&gt;t_choice.t_heap.t_xmin != xid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attempted to kill a tuple inserted by another transaction&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(<a href="../../catalog/catalog.c.html#L145" title="catalog/catalog.c:145">IsToastRelation</a>(relation) || HeapTupleHeaderIsSpeculative(tp.t_data)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;attempted to kill a non-speculative tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!HeapTupleHeaderIsHeapOnly(tp.t_data));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need to check for serializable conflicts here.&nbsp; There is never a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need for a combo CID, either.&nbsp; No need to extract replica identity, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do anything special with infomask bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The tuple will become DEAD immediately.&nbsp; Flag that this page is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * candidate for pruning by setting xmin to <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>. While not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately prunable, it is the oldest xid we can cheaply determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's safe against wraparound / being older than the table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relfrozenxid.&nbsp; To defend against the unlikely case of a new relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having a newer relfrozenxid than our <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, use relfrozenxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if so (<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> can't subsequently move relfrozenxid to beyond<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, so there's no race here).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsValid(<a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(<a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, relation-&gt;rd_rel-&gt;relfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prune_xid = relation-&gt;rd_rel-&gt;relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prune_xid = <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>;<br/></li>
<li>&nbsp; &nbsp; PageSetPrunable(page, prune_xid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* store transaction information of xact deleting the tuple */<br/></li>
<li></span>&nbsp; &nbsp; tp.t_data-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; tp.t_data-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the tuple header xmin to InvalidTransactionId.&nbsp; This makes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple immediately invisible everyone.&nbsp; (In particular, to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on the speculative token, woken up later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HeapTupleHeaderSetXmin(tp.t_data, InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear the speculative insertion token too */<br/></li>
<li></span>&nbsp; &nbsp; tp.t_data-&gt;t_ctid = tp.t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG stuff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The WAL <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> generated here match <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a>().&nbsp; The same recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * routines are used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_delete xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = XLH_DELETE_IS_SUPER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.infobits_set = <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>(tp.t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp.t_data-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;tp.t_self);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.xmax = xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapDelete);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No replica identity &amp; replication origin logged */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(&amp;tp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../../catalog/catalog.c.html#L145" title="catalog/catalog.c:145">IsToastRelation</a>(relation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="heaptoast.c.html#L43" title="access/heap/heaptoast.c:43">heap_toast_delete</a>(relation, &amp;tp, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Never need to mark tuple for invalidation, since catalogs don't support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * speculative insertion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can release the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* count deletion, as we counted the insertion too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L401" title="utils/activity/pgstat_relation.c:401">pgstat_count_heap_delete</a>(relation);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6055" title="access/heap/heapam.c:6055">heap_inplace_update</a> - update a tuple &quot;in place&quot; (ie, overwrite it)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Overwriting violates both MVCC and transactional safety, so the uses<br/></li>
<li></span><span class="Comment"> * of this function in Postgres are extremely limited.&nbsp; Nonetheless we<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> some places to use it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The tuple cannot change size, and therefore it's reasonable to assume<br/></li>
<li></span><span class="Comment"> * that its null bitmap (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) doesn't change either.&nbsp; So we just<br/></li>
<li></span><span class="Comment"> * overwrite the data portion of the tuple without touching the null<br/></li>
<li></span><span class="Comment"> * bitmap or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the header fields.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * tuple is an in-memory tuple structure containing the data to be written<br/></li>
<li></span><span class="Comment"> * over the target tuple.&nbsp; Also, tuple-&gt;t_self identifies the target tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the tuple updated here had better not come directly from the<br/></li>
<li></span><span class="Comment"> * syscache if the relation has a toast relation as this tuple could<br/></li>
<li></span><span class="Comment"> * include toast <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that have been expanded, causing a failure here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6055">&#x200c;</a></span><span class="linkable">heap_inplace_update</span>(Relation relation, HeapTuple tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldlen;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't allow parallel updates.&nbsp; Unlike a regular update,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this should never create a combo CID, so it might be possible to relax<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this restriction, but not without more thought and testing.&nbsp; It's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clear that it would be useful, anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TRANSACTION_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot update tuples during a parallel operation&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(relation, ItemPointerGetBlockNumber(&amp;(tuple-&gt;t_self)));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(&amp;(tuple-&gt;t_self));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldlen = ItemIdGetLength(lp) - htup-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; newlen = tuple-&gt;t_len - tuple-&gt;t_data-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldlen != newlen || htup-&gt;t_hoff != tuple-&gt;t_data-&gt;t_hoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong tuple length&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) htup + htup-&gt;t_hoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) tuple-&gt;t_data + tuple-&gt;t_data-&gt;t_hoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_heap_inplace xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.offnum = ItemPointerGetOffsetNumber(&amp;tuple-&gt;t_self);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapInplace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) htup + htup-&gt;t_hoff, newlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* inplace updates aren't decoded atm, don't log the origin */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, XLOG_HEAP_INPLACE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send out shared cache inval if necessary.&nbsp; Note that because we only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass the new version of the tuple, this mustn't be used for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operations that could change catcache lookup keys.&nbsp; But we aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bothering with index updates either, so that's true a fortiori.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1204" title="utils/cache/inval.c:1204">CacheInvalidateHeapTuple</a>(relation, tuple, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L6138">&#x200c;</a><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FRM_NOOP</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0001<br/></li>
<li><a id="L6139">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FRM_INVALIDATE_XMAX</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0002<br/></li>
<li><a id="L6140">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FRM_RETURN_IS_XID</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0004<br/></li>
<li><a id="L6141">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FRM_RETURN_IS_MULTI</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0008<br/></li>
<li><a id="L6142">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FRM_MARK_COMMITTED</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0010<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine what to do during freezing when a tuple is marked by a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;flags&quot; is an output value; it's used to tell caller what to do on return.<br/></li>
<li></span><span class="Comment"> * &quot;pagefrz&quot; is an input/output value, used to manage page level freezing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Possible <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that we can set in &quot;flags&quot;:<br/></li>
<li></span><span class="Comment"> * <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; don't do anything -- keep existing Xmax<br/></li>
<li></span><span class="Comment"> * <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; mark Xmax as InvalidTransactionId and set XMAX_INVALID flag.<br/></li>
<li></span><span class="Comment"> * <a href="#L6140" title="access/heap/heapam.c:6140">FRM_RETURN_IS_XID</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The Xid return value is a single update Xid to set as xmax.<br/></li>
<li></span><span class="Comment"> * <a href="#L6142" title="access/heap/heapam.c:6142">FRM_MARK_COMMITTED</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Xmax can be marked as HEAP_XMAX_COMMITTED<br/></li>
<li></span><span class="Comment"> * <a href="#L6141" title="access/heap/heapam.c:6141">FRM_RETURN_IS_MULTI</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The return value is a new MultiXactId to set as new Xmax.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (caller must obtain proper infomask bits using <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller delegates control of page freezing to us.&nbsp; In practice we always<br/></li>
<li></span><span class="Comment"> * force freezing of caller's page unless <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a> processing is indicated.<br/></li>
<li></span><span class="Comment"> * We <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> caller ensure that XIDs &lt; FreezeLimit and MXIDs &lt; MultiXactCutoff<br/></li>
<li></span><span class="Comment"> * can never be left behind.&nbsp; We freely choose when and how to process each<br/></li>
<li></span><span class="Comment"> * Multi, without ever violating the cutoff postconditions for freezing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's useful to remove Multis on a proactive timeline (relative to freezing<br/></li>
<li></span><span class="Comment"> * XIDs) to keep MultiXact member SLRU buffer misses to a minimum.&nbsp; It can also<br/></li>
<li></span><span class="Comment"> * be cheaper in the short run, for us, since we too can avoid SLRU buffer<br/></li>
<li></span><span class="Comment"> * misses through eager processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Creates a _new_ MultiXactId when <a href="#L6141" title="access/heap/heapam.c:6141">FRM_RETURN_IS_MULTI</a> is set, though only<br/></li>
<li></span><span class="Comment"> * when FreezeLimit and/or MultiXactCutoff cutoffs leave us with no choice.<br/></li>
<li></span><span class="Comment"> * This can usually be put off, which is usually enough to avoid it altogether.<br/></li>
<li></span><span class="Comment"> * Allocating new multis during VACUUM should be avoided on general principle;<br/></li>
<li></span><span class="Comment"> * only VACUUM can advance relminmxid, so allocating new Multis here comes with<br/></li>
<li></span><span class="Comment"> * its own special risks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Caller must maintain &quot;no freeze&quot; NewRelfrozenXid/NewRelminMxid trackers<br/></li>
<li></span><span class="Comment"> * using <a href="#L7374" title="access/heap/heapam.c:7374">heap_tuple_should_freeze</a> when we haven't forced page-level freezing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Caller should avoid needlessly calling <a href="#L7374" title="access/heap/heapam.c:7374">heap_tuple_should_freeze</a> when we<br/></li>
<li></span><span class="Comment"> * have already forced page-level freezing, since that might incur the same<br/></li>
<li></span><span class="Comment"> * SLRU buffer misses that we specifically intended to avoid by freezing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TransactionId<br/></li>
<li><a id="L6191">&#x200c;</a><span class="linkable">FreezeMultiXactId</span>(MultiXactId multi, uint16 t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> VacuumCutoffs *cutoffs, uint16 *flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapPageFreeze *pagefrz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId newxmax;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_replace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnewmembers;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *newmembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_lockers;<br/></li>
<li>&nbsp; &nbsp; TransactionId update_xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; update_committed;<br/></li>
<li>&nbsp; &nbsp; TransactionId FreezePageRelfrozenXid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should only be called in Multis */<br/></li>
<li></span>&nbsp; &nbsp; Assert(t_infomask &amp; HEAP_XMAX_IS_MULTI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!MultiXactIdIsValid(multi) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HEAP_LOCKED_UPGRADED(t_infomask))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, cutoffs-&gt;relminmxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;found multixact </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> relminmxid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi, cutoffs-&gt;relminmxid)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, cutoffs-&gt;OldestMxact))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId update_xact;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This old multi cannot possibly have members still running, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * verify just in case.&nbsp; If it was a locker only, it can be removed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further consideration; but if it contained an update,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we might need to preserve it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L557" title="access/transam/multixact.c:557">MultiXactIdIsRunning</a>(multi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_IS_LOCKED_ONLY(t_infomask)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;multixact </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> multi freeze cutoff </span><span class="Special">%u</span><span class="Constant"> found to be still running&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi, cutoffs-&gt;OldestMxact)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(t_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* replace multi with single XID for its updater? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; update_xact = <a href="#L7038" title="access/heap/heapam.c:7038">MultiXactIdGetUpdateXid</a>(multi, t_infomask);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(update_xact, cutoffs-&gt;relfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;multixact </span><span class="Special">%u</span><span class="Constant"> contains update XID </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> relfrozenxid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi, update_xact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cutoffs-&gt;relfrozenxid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(update_xact, cutoffs-&gt;OldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Updater XID has to have aborted (otherwise the tuple would have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been pruned away instead, since updater XID is &lt; OldestXmin).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Just remove xmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(update_xact))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;multixact </span><span class="Special">%u</span><span class="Constant"> contains committed update XID </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> removable cutoff </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi, update_xact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cutoffs-&gt;OldestXmin)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have to keep updater XID as new xmax */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6140" title="access/heap/heapam.c:6140">FRM_RETURN_IS_XID</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> update_xact;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some member(s) of this Multi may be below FreezeLimit xid cutoff, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to walk the whole members array to figure out what to do, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nmembers =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_LOCKED_ONLY(t_infomask));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing worth keeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a> case is the only case where we might need to ratchet back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FreezePageRelfrozenXid or FreezePageRelminMxid.&nbsp; It is also the only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case where our caller might ratchet back its NoFreezePageRelfrozenXid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or NoFreezePageRelminMxid &quot;no freeze&quot; trackers to deal with a multi.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a> handling should result in the NewRelfrozenXid/NewRelminMxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trackers managed by VACUUM being ratcheting back by xmax to the degree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required to make it safe to leave xmax undisturbed, independent of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether or not page freezing is triggered somewhere else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our policy is to force freezing in every case other than <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which obviates the need to maintain either set of trackers, anywhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every other case will reliably execute a freeze plan for xmax that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either replaces xmax with an XID/MXID &gt;= OldestXmin/OldestMxact, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sets xmax to an InvalidTransactionId XID, rendering xmax fully frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (VACUUM's NewRelfrozenXid/NewRelminMxid trackers are initialized with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OldestXmin/OldestMxact, so later <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> never need to be tracked here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; need_replace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; FreezePageRelfrozenXid = pagefrz-&gt;FreezePageRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = members[i].xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;relfrozenxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;FreezeLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't violate the FreezeLimit postcondition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_replace = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, FreezePageRelfrozenXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FreezePageRelfrozenXid = xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't violate the MultiXactCutoff postcondition, either */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!need_replace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_replace = <a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, cutoffs-&gt;MultiXactCutoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!need_replace)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * vacuumlazy.c might ratchet back NewRelminMxid, NewRelfrozenXid, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * both together to make it safe to retain this particular multi after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freezing its page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;FreezePageRelfrozenXid = FreezePageRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, pagefrz-&gt;FreezePageRelminMxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;FreezePageRelminMxid = multi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> multi;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do a more thorough second pass over the multi to figure out which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * member XIDs actually need to be kept.&nbsp; Checking the precise status of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individual members might even show that we don't need to keep anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That is quite possible even though the Multi must be &gt;= OldestMxact,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since our second pass only keeps member XIDs when it's truly necessary;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * even member XIDs &gt;= OldestXmin often won't be kept by second pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nnewmembers = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; newmembers = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(MultiXactMember) * nmembers);<br/></li>
<li>&nbsp; &nbsp; has_lockers = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; update_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; update_committed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine whether to keep each member xid, or to ignore it instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId xid = members[i].xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus mstatus = members[i].status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;relfrozenxid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ISUPDATE_from_mxstatus(mstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Locker XID (not updater XID).&nbsp; We only keep lockers that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;OldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;multixact </span><span class="Special">%u</span><span class="Constant"> contains running locker XID </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> removable cutoff </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi, xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cutoffs-&gt;OldestXmin)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newmembers[nnewmembers++] = members[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_lockers = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Updater XID (not locker XID).&nbsp; Should we keep it?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the tuple wasn't totally removed when <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> pruned, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update Xid cannot possibly be older than OldestXmin cutoff unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the updater XID aborted.&nbsp; If the updater transaction is known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aborted or crashed then it's okay to ignore it, otherwise not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case the Multi should never contain two updaters, whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their individual commit status.&nbsp; Check for that first, in passing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(update_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;multixact </span><span class="Special">%u</span><span class="Constant"> has two or more updating members&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;First updater XID=</span><span class="Special">%u</span><span class="Constant"> second updater XID=</span><span class="Special">%u</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_xid, xid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As with all tuple visibility routines, it's critical to test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>, because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * race conditions explained in detail in heapam_visibility.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The transaction committed, so we can tell caller to set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HEAP_XMAX_COMMITTED.&nbsp; (We can only do this because we know the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction is not running.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_committed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_xid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not in progress, not committed -- must be aborted or crashed;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We determined that updater must be kept -- add it to pending new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * members list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;OldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;multixact </span><span class="Special">%u</span><span class="Constant"> contains committed update XID </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> removable cutoff </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; multi, xid, cutoffs-&gt;OldestXmin)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newmembers[nnewmembers++] = members[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine what to do with caller's multi based on information gathered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during our second pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nnewmembers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing worth keeping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newxmax = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TransactionIdIsValid(update_xid) &amp;&amp; !has_lockers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's a single member and it's an update, pass it back alone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without creating a new Multi.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> we could do this when there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * single remaining locker, too, but that would complicate the API too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much; moreover, the case with the single updater is more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting, because those are longer-lived.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nnewmembers == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6140" title="access/heap/heapam.c:6140">FRM_RETURN_IS_XID</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update_committed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6142" title="access/heap/heapam.c:6142">FRM_MARK_COMMITTED</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newxmax = update_xid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a new multixact with the surviving members of the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one, to set as new Xmax in the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newxmax = <a href="../transam/multixact.c.html#L773" title="access/transam/multixact.c:773">MultiXactIdCreateFromMembers</a>(nnewmembers, newmembers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *flags |= <a href="#L6141" title="access/heap/heapam.c:6141">FRM_RETURN_IS_MULTI</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(newmembers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newxmax;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the XID fields of a tuple (xmin, xmax, xvac)<br/></li>
<li></span><span class="Comment"> * are older than the OldestXmin and/or OldestMxact freeze cutoffs.&nbsp; If so,<br/></li>
<li></span><span class="Comment"> * setup enough state (in the *frz output argument) to enable caller to<br/></li>
<li></span><span class="Comment"> * process this tuple as part of freezing its page, and return true.&nbsp; Return<br/></li>
<li></span><span class="Comment"> * false if nothing can be changed about the tuple right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also sets *totally_frozen to true if the tuple will be totally frozen once<br/></li>
<li></span><span class="Comment"> * caller executes returned freeze plan (or if the tuple was already totally<br/></li>
<li></span><span class="Comment"> * frozen by an earlier VACUUM).&nbsp; This indicates that there are no remaining<br/></li>
<li></span><span class="Comment"> * XIDs or MultiXactIds that will need to be processed by a future VACUUM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * VACUUM caller must assemble HeapTupleFreeze freeze plan entries for every<br/></li>
<li></span><span class="Comment"> * tuple that we returned true for, and then execute freezing.&nbsp; Caller must<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> pagefrz fields for page as a whole <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> first call here for<br/></li>
<li></span><span class="Comment"> * each heap page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * VACUUM caller decides on whether or not to freeze the page as a whole.<br/></li>
<li></span><span class="Comment"> * We'll often prepare freeze plans for a page that caller just discards.<br/></li>
<li></span><span class="Comment"> * However, VACUUM doesn't always get to make a choice; it must freeze when<br/></li>
<li></span><span class="Comment"> * pagefrz.freeze_required is set, to ensure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> XIDs &lt; FreezeLimit (and<br/></li>
<li></span><span class="Comment"> * MXIDs &lt; MultiXactCutoff) can never be left behind.&nbsp; We <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> to make sure<br/></li>
<li></span><span class="Comment"> * that VACUUM always follows that rule.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We sometimes force freezing of xmax MultiXactId <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> long <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is<br/></li>
<li></span><span class="Comment"> * strictly necessary to do so just to ensure the FreezeLimit postcondition.<br/></li>
<li></span><span class="Comment"> * It's worth processing MultiXactIds proactively when it is cheap to do so,<br/></li>
<li></span><span class="Comment"> * and it's convenient to make that happen by piggy-backing it on the &quot;force<br/></li>
<li></span><span class="Comment"> * freezing&quot; mechanism.&nbsp; Conversely, we sometimes delay freezing MultiXactIds<br/></li>
<li></span><span class="Comment"> * because it is expensive right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> (though only when it's still possible to<br/></li>
<li></span><span class="Comment"> * do so without violating the FreezeLimit/MultiXactCutoff postcondition).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is assumed that the caller has checked the tuple with<br/></li>
<li></span><span class="Comment"> * <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>() and determined that it is not HEAPTUPLE_DEAD<br/></li>
<li></span><span class="Comment"> * (else we should be removing the tuple, not freezing it).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: This function has side effects: it might allocate a new MultiXactId.<br/></li>
<li></span><span class="Comment"> * It will be set as tuple's new xmax when our *frz output is processed within<br/></li>
<li></span><span class="Comment"> * <a href="#L6815" title="access/heap/heapam.c:6815">heap_execute_freeze_tuple</a> later on.&nbsp; If the tuple is in a shared buffer<br/></li>
<li></span><span class="Comment"> * then caller had better have an exclusive lock on it already.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6541">&#x200c;</a></span><span class="linkable">heap_prepare_freeze_tuple</span>(HeapTupleHeader tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">struct</span> VacuumCutoffs *cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapPageFreeze *pagefrz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFreeze *frz, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *totally_frozen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; xmin_already_frozen = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmax_already_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze_xmin = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace_xvac = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace_xmax = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_xmax = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; frz-&gt;xmax = HeapTupleHeaderGetRawXmax(tuple);<br/></li>
<li>&nbsp; &nbsp; frz-&gt;t_infomask2 = tuple-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; frz-&gt;t_infomask = tuple-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; frz-&gt;frzflags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; frz-&gt;checkflags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process xmin, while keeping track of whether it's already frozen, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will become frozen iff our freeze plan is executed by caller (could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * neither).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xid = HeapTupleHeaderGetXmin(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmin_already_frozen = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;relfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;found xmin </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> relfrozenxid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, cutoffs-&gt;relfrozenxid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Will set freeze_xmin flags in freeze plan below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze_xmin = <a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;OldestXmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Verify that xmin committed if and when freeze plan is executed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freeze_xmin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;checkflags |= HEAP_FREEZE_CHECK_XMIN_COMMITTED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Old-style VACUUM FULL is gone, but we have to process xvac for as long<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as we support having MOVED_OFF/MOVED_IN tuples in the database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xid = HeapTupleHeaderGetXvac(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(cutoffs-&gt;relfrozenxid, xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;OldestXmin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For Xvac, we always freeze proactively.&nbsp; This allows totally_frozen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tracking to ignore xvac.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; replace_xvac = pagefrz-&gt;freeze_required = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Will set replace_xvac flags in freeze plan below */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now process xmax */<br/></li>
<li></span>&nbsp; &nbsp; xid = frz-&gt;xmax;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Raw xmax is a MultiXactId */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId newxmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will either remove xmax completely (in the &quot;freeze_xmax&quot; path),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process xmax by replacing it (in the &quot;replace_xmax&quot; path), or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform no-op xmax processing.&nbsp; The only constraint is that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FreezeLimit/MultiXactCutoff postcondition must never be violated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newxmax = <a href="#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a>(xid, tuple-&gt;t_infomask, cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;flags, pagefrz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax is a MultiXactId, and nothing about it changes for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the only case where 'freeze_required' won't have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set for us by <a href="#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a>, as well as the only case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * neither freeze_xmax nor replace_xmax are set (given a multi).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a no-op, but the call to <a href="#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a> might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ratcheted back NewRelfrozenXid and/or NewRelminMxid trackers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for us (the &quot;freeze page&quot; variants, specifically).&nbsp; That'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make it safe for our caller to freeze the page later on, while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaving this particular xmax undisturbed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a> is _not_ responsible for the &quot;no freeze&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NewRelfrozenXid/NewRelminMxid trackers, though -- that's our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * job.&nbsp; A call to <a href="#L7374" title="access/heap/heapam.c:7374">heap_tuple_should_freeze</a> for this same tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will take place below if 'freeze_required' isn't set already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (This repeats work from <a href="#L6191" title="access/heap/heapam.c:6191">FreezeMultiXactId</a>, but allows &quot;no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freeze&quot; tracker maintenance to happen in only one place.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(newxmax, cutoffs-&gt;MultiXactCutoff));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(MultiXactIdIsValid(newxmax) &amp;&amp; xid == newxmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; <a href="#L6140" title="access/heap/heapam.c:6140">FRM_RETURN_IS_XID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax will become an updater Xid (original MultiXact's updater<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * member Xid will be carried forward as a simple Xid in Xmax).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(newxmax, cutoffs-&gt;OldestXmin));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB -- some of these transformations are only valid because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * know the return Xid is a tuple updater (i.e. not merely a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locker.) Also note that the only reason we don't explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worry about HEAP_KEYS_UPDATED is because it lives in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * t_infomask2 rather than t_infomask.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask &amp;= ~HEAP_XMAX_BITS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;xmax = newxmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; <a href="#L6142" title="access/heap/heapam.c:6142">FRM_MARK_COMMITTED</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask |= HEAP_XMAX_COMMITTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace_xmax = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; <a href="#L6141" title="access/heap/heapam.c:6141">FRM_RETURN_IS_MULTI</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; newbits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; newbits2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmax is an old MultiXactId that we have to replace with a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * MultiXactId, to carry forward two or more original member XIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(newxmax, cutoffs-&gt;OldestMxact));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't use <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a> directly on the new multi<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here; that routine initializes the masks to all zeroes, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would lose other bits we need.&nbsp; Doing it this way ensures all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unrelated bits remain untouched.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask &amp;= ~HEAP_XMAX_BITS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6957" title="access/heap/heapam.c:6957">GetMultiXactIdHintBits</a>(newxmax, &amp;newbits, &amp;newbits2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask |= newbits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask2 |= newbits2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;xmax = newxmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replace_xmax = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Freeze plan for tuple &quot;freezes xmax&quot; in the strictest sense:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it'll leave nothing in xmax (neither an Xid nor a MultiXactId).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(flags &amp; <a href="#L6139" title="access/heap/heapam.c:6139">FRM_INVALIDATE_XMAX</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!TransactionIdIsValid(newxmax));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Will set freeze_xmax flags in freeze plan below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_xmax = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MultiXactId processing forces freezing (barring <a href="#L6138" title="access/heap/heapam.c:6138">FRM_NOOP</a> case) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pagefrz-&gt;freeze_required || (!freeze_xmax &amp;&amp; !replace_xmax));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Raw xmax is normal XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;relfrozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;found xmax </span><span class="Special">%u</span><span class="Constant"> from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> relfrozenxid </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, cutoffs-&gt;relfrozenxid)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Will set freeze_xmax flags in freeze plan below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze_xmax = <a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;OldestXmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify that xmax aborted if and when freeze plan is executed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provided it's from an update. (A lock-only xmax can be removed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * independent of this, since the lock is released at xact end.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (freeze_xmax &amp;&amp; !HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;checkflags |= HEAP_FREEZE_CHECK_XMAX_ABORTED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!TransactionIdIsValid(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Raw xmax is InvalidTransactionId XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xmax_already_frozen = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;found raw xmax </span><span class="Special">%u</span><span class="Constant"> (infomask 0x</span><span class="Special">%04x</span><span class="Constant">) not invalid and not multi&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xid, tuple-&gt;t_infomask)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (freeze_xmin)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!xmin_already_frozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask |= HEAP_XMIN_FROZEN;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replace_xvac)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a MOVED_OFF tuple is not dead, the xvac transaction must have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed; whereas a non-dead MOVED_IN tuple must mean the xvac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction succeeded.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pagefrz-&gt;freeze_required);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED_OFF)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;frzflags |= XLH_INVALID_XVAC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;frzflags |= XLH_FREEZE_XVAC;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replace_xmax)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!xmax_already_frozen &amp;&amp; !freeze_xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pagefrz-&gt;freeze_required);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already set replace_xmax flags in freeze plan earlier */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (freeze_xmax)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!xmax_already_frozen &amp;&amp; !replace_xmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;xmax = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple might be marked either XMAX_INVALID or XMAX_COMMITTED +<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L55" title="regex/regexec.c:55">LOCKED</a>.&nbsp; Normalize to INVALID just to be sure no one gets confused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also get rid of the HEAP_KEYS_UPDATED <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask &amp;= ~HEAP_XMAX_BITS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask |= HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask2 &amp;= ~HEAP_HOT_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; frz-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine if this tuple is already totally frozen, or will become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally frozen (provided caller executes freeze plans for the page)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *totally_frozen = ((freeze_xmin || xmin_already_frozen) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (freeze_xmax || xmax_already_frozen));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!pagefrz-&gt;freeze_required &amp;&amp; !(xmin_already_frozen &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmax_already_frozen))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So far no previous tuple from the page made freezing mandatory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does this tuple force caller to freeze the entire page?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pagefrz-&gt;freeze_required =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7374" title="access/heap/heapam.c:7374">heap_tuple_should_freeze</a>(tuple, cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pagefrz-&gt;NoFreezePageRelfrozenXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;pagefrz-&gt;NoFreezePageRelminMxid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tell caller if this tuple has a usable freeze plan set in *frz */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> freeze_xmin || replace_xvac || replace_xmax || freeze_xmax;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6815" title="access/heap/heapam.c:6815">heap_execute_freeze_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Execute the prepared freezing of a tuple with caller's freeze plan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for ensuring that no other backend can access the<br/></li>
<li></span><span class="Comment"> * storage underlying this tuple, either by holding an exclusive lock on the<br/></li>
<li></span><span class="Comment"> * buffer containing it (which is what lazy VACUUM does), or by having it be<br/></li>
<li></span><span class="Comment"> * in private storage (which is what CLUSTER and friends do).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L6815">&#x200c;</a></span><span class="linkable">heap_execute_freeze_tuple</span>(HeapTupleHeader tuple, HeapTupleFreeze *frz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeaderSetXmax(tuple, frz-&gt;xmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frz-&gt;frzflags &amp; XLH_FREEZE_XVAC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXvac(tuple, FrozenTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frz-&gt;frzflags &amp; XLH_INVALID_XVAC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXvac(tuple, InvalidTransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_infomask = frz-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; tuple-&gt;t_infomask2 = frz-&gt;t_infomask2;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform xmin/xmax XID status sanity checks <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually executing freeze<br/></li>
<li></span><span class="Comment"> * plans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a> doesn't perform these checks directly because<br/></li>
<li></span><span class="Comment"> * pg_xact lookups are relatively expensive.&nbsp; They shouldn't be repeated by<br/></li>
<li></span><span class="Comment"> * successive VACUUMs that each decide against freezing the same page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6838">&#x200c;</a></span><span class="linkable">heap_pre_freeze_checks</span>(Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleFreeze *tuples, <span class="Type">int</span> ntuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFreeze *frz = tuples + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, frz-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Deliberately avoid relying on tuple hint bits here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frz-&gt;checkflags &amp; HEAP_FREEZE_CHECK_XMIN_COMMITTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin = HeapTupleHeaderGetRawXmin(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHeaderXminFrozen(htup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!<a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xmin)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;uncommitted xmin </span><span class="Special">%u</span><span class="Constant"> needs to be frozen&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmin)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a> won't work reliably in the presence of XIDs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left behind by transactions that were in progress during a crash,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we can only check that xmax didn't commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (frz-&gt;checkflags &amp; HEAP_FREEZE_CHECK_XMAX_ABORTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmax = HeapTupleHeaderGetRawXmax(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(TransactionIdIsNormal(xmax));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(<a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xmax)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;cannot freeze committed xmax </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xmax)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper which executes freezing of one or more heap tuples on a page on<br/></li>
<li></span><span class="Comment"> * behalf of caller.&nbsp; Caller passes an array of tuple plans from<br/></li>
<li></span><span class="Comment"> * <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a>.&nbsp; Caller must set 'offset' in each plan for us.<br/></li>
<li></span><span class="Comment"> * Must be called in a critical section that also marks the buffer dirty and,<br/></li>
<li></span><span class="Comment"> * if needed, emits WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L6891">&#x200c;</a></span><span class="linkable">heap_freeze_prepared_tuples</span>(Buffer buffer, HeapTupleFreeze *tuples, <span class="Type">int</span> ntuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFreeze *frz = tuples + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, frz-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6815" title="access/heap/heapam.c:6815">heap_execute_freeze_tuple</a>(htup, frz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L6913" title="access/heap/heapam.c:6913">heap_freeze_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Freeze tuple in place, without WAL logging.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Useful for callers like CLUSTER that perform their own WAL logging.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L6913">&#x200c;</a></span><span class="linkable">heap_freeze_tuple</span>(HeapTupleHeader tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId relfrozenxid, TransactionId relminmxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId FreezeLimit, TransactionId MultiXactCutoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleFreeze frz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_freeze;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; totally_frozen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> VacuumCutoffs cutoffs;<br/></li>
<li>&nbsp; &nbsp; HeapPageFreeze pagefrz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cutoffs.relfrozenxid = relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; cutoffs.relminmxid = relminmxid;<br/></li>
<li>&nbsp; &nbsp; cutoffs.OldestXmin = FreezeLimit;<br/></li>
<li>&nbsp; &nbsp; cutoffs.OldestMxact = MultiXactCutoff;<br/></li>
<li>&nbsp; &nbsp; cutoffs.FreezeLimit = FreezeLimit;<br/></li>
<li>&nbsp; &nbsp; cutoffs.MultiXactCutoff = MultiXactCutoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pagefrz.freeze_required = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; pagefrz.FreezePageRelfrozenXid = FreezeLimit;<br/></li>
<li>&nbsp; &nbsp; pagefrz.FreezePageRelminMxid = MultiXactCutoff;<br/></li>
<li>&nbsp; &nbsp; pagefrz.NoFreezePageRelfrozenXid = FreezeLimit;<br/></li>
<li>&nbsp; &nbsp; pagefrz.NoFreezePageRelminMxid = MultiXactCutoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; do_freeze = <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a>(tuple, &amp;cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pagefrz, &amp;frz, &amp;totally_frozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that because this is not a WAL-logged operation, we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fill in the offset in the freeze record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (do_freeze)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6815" title="access/heap/heapam.c:6815">heap_execute_freeze_tuple</a>(tuple, &amp;frz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> do_freeze;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For a given MultiXactId, return the hint bits that should be set in the<br/></li>
<li></span><span class="Comment"> * tuple's infomask.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normally this should be called for a multixact that was just created, and<br/></li>
<li></span><span class="Comment"> * so is on our local cache, so the GetMembers call is fast.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L6957">&#x200c;</a></span><span class="linkable">GetMultiXactIdHintBits</span>(MultiXactId multi, uint16 *new_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 *new_infomask2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; bits = HEAP_XMAX_IS_MULTI;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; bits2 = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_update = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; LockTupleMode strongest = LockTupleKeyShare;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only use this in multis we just created, so they cannot be <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pre-pg_upgrade.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nmembers = <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the strongest lock mode held by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> member of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multixact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mode = <a href="#L218" title="access/heap/heapam.c:218">TUPLOCK_from_mxstatus</a>(members[i].status);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode &gt; strongest)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strongest = mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See what other bits we need */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (members[i].status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForKeyShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForShare:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForNoKeyUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusForUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits2 |= HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusNoKeyUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> MultiXactStatusUpdate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits2 |= HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_update = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strongest == LockTupleExclusive ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strongest == LockTupleNoKeyExclusive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits |= HEAP_XMAX_EXCL_LOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strongest == LockTupleShare)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits |= HEAP_XMAX_SHR_LOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strongest == LockTupleKeyShare)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits |= HEAP_XMAX_KEYSHR_LOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!has_update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits |= HEAP_XMAX_LOCK_ONLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *new_infomask = bits;<br/></li>
<li>&nbsp; &nbsp; *new_infomask2 = bits2;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7038" title="access/heap/heapam.c:7038">MultiXactIdGetUpdateXid</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a multixact Xmax and corresponding infomask, which does not have the<br/></li>
<li></span><span class="Comment"> * HEAP_XMAX_LOCK_ONLY <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set, obtain and return the Xid of the updating<br/></li>
<li></span><span class="Comment"> * transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is expected to check the status of the updating transaction, if<br/></li>
<li></span><span class="Comment"> * necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TransactionId<br/></li>
<li><a id="L7038">&#x200c;</a><span class="linkable">MultiXactIdGetUpdateXid</span>(TransactionId xmax, uint16 t_infomask)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId update_xact = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!(t_infomask &amp; HEAP_XMAX_LOCK_ONLY));<br/></li>
<li>&nbsp; &nbsp; Assert(t_infomask &amp; HEAP_XMAX_IS_MULTI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we know the LOCK_ONLY <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is not set, this cannot be a multi from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pre-pg_upgrade.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nmembers = <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(xmax, &amp;members, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore lockers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ISUPDATE_from_mxstatus(members[i].status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there can be at most one updater */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(update_xact == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_xact = members[i].xid;<br/></li>
<li><span class="PreProc">#ifndef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in an assert-enabled build, walk the whole array to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no other updater.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> update_xact;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7090" title="access/heap/heapam.c:7090">HeapTupleGetUpdateXid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but use a HeapTupleHeader<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See also HeapTupleHeaderGetUpdateXid, which can be used without previously<br/></li>
<li></span><span class="Comment"> * checking the hint bits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L7090">&#x200c;</a><span class="linkable">HeapTupleGetUpdateXid</span>(HeapTupleHeader tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L7038" title="access/heap/heapam.c:7038">MultiXactIdGetUpdateXid</a>(HeapTupleHeaderGetRawXmax(tuple),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tuple-&gt;t_infomask);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does the given multixact conflict with the current transaction grabbing a<br/></li>
<li></span><span class="Comment"> * tuple lock of the given strength?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed infomask pairs up with the given multixact in the tuple header.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If current_is_member is not NULL, it is set to 'true' if the current<br/></li>
<li></span><span class="Comment"> * transaction is a member of the given multixact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7106">&#x200c;</a></span><span class="linkable">DoesMultiXactIdConflict</span>(MultiXactId multi, uint16 infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LockTupleMode lockmode, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *current_is_member)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; wanted = <a href="#L134" title="access/heap/heapam.c:134">tupleLockExtraInfo</a>[lockmode].hwlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HEAP_LOCKED_UPGRADED(infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nmembers = <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_IS_LOCKED_ONLY(infomask));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId memxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; memlockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &amp;&amp; (current_is_member == <span class="Constant">NULL</span> || *current_is_member))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memlockmode = <a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(members[i].status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore members from current xact (but track their presence) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memxid = members[i].xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(memxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (current_is_member != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *current_is_member = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore members that don't conflict with the lock we want */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lock.c.html#L570" title="storage/lmgr/lock.c:570">DoLockModesConflict</a>(memlockmode, wanted))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ISUPDATE_from_mxstatus(members[i].status))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore aborted updaters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L188" title="access/transam/transam.c:188">TransactionIdDidAbort</a>(memxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore lockers-only that are no longer in progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(memxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Whatever remains are either live lockers that conflict with our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wanted lock, and updaters that are not aborted.&nbsp; Those conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with what we want.&nbsp; Set up to return true, but keep going to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * look for the current transaction among the multixact members,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7205" title="access/heap/heapam.c:7205">Do_MultiXactIdWait</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Actual implementation for the two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> below.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'multi', 'status' and 'infomask' indicate what to sleep on (the status is<br/></li>
<li></span><span class="Comment"> * needed to ensure we only sleep on conflicting members, and the infomask is<br/></li>
<li></span><span class="Comment"> * used to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> multixact access in case it's a lock-only multi); 'nowait'<br/></li>
<li></span><span class="Comment"> * indicates whether to use conditional lock acquisition, to allow callers to<br/></li>
<li></span><span class="Comment"> * fail if lock is unavailable.&nbsp; 'rel', 'ctid' and '<a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>' are used to set up<br/></li>
<li></span><span class="Comment"> * context information for error messages.&nbsp; 'remaining', if not NULL, receives<br/></li>
<li></span><span class="Comment"> * the number of members that are still running, including <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (non-aborted)<br/></li>
<li></span><span class="Comment"> * subtransactions of our own transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do this by sleeping on each member using <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>.&nbsp; Any<br/></li>
<li></span><span class="Comment"> * members that belong to the current backend are *not* waited for, however;<br/></li>
<li></span><span class="Comment"> * this would not merely be useless but would lead to Assert failure inside<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>.&nbsp; By the time this returns, it is certain that all<br/></li>
<li></span><span class="Comment"> * transactions *of other backends* that were members of the MultiXactId<br/></li>
<li></span><span class="Comment"> * that conflict with the requested status are dead (and no new ones can have<br/></li>
<li></span><span class="Comment"> * been added, since it is not legal to add members to an existing<br/></li>
<li></span><span class="Comment"> * MultiXactId).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * But by the time we finish sleeping, someone else may have changed the Xmax<br/></li>
<li></span><span class="Comment"> * of the containing tuple, so the caller needs to iterate on us somehow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that in case we return false, the number of remaining members is<br/></li>
<li></span><span class="Comment"> * not to be trusted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7205">&#x200c;</a></span><span class="linkable">Do_MultiXactIdWait</span>(MultiXactId multi, MultiXactStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 infomask, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nowait,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation rel, ItemPointer ctid, XLTW_Oper <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *remaining)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remain = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for pre-pg_upgrade tuples, no need to sleep at all */<br/></li>
<li></span>&nbsp; &nbsp; nmembers = HEAP_LOCKED_UPGRADED(infomask) ? -<span class="Constant">1</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_LOCKED_ONLY(infomask));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nmembers &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId memxid = members[i].xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MultiXactStatus memstatus = members[i].status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xact.c.html#L938" title="access/transam/xact.c:938">TransactionIdIsCurrentTransactionId</a>(memxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remain++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/lock.c.html#L570" title="storage/lmgr/lock.c:570">DoLockModesConflict</a>(<a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(memstatus),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L159" title="access/heap/heapam.c:159">LOCKMODE_from_mxstatus</a>(status)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remaining &amp;&amp; <a href="../../storage/ipc/procarray.c.html#L1390" title="storage/ipc/procarray.c:1390">TransactionIdIsInProgress</a>(memxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remain++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This member conflicts with our multi, so we have to sleep (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return failure, if asked to avoid <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't set up an error context callback ourselves,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but instead we pass the info down to <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might seem a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> wasteful because the context is set up and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tore down for each member of the multixact, but in reality it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be barely noticeable, and it avoids duplicate code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nowait)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../storage/lmgr/lmgr.c.html#L740" title="storage/lmgr/lmgr.c:740">ConditionalXactLockTableWait</a>(memxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L667" title="storage/lmgr/lmgr.c:667">XactLockTableWait</a>(memxid, rel, ctid, <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (remaining)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *remaining = remain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7283" title="access/heap/heapam.c:7283">MultiXactIdWait</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Sleep on a MultiXactId.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By the time we finish sleeping, someone else may have changed the Xmax<br/></li>
<li></span><span class="Comment"> * of the containing tuple, so the caller needs to iterate on us somehow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return (in *remaining, if not NULL) the number of members that are still<br/></li>
<li></span><span class="Comment"> * running, including <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (non-aborted) subtransactions of our own transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7283">&#x200c;</a></span><span class="linkable">MultiXactIdWait</span>(MultiXactId multi, MultiXactStatus status, uint16 infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation rel, ItemPointer ctid, XLTW_Oper <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *remaining)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L7205" title="access/heap/heapam.c:7205">Do_MultiXactIdWait</a>(multi, status, infomask, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel, ctid, <a href="../../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>, remaining);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7305" title="access/heap/heapam.c:7305">ConditionalMultiXactIdWait</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; As above, but only lock if we can get the lock without blocking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By the time we finish sleeping, someone else may have changed the Xmax<br/></li>
<li></span><span class="Comment"> * of the containing tuple, so the caller needs to iterate on us somehow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the multixact is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> all gone, return true.&nbsp; Returns false if some<br/></li>
<li></span><span class="Comment"> * transactions might still be running.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return (in *remaining, if not NULL) the number of members that are still<br/></li>
<li></span><span class="Comment"> * running, including <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (non-aborted) subtransactions of our own transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7305">&#x200c;</a></span><span class="linkable">ConditionalMultiXactIdWait</span>(MultiXactId multi, MultiXactStatus status,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 infomask, Relation rel, <span class="Type">int</span> *remaining)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L7205" title="access/heap/heapam.c:7205">Do_MultiXactIdWait</a>(multi, status, infomask, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel, <span class="Constant">NULL</span>, XLTW_None, remaining);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7319" title="access/heap/heapam.c:7319">heap_tuple_needs_eventual_freeze</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check to see whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the XID fields of a tuple (xmin, xmax, xvac)<br/></li>
<li></span><span class="Comment"> * will eventually require freezing (if tuple isn't removed by pruning first).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7319">&#x200c;</a></span><span class="linkable">heap_tuple_needs_eventual_freeze</span>(HeapTupleHeader tuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If xmin is a normal transaction ID, this tuple is definitely not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xid = HeapTupleHeaderGetXmin(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If xmax is a valid xact or multixact, this tuple is also not frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactId multi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi = HeapTupleHeaderGetRawXmax(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (MultiXactIdIsValid(multi))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetRawXmax(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetXvac(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7374" title="access/heap/heapam.c:7374">heap_tuple_should_freeze</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value indicates if <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a> sibling function would<br/></li>
<li></span><span class="Comment"> * (or should) force freezing of the heap page that contains caller's tuple.<br/></li>
<li></span><span class="Comment"> * Tuple header XIDs/MXIDs &lt; FreezeLimit/MultiXactCutoff <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> freezing.<br/></li>
<li></span><span class="Comment"> * This includes (xmin, xmax, xvac) fields, as well as MultiXact member XIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The *NoFreezePageRelfrozenXid and *NoFreezePageRelminMxid input/output<br/></li>
<li></span><span class="Comment"> * arguments <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> VACUUM track the oldest extant XID/MXID remaining in rel.<br/></li>
<li></span><span class="Comment"> * Our working assumption is that caller won't decide to freeze this tuple.<br/></li>
<li></span><span class="Comment"> * It's up to caller to only ratchet back its own top-level trackers after the<br/></li>
<li></span><span class="Comment"> * point that it fully commits to not freezing the tuple/page in question.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L7374">&#x200c;</a></span><span class="linkable">heap_tuple_should_freeze</span>(HeapTupleHeader tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">struct</span> VacuumCutoffs *cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *NoFreezePageRelfrozenXid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiXactId *NoFreezePageRelminMxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multi;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First deal with xmin */<br/></li>
<li></span>&nbsp; &nbsp; xid = HeapTupleHeaderGetXmin(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(cutoffs-&gt;relfrozenxid, xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, *NoFreezePageRelfrozenXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *NoFreezePageRelfrozenXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;FreezeLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now deal with xmax */<br/></li>
<li></span>&nbsp; &nbsp; xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; multi = InvalidMultiXactId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multi = HeapTupleHeaderGetRawXmax(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetRawXmax(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(cutoffs-&gt;relfrozenxid, xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xmax is a non-permanent XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, *NoFreezePageRelfrozenXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *NoFreezePageRelfrozenXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;FreezeLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!MultiXactIdIsValid(multi))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xmax is a permanent XID or invalid MultiXactId/XID */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (HEAP_LOCKED_UPGRADED(tuple-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xmax is a pg_upgrade'd MultiXact, which can't have updater XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, *NoFreezePageRelminMxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *NoFreezePageRelminMxid = multi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a> always freezes pg_upgrade'd xmax */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xmax is a MultiXactId that may have an updater XID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MultiXactMember *members;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nmembers;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/multixact.c.html#L3274" title="access/transam/multixact.c:3274">MultiXactIdPrecedesOrEquals</a>(cutoffs-&gt;relminmxid, multi));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, *NoFreezePageRelminMxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *NoFreezePageRelminMxid = multi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(multi, cutoffs-&gt;MultiXactCutoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to check whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> member of the mxact is old */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nmembers = <a href="../transam/multixact.c.html#L1252" title="access/transam/multixact.c:1252">GetMultiXactIdMembers</a>(multi, &amp;members, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_IS_LOCKED_ONLY(tuple-&gt;t_infomask));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nmembers; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = members[i].xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(cutoffs-&gt;relfrozenxid, xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, *NoFreezePageRelfrozenXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *NoFreezePageRelfrozenXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, cutoffs-&gt;FreezeLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nmembers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(members);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetXvac(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsNormal(xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L299" title="access/transam/transam.c:299">TransactionIdPrecedesOrEquals</a>(cutoffs-&gt;relfrozenxid, xid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, *NoFreezePageRelfrozenXid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *NoFreezePageRelfrozenXid = xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a> forces xvac freezing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> freeze;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maintain snapshotConflictHorizon for caller by ratcheting forward its value<br/></li>
<li></span><span class="Comment"> * using <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> committed XIDs contained in 'tuple', an obsolescent heap tuple<br/></li>
<li></span><span class="Comment"> * that caller is in the process of physically removing, e.g. via HOT pruning<br/></li>
<li></span><span class="Comment"> * or index deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> its value to InvalidTransactionId, which is<br/></li>
<li></span><span class="Comment"> * generally interpreted as &quot;definitely no need for a recovery conflict&quot;.<br/></li>
<li></span><span class="Comment"> * Final value must reflect all heap tuples that caller will physically remove<br/></li>
<li></span><span class="Comment"> * (or remove TID references to) via its ongoing pruning/deletion operation.<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/ipc/standby.c.html#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a>() is passed the final value (taken from<br/></li>
<li></span><span class="Comment"> * caller's WAL record) by REDO routine when it replays caller's operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L7482">&#x200c;</a></span><span class="linkable">HeapTupleHeaderAdvanceConflictHorizon</span>(HeapTupleHeader tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId *snapshotConflictHorizon)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xmin = HeapTupleHeaderGetXmin(tuple);<br/></li>
<li>&nbsp; &nbsp; TransactionId xmax = HeapTupleHeaderGetUpdateXid(tuple);<br/></li>
<li>&nbsp; &nbsp; TransactionId xvac = HeapTupleHeaderGetXvac(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tuple-&gt;t_infomask &amp; HEAP_MOVED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(*snapshotConflictHorizon, xvac))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *snapshotConflictHorizon = xvac;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore tuples inserted by an aborted transaction or if the tuple was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated/deleted by the inserting transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for a committed hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, or if no xmin <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set, check clog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHeaderXminCommitted(tuple) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!HeapTupleHeaderXminInvalid(tuple) &amp;&amp; <a href="../transam/transam.c.html#L126" title="access/transam/transam.c:126">TransactionIdDidCommit</a>(xmin)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xmax != xmin &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xmax, *snapshotConflictHorizon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *snapshotConflictHorizon = xmax;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a>.&nbsp; Issues prefetch requests for<br/></li>
<li></span><span class="Comment"> * prefetch_count buffers.&nbsp; The prefetch_state keeps track of all the buffers<br/></li>
<li></span><span class="Comment"> * we can prefetch, and which have already been prefetched; each call to this<br/></li>
<li></span><span class="Comment"> * function picks up where the previous call left off.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we expect the deltids array to be sorted in an order that groups TIDs<br/></li>
<li></span><span class="Comment"> * by heap block, with all TIDs for each block appearing together in exactly<br/></li>
<li></span><span class="Comment"> * one group.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7522">&#x200c;</a></span><span class="linkable">index_delete_prefetch_buffer</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L185" title="access/heap/heapam.c:185">IndexDeletePrefetchState</a> *prefetch_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> prefetch_count)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber cur_hblkno = prefetch_state-&gt;cur_hblkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeltids = prefetch_state-&gt;ndeltids;<br/></li>
<li>&nbsp; &nbsp; TM_IndexDelete *deltids = prefetch_state-&gt;deltids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = prefetch_state-&gt;next_item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i &lt; ndeltids &amp;&amp; count &lt; prefetch_count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointer htid = &amp;deltids[i].tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur_hblkno == InvalidBlockNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(htid) != cur_hblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_hblkno = ItemPointerGetBlockNumber(htid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L638" title="storage/buffer/bufmgr.c:638">PrefetchBuffer</a>(rel, MAIN_FORKNUM, cur_hblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the prefetch position so that <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time we can continue from that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prefetch_state-&gt;next_item = i;<br/></li>
<li>&nbsp; &nbsp; prefetch_state-&gt;cur_hblkno = cur_hblkno;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a>.&nbsp; Checks for index corruption<br/></li>
<li></span><span class="Comment"> * involving an invalid TID in index AM caller's index page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is an ideal place for these checks.&nbsp; The index AM must hold a buffer<br/></li>
<li></span><span class="Comment"> * lock on the index page containing the TIDs we examine here, so we don't<br/></li>
<li></span><span class="Comment"> * have to worry about concurrent VACUUMs at all.&nbsp; We can be sure that the<br/></li>
<li></span><span class="Comment"> * index is corrupt when htid points directly to an LP_UNUSED item or<br/></li>
<li></span><span class="Comment"> * heap-only tuple, which is not the case during standard index scans.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L7567">&#x200c;</a></span><span class="linkable">index_delete_check_htid</span>(TM_IndexDeleteOp *delstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page, OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer htid, TM_IndexStatus *istatus)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber indexpagehoffnum = ItemPointerGetOffsetNumber(htid);<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OffsetNumberIsValid(istatus-&gt;idxoffnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(indexpagehoffnum &gt; maxoff))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;heap tid from index tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) points past end of heap page line pointer array at offset </span><span class="Special">%u</span><span class="Constant"> of block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(htid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexpagehoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istatus-&gt;idxoffnum, delstate-&gt;iblknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(delstate-&gt;irel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; iid = PageGetItemId(page, indexpagehoffnum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!ItemIdIsUsed(iid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;heap tid from index tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) points to unused heap page item at offset </span><span class="Special">%u</span><span class="Constant"> of block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(htid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexpagehoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istatus-&gt;idxoffnum, delstate-&gt;iblknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(delstate-&gt;irel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ItemIdHasStorage(iid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(iid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(HeapTupleHeaderIsHeapOnly(htup)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;heap tid from index tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) points to heap-only tuple at offset </span><span class="Special">%u</span><span class="Constant"> of block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(htid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexpagehoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; istatus-&gt;idxoffnum, delstate-&gt;iblknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(delstate-&gt;irel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * heapam implementation of tableam's index_delete_tuples interface.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This helper function is called by index AMs during index tuple deletion.<br/></li>
<li></span><span class="Comment"> * See tableam header comments for an explanation of the interface implemented<br/></li>
<li></span><span class="Comment"> * here and a general theory of operation.&nbsp; Note that each call here is either<br/></li>
<li></span><span class="Comment"> * a simple index deletion call, or a bottom-up index deletion call.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It's possible for this to generate a fair amount of I/O, since we may be<br/></li>
<li></span><span class="Comment"> * deleting hundreds of tuples from a single index block.&nbsp; To amortize that<br/></li>
<li></span><span class="Comment"> * cost to some degree, this uses prefetching and combines <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> accesses to<br/></li>
<li></span><span class="Comment"> * the same heap block.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>TransactionId<br/></li>
<li><a id="L7627">&#x200c;</a><span class="linkable">heap_index_delete_tuples</span>(Relation rel, TM_IndexDeleteOp *delstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initial assumption is that earlier pruning took care of conflict */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId snapshotConflictHorizon = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; TransactionId priorXmax;<br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L185" title="access/heap/heapam.c:185">IndexDeletePrefetchState</a> prefetch_state;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefetch_distance;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; SnapshotData SnapshotNonVacuumable;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalndeltids = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocksaccessed = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* State that's only used in bottom-up index deletion case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocksfavorable = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curtargetfreespace = delstate-&gt;bottomupfreespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastfreespace = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actualfreespace = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bottomup_final_block = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; InitNonVacuumableSnapshot(SnapshotNonVacuumable, <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort caller's deltids array by TID for further processing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7972" title="access/heap/heapam.c:7972">index_delete_sort</a>(delstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bottom-up case: resort deltids array in an order attuned to where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * greatest number of promising TIDs are to be found, and determine how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many blocks from the start of sorted array should be considered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * favorable.&nbsp; This will also shrink the deltids array in order to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eliminate completely unfavorable blocks up front.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (delstate-&gt;bottomup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocksfavorable = <a href="#L8185" title="access/heap/heapam.c:8185">bottomup_sort_and_shrink</a>(delstate);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Initialize prefetch state. */<br/></li>
<li></span>&nbsp; &nbsp; prefetch_state.cur_hblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; prefetch_state.next_item = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prefetch_state.ndeltids = delstate-&gt;ndeltids;<br/></li>
<li>&nbsp; &nbsp; prefetch_state.deltids = delstate-&gt;deltids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the prefetch distance that we will attempt to maintain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the caller holds a buffer lock somewhere in rel, we'd better make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that isn't a catalog relation <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we call code that does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syscache lookups, to avoid risk of deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../catalog/catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefetch_distance = <a href="../../storage/buffer/bufmgr.c.html#L157" title="storage/buffer/bufmgr.c:157">maintenance_io_concurrency</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prefetch_distance =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/spccache.c.html#L229" title="utils/cache/spccache.c:229">get_tablespace_maintenance_io_concurrency</a>(rel-&gt;rd_rel-&gt;reltablespace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cap initial prefetch distance for bottom-up deletion caller */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (delstate-&gt;bottomup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nblocksfavorable &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nblocksfavorable &lt;= <a href="#L189" title="access/heap/heapam.c:189">BOTTOMUP_MAX_NBLOCKS</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prefetch_distance = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(prefetch_distance, nblocksfavorable);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start prefetching. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L7522" title="access/heap/heapam.c:7522">index_delete_prefetch_buffer</a>(rel, &amp;prefetch_state, prefetch_distance);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate over deltids, determine which to delete, check their horizon */<br/></li>
<li></span>&nbsp; &nbsp; Assert(delstate-&gt;ndeltids &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; delstate-&gt;ndeltids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *ideltid = &amp;delstate-&gt;deltids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexStatus *istatus = delstate-&gt;status + ideltid-&gt;id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointer htid = &amp;ideltid-&gt;tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read buffer, and perform required extra steps each time a new block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is encountered.&nbsp; Avoid refetching if it's the same block as the one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the last htid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetBlockNumber(htid) != blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider giving up early for bottom-up index deletion caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first. (Only prefetch <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block afterwards, when it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * becomes clear that we're at least going to access the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block in line.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sometimes the first block frees so much space for bottom-up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller that the deletion process can end without accessing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more blocks.&nbsp; It is usually necessary to access 2 or 3 blocks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * per bottom-up deletion operation, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delstate-&gt;bottomup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We often allow caller to delete a few additional items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whose entries we reached after the point that space target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from caller was satisfied.&nbsp; The cost of accessing the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was already paid at that point, so it made sense to finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it off.&nbsp; When that happened, we finalize everything here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (by finishing off the whole bottom-up deletion operation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without needlessly paying the cost of accessing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * blocks).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bottomup_final_block)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give up when we didn't enable our caller to free <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional space as a result of processing the page that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just finished up with.&nbsp; This rule is the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> way in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we keep the cost of bottom-up deletion under control.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocksaccessed &gt;= <span class="Constant">1</span> &amp;&amp; actualfreespace == lastfreespace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastfreespace = actualfreespace;&nbsp; &nbsp; <span class="Comment">/* for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deletion operation (which is bottom-up) will definitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * access the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block in line.&nbsp; Prepare for that <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decay target free space so that we don't hang on for too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * long with a marginal case. (Space target is only truly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * helpful when it allows us to recognize that we don't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to access more than 1 or 2 blocks to satisfy caller due to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * agreeable workload characteristics.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more patient when we encounter contiguous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * blocks, though: these are treated as favorable blocks.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decay process is only applied when the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block in line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not a favorable/contiguous block.&nbsp; This is not an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exception to the general rule; we still insist on finding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at least one deletable item per block accessed.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L8069" title="access/heap/heapam.c:8069">bottomup_nblocksfavorable</a>() for full details of the theory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behind favorable blocks and heap block locality in general.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: The first block in line is always treated as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * favorable block, so the earliest possible point that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decay can be applied is just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we access the second<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block in line.&nbsp; The Assert() verifies this for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nblocksaccessed &gt; <span class="Constant">0</span> || nblocksfavorable &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocksfavorable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocksfavorable--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curtargetfreespace /= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* release old buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = ItemPointerGetBlockNumber(htid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(rel, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocksaccessed++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!delstate-&gt;bottomup ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nblocksaccessed &lt;= <a href="#L189" title="access/heap/heapam.c:189">BOTTOMUP_MAX_NBLOCKS</a>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_PREFETCH<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To maintain the prefetch distance, prefetch one more page for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each page we read.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7522" title="access/heap/heapam.c:7522">index_delete_prefetch_buffer</a>(rel, &amp;prefetch_state, <span class="Constant">1</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In passing, detect index corruption involving an index page with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID that points to a location in the heap that couldn't possibly be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct.&nbsp; We only do this with actual TIDs from caller's index page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (not items reached by traversing through a HOT chain).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7567" title="access/heap/heapam.c:7567">index_delete_check_htid</a>(delstate, page, maxoff, htid, istatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (istatus-&gt;knowndeletable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!delstate-&gt;bottomup &amp;&amp; !istatus-&gt;promising);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerData tmp = *htid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleData heapTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples from this HOT chain non-vacuumable? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1627" title="access/heap/heapam.c:1627">heap_hot_search_buffer</a>(&amp;tmp, rel, buf, &amp;SnapshotNonVacuumable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;heapTuple, <span class="Constant">NULL</span>, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't delete entry */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller will delete, since whole HOT chain is vacuumable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;knowndeletable = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Maintain index free space info for bottom-up deletion case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delstate-&gt;bottomup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(istatus-&gt;freespace &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actualfreespace += istatus-&gt;freespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (actualfreespace &gt;= curtargetfreespace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bottomup_final_block = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Maintain snapshotConflictHorizon value for deletion operation as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whole by advancing current value using heap tuple headers.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loosely based on the logic for pruning a HOT chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(htid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; priorXmax = InvalidTransactionId;&nbsp; &nbsp; <span class="Comment">/* cannot check first XMIN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check (pure paranoia) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An offset past the end of page's line pointer array is possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the array was truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemIdGetRedirect(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll often encounter LP_DEAD line pointers (especially with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entry marked knowndeletable by our caller up front).&nbsp; No heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple headers get examined for an htid that leads us to an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LP_DEAD item.&nbsp; This is okay because the earlier pruning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operation that made the line pointer LP_DEAD in the first place<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must have considered the original tuple header as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generating its own snapshotConflictHorizon value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Relying on XLOG_HEAP2_PRUNE_VACUUM_SCAN <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> like this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same strategy that index vacuuming uses in all cases. Index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VACUUM WAL <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> don't even have a snapshotConflictHorizon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * field of their own for this reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the tuple XMIN against prior XMAX, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(priorXmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetXmin(htup), priorXmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L7482" title="access/heap/heapam.c:7482">HeapTupleHeaderAdvanceConflictHorizon</a>(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;snapshotConflictHorizon);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple is not HOT-updated, then we are at the end of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HOT-chain.&nbsp; No need to visit later tuples from the same update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chain (they get their own index entries) -- just move on to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> htid from index AM caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderIsHotUpdated(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> HOT chain member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerGetBlockNumber(&amp;htup-&gt;t_ctid) == blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(&amp;htup-&gt;t_ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorXmax = HeapTupleHeaderGetUpdateXid(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Enable further/final shrinking of deltids for caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; finalndeltids = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shrink deltids array to exclude non-deletable entries at the end.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not just a minor optimization.&nbsp; Final deltids array size might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero for a bottom-up caller.&nbsp; Index AM is explicitly allowed to rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ndeltids being zero in all cases with zero total deletable entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(finalndeltids &gt; <span class="Constant">0</span> || delstate-&gt;bottomup);<br/></li>
<li>&nbsp; &nbsp; delstate-&gt;ndeltids = finalndeltids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> snapshotConflictHorizon;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Specialized inlineable comparison function for <a href="#L7972" title="access/heap/heapam.c:7972">index_delete_sort</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L7936">&#x200c;</a></span><span class="linkable">index_delete_sort_cmp</span>(TM_IndexDelete *deltid1, TM_IndexDelete *deltid2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointer tid1 = &amp;deltid1-&gt;tid;<br/></li>
<li>&nbsp; &nbsp; ItemPointer tid2 = &amp;deltid2-&gt;tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk1 = ItemPointerGetBlockNumber(tid1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk2 = ItemPointerGetBlockNumber(tid2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blk1 != blk2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (blk1 &lt; blk2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber pos1 = ItemPointerGetOffsetNumber(tid1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber pos2 = ItemPointerGetOffsetNumber(tid2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pos1 != pos2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (pos1 &lt; pos2) ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort deltids array from delstate by TID.&nbsp; This prepares it for further<br/></li>
<li></span><span class="Comment"> * processing by <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This operation becomes a noticeable consumer of CPU cycles with some<br/></li>
<li></span><span class="Comment"> * workloads, so we go to the trouble of specialization/micro optimization.<br/></li>
<li></span><span class="Comment"> * We use shellsort for this because it's easy to specialize, compiles to<br/></li>
<li></span><span class="Comment"> * relatively few instructions, and is adaptive to presorted inputs/subsets<br/></li>
<li></span><span class="Comment"> * (which are typical here).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L7972">&#x200c;</a></span><span class="linkable">index_delete_sort</span>(TM_IndexDeleteOp *delstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_IndexDelete *deltids = delstate-&gt;deltids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeltids = delstate-&gt;ndeltids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shellsort gap sequence (taken from Sedgewick-Incerpi paper).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This implementation is fast with array sizes up to ~4500.&nbsp; This covers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all supported BLCKSZ <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; gaps[<span class="Constant">9</span>] = {<span class="Constant">1968</span>, <span class="Constant">861</span>, <span class="Constant">336</span>, <span class="Constant">112</span>, <span class="Constant">48</span>, <span class="Constant">21</span>, <span class="Constant">7</span>, <span class="Constant">3</span>, <span class="Constant">1</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Think carefully <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing anything here -- keep swaps cheap */<br/></li>
<li></span>&nbsp; &nbsp; StaticAssertDecl(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexDelete) &lt;= <span class="Constant">8</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> size exceeds 8 bytes&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> g = <span class="Constant">0</span>; g &lt; lengthof(gaps); g++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> hi = gaps[g], i = low + hi; i &lt; ndeltids; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete d = deltids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (j &gt;= hi &amp;&amp; <a href="#L7936" title="access/heap/heapam.c:7936">index_delete_sort_cmp</a>(&amp;deltids[j - hi], &amp;d) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deltids[j] = deltids[j - hi];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j -= hi;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deltids[j] = d;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns how many blocks should be considered favorable/contiguous for a<br/></li>
<li></span><span class="Comment"> * bottom-up index deletion pass.&nbsp; This is a number of heap blocks that starts<br/></li>
<li></span><span class="Comment"> * from and includes the first block in line.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is always at least one favorable block during bottom-up index<br/></li>
<li></span><span class="Comment"> * deletion.&nbsp; In the worst case (i.e. with totally random heap blocks) the<br/></li>
<li></span><span class="Comment"> * first block in line (the only favorable block) can be thought of as a<br/></li>
<li></span><span class="Comment"> * degenerate array of contiguous blocks that consists of a single block.<br/></li>
<li></span><span class="Comment"> * <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a>() will expect this.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller passes blockgroups, a description of the final order that deltids<br/></li>
<li></span><span class="Comment"> * will be sorted in for <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a>() bottom-up index deletion<br/></li>
<li></span><span class="Comment"> * processing.&nbsp; Note that deltids need not actually be sorted just yet (caller<br/></li>
<li></span><span class="Comment"> * only passes deltids to us so that we can interpret blockgroups).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * You might guess that the existence of contiguous blocks cannot matter much,<br/></li>
<li></span><span class="Comment"> * since in general the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> factor that determines which blocks we visit is<br/></li>
<li></span><span class="Comment"> * the number of promising TIDs, which is a fixed hint from the index AM.<br/></li>
<li></span><span class="Comment"> * We're not really targeting the general case, though -- the actual goal is<br/></li>
<li></span><span class="Comment"> * to adapt our behavior to a wide variety of naturally occurring conditions.<br/></li>
<li></span><span class="Comment"> * The effects of most of the heuristics we apply are only noticeable in the<br/></li>
<li></span><span class="Comment"> * aggregate, over time and across many _related_ bottom-up index deletion<br/></li>
<li></span><span class="Comment"> * passes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Deeming certain blocks favorable allows heapam to recognize and adapt to<br/></li>
<li></span><span class="Comment"> * workloads where heap blocks visited during bottom-up index deletion can be<br/></li>
<li></span><span class="Comment"> * accessed contiguously, in the sense that each newly visited block is the<br/></li>
<li></span><span class="Comment"> * neighbor of the block that bottom-up deletion just finished processing (or<br/></li>
<li></span><span class="Comment"> * close enough to it).&nbsp; It will likely be cheaper to access more favorable<br/></li>
<li></span><span class="Comment"> * blocks sooner rather than later (e.g. in this pass, not across a series of<br/></li>
<li></span><span class="Comment"> * related bottom-up passes).&nbsp; Either way it is probably only a matter of time<br/></li>
<li></span><span class="Comment"> * (or a matter of further correlated version churn) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> all blocks that<br/></li>
<li></span><span class="Comment"> * appear together as a single large batch of favorable blocks get accessed by<br/></li>
<li></span><span class="Comment"> * _some_ bottom-up pass.&nbsp; Large batches of favorable blocks tend to either<br/></li>
<li></span><span class="Comment"> * appear almost constantly or not even once (it all depends on per-index<br/></li>
<li></span><span class="Comment"> * workload characteristics).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the blockgroups sort order applies a power-of-two bucketing<br/></li>
<li></span><span class="Comment"> * scheme that creates opportunities for contiguous groups of blocks to get<br/></li>
<li></span><span class="Comment"> * batched together, at least with workloads that are naturally amenable to<br/></li>
<li></span><span class="Comment"> * being driven by heap block locality.&nbsp; This doesn't just enhance the spatial<br/></li>
<li></span><span class="Comment"> * locality of bottom-up heap block processing in the obvious way.&nbsp; It also<br/></li>
<li></span><span class="Comment"> * enables temporal locality of access, since sorting by heap block number<br/></li>
<li></span><span class="Comment"> * naturally tends to make the bottom-up processing order deterministic.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider the following example to get a sense of how temporal locality<br/></li>
<li></span><span class="Comment"> * might matter: There is a heap relation with several indexes, each of which<br/></li>
<li></span><span class="Comment"> * is low to medium cardinality.&nbsp; It is subject to constant non-HOT updates.<br/></li>
<li></span><span class="Comment"> * The updates are skewed (in one part of the primary key, perhaps).&nbsp; None of<br/></li>
<li></span><span class="Comment"> * the indexes are logically modified by the UPDATE statements (if they were<br/></li>
<li></span><span class="Comment"> * then bottom-up index deletion would not be triggered in the first place).<br/></li>
<li></span><span class="Comment"> * Naturally, each new round of index tuples (for each heap tuple that gets a<br/></li>
<li></span><span class="Comment"> * <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a>() call) will have the same heap TID in each and every index.<br/></li>
<li></span><span class="Comment"> * Since these indexes are low cardinality and never get logically modified,<br/></li>
<li></span><span class="Comment"> * heapam processing during bottom-up deletion passes will access heap blocks<br/></li>
<li></span><span class="Comment"> * in approximately sequential order.&nbsp; Temporal locality of access occurs due<br/></li>
<li></span><span class="Comment"> * to bottom-up deletion passes behaving very similarly across each of the<br/></li>
<li></span><span class="Comment"> * indexes at <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given moment.&nbsp; This keeps the number of buffer misses needed<br/></li>
<li></span><span class="Comment"> * to visit heap blocks to a minimum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L8069">&#x200c;</a></span><span class="linkable">bottomup_nblocksfavorable</span>(<a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *blockgroups, <span class="Type">int</span> nblockgroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *deltids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; lastblock = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocksfavorable = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nblockgroups &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(nblockgroups &lt;= <a href="#L189" title="access/heap/heapam.c:189">BOTTOMUP_MAX_NBLOCKS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We tolerate heap blocks that will be accessed only slightly out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical order.&nbsp; Small blips occur when a pair of almost-contiguous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks happen to fall into different buckets (perhaps due only to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * small difference in npromisingtids that the bucketing scheme didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quite manage to ignore).&nbsp; We effectively ignore these blips by applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a small tolerance.&nbsp; The precise tolerance we use is a little arbitrary,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it works well enough in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> b = <span class="Constant">0</span>; b &lt; nblockgroups; b++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *group = blockgroups + b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *firstdtid = deltids + group-&gt;ifirsttid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber block = ItemPointerGetBlockNumber(&amp;firstdtid-&gt;tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lastblock != -<span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((int64) block &lt; lastblock - <a href="#L190" title="access/heap/heapam.c:190">BOTTOMUP_TOLERANCE_NBLOCKS</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (int64) block &gt; lastblock + <a href="#L190" title="access/heap/heapam.c:190">BOTTOMUP_TOLERANCE_NBLOCKS</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nblocksfavorable++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastblock = block;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Always indicate that there is at least 1 favorable block */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nblocksfavorable &gt;= <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nblocksfavorable;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort comparison function for <a href="#L8185" title="access/heap/heapam.c:8185">bottomup_sort_and_shrink</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L8112">&#x200c;</a></span><span class="linkable">bottomup_sort_and_shrink_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *arg1, <span class="Type">const</span> <span class="Type">void</span> *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *group1 = (<span class="Type">const</span> <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *) arg1;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *group2 = (<span class="Type">const</span> <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *) arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most significant field is npromisingtids (which we invert the order of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so as to sort in desc order).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller should have already normalized npromisingtids fields into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * power-of-two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (buckets).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (group1-&gt;npromisingtids &gt; group2-&gt;npromisingtids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (group1-&gt;npromisingtids &lt; group2-&gt;npromisingtids)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tiebreak: desc ntids sort order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot expect power-of-two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for ntids fields.&nbsp; We should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behave as if they were already rounded up for us instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (group1-&gt;ntids != group2-&gt;ntids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; ntids1 = pg_nextpower2_32((uint32) group1-&gt;ntids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; ntids2 = pg_nextpower2_32((uint32) group2-&gt;ntids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntids1 &gt; ntids2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntids1 &lt; ntids2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tiebreak: asc offset-into-deltids-for-block (offset to first TID for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block in deltids array) order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is equivalent to sorting in ascending heap block number order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (among otherwise <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> subsets of the array).&nbsp; This approach allows us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid accessing the out-of-line TID.&nbsp; (We rely on the assumption<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the deltids array was sorted in ascending heap TID order when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these offsets to the first TID from each heap block group were formed.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (group1-&gt;ifirsttid &gt; group2-&gt;ifirsttid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (group1-&gt;ifirsttid &lt; group2-&gt;ifirsttid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_unreachable();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L7627" title="access/heap/heapam.c:7627">heap_index_delete_tuples</a>() helper function for bottom-up deletion callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sorts deltids array in the order needed for useful processing by bottom-up<br/></li>
<li></span><span class="Comment"> * deletion.&nbsp; The array should already be sorted in TID order when we're<br/></li>
<li></span><span class="Comment"> * called.&nbsp; The sort process groups heap TIDs from deltids into heap block<br/></li>
<li></span><span class="Comment"> * groupings.&nbsp; Earlier/more-promising groups/blocks are usually those that are<br/></li>
<li></span><span class="Comment"> * known to have the most &quot;promising&quot; TIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets new size of deltids array (ndeltids) in state.&nbsp; deltids will only have<br/></li>
<li></span><span class="Comment"> * TIDs from the <a href="#L189" title="access/heap/heapam.c:189">BOTTOMUP_MAX_NBLOCKS</a> most promising heap blocks when we<br/></li>
<li></span><span class="Comment"> * return.&nbsp; This often means that deltids will be shrunk to a small fraction<br/></li>
<li></span><span class="Comment"> * of its original size (we eliminate many heap blocks from consideration for<br/></li>
<li></span><span class="Comment"> * caller up front).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of &quot;favorable&quot; blocks.&nbsp; See <a href="#L8069" title="access/heap/heapam.c:8069">bottomup_nblocksfavorable</a>()<br/></li>
<li></span><span class="Comment"> * for a definition and full details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L8185">&#x200c;</a></span><span class="linkable">bottomup_sort_and_shrink</span>(TM_IndexDeleteOp *delstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *blockgroups;<br/></li>
<li>&nbsp; &nbsp; TM_IndexDelete *reordereddeltids;<br/></li>
<li>&nbsp; &nbsp; BlockNumber curblock = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblockgroups = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncopied = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocksfavorable = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delstate-&gt;bottomup);<br/></li>
<li>&nbsp; &nbsp; Assert(delstate-&gt;ndeltids &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate per-heap-block count of TIDs */<br/></li>
<li></span>&nbsp; &nbsp; blockgroups = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a>) * delstate-&gt;ndeltids);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; delstate-&gt;ndeltids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *ideltid = &amp;delstate-&gt;deltids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexStatus *istatus = delstate-&gt;status + ideltid-&gt;id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointer htid = &amp;ideltid-&gt;tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; promising = istatus-&gt;promising;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curblock != ItemPointerGetBlockNumber(htid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New block group */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblockgroups++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(curblock &lt; ItemPointerGetBlockNumber(htid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !BlockNumberIsValid(curblock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curblock = ItemPointerGetBlockNumber(htid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockgroups[nblockgroups - <span class="Constant">1</span>].ifirsttid = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockgroups[nblockgroups - <span class="Constant">1</span>].ntids = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockgroups[nblockgroups - <span class="Constant">1</span>].npromisingtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockgroups[nblockgroups - <span class="Constant">1</span>].ntids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (promising)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blockgroups[nblockgroups - <span class="Constant">1</span>].npromisingtids++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're about ready to sort block groups to determine the optimal order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for visiting heap blocks.&nbsp; But <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do, round the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * promising tuples for each block group up to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> power-of-two,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless it is very low (less than 4), in which case we round up to 4.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * npromisingtids is far too noisy to trust when choosing between a pair<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of block groups that both have very low <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This scheme divides heap blocks/block groups into buckets.&nbsp; Each bucket<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains blocks that have _approximately_ the same number of promising<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TIDs as each other.&nbsp; The goal is to ignore relatively small differences<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the total number of promising entries, so that the whole process can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * give a little weight to heapam factors (like heap block locality)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead.&nbsp; This isn't a trade-off, really -- we have nothing to lose. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be foolish to interpret small differences in npromisingtids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as anything more than noise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We tiebreak on nhtids when sorting block group subsets that have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same npromisingtids, but this has the same issues as npromisingtids,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and so nhtids is subject to the same power-of-two bucketing scheme. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only reason that we don't fix nhtids in the same way here too is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll need accurate nhtids <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> after the sort.&nbsp; We handle nhtids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bucketization dynamically instead (in the sort comparator).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See <a href="#L8069" title="access/heap/heapam.c:8069">bottomup_nblocksfavorable</a>() for a full explanation of when and how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap locality/favorable blocks can significantly influence when and how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap blocks are accessed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> b = <span class="Constant">0</span>; b &lt; nblockgroups; b++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *group = blockgroups + b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Better off falling back on nhtids with low npromisingtids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (group-&gt;npromisingtids &lt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group-&gt;npromisingtids = <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; group-&gt;npromisingtids =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_nextpower2_32((uint32) group-&gt;npromisingtids);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort groups and rearrange caller's deltids array */<br/></li>
<li></span>&nbsp; &nbsp; qsort(blockgroups, nblockgroups, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8112" title="access/heap/heapam.c:8112">bottomup_sort_and_shrink_cmp</a>);<br/></li>
<li>&nbsp; &nbsp; reordereddeltids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(delstate-&gt;ndeltids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexDelete));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nblockgroups = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L189" title="access/heap/heapam.c:189">BOTTOMUP_MAX_NBLOCKS</a>, nblockgroups);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine number of favorable blocks at the start of final deltids */<br/></li>
<li></span>&nbsp; &nbsp; nblocksfavorable = <a href="#L8069" title="access/heap/heapam.c:8069">bottomup_nblocksfavorable</a>(blockgroups, nblockgroups,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; delstate-&gt;deltids);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> b = <span class="Constant">0</span>; b &lt; nblockgroups; b++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="access/heap/heapam.c:196">IndexDeleteCounts</a> *group = blockgroups + b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *firstdtid = delstate-&gt;deltids + group-&gt;ifirsttid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(reordereddeltids + ncopied, firstdtid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexDelete) * group-&gt;ntids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ncopied += group-&gt;ntids;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy final grouped and sorted TIDs back into start of caller's array */<br/></li>
<li></span>&nbsp; &nbsp; memcpy(delstate-&gt;deltids, reordereddeltids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexDelete) * ncopied);<br/></li>
<li>&nbsp; &nbsp; delstate-&gt;ndeltids = ncopied;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(reordereddeltids);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(blockgroups);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nblocksfavorable;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> for a heap-visible operation.&nbsp; 'block' is the block<br/></li>
<li></span><span class="Comment"> * being marked all-visible, and vm_buffer is the buffer containing the<br/></li>
<li></span><span class="Comment"> * corresponding visibility map block.&nbsp; Both should have already been modified<br/></li>
<li></span><span class="Comment"> * and dirtied.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * snapshotConflictHorizon comes from the largest xmin on the page being<br/></li>
<li></span><span class="Comment"> * marked all-visible.&nbsp; REDO routine uses it to generate recovery conflicts.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If checksums or <a href="../transam/xlog.c.html#L123" title="access/transam/xlog.c:123">wal_log_hints</a> are enabled, we may also generate a full-page<br/></li>
<li></span><span class="Comment"> * image of heap_buffer. Otherwise, we <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> away the FPI (by specifying<br/></li>
<li></span><span class="Comment"> * REGBUF_NO_IMAGE for the heap buffer), in which case the caller should *not*<br/></li>
<li></span><span class="Comment"> * update the heap page's LSN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L8314">&#x200c;</a><span class="linkable">log_heap_visible</span>(Relation rel, Buffer heap_buffer, Buffer vm_buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId snapshotConflictHorizon, uint8 vmflags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_heap_visible xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(heap_buffer));<br/></li>
<li>&nbsp; &nbsp; Assert(BufferIsValid(vm_buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.snapshotConflictHorizon = snapshotConflictHorizon;<br/></li>
<li>&nbsp; &nbsp; xlrec.flags = vmflags;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsAccessibleInLogicalDecoding(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= VISIBILITYMAP_XLOG_CATALOG_REL;<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapVisible);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, vm_buffer, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; flags = REGBUF_STANDARD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogHintBitIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags |= REGBUF_NO_IMAGE;<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, heap_buffer, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP2_ID, XLOG_HEAP2_VISIBLE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> for a heap-update operation.&nbsp; Caller must already<br/></li>
<li></span><span class="Comment"> * have modified the buffer(s) and marked them dirty.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L8348">&#x200c;</a><span class="linkable">log_heap_update</span>(Relation reln, Buffer oldbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer newbuf, HeapTuple oldtup, HeapTuple newtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple old_key_tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> all_visible_cleared, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> new_all_visible_cleared)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_heap_update xlrec;<br/></li>
<li>&nbsp; &nbsp; xl_heap_header xlhdr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_header xlhdr_idx;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; prefix_suffix[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; prefixlen = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suffixlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(newbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_tuple_data = RelationIsLogicallyLogged(reln);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; init;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller should not call me on a non-WAL-logged relation */<br/></li>
<li></span>&nbsp; &nbsp; Assert(RelationNeedsWAL(reln));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsHeapOnly(newtup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP_HOT_UPDATE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP_UPDATE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the old and new tuple are on the same page, we only need to log the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parts of the new tuple that were changed.&nbsp; That saves on the amount of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL we need to write.&nbsp; Currently, we just count <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unchanged bytes in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the beginning and end of the tuple.&nbsp; That's quick to check, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perfectly covers the common case that only one field is updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could do this even if the old and new tuple are on different pages,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but only if we don't make a full-page image of the old page, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * difficult to know in advance.&nbsp; Also, if the old tuple is corrupt for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some reason, it would allow the corruption to propagate the new page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it seems best to avoid.&nbsp; Under the general assumption that most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updates tend to create the new tuple version on the same page, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't much to be gained by doing this across pages anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Skip this if we're taking a full-page image of the new page, as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't include the new tuple in the WAL record in that case.&nbsp; Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disable if <a href="../transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a>='logical', as logical decoding needs to be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read the new tuple in whole from the WAL record alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldbuf == newbuf &amp;&amp; !need_tuple_data &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../transam/xloginsert.c.html#L1027" title="access/transam/xloginsert.c:1027">XLogCheckBufferNeedsBackup</a>(newbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oldp = (<span class="Type">char</span> *) oldtup-&gt;t_data + oldtup-&gt;t_data-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *newp = (<span class="Type">char</span> *) newtup-&gt;t_data + newtup-&gt;t_data-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldlen = oldtup-&gt;t_len - oldtup-&gt;t_data-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen = newtup-&gt;t_len - newtup-&gt;t_data-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for common prefix between old and new tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (prefixlen = <span class="Constant">0</span>; prefixlen &lt; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(oldlen, newlen); prefixlen++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newp[prefixlen] != oldp[prefixlen])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Storing the length of the prefix takes 2 bytes, so we need to save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at least 3 bytes or there's no point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefixlen &lt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefixlen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same for suffix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (suffixlen = <span class="Constant">0</span>; suffixlen &lt; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(oldlen, newlen) - prefixlen; suffixlen++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newp[newlen - suffixlen - <span class="Constant">1</span>] != oldp[oldlen - suffixlen - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (suffixlen &lt; <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suffixlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> WAL data chain */<br/></li>
<li></span>&nbsp; &nbsp; xlrec.flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (all_visible_cleared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_all_visible_cleared)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prefixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_PREFIX_FROM_OLD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (suffixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_SUFFIX_FROM_OLD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (need_tuple_data)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_CONTAINS_NEW_TUPLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (old_key_tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;rd_rel-&gt;relreplident == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_CONTAINS_OLD_TUPLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLH_UPDATE_CONTAINS_OLD_KEY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If new tuple is the single and first tuple on page... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerGetOffsetNumber(&amp;(newtup-&gt;t_self)) == FirstOffsetNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageGetMaxOffsetNumber(page) == FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; info |= XLOG_HEAP_INIT_PAGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; init = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; init = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare WAL data for the old page */<br/></li>
<li></span>&nbsp; &nbsp; xlrec.old_offnum = ItemPointerGetOffsetNumber(&amp;oldtup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; xlrec.old_xmax = HeapTupleHeaderGetRawXmax(oldtup-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; xlrec.old_infobits_set = <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>(oldtup-&gt;t_data-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldtup-&gt;t_data-&gt;t_infomask2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare WAL data for the new page */<br/></li>
<li></span>&nbsp; &nbsp; xlrec.new_offnum = ItemPointerGetOffsetNumber(&amp;newtup-&gt;t_self);<br/></li>
<li>&nbsp; &nbsp; xlrec.new_xmax = HeapTupleHeaderGetRawXmax(newtup-&gt;t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bufflags = REGBUF_STANDARD;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (init)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufflags |= REGBUF_WILL_INIT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (need_tuple_data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bufflags |= REGBUF_KEEP_DATA;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, newbuf, bufflags);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldbuf != newbuf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, oldbuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapUpdate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare WAL data for the new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prefixlen &gt; <span class="Constant">0</span> || suffixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefixlen &gt; <span class="Constant">0</span> &amp;&amp; suffixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix_suffix[<span class="Constant">0</span>] = prefixlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prefix_suffix[<span class="Constant">1</span>] = suffixlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;prefix_suffix, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16) * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prefixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;prefixlen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;suffixlen, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlhdr.t_infomask2 = newtup-&gt;t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; xlhdr.t_infomask = newtup-&gt;t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; xlhdr.t_hoff = newtup-&gt;t_data-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; Assert(SizeofHeapTupleHeader + prefixlen + suffixlen &lt;= newtup-&gt;t_len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PG73FORMAT: write bitmap [+ padding] [+ oid] + data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The 'data' doesn't include the common prefix or suffix.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;xlhdr, SizeOfHeapHeader);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prefixlen == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) newtup-&gt;t_data) + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup-&gt;t_len - SizeofHeapTupleHeader - suffixlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have to write the null bitmap and data after the common prefix as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * two separate rdata entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bitmap [+ padding] [+ oid] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newtup-&gt;t_data-&gt;t_hoff - SizeofHeapTupleHeader &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) newtup-&gt;t_data) + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup-&gt;t_data-&gt;t_hoff - SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* data after common prefix */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) newtup-&gt;t_data) + newtup-&gt;t_data-&gt;t_hoff + prefixlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup-&gt;t_len - newtup-&gt;t_data-&gt;t_hoff - prefixlen - suffixlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to log a tuple identity */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (need_tuple_data &amp;&amp; old_key_tuple)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't really need this, but its more comfy to decode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xlhdr_idx.t_infomask2 = old_key_tuple-&gt;t_data-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlhdr_idx.t_infomask = old_key_tuple-&gt;t_data-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlhdr_idx.t_hoff = old_key_tuple-&gt;t_data-&gt;t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlhdr_idx, SizeOfHeapHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG73FORMAT: write bitmap [+ padding] [+ oid] + data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) old_key_tuple-&gt;t_data + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; old_key_tuple-&gt;t_len - SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* filtering by origin on a row level is much more efficient */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L456" title="access/transam/xloginsert.c:456">XLogSetRecordFlags</a>(XLOG_INCLUDE_ORIGIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP_ID, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> of an XLOG_HEAP2_NEW_CID record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only used in <a href="../transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> &gt;= WAL_LEVEL_LOGICAL, and only for catalog<br/></li>
<li></span><span class="Comment"> * tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L8570">&#x200c;</a><span class="linkable">log_heap_new_cid</span>(Relation relation, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_heap_new_cid xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader hdr = tup-&gt;t_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;tup-&gt;t_self));<br/></li>
<li>&nbsp; &nbsp; Assert(tup-&gt;t_tableOid != InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.top_xid = <a href="../transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; xlrec.target_locator = relation-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; xlrec.target_tid = tup-&gt;t_self;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple got inserted &amp; deleted in the same TX we definitely have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * combo CID, set cmin and cmax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;t_infomask &amp; HEAP_COMBOCID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(hdr-&gt;t_infomask &amp; HEAP_XMAX_INVALID));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHeaderXminInvalid(hdr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.cmin = <a href="../../utils/time/combocid.c.html#L104" title="utils/time/combocid.c:104">HeapTupleHeaderGetCmin</a>(hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.cmax = <a href="../../utils/time/combocid.c.html#L118" title="utils/time/combocid.c:118">HeapTupleHeaderGetCmax</a>(hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.combocid = HeapTupleHeaderGetRawCommandId(hdr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No combo CID, so only cmin or cmax can be set by this TX */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple inserted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to check for LOCK ONLY because multixacts might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transferred to the new tuple in case of FOR <a href="../../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE updates in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which case there will be an xmax, although the tuple just got<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hdr-&gt;t_infomask &amp; HEAP_XMAX_INVALID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HEAP_XMAX_IS_LOCKED_ONLY(hdr-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.cmin = HeapTupleHeaderGetRawCommandId(hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.cmax = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple from a different tx updated or deleted. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.cmin = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.cmax = HeapTupleHeaderGetRawCommandId(hdr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.combocid = InvalidCommandId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't need to register the buffer here, because this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation does not modify the page. The insert/update/delete that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called us certainly did, but that's WAL-logged separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapNewCid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* will be looked at irrespective of origin */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP2_ID, XLOG_HEAP2_NEW_CID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> recptr;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a heap tuple representing the configured REPLICA IDENTITY to represent<br/></li>
<li></span><span class="Comment"> * the old tuple in an UPDATE or DELETE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns NULL if there's no need to log an identity or if there's no suitable<br/></li>
<li></span><span class="Comment"> * key defined.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass key_required true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> replica identity columns changed value, or if<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> external data.&nbsp; <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> must always pass true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * *copy is set to true if the returned tuple is a modified copy rather than<br/></li>
<li></span><span class="Comment"> * the same tuple that was passed in.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> HeapTuple<br/></li>
<li><a id="L8651">&#x200c;</a><span class="linkable">ExtractReplicaIdentity</span>(Relation relation, HeapTuple tp, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> key_required,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *copy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; desc = RelationGetDescr(relation);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; replident = relation-&gt;rd_rel-&gt;relreplident;<br/></li>
<li>&nbsp; &nbsp; Bitmapset&nbsp; *idattrs;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; key_tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[MaxHeapAttributeNumber];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[MaxHeapAttributeNumber];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *copy = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationIsLogicallyLogged(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replident == REPLICA_IDENTITY_NOTHING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (replident == REPLICA_IDENTITY_FULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When logging the entire old tuple, it very well could contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toasted columns. If so, force them to be inlined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *copy = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="heaptoast.c.html#L350" title="access/heap/heaptoast.c:350">toast_flatten_tuple</a>(tp, desc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if the key isn't required and we're only logging the key, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!key_required)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the replica identity columns */<br/></li>
<li></span>&nbsp; &nbsp; idattrs = <a href="../../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INDEX_ATTR_BITMAP_IDENTITY_KEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's no defined replica identity columns, treat as !key_required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This case should not be reachable from <a href="#L3146" title="access/heap/heapam.c:3146">heap_update</a>, since that should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculate key_required accurately.&nbsp; But <a href="#L2679" title="access/heap/heapam.c:2679">heap_delete</a> just passes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constant true for key_required, so we can hit this case in deletes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (bms_is_empty(idattrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a new tuple containing only the replica identity columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with nulls elsewhere.&nbsp; While we're at it, assert that the replica<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identity columns aren't null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1345" title="access/common/heaptuple.c:1345">heap_deform_tuple</a>(tp, desc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; desc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(i + <span class="Constant">1</span> - FirstLowInvalidHeapAttributeNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idattrs))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!nulls[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; key_tuple = <a href="../common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(desc, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; *copy = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../nodes/bitmapset.c.html#L239" title="nodes/bitmapset.c:239">bms_free</a>(idattrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tuple, which by here only contains indexed columns, still has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toasted columns, force them to be inlined. This is somewhat unlikely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since there's limits on the size of indexed columns, so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate <a href="heaptoast.c.html#L350" title="access/heap/heaptoast.c:350">toast_flatten_tuple</a>()s functionality in the above loop over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indexed columns, even if it would be more efficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasExternal(key_tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; oldtup = key_tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key_tuple = <a href="heaptoast.c.html#L350" title="access/heap/heaptoast.c:350">toast_flatten_tuple</a>(oldtup, desc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(oldtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> key_tuple;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replay XLOG_HEAP2_PRUNE_* <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8743">&#x200c;</a></span><span class="linkable">heap_xlog_prune_freeze</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *maindataptr = XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; xl_heap_prune xlrec;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, &amp;blkno);<br/></li>
<li>&nbsp; &nbsp; memcpy(&amp;xlrec, maindataptr, SizeOfHeapPrune);<br/></li>
<li>&nbsp; &nbsp; maindataptr += SizeOfHeapPrune;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will take an ordinary exclusive lock or a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock depending on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the XLHP_CLEANUP_LOCK flag is set.&nbsp; With an ordinary exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, we better not be doing anything that requires moving existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((xlrec.flags &amp; XLHP_CLEANUP_LOCK) != <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xlrec.flags &amp; (XLHP_HAS_REDIRECTIONS | XLHP_HAS_DEAD_ITEMS)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are about to remove and/or freeze tuples.&nbsp; In Hot Standby mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that there are no queries running for which the removed tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are still visible or which still consider the frozen xids as running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The conflict horizon XID comes after xl_heap_prune.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((xlrec.flags &amp; XLHP_HAS_CONFLICT_HORIZON) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId snapshot_conflict_horizon;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* memcpy() because snapshot_conflict_horizon is stored unaligned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;snapshot_conflict_horizon, maindataptr, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maindataptr += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a>(snapshot_conflict_horizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xlrec.flags &amp; XLHP_IS_CATALOG_REL) != <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have a full-page image, restore it and we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; action = <a href="../transam/xlogutils.c.html#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a>(record, <span class="Constant">0</span>, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xlrec.flags &amp; XLHP_CLEANUP_LOCK) != <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *redirected;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *nowdead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *nowunused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nredirected;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nplans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlhp_freeze_plan *plans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *frz_offsets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *dataptr = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../rmgrdesc/heapdesc.c.html#L104" title="access/rmgrdesc/heapdesc.c:104">heap_xlog_deserialize_prune_and_freeze</a>(dataptr, xlrec.flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nplans, &amp;plans, &amp;frz_offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nredirected, &amp;redirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ndead, &amp;nowdead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;nunused, &amp;nowunused);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update all line pointers per the record, and repair fragmentation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nredirected &gt; <span class="Constant">0</span> || ndead &gt; <span class="Constant">0</span> || nunused &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pruneheap.c.html#L1540" title="access/heap/pruneheap.c:1540">heap_page_prune_execute</a>(buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xlrec.flags &amp; XLHP_CLEANUP_LOCK) == <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; redirected, nredirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowdead, ndead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowunused, nunused);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Freeze tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> p = <span class="Constant">0</span>; p &lt; nplans; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFreeze frz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert freeze plan representation from WAL record into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * per-tuple format used by <a href="#L6815" title="access/heap/heapam.c:6815">heap_execute_freeze_tuple</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz.xmax = plans[p].xmax;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz.t_infomask2 = plans[p].t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz.t_infomask = plans[p].t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz.frzflags = plans[p].frzflags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz.offset = InvalidOffsetNumber;&nbsp; &nbsp; <span class="Comment">/* unused, but be tidy */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; plans[p].ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offset = *(frz_offsets++);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L6815" title="access/heap/heapam.c:6815">heap_execute_freeze_tuple</a>(tuple, &amp;frz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There should be no more data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((<span class="Type">char</span> *) frz_offsets == dataptr + datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we don't worry about updating the page's prunability hints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At worst this will cause an extra prune cycle to occur soon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we released <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> space or line pointers, update the free space map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do this regardless of a full-page image being applied, since the FSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data is not in the page anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec.flags &amp; (XLHP_HAS_REDIRECTIONS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLHP_HAS_DEAD_ITEMS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLHP_HAS_NOW_UNUSED_ITEMS))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(BufferGetPage(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L211" title="storage/freespace/freespace.c:211">XLogRecordPageWithFreeSpace</a>(rlocator, blkno, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Replay XLOG_HEAP2_VISIBLE record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The critical integrity requirement here is that we must never end up with<br/></li>
<li></span><span class="Comment"> * a situation where the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set, and the page-level<br/></li>
<li></span><span class="Comment"> * PD_ALL_VISIBLE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is clear.&nbsp; If that were to occur, then a subsequent<br/></li>
<li></span><span class="Comment"> * page modification would fail to clear the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L8895">&#x200c;</a></span><span class="linkable">heap_xlog_visible</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_visible *xlrec = (xl_heap_visible *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((xlrec-&gt;flags &amp; VISIBILITYMAP_XLOG_VALID_BITS) == xlrec-&gt;flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">1</span>, &amp;rlocator, <span class="Constant">NULL</span>, &amp;blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Hot Standby transactions running that have an xmin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * horizon old enough that this page isn't all-visible for them, they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might incorrectly decide that an index-only scan can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a heap fetch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: It might be better to throw some kind of &quot;soft&quot; conflict here that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forces <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index-only scan that is in flight to perform heap fetches,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than killing the transaction outright.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a>(xlrec-&gt;snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;flags &amp; VISIBILITYMAP_XLOG_CATALOG_REL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the heap page, if it still exists. If the heap file has dropped or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * truncated later in recovery, we don't need to update the page, but we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better still update the visibility map.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; action = <a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't bump the LSN of the heap page when setting the visibility<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> (unless checksums or wal_hint_bits is enabled, in which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case we must). This exposes us to torn page hazards, but since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're not inspecting the existing page contents in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't care.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogHintBitIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (action == BLK_RESTORED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If heap block was backed up, we already restored it and there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing more to do. (This can only happen with checksums or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../transam/xlog.c.html#L123" title="access/transam/xlog.c:123">wal_log_hints</a> enabled.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; space = <a href="../../storage/page/bufpage.c.html#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a>(BufferGetPage(buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since FSM is not WAL-logged and only updated heuristically, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * easily becomes stale in standbys.&nbsp; If the standby is later promoted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and runs VACUUM, it will <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> updating individual free space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * figures for pages that became all-visible (or all-frozen, depending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> mode,) which is troublesome when <a href="../../storage/freespace/freespace.c.html#L358" title="storage/freespace/freespace.c:358">FreeSpaceMapVacuum</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * propagates too optimistic free space <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> FSM layers;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later inserters try to use such pages only to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out that they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are unusable.&nbsp; This can cause long stalls when there are many such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forestall those problems by updating FSM's idea about a page that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is becoming all-visible or all-frozen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do this regardless of a full-page image being applied, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FSM data is not in the page anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; VISIBILITYMAP_VALID_BITS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L211" title="storage/freespace/freespace.c:211">XLogRecordPageWithFreeSpace</a>(rlocator, blkno, space);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if we skipped the heap page update due to the LSN interlock, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still safe to update the visibility map.&nbsp; Any WAL record that clears<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> does so <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> checking the page LSN, so <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bits that need to be cleared will still be cleared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a>(record, <span class="Constant">0</span>, RBM_ZERO_ON_ERROR, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;vmbuffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; vmpage = BufferGetPage(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; vmbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page if it was read as zeros */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(vmpage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(vmpage, BLCKSZ, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove VISIBILITYMAP_XLOG_* */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vmbits = xlrec-&gt;flags &amp; VISIBILITYMAP_VALID_BITS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../transam/xlogutils.c.html#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a> locked the buffer. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a> will handle locking itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(vmbuffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(rlocator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, blkno, &amp;vmbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>(reln, blkno, InvalidBuffer, lsn, vmbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;snapshotConflictHorizon, vmbits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (BufferIsValid(vmbuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(vmbuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an &quot;infobits&quot; field from an XLog record, set the correct bits in the<br/></li>
<li></span><span class="Comment"> * given infomask and infomask2 for the tuple touched by the record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (This is the reverse of <a href="#L2634" title="access/heap/heapam.c:2634">compute_infobits</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9030">&#x200c;</a></span><span class="linkable">fix_infomask_from_infobits</span>(uint8 infobits, uint16 *infomask, uint16 *infomask2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; *infomask &amp;= ~(HEAP_XMAX_IS_MULTI | HEAP_XMAX_LOCK_ONLY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_XMAX_KEYSHR_LOCK | HEAP_XMAX_EXCL_LOCK);<br/></li>
<li>&nbsp; &nbsp; *infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infobits &amp; XLHL_XMAX_IS_MULTI)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_XMAX_IS_MULTI;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infobits &amp; XLHL_XMAX_LOCK_ONLY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_XMAX_LOCK_ONLY;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infobits &amp; XLHL_XMAX_EXCL_LOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_XMAX_EXCL_LOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* note HEAP_XMAX_SHR_LOCK isn't considered here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (infobits &amp; XLHL_XMAX_KEYSHR_LOCK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infomask |= HEAP_XMAX_KEYSHR_LOCK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (infobits &amp; XLHL_KEYS_UPDATED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *infomask2 |= HEAP_KEYS_UPDATED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9051">&#x200c;</a></span><span class="linkable">heap_xlog_delete</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_delete *xlrec = (xl_heap_delete *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator target_locator;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData target_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;target_locator, <span class="Constant">NULL</span>, &amp;blkno);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetBlockNumber(&amp;target_tid, blkno);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetOffsetNumber(&amp;target_tid, xlrec-&gt;offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_DELETE_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(target_locator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, blkno, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, blkno, vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= xlrec-&gt;offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, xlrec-&gt;offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; xlrec-&gt;offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderClearHotUpdated(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9030" title="access/heap/heapam.c:9030">fix_infomask_from_infobits</a>(xlrec-&gt;infobits_set,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;htup-&gt;t_infomask, &amp;htup-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(xlrec-&gt;flags &amp; XLH_DELETE_IS_SUPER))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(htup, xlrec-&gt;xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmin(htup, InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmax(htup, FirstCommandId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the page as a candidate for pruning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageSetPrunable(page, XLogRecGetXid(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_DELETE_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure t_ctid is set correctly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_DELETE_IS_PARTITION_MOVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetMovedPartitions(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_ctid = target_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9124">&#x200c;</a></span><span class="linkable">heap_xlog_insert</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_insert *xlrec = (xl_heap_insert *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderData hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[MaxHeapTupleSize];<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbuf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; xl_heap_header xlhdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newlen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator target_locator;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData target_tid;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;target_locator, <span class="Constant">NULL</span>, &amp;blkno);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetBlockNumber(&amp;target_tid, blkno);<br/></li>
<li>&nbsp; &nbsp; ItemPointerSetOffsetNumber(&amp;target_tid, xlrec-&gt;offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_INSERT_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(target_locator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, blkno, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, blkno, vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we inserted the first and only tuple on the page, re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page from scratch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecGetInfo(record) &amp; XLOG_HEAP_INIT_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BufferGetPageSize(buffer), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; action = BLK_NEEDS_REDO;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; action = <a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) + <span class="Constant">1</span> &lt; xlrec-&gt;offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid max offset number&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newlen = datalen - SizeOfHeapHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(datalen &gt; SizeOfHeapHeader &amp;&amp; newlen &lt;= MaxHeapTupleSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) &amp;xlhdr, data, SizeOfHeapHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; data += SizeOfHeapHeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = &amp;tbuf.hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet((<span class="Type">char</span> *) htup, <span class="Constant">0</span>, SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG73FORMAT: get bitmap [+ padding] [+ oid] + data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) htup + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newlen += SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 = xlhdr.t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask = xlhdr.t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_hoff = xlhdr.t_hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmin(htup, XLogRecGetXid(record));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmin(htup, FirstCommandId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_ctid = target_tid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) htup, newlen, xlrec-&gt;offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Constant">true</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add tuple&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page); <span class="Comment">/* needed to update FSM below */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_INSERT_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLH_INSERT_ALL_FROZEN_SET implies that all tuples are visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_INSERT_ALL_FROZEN_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the page is running low on free space, update the FSM as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arbitrarily, our definition of &quot;low&quot; is less than 20%. We can't do much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better than that without knowing the fill-factor for the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Don't do this if the page was restored from full page image. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't bother to update the FSM in that case, it doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally accurate anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO &amp;&amp; freespace &lt; BLCKSZ / <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L211" title="storage/freespace/freespace.c:211">XLogRecordPageWithFreeSpace</a>(target_locator, blkno, freespace);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handles MULTI_INSERT record type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9244">&#x200c;</a></span><span class="linkable">heap_xlog_multi_insert</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_multi_insert *xlrec;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderData hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[MaxHeapTupleSize];<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbuf;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newlen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isinit = (XLogRecGetInfo(record) &amp; XLOG_HEAP_INIT_PAGE) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Insertion doesn't overwrite MVCC data, so no conflict processing is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xlrec = (xl_heap_multi_insert *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, &amp;blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that the mutually exclusive flags are not both set */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!((xlrec-&gt;flags &amp; XLH_INSERT_ALL_VISIBLE_CLEARED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (xlrec-&gt;flags &amp; XLH_INSERT_ALL_FROZEN_SET)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_INSERT_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(rlocator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, blkno, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, blkno, vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isinit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BufferGetPageSize(buffer), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; action = BLK_NEEDS_REDO;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; action = <a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tupdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *endptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuples are stored as block data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdata = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; endptr = tupdata + len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xlrec-&gt;ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_multi_insert_tuple *xlhdr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're reinitializing the page, the tuples are stored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order from FirstOffsetNumber. Otherwise there's an array of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offsets in the WAL record, and the tuples come after that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isinit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = FirstOffsetNumber + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;offsets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) + <span class="Constant">1</span> &lt; offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid max offset number&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlhdr = (xl_multi_insert_tuple *) SHORTALIGN(tupdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdata = ((<span class="Type">char</span> *) xlhdr) + SizeOfMultiInsertTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen = xlhdr-&gt;datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newlen &lt;= MaxHeapTupleSize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = &amp;tbuf.hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemSet((<span class="Type">char</span> *) htup, <span class="Constant">0</span>, SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PG73FORMAT: get bitmap [+ padding] [+ oid] + data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) htup + SizeofHeapTupleHeader,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) tupdata,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; newlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdata += newlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newlen += SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 = xlhdr-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask = xlhdr-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_hoff = xlhdr-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmin(htup, XLogRecGetXid(record));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmin(htup, FirstCommandId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetBlockNumber(&amp;htup-&gt;t_ctid, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetOffsetNumber(&amp;htup-&gt;t_ctid, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = PageAddItem(page, (Item) htup, newlen, offnum, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupdata != endptr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;total tuple length mismatch&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page); <span class="Comment">/* needed to update FSM below */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_INSERT_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLH_INSERT_ALL_FROZEN_SET implies that all tuples are visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_INSERT_ALL_FROZEN_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the page is running low on free space, update the FSM as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arbitrarily, our definition of &quot;low&quot; is less than 20%. We can't do much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better than that without knowing the fill-factor for the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Don't do this if the page was restored from full page image. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't bother to update the FSM in that case, it doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally accurate anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (action == BLK_NEEDS_REDO &amp;&amp; freespace &lt; BLCKSZ / <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L211" title="storage/freespace/freespace.c:211">XLogRecordPageWithFreeSpace</a>(rlocator, blkno, freespace);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handles UPDATE and HOT_UPDATE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9391">&#x200c;</a></span><span class="linkable">heap_xlog_update</span>(XLogReaderState *record, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hot_update)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_update *xlrec = (xl_heap_update *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; BlockNumber oldblk;<br/></li>
<li>&nbsp; &nbsp; BlockNumber newblk;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData newtid;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; obuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData oldtup;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; prefixlen = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; suffixlen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *newp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">union<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderData hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[MaxHeapTupleSize];<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tbuf;<br/></li>
<li>&nbsp; &nbsp; xl_heap_header xlhdr;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; newlen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction oldaction;<br/></li>
<li>&nbsp; &nbsp; XLogRedoAction newaction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> to keep the compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; oldtup.t_data = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; oldtup.t_len = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, &amp;newblk);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogreader.c.html#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(record, <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;oldblk, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOT updates are never done across pages */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!hot_update);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldblk = newblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSet(&amp;newtid, newblk, xlrec-&gt;new_offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(rlocator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, oldblk, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, oldblk, vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal operation, it is important to lock the two pages in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page-number order, to avoid possible deadlocks against other update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operations going the other way.&nbsp; However, during WAL replay there can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be no other update happening, so we don't need to worry about that. But<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we *do* need to worry that we don't expose an inconsistent state to Hot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Standby queries --- so the original page can't be unlocked <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added the new tuple to the new page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with old tuple version */<br/></li>
<li></span>&nbsp; &nbsp; oldaction = <a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, (oldblk == newblk) ? <span class="Constant">0</span> : <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;obuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldaction == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(obuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;old_offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_data = htup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldtup.t_len = ItemIdGetLength(lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hot_update)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetHotUpdated(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderClearHotUpdated(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9030" title="access/heap/heapam.c:9030">fix_infomask_from_infobits</a>(xlrec-&gt;old_infobits_set, &amp;htup-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;htup-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(htup, xlrec-&gt;old_xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmax(htup, FirstCommandId, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set forward chain link in t_ctid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_ctid = newtid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the page as a candidate for pruning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageSetPrunable(page, XLogRecGetXid(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_UPDATE_OLD_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(obuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the page the new tuple goes into, if different from old.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldblk == newblk)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbuffer = obuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newaction = oldaction;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (XLogRecGetInfo(record) &amp; XLOG_HEAP_INIT_PAGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbuffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(nbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, BufferGetPageSize(nbuffer), <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newaction = BLK_NEEDS_REDO;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newaction = <a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;nbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(rlocator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, newblk, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, newblk, vmbuffer, VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Deal with new tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newaction == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *recdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *recdata_end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recdata = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;datalen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recdata_end = recdata + datalen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(nbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;new_offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) + <span class="Constant">1</span> &lt; offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid max offset number&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_UPDATE_PREFIX_FROM_OLD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newblk == oldblk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;prefixlen, recdata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recdata += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_UPDATE_SUFFIX_FROM_OLD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newblk == oldblk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;suffixlen, recdata, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recdata += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) &amp;xlhdr, recdata, SizeOfHeapHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recdata += SizeOfHeapHeader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplen = recdata_end - recdata;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplen &lt;= MaxHeapTupleSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = &amp;tbuf.hdr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet((<span class="Type">char</span> *) htup, <span class="Constant">0</span>, SizeofHeapTupleHeader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reconstruct the new tuple using the prefix and/or suffix from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * old tuple, and the data stored in the WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newp = (<span class="Type">char</span> *) htup + SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prefixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy bitmap [+ padding] [+ oid] from WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = xlhdr.t_hoff - SizeofHeapTupleHeader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newp, recdata, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recdata += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newp += len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy prefix from old tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newp, (<span class="Type">char</span> *) oldtup.t_data + oldtup.t_data-&gt;t_hoff, prefixlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newp += prefixlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy new tuple data from WAL record */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = tuplen - (xlhdr.t_hoff - SizeofHeapTupleHeader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newp, recdata, len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recdata += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newp += len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * copy bitmap [+ padding] [+ oid] + data from record, all in one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newp, recdata, tuplen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recdata += tuplen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newp += tuplen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(recdata == recdata_end);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy suffix from old tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (suffixlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(newp, (<span class="Type">char</span> *) oldtup.t_data + oldtup.t_len - suffixlen, suffixlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newlen = SizeofHeapTupleHeader + tuplen + prefixlen + suffixlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 = xlhdr.t_infomask2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask = xlhdr.t_infomask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_hoff = xlhdr.t_hoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmin(htup, XLogRecGetXid(record));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmin(htup, FirstCommandId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(htup, xlrec-&gt;new_xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure there is no forward chain link in t_ctid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_ctid = newtid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = PageAddItem(page, (Item) htup, newlen, offnum, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add tuple&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_UPDATE_NEW_ALL_VISIBLE_CLEARED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageClearAllVisible(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page); <span class="Comment">/* needed to update FSM below */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(nbuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(nbuffer) &amp;&amp; nbuffer != obuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(nbuffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(obuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(obuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the new page is running low on free space, update the FSM as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arbitrarily, our definition of &quot;low&quot; is less than 20%. We can't do much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * better than that without knowing the fill-factor for the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, don't update the FSM on HOT updates, because after crash<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, either the old or the new tuple will certainly be dead and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prunable. After pruning, the page will have roughly as much free space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as it did <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the update, assuming the new tuple is about the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size as the old one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Don't do this if the page was restored from full page image. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't bother to update the FSM in that case, it doesn't need to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * totally accurate anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newaction == BLK_NEEDS_REDO &amp;&amp; !hot_update &amp;&amp; freespace &lt; BLCKSZ / <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L211" title="storage/freespace/freespace.c:211">XLogRecordPageWithFreeSpace</a>(rlocator, newblk, freespace);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9663">&#x200c;</a></span><span class="linkable">heap_xlog_confirm</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_confirm *xlrec = (xl_heap_confirm *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Confirm tuple as actually inserted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;htup-&gt;t_ctid, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer), offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9699">&#x200c;</a></span><span class="linkable">heap_xlog_lock</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_lock *xlrec = (xl_heap_lock *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_LOCK_ALL_FROZEN_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, &amp;block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(rlocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, block, vmbuffer, VISIBILITYMAP_ALL_FROZEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9030" title="access/heap/heapam.c:9030">fix_infomask_from_infobits</a>(xlrec-&gt;infobits_set, &amp;htup-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;htup-&gt;t_infomask2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear relevant update flags, but only if the modified infomask says<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HEAP_XMAX_IS_LOCKED_ONLY(htup-&gt;t_infomask))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderClearHotUpdated(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure there is no forward chain link in t_ctid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;htup-&gt;t_ctid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(htup, xlrec-&gt;xmax);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetCmax(htup, FirstCommandId, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9770">&#x200c;</a></span><span class="linkable">heap_xlog_lock_updated</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_lock_updated *xlrec;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec = (xl_heap_lock_updated *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility map may need to be fixed even if the heap page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already up-to-date.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;flags &amp; XLH_LOCK_ALL_FROZEN_CLEARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; vmbuffer = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, &amp;block);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(rlocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>(reln, block, &amp;vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="visibilitymap.c.html#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>(reln, block, vmbuffer, VISIBILITYMAP_ALL_FROZEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(vmbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(reln);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask &amp;= ~(HEAP_XMAX_BITS | HEAP_MOVED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup-&gt;t_infomask2 &amp;= ~HEAP_KEYS_UPDATED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9030" title="access/heap/heapam.c:9030">fix_infomask_from_infobits</a>(xlrec-&gt;infobits_set, &amp;htup-&gt;t_infomask,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;htup-&gt;t_infomask2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeaderSetXmax(htup, xlrec-&gt;xmax);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L9830">&#x200c;</a></span><span class="linkable">heap_xlog_inplace</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_heap_inplace *xlrec = (xl_heap_inplace *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; oldlen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newlen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *newtup = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;newlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = xlrec-&gt;offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &gt;= offnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageGetMaxOffsetNumber(page) &lt; offnum || !ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;invalid lp&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldlen = ItemIdGetLength(lp) - htup-&gt;t_hoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldlen != newlen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;wrong tuple length&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy((<span class="Type">char</span> *) htup + htup-&gt;t_hoff, newtup, newlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L9871">&#x200c;</a></span><span class="linkable">heap_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These operations don't overwrite MVCC data so no conflict processing is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required. The ones in heap2 rmgr do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (info &amp; XLOG_HEAP_OPMASK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9124" title="access/heap/heapam.c:9124">heap_xlog_insert</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9051" title="access/heap/heapam.c:9051">heap_xlog_delete</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9391" title="access/heap/heapam.c:9391">heap_xlog_update</a>(record, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_TRUNCATE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TRUNCATE is a no-op because the actions are already logged as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SMGR WAL <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; TRUNCATE WAL record only exists for logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_HOT_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9391" title="access/heap/heapam.c:9391">heap_xlog_update</a>(record, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_CONFIRM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9663" title="access/heap/heapam.c:9663">heap_xlog_confirm</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_LOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9699" title="access/heap/heapam.c:9699">heap_xlog_lock</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP_INPLACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9830" title="access/heap/heapam.c:9830">heap_xlog_inplace</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L9871" title="access/heap/heapam.c:9871">heap_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L9917">&#x200c;</a></span><span class="linkable">heap2_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (info &amp; XLOG_HEAP_OPMASK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_PRUNE_ON_ACCESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_PRUNE_VACUUM_SCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_PRUNE_VACUUM_CLEANUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8743" title="access/heap/heapam.c:8743">heap_xlog_prune_freeze</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_VISIBLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L8895" title="access/heap/heapam.c:8895">heap_xlog_visible</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_MULTI_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9244" title="access/heap/heapam.c:9244">heap_xlog_multi_insert</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_LOCK_UPDATED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L9770" title="access/heap/heapam.c:9770">heap_xlog_lock_updated</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_NEW_CID:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nothing to do on a real replay, only used during logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decoding.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_HEAP2_REWRITE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="rewriteheap.c.html#L1073" title="access/heap/rewriteheap.c:1073">heap_xlog_logical_rewrite</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L9917" title="access/heap/heapam.c:9917">heap2_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mask a heap page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing consistency checks on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L9956">&#x200c;</a></span><span class="linkable">heap_mask</span>(<span class="Type">char</span> *pagedata, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) pagedata;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L46" title="access/common/bufmask.c:46">mask_page_hint_bits</a>(page);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L71" title="access/common/bufmask.c:71">mask_unused_space</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (off = <span class="Constant">1</span>; off &lt;= PageGetMaxOffsetNumber(page); off++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *page_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page_item = (<span class="Type">char</span> *) (page + ItemIdGetOffset(iid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsNormal(iid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader page_htup = (HeapTupleHeader) page_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If xmin of a tuple is not yet frozen, we should ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differences in hint bits, since they can be set without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitting WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderXminFrozen(page_htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_htup-&gt;t_infomask &amp;= ~HEAP_XACT_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still we need to mask xmax hint bits. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_htup-&gt;t_infomask &amp;= ~HEAP_XMAX_INVALID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_htup-&gt;t_infomask &amp;= ~HEAP_XMAX_COMMITTED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During replay, we set Command Id to FirstCommandId. Hence, mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it. See <a href="#L9124" title="access/heap/heapam.c:9124">heap_xlog_insert</a>() for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_htup-&gt;t_choice.t_heap.t_field3.t_cid = MASK_MARKER;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For a speculative tuple, <a href="#L1990" title="access/heap/heapam.c:1990">heap_insert</a>() does not set ctid in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller-passed heap tuple itself, leaving the ctid field to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain a speculative token value - a per-backend monotonically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increasing identifier. Besides, it does not WAL-log ctid under<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> circumstances.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * During redo, <a href="#L9124" title="access/heap/heapam.c:9124">heap_xlog_insert</a>() sets t_ctid to current block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number and self offset number. It doesn't care about <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * speculative insertions on the primary. Hence, we set t_ctid to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current block number and self offset number to ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inconsistency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHeaderIsSpeculative(page_htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;page_htup-&gt;t_ctid, blkno, off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: Not ignoring ctid changes due to the tuple having moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (i.e. HeapTupleHeaderIndicatesMovedPartitions), because that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important information that needs to be in-sync between primary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and standby, and thus is WAL logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding bytes after the tuple, when the length of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item is not MAXALIGNed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdHasStorage(iid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len = ItemIdGetLength(iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; padlen = MAXALIGN(len) - len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (padlen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(page_item + len, MASK_MARKER, padlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L10052" title="access/heap/heapam.c:10052">HeapCheckForSerializableConflictOut</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We are reading a tuple.&nbsp; If it's not visible, there may be a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rw-conflict out with the inserter.&nbsp; Otherwise, if it is visible to us<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; but has been deleted, there may be a rw-conflict out with the deleter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We will determine the top level xid of the writing transaction with which<br/></li>
<li></span><span class="Comment"> * we may be in conflict, and ask <a href="../../storage/lmgr/predicate.c.html#L4008" title="storage/lmgr/predicate.c:4008">CheckForSerializableConflictOut</a>() to check<br/></li>
<li></span><span class="Comment"> * for overlap with our own transaction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should be called just about anywhere in heapam.c where a<br/></li>
<li></span><span class="Comment"> * tuple has been read. The caller must hold at least a shared lock on the<br/></li>
<li></span><span class="Comment"> * buffer, because this function might set hint bits on the tuple. There is<br/></li>
<li></span><span class="Comment"> * currently no known reason to call this function from an index AM.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L10052">&#x200c;</a></span><span class="linkable">HeapCheckForSerializableConflictOut</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> visible, Relation relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple tuple, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId xid;<br/></li>
<li>&nbsp; &nbsp; HTSV_Result htsvResult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/lmgr/predicate.c.html#L3976" title="storage/lmgr/predicate.c:3976">CheckForSerializableConflictOutNeeded</a>(relation, snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see whether the tuple has been written to by a concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction, either to create it not visible to us, or to delete it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while it is visible to us.&nbsp; The &quot;visible&quot; <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> indicates whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple is visible to us, while <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a> checks what else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is going on with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the event of a concurrently inserted tuple that also happens to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been concurrently updated (by a separate transaction), the xmin of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple will be used -- not the updater's xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; htsvResult = <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>(tuple, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>, buffer);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (htsvResult)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_LIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (visible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetXmin(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_RECENTLY_DEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DELETE_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (visible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetUpdateXid(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetXmin(tuple-&gt;t_data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is like the HEAPTUPLE_DEAD case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!visible);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_INSERT_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = HeapTupleHeaderGetXmin(tuple-&gt;t_data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!visible);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The only way to get to this default clause is if a new value is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added to the enum type without adding it to this switch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statement.&nbsp; That's a bug, so elog.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized return value from <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>: </span><span class="Special">%u</span><span class="Constant">&quot;</span>, htsvResult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In spite of having all enum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> covered and calling elog on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this default, some compilers think this is a code path which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allows xid to be used below without initialization. Silence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that warning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(TransactionIdIsValid(xid));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../transam/transam.c.html#L329" title="access/transam/transam.c:329">TransactionIdFollowsOrEquals</a>(xid, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find top level xid.&nbsp; Bail out if xid is too early to be a conflict, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it's our own xid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdEquals(xid, <a href="../transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; xid = <a href="../transam/subtrans.c.html#L163" title="access/transam/subtrans.c:163">SubTransGetTopmostTransaction</a>(xid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, <a href="../../utils/time/snapmgr.c.html#L98" title="utils/time/snapmgr.c:98">TransactionXmin</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L4008" title="storage/lmgr/predicate.c:4008">CheckForSerializableConflictOut</a>(relation, xid, snapshot);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
