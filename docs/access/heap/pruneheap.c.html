<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/pruneheap.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/pruneheap.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L153">PruneState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1764">heap_get_root_tuples</a></li>
<li><a href="#L1891">heap_log_freeze_cmp</a></li>
<li><a href="#L1875">heap_log_freeze_eq</a></li>
<li><a href="#L1937">heap_log_freeze_new_plan</a></li>
<li><a href="#L1957">heap_log_freeze_plan</a></li>
<li><a href="#L348">heap_page_prune_and_freeze</a></li>
<li><a href="#L1540">heap_page_prune_execute</a></li>
<li><a href="#L193">heap_page_prune_opt</a></li>
<li><a href="#L978">heap_prune_chain</a></li>
<li><a href="#L1225">heap_prune_record_dead</a></li>
<li><a href="#L1259">heap_prune_record_dead_or_unused</a></li>
<li><a href="#L1180">heap_prune_record_prunable</a></li>
<li><a href="#L1194">heap_prune_record_redirect</a></li>
<li><a href="#L1487">heap_prune_record_unchanged_lp_dead</a></li>
<li><a href="#L1309">heap_prune_record_unchanged_lp_normal</a></li>
<li><a href="#L1515">heap_prune_record_unchanged_lp_redirect</a></li>
<li><a href="#L1298">heap_prune_record_unchanged_lp_unused</a></li>
<li><a href="#L1276">heap_prune_record_unused</a></li>
<li><a href="#L915">heap_prune_satisfies_vacuum</a></li>
<li><a href="#L939">htsv_get_valid_status</a></li>
<li><a href="#L2032">log_heap_prune_and_freeze</a></li>
<li><a href="#L1716">page_verify_redirects</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pruneheap.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; heap page pruning and HOT-chain management code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/pruneheap.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Working data for <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() and subroutines */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Arguments passed to <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* tuple visibility test, initialized for the relation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *vistest;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* whether or not dead items can be set LP_UNUSED during pruning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mark_unused_now;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* whether to attempt freezing tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> VacuumCutoffs *cutoffs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fields describing what to do to the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId new_prune_xid;&nbsp; &nbsp; <span class="Comment">/* new prune hint value */<br/></li>
<li></span>&nbsp; &nbsp; TransactionId latest_xid_removed;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nredirected;&nbsp; &nbsp; <span class="Comment">/* numbers of entries in arrays below */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndead;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nunused;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfrozen;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* arrays that accumulate indexes of items to be changed */<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber redirected[MaxHeapTuplesPerPage * <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber nowdead[MaxHeapTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; OffsetNumber nowunused[MaxHeapTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; HeapTupleFreeze frozen[MaxHeapTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Working state for HOT chain processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'root_items' contains offsets of all LP_REDIRECT line pointers and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal non-HOT tuples.&nbsp; They can be stand-alone items or the first item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in a HOT chain.&nbsp; 'heaponly_items' contains heap-only tuples which can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only be removed as part of a HOT chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nroot_items;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber root_items[MaxHeapTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nheaponly_items;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber heaponly_items[MaxHeapTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed[offnum] is true if item at offnum has been processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This needs to be MaxHeapTuplesPerPage + 1 long as FirstOffsetNumber is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. Otherwise every access would need to subtract 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; processed[MaxHeapTuplesPerPage + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tuple visibility is only computed once for each tuple, for correctness<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and efficiency reasons; see comment in <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * details.&nbsp; This is of type int8[], instead of HTSV_Result[], so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use -1 to indicate no visibility has been computed, e.g. for LP_DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This needs to be MaxHeapTuplesPerPage + 1 long as FirstOffsetNumber is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. Otherwise every access would need to subtract 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; int8&nbsp; &nbsp; &nbsp; &nbsp; htsv[MaxHeapTuplesPerPage + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Freezing-related state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HeapPageFreeze pagefrz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*-------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Information about what was done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These fields are not used by pruning itself for the most part, but are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used to collect information about what was pruned and what state the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page is in after pruning, for the benefit of the caller.&nbsp; They are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copied to the caller's PruneFreezeResult at the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -------------------------------------------------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeleted;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Number of tuples deleted from the page */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Number of live and recently dead tuples, after pruning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; live_tuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recently_dead_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Whether or not the page makes rel truncation unsafe */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hastup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LP_DEAD items on the page after pruning.&nbsp; Includes existing LP_DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lpdead_items;&nbsp; &nbsp; <span class="Comment">/* number of items in the array */<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber *deadoffsets;&nbsp; &nbsp; <span class="Comment">/* points directly to presult-&gt;deadoffsets */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all_visible and all_frozen indicate if the all-visible and all-frozen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bits in the visibility map can be set for this page after pruning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visibility_cutoff_xid is the newest xmin of live tuples on the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller can use it as the conflict horizon, when setting the VM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bits.&nbsp; It is only valid if we froze some tuples, and all_frozen is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: all_visible and all_frozen don't include LP_DEAD items.&nbsp; That's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * convenient for <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>(), to use them to decide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether to freeze the page or not.&nbsp; The all_visible and all_frozen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> returned to the caller are adjusted to include LP_DEAD items at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all_frozen should only be considered valid if all_visible is also set;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't bother to clear the all_frozen flag every time we clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all_visible flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_visible;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; all_frozen;<br/></li>
<li>&nbsp; &nbsp; TransactionId visibility_cutoff_xid;<br/></li>
<li><a id="L153">&#x200c;</a>} <span class="linkable">PruneState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Local <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><span class="Type">static</span> HTSV_Result <a href="#L915" title="access/heap/pruneheap.c:915">heap_prune_satisfies_vacuum</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer buffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> HTSV_Result <a href="#L939" title="access/heap/pruneheap.c:939">htsv_get_valid_status</a>(<span class="Type">int</span> status);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L978" title="access/heap/pruneheap.c:978">heap_prune_chain</a>(Page page, BlockNumber blockno, OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber rootoffnum, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1180" title="access/heap/pruneheap.c:1180">heap_prune_record_prunable</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, TransactionId xid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1194" title="access/heap/pruneheap.c:1194">heap_prune_record_redirect</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, OffsetNumber rdoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1225" title="access/heap/pruneheap.c:1225">heap_prune_record_dead</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1259" title="access/heap/pruneheap.c:1259">heap_prune_record_dead_or_unused</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1298" title="access/heap/pruneheap.c:1298">heap_prune_record_unchanged_lp_unused</a>(Page page, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1309" title="access/heap/pruneheap.c:1309">heap_prune_record_unchanged_lp_normal</a>(Page page, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1487" title="access/heap/pruneheap.c:1487">heap_prune_record_unchanged_lp_dead</a>(Page page, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1515" title="access/heap/pruneheap.c:1515">heap_prune_record_unchanged_lp_redirect</a>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1716" title="access/heap/pruneheap.c:1716">page_verify_redirects</a>(Page page);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Optionally prune and repair fragmentation in the specified page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is an opportunistic function.&nbsp; It will perform housekeeping<br/></li>
<li></span><span class="Comment"> * only if the page heuristically looks like a candidate for pruning and we<br/></li>
<li></span><span class="Comment"> * can acquire buffer <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock without blocking.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is called quite often.&nbsp; It's important that it fall out quickly<br/></li>
<li></span><span class="Comment"> * if there's not <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> use in pruning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have pin on the buffer, and must *not* have a lock on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="linkable">heap_page_prune_opt</span>(Relation relation, Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; TransactionId prune_xid;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *vistest;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; minfree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't write WAL in recovery mode, so there's no point trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clean the page. The primary will likely issue a cleaning WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * soon anyway, so this is no particular loss.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First check whether there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> chance there's something to prune,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determining the appropriate horizon is a waste if there's no prune_xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. no updates/deletes left potentially dead tuples around).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prune_xid = ((PageHeader) page)-&gt;pd_prune_xid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(prune_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether prune_xid indicates that there may be dead rows that can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be cleaned up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vistest = <a href="../../storage/ipc/procarray.c.html#L4091" title="storage/ipc/procarray.c:4091">GlobalVisTestFor</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/ipc/procarray.c.html#L4248" title="storage/ipc/procarray.c:4248">GlobalVisTestIsRemovableXid</a>(vistest, prune_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We prune when a previous UPDATE failed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> enough space on the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a new tuple version, or when free space falls below the relation's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fill-factor target (but not less than 10%).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checking free space here is questionable since we aren't holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock on the buffer; in the worst case we could get a bogus answer. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unlikely to be *seriously* wrong, though, since reading either pd_lower<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or pd_upper is probably atomic.&nbsp; Avoiding taking a lock seems more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * important than sometimes getting a wrong answer in what is after all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just a heuristic estimate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; minfree = RelationGetTargetPageFreeSpace(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HEAP_DEFAULT_FILLFACTOR);<br/></li>
<li>&nbsp; &nbsp; minfree = Max(minfree, BLCKSZ / <span class="Constant">10</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsFull(page) || <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page) &lt; minfree)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, try to get exclusive buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5326" title="storage/buffer/bufmgr.c:5326">ConditionalLockBufferForCleanup</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that we have buffer lock, get accurate information about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page's free space, and recheck the heuristic about whether to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prune.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsFull(page) || <a href="../../storage/page/bufpage.c.html#L991" title="storage/page/bufpage.c:991">PageGetHeapFreeSpace</a>(page) &lt; minfree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber dummy_off_loc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PruneFreezeResult presult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, pass mark_unused_now as false regardless of whether or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not the relation has indexes, since we cannot safely determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that during on-access pruning with the current implementation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>(relation, buffer, vistest, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, &amp;presult, PRUNE_ON_ACCESS, &amp;dummy_off_loc, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report the number of tuples reclaimed to pgstats.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * presult.ndeleted minus the number of newly-LP_DEAD-set items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We derive the number of dead tuples like this to avoid totally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forgetting about items that were set to LP_DEAD, since they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still need to be cleaned up by VACUUM.&nbsp; We only want to count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap-only tuples that just became LP_UNUSED in our report,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * which don't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VACUUM doesn't have to compensate in the same way when it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tracks ndeleted, since it will set the same LP_DEAD items to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LP_UNUSED separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presult.ndeleted &gt; presult.nnewlpdead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/pgstat_relation.c.html#L439" title="utils/activity/pgstat_relation.c:439">pgstat_update_heap_dead_tuples</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; presult.ndeleted - presult.nnewlpdead);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And release buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buffer, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We avoid reuse of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> free space created on the page by unrelated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * UPDATEs/INSERTs by opting to not update the FSM at this point.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free space should be reused by UPDATEs to *this* page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prune and repair fragmentation and potentially freeze tuples on the<br/></li>
<li></span><span class="Comment"> * specified page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have pin and buffer <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on the page.&nbsp; Note that we<br/></li>
<li></span><span class="Comment"> * don't update the FSM information for page on caller's behalf.&nbsp; Caller might<br/></li>
<li></span><span class="Comment"> * also need to account for a reduction in the length of the line pointer<br/></li>
<li></span><span class="Comment"> * array following array truncation by us.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the HEAP_PRUNE_FREEZE option is set, we will also freeze tuples if it's<br/></li>
<li></span><span class="Comment"> * required in order to advance relfrozenxid / relminmxid, or if it's<br/></li>
<li></span><span class="Comment"> * considered advantageous for overall system performance to do so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; The<br/></li>
<li></span><span class="Comment"> * 'cutoffs', 'presult', 'new_relfrozen_xid' and 'new_relmin_mxid' arguments<br/></li>
<li></span><span class="Comment"> * are required when freezing.&nbsp; When HEAP_PRUNE_FREEZE option is set, we also<br/></li>
<li></span><span class="Comment"> * set presult-&gt;all_visible and presult-&gt;all_frozen on exit, to indicate if<br/></li>
<li></span><span class="Comment"> * the VM bits can be set.&nbsp; They are always set to false when the<br/></li>
<li></span><span class="Comment"> * HEAP_PRUNE_FREEZE option is not set, because at the moment only callers<br/></li>
<li></span><span class="Comment"> * that also freeze need that information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * vistest is used to distinguish whether tuples are DEAD or RECENTLY_DEAD<br/></li>
<li></span><span class="Comment"> * (see <a href="#L915" title="access/heap/pruneheap.c:915">heap_prune_satisfies_vacuum</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * options:<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; MARK_UNUSED_NOW indicates that dead items can be set LP_UNUSED during<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; pruning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; FREEZE indicates that we will also freeze tuples, and will return<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; 'all_visible', 'all_frozen' flags to the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cutoffs contains the freeze cutoffs, established by VACUUM at the beginning<br/></li>
<li></span><span class="Comment"> * of vacuuming the relation.&nbsp; Required if HEAP_PRUNE_FREEZE option is set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * presult contains output parameters needed by callers, such as the number of<br/></li>
<li></span><span class="Comment"> * tuples removed and the offsets of dead items on the page after pruning.<br/></li>
<li></span><span class="Comment"> * <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() is responsible for initializing it.&nbsp; Required<br/></li>
<li></span><span class="Comment"> * by all callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * reason indicates why the pruning is performed.&nbsp; It is included in the WAL<br/></li>
<li></span><span class="Comment"> * record for debugging and analysis purposes, but otherwise has no effect.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * off_loc is the offset location required by the caller to use in error<br/></li>
<li></span><span class="Comment"> * callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * new_relfrozen_xid and new_relmin_mxid must provided by the caller if the<br/></li>
<li></span><span class="Comment"> * HEAP_PRUNE_FREEZE option is set.&nbsp; On entry, they contain the oldest XID and<br/></li>
<li></span><span class="Comment"> * multi-XID seen on the relation so far.&nbsp; They will be updated with oldest<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> present on the page after pruning.&nbsp; After processing the whole<br/></li>
<li></span><span class="Comment"> * relation, VACUUM can use these <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as the new relfrozenxid/relminmxid<br/></li>
<li></span><span class="Comment"> * for the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L348">&#x200c;</a></span><span class="linkable">heap_page_prune_and_freeze</span>(Relation relation, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/procarray.c.html#L167" title="storage/ipc/procarray.c:167">GlobalVisState</a> *vistest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> VacuumCutoffs *cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PruneFreezeResult *presult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PruneReason reason,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *off_loc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TransactionId *new_relfrozen_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MultiXactId *new_relmin_mxid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; BlockNumber blockno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a>&nbsp; &nbsp; prstate;<br/></li>
<li>&nbsp; &nbsp; HeapTupleData tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_freeze;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_prune;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_hint;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hint_bit_fpi;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; fpi_before = <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>.wal_fpi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy parameters to prstate */<br/></li>
<li></span>&nbsp; &nbsp; prstate.vistest = vistest;<br/></li>
<li>&nbsp; &nbsp; prstate.mark_unused_now = (options &amp; HEAP_PAGE_PRUNE_MARK_UNUSED_NOW) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.freeze = (options &amp; HEAP_PAGE_PRUNE_FREEZE) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.cutoffs = cutoffs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our strategy is to scan the page and make lists of items to change,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then apply the changes within a critical section.&nbsp; This keeps as much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logic as possible out of the critical section, and also ensures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * WAL replay will work the same as the normal case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the new pd_prune_xid value to zero (indicating no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prunable tuples).&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples which may soon become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prunable, we will save the lowest relevant XID in new_prune_xid. Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the rest of our working state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prstate.new_prune_xid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; prstate.latest_xid_removed = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; prstate.nredirected = prstate.ndead = prstate.nunused = prstate.nfrozen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.nroot_items = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.nheaponly_items = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> page freezing working state */<br/></li>
<li></span>&nbsp; &nbsp; prstate.pagefrz.freeze_required = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prstate.freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(new_relfrozen_xid &amp;&amp; new_relmin_mxid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.FreezePageRelfrozenXid = *new_relfrozen_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.NoFreezePageRelfrozenXid = *new_relfrozen_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.FreezePageRelminMxid = *new_relmin_mxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.NoFreezePageRelminMxid = *new_relmin_mxid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(new_relfrozen_xid == <span class="Constant">NULL</span> &amp;&amp; new_relmin_mxid == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.FreezePageRelminMxid = InvalidMultiXactId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.NoFreezePageRelminMxid = InvalidMultiXactId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.FreezePageRelfrozenXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.pagefrz.NoFreezePageRelfrozenXid = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prstate.ndeleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.live_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.recently_dead_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.hastup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.lpdead_items = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; prstate.deadoffsets = presult-&gt;deadoffsets;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller may update the VM after we're done.&nbsp; We can keep track of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the page will be all-visible and all-frozen after pruning and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freezing to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> the caller to do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, only VACUUM sets the VM bits.&nbsp; To save the effort, only do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the bookkeeping if the caller needs it.&nbsp; Currently, that's tied to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HEAP_PAGE_PRUNE_FREEZE, but it could be a separate flag if you wanted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to update the VM bits without also freezing or freeze without also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setting the VM bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In addition to telling the caller whether it can set the VM <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also use 'all_visible' and 'all_frozen' for our own decision-making. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the whole page would become frozen, we consider opportunistically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * freezing tuples.&nbsp; We will not be able to freeze the whole page if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are tuples present that are not visible to everyone or if there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dead tuples which are not yet removable.&nbsp; However, dead tuples which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be removed by the end of vacuuming should not preclude us from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opportunistically freezing.&nbsp; Because of that, we do not clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all_visible when we see LP_DEAD items.&nbsp; We fix that at the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function, when we return the value to the caller, so that the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't set the VM <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> incorrectly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prstate.freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.all_visible = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.all_frozen = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initializing to false allows skipping the work to update them in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1309" title="access/heap/pruneheap.c:1309">heap_prune_record_unchanged_lp_normal</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prstate.all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The visibility cutoff xid is the newest xmin of live tuples on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.&nbsp; In the common case, this will be set as the conflict horizon the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller can use for updating the VM.&nbsp; If, at the end of freezing and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pruning, the page is all-frozen, there is no possibility that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running transaction on the standby does not see tuples on the page as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all-visible, so the conflict horizon remains InvalidTransactionId.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; prstate.visibility_cutoff_xid = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; tup.t_tableOid = RelationGetRelid(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine HTSV for all tuples, and queue them up for processing as HOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chain roots or as heap-only items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determining HTSV only once for each tuple is required for correctness,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to deal with cases where running HTSV twice could result in different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results.&nbsp; For example, RECENTLY_DEAD can turn to DEAD if another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checked item causes <a href="../../storage/ipc/procarray.c.html#L4206" title="storage/ipc/procarray.c:4206">GlobalVisTestIsRemovableFullXid</a>() to update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * horizon, or INSERT_IN_PROGRESS can change to DEAD if the inserting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction aborts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's also good for performance. Most commonly tuples within a page are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored at decreasing offsets (while the items are stored at increasing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offsets). When processing all tuples on a page this leads to reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory at decreasing offsets within a page, with a variable stride.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That's hard for CPU prefetchers to deal with. Processing the items in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reverse order (and thus the tuples in increasing order) increases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prefetching efficiency significantly / decreases the number of cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * misses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &gt;= FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberPrev(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the offset number so that we can display it along with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error that occurred while processing this tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *off_loc = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.processed[offnum] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.htsv[offnum] = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do if slot doesn't contain a tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1298" title="access/heap/pruneheap.c:1298">heap_prune_record_unchanged_lp_unused</a>(page, &amp;prstate, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsDead(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the caller set mark_unused_now true, we can set dead line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointers LP_UNUSED <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(prstate.mark_unused_now))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>(&amp;prstate, offnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1487" title="access/heap/pruneheap.c:1487">heap_prune_record_unchanged_lp_dead</a>(page, &amp;prstate, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This is the start of a HOT chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.root_items[prstate.nroot_items++] = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(itemid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the tuple's visibility status and queue it up for processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup.t_data = htup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup.t_len = ItemIdGetLength(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(&amp;tup.t_self, blockno, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.htsv[offnum] = <a href="#L915" title="access/heap/pruneheap.c:915">heap_prune_satisfies_vacuum</a>(&amp;prstate, &amp;tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderIsHeapOnly(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.root_items[prstate.nroot_items++] = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.heaponly_items[prstate.nheaponly_items++] = offnum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If checksums are enabled, <a href="#L915" title="access/heap/pruneheap.c:915">heap_prune_satisfies_vacuum</a>() may have caused<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an FPI to be emitted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hint_bit_fpi = fpi_before != <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>.wal_fpi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process HOT chains.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We added the items to the array starting from 'maxoff', so by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing the array in reverse order, we process the items in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ascending offset number order.&nbsp; The order doesn't matter for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correctness, but some quick micro-benchmarking suggests that this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * faster.&nbsp; (Earlier PostgreSQL versions, which scanned all the items on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page instead of using the root_items array, also did it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ascending offset number order.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = prstate.nroot_items - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = prstate.root_items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore items already processed as part of an earlier chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate.processed[offnum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see preceding loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *off_loc = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process this item or chain of items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L978" title="access/heap/pruneheap.c:978">heap_prune_chain</a>(page, blockno, maxoff, offnum, &amp;prstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> heap-only tuples that were not already processed as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a HOT chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = prstate.nheaponly_items - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = prstate.heaponly_items[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate.processed[offnum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see preceding loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *off_loc = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple is DEAD and doesn't chain to anything else, mark it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unused.&nbsp; (If it does chain, we can only remove it as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pruning its chain.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need this primarily to handle aborted HOT updates, that is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XMIN_INVALID heap-only tuples.&nbsp; Those might not be linked to by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chain, since the parent tuple might be re-updated <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pruning occurs.&nbsp; So we have to be able to reap them separately from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chain-pruning.&nbsp; (Note that HeapTupleHeaderIsHotUpdated will never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return true for an XMIN_INVALID tuple, so this code will work even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when there were sequential updates within the aborted transaction.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate.htsv[offnum] == HEAPTUPLE_DEAD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup = (HeapTupleHeader) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (likely(!HeapTupleHeaderIsHotUpdated(htup)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam.c.html#L7482" title="access/heap/heapam.c:7482">HeapTupleHeaderAdvanceConflictHorizon</a>(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;prstate.latest_xid_removed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>(&amp;prstate, offnum, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This tuple should've been processed and removed as part of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a HOT chain, so something's wrong.&nbsp; To preserve evidence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't dare to remove it.&nbsp; We cannot leave behind a DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple either, because that will cause VACUUM to error out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Throwing an error with a distinct error message seems like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the least bad option.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;dead heap-only tuple (</span><span class="Special">%u</span><span class="Constant">, </span><span class="Special">%d</span><span class="Constant">) is not linked to from <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> HOT chain&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blockno, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1309" title="access/heap/pruneheap.c:1309">heap_prune_record_unchanged_lp_normal</a>(page, &amp;prstate, offnum);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have processed every tuple exactly once&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *off_loc = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(prstate.processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clear the offset information once we have processed the given page. */<br/></li>
<li></span>&nbsp; &nbsp; *off_loc = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; do_prune = prstate.nredirected &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.ndead &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.nunused &gt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if we don't prune anything, if we found a new value for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pd_prune_xid field or the page was marked full, we will update the hint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; do_hint = ((PageHeader) page)-&gt;pd_prune_xid != prstate.new_prune_xid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageIsFull(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide if we want to go ahead with freezing according to the freeze<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * plans we prepared, or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; do_freeze = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prstate.freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate.pagefrz.freeze_required)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="heapam.c.html#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a> indicated that at least one XID/MXID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> FreezeLimit/MultiXactCutoff is present.&nbsp; Must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * freeze to advance relfrozenxid/relminmxid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Opportunistically freeze the page if we are generating an FPI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway and if doing so means that we can set the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-frozen afterwards (might not happen until VACUUM's final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap pass).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Previously, we knew if pruning emitted an FPI by checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a>.wal_fpi <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after pruning.&nbsp; Once the freeze<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and prune <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> were combined, this heuristic couldn't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used anymore.&nbsp; The opportunistic freeze heuristic must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * improved; however, for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, try to approximate the old logic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate.all_visible &amp;&amp; prstate.all_frozen &amp;&amp; prstate.nfrozen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Freezing would make the page all-frozen.&nbsp; Have already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitted an FPI or will do so anyway?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hint_bit_fpi)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (do_prune)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xloginsert.c.html#L1027" title="access/transam/xloginsert.c:1027">XLogCheckBufferNeedsBackup</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (do_hint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogHintBitIsNeeded() &amp;&amp; <a href="../transam/xloginsert.c.html#L1027" title="access/transam/xloginsert.c:1027">XLogCheckBufferNeedsBackup</a>(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_freeze = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (do_freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Validate the tuples we will be freezing <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * critical section.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam.c.html#L6838" title="access/heap/heapam.c:6838">heap_pre_freeze_checks</a>(buffer, prstate.frozen, prstate.nfrozen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (prstate.nfrozen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page contained some tuples that were not already frozen, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chose not to freeze them <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; The page won't be all-frozen then.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!prstate.pagefrz.freeze_required);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate.nfrozen = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* avoid miscounts in instrumentation */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have no freeze plans to execute.&nbsp; The page might already be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-frozen (perhaps only following pruning), though.&nbsp; Such pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can be marked all-frozen in the VM by our caller, even though <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of its tuples were newly frozen here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Any error while applying the changes is critical */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (do_hint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the page's pd_prune_xid field to either zero, or the lowest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XID of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> soon-prunable tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((PageHeader) page)-&gt;pd_prune_xid = prstate.new_prune_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also clear the &quot;page is full&quot; flag, since there's no point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * repeating the prune/defrag process until something else happens to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PageClearFull(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If that's all we had to do to the page, this is a non-WAL-logged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hint.&nbsp; If we are going to freeze or prune the page, we will mark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the buffer dirty below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!do_freeze &amp;&amp; !do_prune)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buffer, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (do_prune || do_freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply the planned item changes and repair page fragmentation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_prune)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1540" title="access/heap/pruneheap.c:1540">heap_page_prune_execute</a>(buffer, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.redirected, prstate.nredirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.nowdead, prstate.ndead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.nowunused, prstate.nunused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_freeze)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam.c.html#L6891" title="access/heap/heapam.c:6891">heap_freeze_prepared_tuples</a>(buffer, prstate.frozen, prstate.nfrozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit a WAL XLOG_HEAP2_PRUNE_FREEZE record showing what we did<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The snapshotConflictHorizon for the whole record should be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most conservative of all the horizons calculated for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible modifications.&nbsp; If this record will prune tuples, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions on the standby older than the youngest xmax of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most recently removed tuple this record will prune will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflict.&nbsp; If this record will freeze tuples, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the standby with xids older than the youngest tuple this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record will freeze will conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId frz_conflict_horizon = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId conflict_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can use the visibility_cutoff_xid as our cutoff for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflicts when the whole page is eligible to become all-frozen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the VM once we're done with it.&nbsp; Otherwise we generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conservative cutoff by stepping back from OldestXmin.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_freeze)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate.all_visible &amp;&amp; prstate.all_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz_conflict_horizon = prstate.visibility_cutoff_xid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoids false conflicts when <a href="../../replication/walreceiver.c.html#L89" title="replication/walreceiver.c:89">hot_standby_feedback</a> in use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; frz_conflict_horizon = prstate.cutoffs-&gt;OldestXmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdRetreat(frz_conflict_horizon);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(frz_conflict_horizon, prstate.latest_xid_removed))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflict_xid = frz_conflict_horizon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflict_xid = prstate.latest_xid_removed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2032" title="access/heap/pruneheap.c:2032">log_heap_prune_and_freeze</a>(relation, buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conflict_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, reason,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.frozen, prstate.nfrozen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.redirected, prstate.nredirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.nowdead, prstate.ndead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate.nowunused, prstate.nunused);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy information back for caller */<br/></li>
<li></span>&nbsp; &nbsp; presult-&gt;ndeleted = prstate.ndeleted;<br/></li>
<li>&nbsp; &nbsp; presult-&gt;nnewlpdead = prstate.ndead;<br/></li>
<li>&nbsp; &nbsp; presult-&gt;nfrozen = prstate.nfrozen;<br/></li>
<li>&nbsp; &nbsp; presult-&gt;live_tuples = prstate.live_tuples;<br/></li>
<li>&nbsp; &nbsp; presult-&gt;recently_dead_tuples = prstate.recently_dead_tuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It was convenient to ignore LP_DEAD items in all_visible earlier on to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make the choice of whether or not to freeze the page unaffected by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short-term presence of LP_DEAD items.&nbsp; These LP_DEAD items were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effectively assumed to be LP_UNUSED items in the making.&nbsp; It doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter which <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> heap pass (initial pass or final pass) ends up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setting the page all-frozen, as long as the ongoing VACUUM does it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that freezing has been finalized, unset all_visible if there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items on the page.&nbsp; It needs to reflect the present state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the page, as expected by our caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prstate.all_visible &amp;&amp; prstate.lpdead_items == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; presult-&gt;all_visible = prstate.all_visible;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; presult-&gt;all_frozen = prstate.all_frozen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; presult-&gt;all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; presult-&gt;all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; presult-&gt;hastup = prstate.hastup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For callers planning to update the visibility map, the conflict horizon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for that record must be the newest xmin on the page.&nbsp; However, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page is completely frozen, there can be no conflict and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vm_conflict_horizon should remain InvalidTransactionId.&nbsp; This includes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the case that we just froze all the tuples; the prune-freeze record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * included the conflict XID already so the caller doesn't need it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (presult-&gt;all_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; presult-&gt;vm_conflict_horizon = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; presult-&gt;vm_conflict_horizon = prstate.visibility_cutoff_xid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; presult-&gt;lpdead_items = prstate.lpdead_items;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the presult-&gt;deadoffsets array was already filled in */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (prstate.freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (presult-&gt;nfrozen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *new_relfrozen_xid = prstate.pagefrz.FreezePageRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *new_relmin_mxid = prstate.pagefrz.FreezePageRelminMxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *new_relfrozen_xid = prstate.pagefrz.NoFreezePageRelfrozenXid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *new_relmin_mxid = prstate.pagefrz.NoFreezePageRelminMxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform visibility checks for heap pruning.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> HTSV_Result<br/></li>
<li><a id="L915">&#x200c;</a><span class="linkable">heap_prune_satisfies_vacuum</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, HeapTuple tup, Buffer buffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HTSV_Result res;<br/></li>
<li>&nbsp; &nbsp; TransactionId dead_after;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="heapam_visibility.c.html#L1196" title="access/heap/heapam_visibility.c:1196">HeapTupleSatisfiesVacuumHorizon</a>(tup, buffer, &amp;dead_after);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (res != HEAPTUPLE_RECENTLY_DEAD)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/ipc/procarray.c.html#L4248" title="storage/ipc/procarray.c:4248">GlobalVisTestIsRemovableXid</a>(prstate-&gt;vistest, dead_after))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = HEAPTUPLE_DEAD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pruning calculates tuple visibility once and saves the results in an array<br/></li>
<li></span><span class="Comment"> * of int8.&nbsp; See <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a>.htsv for details.&nbsp; This helper function is meant<br/></li>
<li></span><span class="Comment"> * to guard against examining visibility status array members which have not<br/></li>
<li></span><span class="Comment"> * yet been computed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> HTSV_Result<br/></li>
<li><a id="L939">&#x200c;</a><span class="linkable">htsv_get_valid_status</span>(<span class="Type">int</span> status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(status &gt;= HEAPTUPLE_DEAD &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status &lt;= HEAPTUPLE_DELETE_IN_PROGRESS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (HTSV_Result) status;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prune specified line pointer or a HOT chain originating at line pointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Tuple visibility information is provided in prstate-&gt;htsv.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the item is an index-referenced tuple (i.e. not a heap-only tuple),<br/></li>
<li></span><span class="Comment"> * the HOT chain is pruned by removing all DEAD tuples at the start of the HOT<br/></li>
<li></span><span class="Comment"> * chain.&nbsp; We also prune <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> RECENTLY_DEAD tuples preceding a DEAD tuple.<br/></li>
<li></span><span class="Comment"> * This is OK because a RECENTLY_DEAD tuple preceding a DEAD tuple is really<br/></li>
<li></span><span class="Comment"> * DEAD, our visibility test is just too coarse to detect it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pruning must never leave behind a DEAD tuple that still has tuple storage.<br/></li>
<li></span><span class="Comment"> * VACUUM isn't prepared to deal with that case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The root line pointer is redirected to the tuple immediately after the<br/></li>
<li></span><span class="Comment"> * latest DEAD tuple.&nbsp; If all tuples in the chain are DEAD, the root line<br/></li>
<li></span><span class="Comment"> * pointer is marked LP_DEAD.&nbsp; (This includes the case of a DEAD simple<br/></li>
<li></span><span class="Comment"> * tuple, which we treat as a chain of length 1.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We don't actually change the page here. We just add entries to the arrays in<br/></li>
<li></span><span class="Comment"> * prstate showing the changes to be made.&nbsp; Items to be redirected are added<br/></li>
<li></span><span class="Comment"> * to the redirected[] array (two entries per redirection); items to be set to<br/></li>
<li></span><span class="Comment"> * LP_DEAD state are added to nowdead[]; and items to be set to LP_UNUSED<br/></li>
<li></span><span class="Comment"> * state are added to nowunused[].&nbsp; We perform bookkeeping of live tuples,<br/></li>
<li></span><span class="Comment"> * visibility etc. based on what the page will look like after the changes<br/></li>
<li></span><span class="Comment"> * applied.&nbsp; All that bookkeeping is performed in the heap_prune_record_*()<br/></li>
<li></span><span class="Comment"> * subroutines.&nbsp; The division of labor is that <a href="#L978" title="access/heap/pruneheap.c:978">heap_prune_chain</a>() decides the<br/></li>
<li></span><span class="Comment"> * fate of each tuple, ie. whether it's going to be removed, redirected or<br/></li>
<li></span><span class="Comment"> * left unchanged, and the heap_prune_record_*() subroutines update <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a><br/></li>
<li></span><span class="Comment"> * based on that outcome.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L978">&#x200c;</a></span><span class="linkable">heap_prune_chain</span>(Page page, BlockNumber blockno, OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber rootoffnum, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TransactionId priorXmax = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; rootlp;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber chainitems[MaxHeapTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After traversing the HOT chain, ndeadchain is the index in chainitems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the first live successor after the last dead item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeadchain = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchain = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rootlp = PageGetItemId(page, rootoffnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start from the root tuple */<br/></li>
<li></span>&nbsp; &nbsp; offnum = rootoffnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* while not end of the chain */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check (pure paranoia) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An offset past the end of page's line pointer array is possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the array was truncated (original item must have been unused)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If item is already processed, stop --- it must not be same chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate-&gt;processed[offnum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unused item obviously isn't part of the chain. Likewise, a dead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * line pointer can't be part of the chain.&nbsp; Both of those cases were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already marked as processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsUsed(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!ItemIdIsDead(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are looking at the redirected root line pointer, jump to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first normal tuple in the chain.&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a redirect somewhere<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else, stop --- it must not be same chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nchain &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not at start of chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chainitems[nchain++] = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemIdGetRedirect(rootlp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the tuple XMIN against prior XMAX, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(priorXmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(HeapTupleHeaderGetXmin(htup), priorXmax))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, this tuple is indeed a member of the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; chainitems[nchain++] = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L939" title="access/heap/pruneheap.c:939">htsv_get_valid_status</a>(prstate-&gt;htsv[offnum]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DEAD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember the last DEAD tuple seen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeadchain = nchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heapam.c.html#L7482" title="access/heap/heapam.c:7482">HeapTupleHeaderAdvanceConflictHorizon</a>(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;prstate-&gt;latest_xid_removed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chain member */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_RECENTLY_DEAD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to advance the conflict horizon for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RECENTLY_DEAD tuples, even if we are removing them.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is because we only remove RECENTLY_DEAD tuples if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precede a DEAD tuple, and the DEAD tuple must have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserted by a newer transaction than the RECENTLY_DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple by virtue of being later in the chain.&nbsp; We will have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advanced the conflict horizon for the DEAD tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance past RECENTLY_DEAD tuples just in case there's a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DEAD one after them.&nbsp; We have to make sure that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DEAD tuples, since DEAD tuples that still have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple storage after pruning will confuse VACUUM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DELETE_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_LIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_INSERT_IN_PROGRESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> process_chain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a> result&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> process_chain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the tuple is not HOT-updated, then we are at the end of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HOT-update chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderIsHotUpdated(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> process_chain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOT implies it can't have moved to different partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHeaderIndicatesMovedPartitions(htup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chain member.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerGetBlockNumber(&amp;htup-&gt;t_ctid) == blockno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = ItemPointerGetOffsetNumber(&amp;htup-&gt;t_ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; priorXmax = HeapTupleHeaderGetUpdateXid(htup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(rootlp) &amp;&amp; nchain &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found a redirect item that doesn't point to a valid follow-on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item.&nbsp; This can happen if the loop in <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caused us to visit the dead successor of a redirect item <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visiting the redirect item.&nbsp; We can clean up by setting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redirect item to LP_DEAD state or LP_UNUSED if the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="access/heap/pruneheap.c:1259">heap_prune_record_dead_or_unused</a>(prstate, rootoffnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">process_chain</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndeadchain == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No DEAD tuple was found, so the chain is entirely composed of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * normal, unchanged tuples.&nbsp; Leave it alone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsRedirected(rootlp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1515" title="access/heap/pruneheap.c:1515">heap_prune_record_unchanged_lp_redirect</a>(prstate, rootoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; i &lt; nchain; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1309" title="access/heap/pruneheap.c:1309">heap_prune_record_unchanged_lp_normal</a>(page, prstate, chainitems[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ndeadchain == nchain)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The entire chain is dead.&nbsp; Mark the root line pointer LP_DEAD, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fully remove the other tuples in the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1259" title="access/heap/pruneheap.c:1259">heap_prune_record_dead_or_unused</a>(prstate, rootoffnum, ItemIdIsNormal(rootlp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; nchain; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>(prstate, chainitems[i], <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We found a DEAD tuple in the chain.&nbsp; Redirect the root line pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the first non-DEAD tuple, and mark as unused each intermediate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item that we are able to remove from the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1194" title="access/heap/pruneheap.c:1194">heap_prune_record_redirect</a>(prstate, rootoffnum, chainitems[ndeadchain],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemIdIsNormal(rootlp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; ndeadchain; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>(prstate, chainitems[i], <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the rest of tuples in the chain are normal, unchanged tuples */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = ndeadchain; i &lt; nchain; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1309" title="access/heap/pruneheap.c:1309">heap_prune_record_unchanged_lp_normal</a>(page, prstate, chainitems[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Record lowest soon-prunable XID */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1180">&#x200c;</a></span><span class="linkable">heap_prune_record_prunable</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, TransactionId xid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should exactly match the PageSetPrunable macro.&nbsp; We can't store<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly into the page header yet, so we update working state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(TransactionIdIsNormal(xid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!TransactionIdIsValid(prstate-&gt;new_prune_xid) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xid, prstate-&gt;new_prune_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;new_prune_xid = xid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Record line pointer to be redirected */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1194">&#x200c;</a></span><span class="linkable">heap_prune_record_redirect</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, OffsetNumber rdoffnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do not mark the redirect target here.&nbsp; It needs to be counted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separately as an unchanged tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(prstate-&gt;nredirected &lt; MaxHeapTuplesPerPage);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;redirected[prstate-&gt;nredirected * <span class="Constant">2</span>] = offnum;<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;redirected[prstate-&gt;nredirected * <span class="Constant">2</span> + <span class="Constant">1</span>] = rdoffnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prstate-&gt;nredirected++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the root entry had been a normal tuple, we are deleting it, so count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it in the result.&nbsp; But changing a redirect (even to DEAD state) doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (was_normal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;ndeleted++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prstate-&gt;hastup = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Record line pointer to be marked dead */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1225">&#x200c;</a></span><span class="linkable">heap_prune_record_dead</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(prstate-&gt;ndead &lt; MaxHeapTuplesPerPage);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;nowdead[prstate-&gt;ndead] = offnum;<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;ndead++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deliberately delay unsetting all_visible until later during pruning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Removable dead tuples shouldn't preclude freezing the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record the dead offset for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> */<br/></li>
<li></span>&nbsp; &nbsp; prstate-&gt;deadoffsets[prstate-&gt;lpdead_items++] = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the root entry had been a normal tuple, we are deleting it, so count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it in the result.&nbsp; But changing a redirect (even to DEAD state) doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (was_normal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;ndeleted++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Depending on whether or not the caller set mark_unused_now to true, record that a<br/></li>
<li></span><span class="Comment"> * line pointer should be marked LP_DEAD or LP_UNUSED. There are other cases in<br/></li>
<li></span><span class="Comment"> * which we will mark line pointers LP_UNUSED, but we will not mark line<br/></li>
<li></span><span class="Comment"> * pointers LP_DEAD if mark_unused_now is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1259">&#x200c;</a></span><span class="linkable">heap_prune_record_dead_or_unused</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the caller set mark_unused_now to true, we can remove dead tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during pruning instead of marking their line pointers dead. Set this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple's line pointer LP_UNUSED. We hint that this option is less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(prstate-&gt;mark_unused_now))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>(prstate, offnum, was_normal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1225" title="access/heap/pruneheap.c:1225">heap_prune_record_dead</a>(prstate, offnum, was_normal);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Record line pointer to be marked unused */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1276">&#x200c;</a></span><span class="linkable">heap_prune_record_unused</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_normal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(prstate-&gt;nunused &lt; MaxHeapTuplesPerPage);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;nowunused[prstate-&gt;nunused] = offnum;<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;nunused++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the root entry had been a normal tuple, we are deleting it, so count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it in the result.&nbsp; But changing a redirect (even to DEAD state) doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (was_normal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;ndeleted++;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record an unused line pointer that is left unchanged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1298">&#x200c;</a></span><span class="linkable">heap_prune_record_unchanged_lp_unused</span>(Page page, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record line pointer that is left unchanged.&nbsp; We consider freezing it, and<br/></li>
<li></span><span class="Comment"> * update bookkeeping of tuple counts and page visibility.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1309">&#x200c;</a></span><span class="linkable">heap_prune_record_unchanged_lp_normal</span>(Page page, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prstate-&gt;hastup = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the page is not empty */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The criteria for counting a tuple as live in this block need to match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what <a href="../../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c's <a href="../../commands/analyze.c.html#L1153" title="commands/analyze.c:1153">acquire_sample_rows</a>() does, otherwise VACUUM and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ANALYZE may produce wildly different reltuples <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, e.g. when there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are many recently-dead tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The logic here is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> simpler than <a href="../../commands/analyze.c.html#L1153" title="commands/analyze.c:1153">acquire_sample_rows</a>(), as VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can't run inside a transaction block, which makes some cases impossible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (e.g. in-progress insert from the same transaction).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HEAPTUPLE_DEAD are handled by the other heap_prune_record_*()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subroutines.&nbsp; They don't count dead items like <a href="../../commands/analyze.c.html#L1153" title="commands/analyze.c:1153">acquire_sample_rows</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does, because we assume that all dead items will become LP_UNUSED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> VACUUM finishes.&nbsp; This difference is only superficial.&nbsp; VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effectively agrees with ANALYZE about DEAD items, in the end.&nbsp; VACUUM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't remember LP_DEAD items, but only because they're not supposed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be left behind when it is done. (Cases where we bypass index vacuuming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will violate this optimistic assumption, but the overall impact of that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be negligible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, PageGetItemId(page, offnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (prstate-&gt;htsv[offnum])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_LIVE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count it as live.&nbsp; Not only is this natural, but it's also what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/analyze.c.html#L1153" title="commands/analyze.c:1153">acquire_sample_rows</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;live_tuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is the tuple definitely visible to all transactions?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: Like with per-tuple hint bits, we can't set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PD_ALL_VISIBLE flag if the inserter committed asynchronously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See <a href="heapam_visibility.c.html#L114" title="access/heap/heapam_visibility.c:114">SetHintBits</a> for more info.&nbsp; Check that the tuple is hinted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xmin-committed because of that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prstate-&gt;all_visible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId xmin;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderXminCommitted(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The inserter definitely committed.&nbsp; But is it old enough<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that everyone sees it as committed?&nbsp; A FrozenTransactionId<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is seen as committed to everyone.&nbsp; Otherwise, we check if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is a snapshot that considers this xid to still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running, and if so, we don't consider the page all-visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xmin = HeapTupleHeaderGetXmin(htup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> always use prstate-&gt;cutoffs for this test, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we only update 'all_visible' when freezing is requested. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could use <a href="../../storage/ipc/procarray.c.html#L4248" title="storage/ipc/procarray.c:4248">GlobalVisTestIsRemovableXid</a> instead, if a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-freezing caller wanted to set the VM <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(prstate-&gt;cutoffs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(xmin, prstate-&gt;cutoffs-&gt;OldestXmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;all_visible = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Track newest xmin on page. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/transam.c.html#L314" title="access/transam/transam.c:314">TransactionIdFollows</a>(xmin, prstate-&gt;visibility_cutoff_xid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionIdIsNormal(xmin))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;visibility_cutoff_xid = xmin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_RECENTLY_DEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;recently_dead_tuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;all_visible = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This tuple will soon become DEAD.&nbsp; Update the hint field so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the page is reconsidered for pruning in future.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="access/heap/pruneheap.c:1180">heap_prune_record_prunable</a>(prstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetUpdateXid(htup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_INSERT_IN_PROGRESS:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not count these rows as live, because we expect the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserting transaction to update the counters at commit, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume that will happen only after we report our results.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assumption is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> shaky, but it is what <a href="../../commands/analyze.c.html#L1153" title="commands/analyze.c:1153">acquire_sample_rows</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does, so be consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;all_visible = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we wanted to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> for aborts, we might consider marking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page prunable when we see INSERT_IN_PROGRESS.&nbsp; But we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't.&nbsp; See related decisions about when to mark the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prunable in heapam.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> HEAPTUPLE_DELETE_IN_PROGRESS:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This an expected case during concurrent <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; Count such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rows as live.&nbsp; As above, we assume the deleting transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will commit and update the counters after we report.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;live_tuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;all_visible = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This tuple may soon become DEAD.&nbsp; Update the hint field so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page is reconsidered for pruning in future.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1180" title="access/heap/pruneheap.c:1180">heap_prune_record_prunable</a>(prstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HeapTupleHeaderGetUpdateXid(htup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DEAD tuples should've been passed to <a href="#L1225" title="access/heap/pruneheap.c:1225">heap_prune_record_dead</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or <a href="#L1276" title="access/heap/pruneheap.c:1276">heap_prune_record_unused</a>() instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected <a href="heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a> result </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prstate-&gt;htsv[offnum]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider freezing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> normal tuples which will not be removed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prstate-&gt;freeze)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; totally_frozen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="heapam.c.html#L6541" title="access/heap/heapam.c:6541">heap_prepare_freeze_tuple</a>(htup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; prstate-&gt;cutoffs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prstate-&gt;pagefrz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;prstate-&gt;frozen[prstate-&gt;nfrozen],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;totally_frozen)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save prepared freeze plan for later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;frozen[prstate-&gt;nfrozen++].offset = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple isn't either totally frozen already or eligible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become totally frozen (according to its freeze plan), then the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * definitely cannot be set all-frozen in the visibility map later on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!totally_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prstate-&gt;all_frozen = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record line pointer that was already LP_DEAD and is left unchanged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1487">&#x200c;</a></span><span class="linkable">heap_prune_record_unchanged_lp_dead</span>(Page page, <a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deliberately don't set hastup for LP_DEAD items.&nbsp; We make the soft<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumption that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items encountered here will become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LP_UNUSED later on, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="vacuumlazy.c.html#L2677" title="access/heap/vacuumlazy.c:2677">count_nondeletable_pages</a> is reached.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't make this assumption then rel truncation will only happen every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other VACUUM, at most.&nbsp; Besides, VACUUM must treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hastup/nonempty_pages as provisional no matter how LP_DEAD items are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handled (handled here, or handled later on).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, don't unset all_visible until later, at the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>().&nbsp; This will allow us to attempt to freeze<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page after pruning.&nbsp; As long as we unset it <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> updating the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * visibility map, this will be correct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record the dead offset for <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> */<br/></li>
<li></span>&nbsp; &nbsp; prstate-&gt;deadoffsets[prstate-&gt;lpdead_items++] = offnum;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record LP_REDIRECT that is left unchanged.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1515">&#x200c;</a></span><span class="linkable">heap_prune_record_unchanged_lp_redirect</span>(<a href="#L153" title="access/heap/pruneheap.c:153">PruneState</a> *prstate, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A redirect line pointer doesn't count as a live tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we leave a redirect line pointer in place, there will be another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple on the page that it points to.&nbsp; We will do the bookkeeping for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that separately.&nbsp; So we have nothing to do here, except remember that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we processed this item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!prstate-&gt;processed[offnum]);<br/></li>
<li>&nbsp; &nbsp; prstate-&gt;processed[offnum] = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform the actual page changes needed by <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'lp_truncate_only' is set, we are merely marking LP_DEAD line pointers<br/></li>
<li></span><span class="Comment"> * as unused, not redirecting or removing anything else.&nbsp; The<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/page/bufpage.c.html#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a>() call is skipped in that case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If 'lp_truncate_only' is not set, the caller must hold a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on<br/></li>
<li></span><span class="Comment"> * the buffer.&nbsp; If it is set, an ordinary exclusive lock suffices.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1540">&#x200c;</a></span><span class="linkable">heap_page_prune_execute</span>(Buffer buffer, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> lp_truncate_only,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *redirected, <span class="Type">int</span> nredirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *nowdead, <span class="Type">int</span> ndead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *nowunused, <span class="Type">int</span> nunused)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; OffsetNumber *offnum;<br/></li>
<li>&nbsp; &nbsp; HeapTupleHeader htup <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be called unless there's something to do */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nredirected &gt; <span class="Constant">0</span> || ndead &gt; <span class="Constant">0</span> || nunused &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If 'lp_truncate_only', we can only remove already-dead line pointers */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!lp_truncate_only || (nredirected == <span class="Constant">0</span> &amp;&amp; ndead == <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update all redirected line pointers */<br/></li>
<li></span>&nbsp; &nbsp; offnum = redirected;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nredirected; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber fromoff = *offnum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber tooff = *offnum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; fromlp = PageGetItemId(page, fromoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; tolp <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any existing item that we set as an LP_REDIRECT (<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> 'from' item)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be the first item from a HOT chain.&nbsp; If the item has tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storage then it can't be a heap-only tuple.&nbsp; Otherwise we are just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maintaining an existing LP_REDIRECT from an existing HOT chain that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has been pruned at least once <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsRedirected(fromlp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdHasStorage(fromlp) &amp;&amp; ItemIdIsNormal(fromlp));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, fromlp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHeaderIsHeapOnly(htup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't need to redundantly set the redirect */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdGetRedirect(fromlp) != tooff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The item that we're about to set as an LP_REDIRECT (the 'from'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item) will point to an existing item (the 'to' item) that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already a heap-only tuple.&nbsp; There can be at most one LP_REDIRECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item per HOT chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to keep around an LP_REDIRECT item (after original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-heap-only root tuple gets pruned away) so that it's always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible for VACUUM to easily figure out what TID to delete from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes when an entire HOT chain becomes dead.&nbsp; A heap-only tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can never become LP_DEAD; an LP_REDIRECT item or a regular heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This check may <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> problems, e.g. the target of a redirect could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be marked as unused subsequently. The <a href="#L1716" title="access/heap/pruneheap.c:1716">page_verify_redirects</a>() check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below will catch such problems.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tolp = PageGetItemId(page, tooff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdHasStorage(tolp) &amp;&amp; ItemIdIsNormal(tolp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, tolp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(HeapTupleHeaderIsHeapOnly(htup));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetRedirect(fromlp, tooff);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update all <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-dead line pointers */<br/></li>
<li></span>&nbsp; &nbsp; offnum = nowdead;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ndead; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off = *offnum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, off);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An LP_DEAD line pointer must be left behind when the original item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which is dead to everybody) could still be referenced by a TID in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an index.&nbsp; This should never be necessary with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> individual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap-only tuple item, though. (It's not clear how much of a problem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that would be, but there is no reason to allow it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdHasStorage(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHeaderIsHeapOnly(htup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Whole HOT chain becomes dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsRedirected(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetDead(lp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update all <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-unused line pointers */<br/></li>
<li></span>&nbsp; &nbsp; offnum = nowunused;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nunused; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off = *offnum++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, off);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lp_truncate_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Setting LP_DEAD to LP_UNUSED in <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>'s second pass */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsDead(lp) &amp;&amp; !ItemIdHasStorage(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When <a href="#L348" title="access/heap/pruneheap.c:348">heap_page_prune_and_freeze</a>() was called, mark_unused_now<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may have been passed as true, which allows would-be LP_DEAD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items to be made LP_UNUSED instead.&nbsp; This is only possible if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation has no indexes.&nbsp; If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dead items, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark_unused_now was not true and every item being marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LP_UNUSED must refer to a heap-only tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndead &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdHasStorage(lp) &amp;&amp; ItemIdIsNormal(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(HeapTupleHeaderIsHeapOnly(htup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsUsed(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetUnused(lp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lp_truncate_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L835" title="storage/page/bufpage.c:835">PageTruncateLinePointerArray</a>(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally, repair <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fragmentation, and update the page's hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about whether it has free pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L699" title="storage/page/bufpage.c:699">PageRepairFragmentation</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now that the page has been modified, assert that redirect items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still point to valid targets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1716" title="access/heap/pruneheap.c:1716">page_verify_redirects</a>(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If built with assertions, verify that all LP_REDIRECT items point to a<br/></li>
<li></span><span class="Comment"> * valid item.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One way that bugs related to HOT pruning show is redirect items pointing to<br/></li>
<li></span><span class="Comment"> * removed tuples. It's not trivial to reliably check that marking an item<br/></li>
<li></span><span class="Comment"> * unused will not orphan a redirect item during <a href="#L978" title="access/heap/pruneheap.c:978">heap_prune_chain</a>() /<br/></li>
<li></span><span class="Comment"> * <a href="#L1540" title="access/heap/pruneheap.c:1540">heap_page_prune_execute</a>(), so we additionally check the whole page after<br/></li>
<li></span><span class="Comment"> * pruning. Without this check such bugs would typically only cause asserts<br/></li>
<li></span><span class="Comment"> * later, potentially well after the corruption has been introduced.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also check comments in <a href="#L1540" title="access/heap/pruneheap.c:1540">heap_page_prune_execute</a>()'s redirection loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1716">&#x200c;</a></span><span class="linkable">page_verify_redirects</span>(Page page)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber targoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; targitem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsRedirected(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targoff = ItemIdGetRedirect(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targitem = PageGetItemId(page, targoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsUsed(targitem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsNormal(targitem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdHasStorage(targitem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, targitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(HeapTupleHeaderIsHeapOnly(htup));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * For all items in this page, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> their respective root line pointers.<br/></li>
<li></span><span class="Comment"> * If item k is part of a HOT-chain with root at item j, then we set<br/></li>
<li></span><span class="Comment"> * root_offsets[k - 1] = j.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed-in root_offsets array must have MaxHeapTuplesPerPage entries.<br/></li>
<li></span><span class="Comment"> * Unused entries are filled with InvalidOffsetNumber (zero).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The function must be called with at least share lock on the buffer, to<br/></li>
<li></span><span class="Comment"> * prevent concurrent prune operations.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: The information collected here is valid only as long as the caller<br/></li>
<li></span><span class="Comment"> * holds a pin on the buffer. Once pin is released, a tuple might be pruned<br/></li>
<li></span><span class="Comment"> * and reused by a completely unrelated tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1764">&#x200c;</a></span><span class="linkable">heap_get_root_tuples</span>(Page page, OffsetNumber *root_offsets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemSet(root_offsets, InvalidOffsetNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MaxHeapTuplesPerPage * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = FirstOffsetNumber; offnum &lt;= maxoff; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleHeader htup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber nextoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionId priorXmax;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> unused and dead items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(lp) || ItemIdIsDead(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if this tuple is part of a HOT-chain rooted at some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple. If so, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>; we'll process it when we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its root.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHeaderIsHeapOnly(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is either a plain tuple or the root of a HOT-chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember it in the mapping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root_offsets[offnum - <span class="Constant">1</span>] = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not the start of a HOT-chain, we're done with it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderIsHotUpdated(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up to scan the HOT-chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextoffnum = ItemPointerGetOffsetNumber(&amp;htup-&gt;t_ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorXmax = HeapTupleHeaderGetUpdateXid(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be a redirect item. We do not set its root_offsets entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemIdIsRedirected(lp));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up to scan the HOT-chain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextoffnum = ItemIdGetRedirect(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorXmax = InvalidTransactionId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now follow the HOT-chain and collect other tuples in the chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: Even though this is a nested loop, the complexity of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function is O(N) because a tuple in the page should be visited not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than twice, once in the outer loop and once in HOT-chain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Sanity check (pure paranoia) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An offset past the end of page's line pointer array is possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the array was truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, nextoffnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for broken chains */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsNormal(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; htup = (HeapTupleHeader) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(priorXmax) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !TransactionIdEquals(priorXmax, HeapTupleHeaderGetXmin(htup)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember the root line pointer for this item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; root_offsets[nextoffnum - <span class="Constant">1</span>] = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> chain member, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleHeaderIsHotUpdated(htup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* HOT implies it can't have moved to different partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!HeapTupleHeaderIndicatesMovedPartitions(htup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nextoffnum = ItemPointerGetOffsetNumber(&amp;htup-&gt;t_ctid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorXmax = HeapTupleHeaderGetUpdateXid(htup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare fields that describe actions required to freeze tuple with caller's<br/></li>
<li></span><span class="Comment"> * open plan.&nbsp; If everything matches then the frz tuple plan is equivalent to<br/></li>
<li></span><span class="Comment"> * caller's plan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1875">&#x200c;</a></span><span class="linkable">heap_log_freeze_eq</span>(xlhp_freeze_plan *plan, HeapTupleFreeze *frz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (plan-&gt;xmax == frz-&gt;xmax &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;t_infomask2 == frz-&gt;t_infomask2 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;t_infomask == frz-&gt;t_infomask &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plan-&gt;frzflags == frz-&gt;frzflags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller must call <a href="#L1937" title="access/heap/pruneheap.c:1937">heap_log_freeze_new_plan</a> again for frz */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator used to deduplicate XLOG_HEAP2_FREEZE_PAGE freeze plans<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1891">&#x200c;</a></span><span class="linkable">heap_log_freeze_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *arg1, <span class="Type">const</span> <span class="Type">void</span> *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTupleFreeze *frz1 = (HeapTupleFreeze *) arg1;<br/></li>
<li>&nbsp; &nbsp; HeapTupleFreeze *frz2 = (HeapTupleFreeze *) arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frz1-&gt;xmax &lt; frz2-&gt;xmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frz1-&gt;xmax &gt; frz2-&gt;xmax)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frz1-&gt;t_infomask2 &lt; frz2-&gt;t_infomask2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frz1-&gt;t_infomask2 &gt; frz2-&gt;t_infomask2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frz1-&gt;t_infomask &lt; frz2-&gt;t_infomask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frz1-&gt;t_infomask &gt; frz2-&gt;t_infomask)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (frz1-&gt;frzflags &lt; frz2-&gt;frzflags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frz1-&gt;frzflags &gt; frz2-&gt;frzflags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1875" title="access/heap/pruneheap.c:1875">heap_log_freeze_eq</a> would consider these tuple-wise plans to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (So the tuples will share a single canonical freeze plan.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We tiebreak on page offset number to keep each freeze plan's page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * offset number array individually sorted. (Unnecessary, but be tidy.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (frz1-&gt;offset &lt; frz2-&gt;offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (frz1-&gt;offset &gt; frz2-&gt;offset)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start new plan initialized using tuple-level actions.&nbsp; At least one tuple<br/></li>
<li></span><span class="Comment"> * will have steps required to freeze described by caller's plan during REDO.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1937">&#x200c;</a></span><span class="linkable">heap_log_freeze_new_plan</span>(xlhp_freeze_plan *plan, HeapTupleFreeze *frz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; plan-&gt;xmax = frz-&gt;xmax;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;t_infomask2 = frz-&gt;t_infomask2;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;t_infomask = frz-&gt;t_infomask;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;frzflags = frz-&gt;frzflags;<br/></li>
<li>&nbsp; &nbsp; plan-&gt;ntuples = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Deduplicate tuple-based freeze plans so that each distinct set of<br/></li>
<li></span><span class="Comment"> * processing steps is only stored once in XLOG_HEAP2_FREEZE_PAGE <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> * Called during original execution of freezing (for logged relations).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is number of plans set in *plans_out for caller.&nbsp; Also writes<br/></li>
<li></span><span class="Comment"> * an array of offset numbers into *offsets_out output argument for caller<br/></li>
<li></span><span class="Comment"> * (actually there is one array per freeze plan, but that's not of immediate<br/></li>
<li></span><span class="Comment"> * concern to our caller).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1957">&#x200c;</a></span><span class="linkable">heap_log_freeze_plan</span>(HeapTupleFreeze *tuples, <span class="Type">int</span> ntuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlhp_freeze_plan *plans_out,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *offsets_out)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nplans = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort tuple-based freeze plans in the order required to deduplicate */<br/></li>
<li></span>&nbsp; &nbsp; qsort(tuples, ntuples, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(HeapTupleFreeze), <a href="#L1891" title="access/heap/pruneheap.c:1891">heap_log_freeze_cmp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFreeze *frz = tuples + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New canonical freeze plan starting with first tup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1937" title="access/heap/pruneheap.c:1937">heap_log_freeze_new_plan</a>(plans_out, frz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nplans++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L1875" title="access/heap/pruneheap.c:1875">heap_log_freeze_eq</a>(plans_out, frz))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tup matches open canonical plan -- include tup in it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offsets_out[i - <span class="Constant">1</span>] &lt; frz-&gt;offset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plans_out-&gt;ntuples++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tup doesn't match current plan -- done with it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plans_out++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* New canonical freeze plan starting with this tup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1937" title="access/heap/pruneheap.c:1937">heap_log_freeze_new_plan</a>(plans_out, frz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nplans++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save page offset number in dedicated buffer in passing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * REDO routine relies on the record's offset numbers array grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offset numbers by freeze plan.&nbsp; The sort order within each grouping<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is ascending offset number order, just to keep things tidy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; offsets_out[i] = frz-&gt;offset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nplans &gt; <span class="Constant">0</span> &amp;&amp; nplans &lt;= ntuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nplans;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write an XLOG_HEAP2_PRUNE_FREEZE WAL record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for several different page maintenance operations:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Page pruning, in VACUUM's 1st pass or on access: Some items are<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; redirected, some marked dead, and some removed altogether.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Freezing: Items are marked as 'frozen'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Vacuum, 2nd pass: Items that are already LP_DEAD are marked as unused.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * They have enough commonalities that we use a single WAL record for them<br/></li>
<li></span><span class="Comment"> * all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If replaying the record requires a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, pass cleanup_lock = true.<br/></li>
<li></span><span class="Comment"> * Replaying 'redirected' or 'dead' items always requires a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock, but<br/></li>
<li></span><span class="Comment"> * replaying 'unused' items depends on whether they were all previously marked<br/></li>
<li></span><span class="Comment"> * as dead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This function scribbles on the 'frozen' array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: This is called in a critical section, so careful what you do here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2032">&#x200c;</a></span><span class="linkable">log_heap_prune_and_freeze</span>(Relation relation, Buffer buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId conflict_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> cleanup_lock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PruneReason reason,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTupleFreeze *frozen, <span class="Type">int</span> nfrozen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *redirected, <span class="Type">int</span> nredirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *dead, <span class="Type">int</span> ndead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *unused, <span class="Type">int</span> nunused)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_heap_prune xlrec;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The following local variables hold data registered in the WAL record: */<br/></li>
<li></span>&nbsp; &nbsp; xlhp_freeze_plan plans[MaxHeapTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; xlhp_freeze_plans freeze_plans;<br/></li>
<li>&nbsp; &nbsp; xlhp_prune_items redirect_items;<br/></li>
<li>&nbsp; &nbsp; xlhp_prune_items dead_items;<br/></li>
<li>&nbsp; &nbsp; xlhp_prune_items unused_items;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber frz_offsets[MaxHeapTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; xlrec.flags = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare data for the buffer.&nbsp; The arrays are not actually in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer, but we pretend that they are.&nbsp; When <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> stores a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page image, the arrays can be omitted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buffer, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfrozen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nplans;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_HAS_FREEZE_PLANS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepare deduplicated representation for use in the WAL record. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * destructively sorts frozen tuples array in-place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nplans = <a href="#L1957" title="access/heap/pruneheap.c:1957">heap_log_freeze_plan</a>(frozen, nfrozen, plans, frz_offsets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeze_plans.nplans = nplans;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;freeze_plans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(xlhp_freeze_plans, plans));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) plans,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlhp_freeze_plan) * nplans);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nredirected &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_HAS_REDIRECTIONS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; redirect_items.ntargets = nredirected;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;redirect_items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(xlhp_prune_items, data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) redirected,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber[<span class="Constant">2</span>]) * nredirected);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndead &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_HAS_DEAD_ITEMS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dead_items.ntargets = ndead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;dead_items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(xlhp_prune_items, data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) dead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * ndead);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nunused &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_HAS_NOW_UNUSED_ITEMS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unused_items.ntargets = nunused;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;unused_items,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(xlhp_prune_items, data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) unused,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * nunused);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nfrozen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) frz_offsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber) * nfrozen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> xl_heap_prune record.&nbsp; We already set the XLPH_HAS_*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationIsAccessibleInLogicalDecoding(relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_IS_CATALOG_REL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(conflict_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_HAS_CONFLICT_HORIZON;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cleanup_lock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags |= XLHP_CLEANUP_LOCK;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nredirected == <span class="Constant">0</span> &amp;&amp; ndead == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* also, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items in 'unused' must've been LP_DEAD previously */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfHeapPrune);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (TransactionIdIsValid(conflict_xid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;conflict_xid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TransactionId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (reason)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PRUNE_ON_ACCESS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP2_PRUNE_ON_ACCESS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PRUNE_VACUUM_SCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP2_PRUNE_VACUUM_SCAN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PRUNE_VACUUM_CLEANUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info = XLOG_HEAP2_PRUNE_VACUUM_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized prune reason: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) reason);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_HEAP2_ID, info);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(BufferGetPage(buffer), recptr);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
