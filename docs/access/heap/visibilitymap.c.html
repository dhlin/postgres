<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/heap/visibilitymap.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/heap/visibilitymap.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L138">visibilitymap_clear</a></li>
<li><a href="#L384">visibilitymap_count</a></li>
<li><a href="#L336">visibilitymap_get_status</a></li>
<li><a href="#L191">visibilitymap_pin</a></li>
<li><a href="#L215">visibilitymap_pin_ok</a></li>
<li><a href="#L438">visibilitymap_prepare_truncate</a></li>
<li><a href="#L244">visibilitymap_set</a></li>
<li><a href="#L612">vm_extend</a></li>
<li><a href="#L538">vm_readbuf</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L123">FROZEN_MASK8</a></li>
<li><a href="#L117">HEAPBLK_TO_MAPBLOCK</a></li>
<li><a href="#L118">HEAPBLK_TO_MAPBYTE</a></li>
<li><a href="#L119">HEAPBLK_TO_OFFSET</a></li>
<li><a href="#L111">HEAPBLOCKS_PER_BYTE</a></li>
<li><a href="#L114">HEAPBLOCKS_PER_PAGE</a></li>
<li><a href="#L108">MAPSIZE</a></li>
<li><a href="#L122">VISIBLE_MASK8</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * visibilitymap.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; bitmap for tracking visibility of heap tuples<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/heap/visibilitymap.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>&nbsp; - clear bits for one page in the visibility map<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>&nbsp; &nbsp;&nbsp; - pin a map page for setting a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L215" title="access/heap/visibilitymap.c:215">visibilitymap_pin_ok</a> - check whether correct map page is already pinned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>&nbsp; &nbsp;&nbsp; - set a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in a previously pinned page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a> - get status of bits<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L384" title="access/heap/visibilitymap.c:384">visibilitymap_count</a>&nbsp; - count number of bits set in visibility map<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L438" title="access/heap/visibilitymap.c:438">visibilitymap_prepare_truncate</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prepare for truncation of the visibility map<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The visibility map is a bitmap with two bits (all-visible and all-frozen)<br/></li>
<li></span><span class="Comment"> * per heap page. A set all-visible <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> means that all tuples on the page are<br/></li>
<li></span><span class="Comment"> * known visible to all transactions, and therefore the page doesn't need to<br/></li>
<li></span><span class="Comment"> * be vacuumed. A set all-frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> means that all tuples on the page are<br/></li>
<li></span><span class="Comment"> * completely frozen, and therefore the page doesn't need to be vacuumed even<br/></li>
<li></span><span class="Comment"> * if whole table scanning <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> is required (e.g. anti-wraparound <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>).<br/></li>
<li></span><span class="Comment"> * The all-frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> must be set only when the page is already all-visible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The map is conservative in the sense that we make sure that whenever a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * is set, we know the condition is true, but if a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is not set, it might or<br/></li>
<li></span><span class="Comment"> * might not be true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Clearing visibility map bits is not separately WAL-logged.&nbsp; The callers<br/></li>
<li></span><span class="Comment"> * must make sure that whenever a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is cleared, the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is cleared on WAL<br/></li>
<li></span><span class="Comment"> * replay of the updating operation as well.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we *set* a visibility map during VACUUM, we must write WAL.&nbsp; This may<br/></li>
<li></span><span class="Comment"> * seem counterintuitive, since the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is basically a hint: if it is clear,<br/></li>
<li></span><span class="Comment"> * it may still be the case that every tuple on the page is visible to all<br/></li>
<li></span><span class="Comment"> * transactions; we just don't know that for certain.&nbsp; The difficulty is that<br/></li>
<li></span><span class="Comment"> * there are two bits which are typically set together: the PD_ALL_VISIBLE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * on the page itself, and the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.&nbsp; If a crash occurs after the<br/></li>
<li></span><span class="Comment"> * visibility map page makes it to disk and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the updated heap page makes<br/></li>
<li></span><span class="Comment"> * it to disk, redo must set the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> on the heap page.&nbsp; Otherwise, the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * insert, update, or delete on the heap page will fail to realize that the<br/></li>
<li></span><span class="Comment"> * visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> must be cleared, possibly causing index-only scans to<br/></li>
<li></span><span class="Comment"> * return wrong answers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * VACUUM will normally <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> pages for which the visibility map <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set;<br/></li>
<li></span><span class="Comment"> * such pages can't contain <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dead tuples and therefore don't need vacuuming.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * LOCKING<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In heapam.c, whenever a page is modified so that not all tuples on the<br/></li>
<li></span><span class="Comment"> * page are visible to everyone anymore, the corresponding <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the<br/></li>
<li></span><span class="Comment"> * visibility map is cleared. In order to be crash-safe, we need to do this<br/></li>
<li></span><span class="Comment"> * while still holding a lock on the heap page and in the same critical<br/></li>
<li></span><span class="Comment"> * section that logs the page modification. However, we don't want to hold<br/></li>
<li></span><span class="Comment"> * the buffer lock over <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O that may be required to read in the visibility<br/></li>
<li></span><span class="Comment"> * map page.&nbsp; To avoid this, we examine the heap page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locking it;<br/></li>
<li></span><span class="Comment"> * if the page-level PD_ALL_VISIBLE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set, we pin the visibility map<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.&nbsp; Then, we lock the buffer.&nbsp; But this creates a race condition: there<br/></li>
<li></span><span class="Comment"> * is a possibility that in the time it takes to lock the buffer, the<br/></li>
<li></span><span class="Comment"> * PD_ALL_VISIBLE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> gets set.&nbsp; If that happens, we have to unlock the<br/></li>
<li></span><span class="Comment"> * buffer, pin the visibility map page, and relock the buffer.&nbsp; This shouldn't<br/></li>
<li></span><span class="Comment"> * happen often, because only VACUUM currently sets visibility map bits,<br/></li>
<li></span><span class="Comment"> * and the race will only occur if VACUUM processes a given page at almost<br/></li>
<li></span><span class="Comment"> * exactly the same time that someone tries to further modify it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To set a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, you need to hold a lock on the heap page. That prevents<br/></li>
<li></span><span class="Comment"> * the race condition where VACUUM sees that all tuples on the page are<br/></li>
<li></span><span class="Comment"> * visible to everyone, but another backend modifies the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> VACUUM<br/></li>
<li></span><span class="Comment"> * sets the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the visibility map.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is set, the LSN of the visibility map page is updated to make<br/></li>
<li></span><span class="Comment"> * sure that the visibility map update doesn't get written to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment"> * WAL record of the changes that made it possible to set the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is flushed.<br/></li>
<li></span><span class="Comment"> * But when a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is cleared, we don't have to do that because it's always<br/></li>
<li></span><span class="Comment"> * safe to clear a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the map from correctness point of view.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*#define TRACE_VISIBILITYMAP */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Size of the bitmap on each visibility map page, in bytes. There's no<br/></li>
<li></span><span class="Comment"> * extra headers, so the whole page minus the standard page header is<br/></li>
<li></span><span class="Comment"> * used for the bitmap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAPSIZE</span> (BLCKSZ - MAXALIGN(SizeOfPageHeaderData))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Number of heap blocks we can represent in one byte */<br/></li>
<li><a id="L111">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLOCKS_PER_BYTE</span> (BITS_PER_BYTE / BITS_PER_HEAPBLOCK)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Number of heap blocks we can represent in one visibility map page. */<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLOCKS_PER_PAGE</span> (<a href="#L108" title="access/heap/visibilitymap.c:108">MAPSIZE</a> * <a href="#L111" title="access/heap/visibilitymap.c:111">HEAPBLOCKS_PER_BYTE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Mapping from heap block number to the right <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the visibility map */<br/></li>
<li><a id="L117">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLK_TO_MAPBLOCK</span>(x) ((x) / <a href="#L114" title="access/heap/visibilitymap.c:114">HEAPBLOCKS_PER_PAGE</a>)<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLK_TO_MAPBYTE</span>(x) (((x) % <a href="#L114" title="access/heap/visibilitymap.c:114">HEAPBLOCKS_PER_PAGE</a>) / <a href="#L111" title="access/heap/visibilitymap.c:111">HEAPBLOCKS_PER_BYTE</a>)<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLK_TO_OFFSET</span>(x) (((x) % <a href="#L111" title="access/heap/visibilitymap.c:111">HEAPBLOCKS_PER_BYTE</a>) * BITS_PER_HEAPBLOCK)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Masks for counting subsets of bits in the visibility map. */<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">VISIBLE_MASK8</span>&nbsp; &nbsp; (</span><span class="Constant">0x55</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* The <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of each <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> pair */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">FROZEN_MASK8</span>&nbsp; &nbsp; (</span><span class="Constant">0xaa</span><span class="PreProc">)&nbsp; &nbsp; </span><span class="Comment">/* The <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of each <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> pair */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* prototypes for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> routines */<br/></li>
<li></span><span class="Type">static</span> Buffer <a href="#L538" title="access/heap/visibilitymap.c:538">vm_readbuf</a>(Relation rel, BlockNumber blkno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> extend);<br/></li>
<li><span class="Type">static</span> Buffer <a href="#L612" title="access/heap/visibilitymap.c:612">vm_extend</a>(Relation rel, BlockNumber vm_nblocks);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a> - clear specified bits for one page in visibility map<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * You must pass a buffer containing the correct map page to this function.<br/></li>
<li></span><span class="Comment"> * Call <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a> first to pin the right one. This function doesn't do<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O.&nbsp; Returns true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bits have been cleared and false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L138">&#x200c;</a></span><span class="linkable">visibilitymap_clear</span>(Relation rel, BlockNumber heapBlk, Buffer vmbuf, uint8 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlock = <a href="#L117" title="access/heap/visibilitymap.c:117">HEAPBLK_TO_MAPBLOCK</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapByte = <a href="#L118" title="access/heap/visibilitymap.c:118">HEAPBLK_TO_MAPBYTE</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapOffset = <a href="#L119" title="access/heap/visibilitymap.c:119">HEAPBLK_TO_OFFSET</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; mask = flags &lt;&lt; mapOffset;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *map;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cleared = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must never clear all_visible <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> while leaving all_frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set */<br/></li>
<li></span>&nbsp; &nbsp; Assert(flags &amp; VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; Assert(flags != VISIBILITYMAP_ALL_VISIBLE);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_VISIBILITYMAP<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;vm_clear </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>, RelationGetRelationName(rel), heapBlk);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(vmbuf) || <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(vmbuf) != mapBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong buffer passed to <a href="#L138" title="access/heap/visibilitymap.c:138">visibilitymap_clear</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(vmbuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; map = PageGetContents(BufferGetPage(vmbuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (map[mapByte] &amp; mask)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map[mapByte] &amp;= ~mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(vmbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cleared = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(vmbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cleared;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a> - pin a map page for setting a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Setting a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in the visibility map is a two-phase operation. First, call<br/></li>
<li></span><span class="Comment"> * <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a>, to pin the visibility map page containing the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for<br/></li>
<li></span><span class="Comment"> * the heap page. Because that can require I/O to read the map page, you<br/></li>
<li></span><span class="Comment"> * shouldn't hold a lock on the heap page while doing that. Then, call<br/></li>
<li></span><span class="Comment"> * <a href="#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a> to actually set the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, *vmbuf should be InvalidBuffer or a valid buffer returned by<br/></li>
<li></span><span class="Comment"> * an earlier call to <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a> or <a href="#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a> on the same<br/></li>
<li></span><span class="Comment"> * relation. On return, *vmbuf is a valid buffer with the map page containing<br/></li>
<li></span><span class="Comment"> * the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for heapBlk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page doesn't exist in the map file yet, it is extended.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L191">&#x200c;</a></span><span class="linkable">visibilitymap_pin</span>(Relation rel, BlockNumber heapBlk, Buffer *vmbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlock = <a href="#L117" title="access/heap/visibilitymap.c:117">HEAPBLK_TO_MAPBLOCK</a>(heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reuse the old pinned buffer if possible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(*vmbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(*vmbuf) == mapBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(*vmbuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *vmbuf = <a href="#L538" title="access/heap/visibilitymap.c:538">vm_readbuf</a>(rel, mapBlock, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L215" title="access/heap/visibilitymap.c:215">visibilitymap_pin_ok</a> - do we already have the correct page pinned?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, vmbuf should be InvalidBuffer or a valid buffer returned by<br/></li>
<li></span><span class="Comment"> * an earlier call to <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a> or <a href="#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a> on the same<br/></li>
<li></span><span class="Comment"> * relation.&nbsp; The return value indicates whether the buffer covers the<br/></li>
<li></span><span class="Comment"> * given heapBlk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L215">&#x200c;</a></span><span class="linkable">visibilitymap_pin_ok</span>(BlockNumber heapBlk, Buffer vmbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlock = <a href="#L117" title="access/heap/visibilitymap.c:117">HEAPBLK_TO_MAPBLOCK</a>(heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> BufferIsValid(vmbuf) &amp;&amp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(vmbuf) == mapBlock;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a> - set <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>(s) on a previously pinned page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * recptr is the LSN of the XLOG record we're replaying, if we're in recovery,<br/></li>
<li></span><span class="Comment"> * or InvalidXLogRecPtr in normal running.&nbsp; The VM page LSN is advanced to the<br/></li>
<li></span><span class="Comment"> * one provided; in normal running, we generate a new XLOG record and set the<br/></li>
<li></span><span class="Comment"> * page LSN to that value (though the heap page's LSN may *not* be updated;<br/></li>
<li></span><span class="Comment"> * see below).&nbsp; cutoff_xid is the largest xmin on the page being marked<br/></li>
<li></span><span class="Comment"> * all-visible; it is needed for Hot Standby, and can be InvalidTransactionId<br/></li>
<li></span><span class="Comment"> * if the page contains no tuples.&nbsp; It can also be set to InvalidTransactionId<br/></li>
<li></span><span class="Comment"> * when a page that is already all-visible is being marked all-frozen.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is expected to set the heap page's PD_ALL_VISIBLE <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling<br/></li>
<li></span><span class="Comment"> * this function. Except in recovery, caller should also pass the heap<br/></li>
<li></span><span class="Comment"> * buffer. When checksums are enabled and we're not in recovery, we must add<br/></li>
<li></span><span class="Comment"> * the heap buffer to the WAL chain to protect it from being torn.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * You must pass a buffer containing the correct map page to this function.<br/></li>
<li></span><span class="Comment"> * Call <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a> first to pin the right one. This function doesn't do<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> I/O.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="linkable">visibilitymap_set</span>(Relation rel, BlockNumber heapBlk, Buffer heapBuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr recptr, Buffer vmBuf, TransactionId cutoff_xid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlock = <a href="#L117" title="access/heap/visibilitymap.c:117">HEAPBLK_TO_MAPBLOCK</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; mapByte = <a href="#L118" title="access/heap/visibilitymap.c:118">HEAPBLK_TO_MAPBYTE</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; mapOffset = <a href="#L119" title="access/heap/visibilitymap.c:119">HEAPBLK_TO_OFFSET</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp;&nbsp; *map;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_VISIBILITYMAP<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;vm_set </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>, RelationGetRelationName(rel), heapBlk);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> || XLogRecPtrIsInvalid(recptr));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> || PageIsAllVisible((Page) BufferGetPage(heapBuf)));<br/></li>
<li>&nbsp; &nbsp; Assert((flags &amp; VISIBILITYMAP_VALID_BITS) == flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must never set all_frozen <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> without also setting all_visible <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(flags != VISIBILITYMAP_ALL_FROZEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that we have the right heap page pinned, if present */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(heapBuf) &amp;&amp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(heapBuf) != heapBlk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong heap buffer passed to <a href="#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that we have the right VM page pinned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(vmBuf) || <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(vmBuf) != mapBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong VM buffer passed to <a href="#L244" title="access/heap/visibilitymap.c:244">visibilitymap_set</a>&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(vmBuf);<br/></li>
<li>&nbsp; &nbsp; map = (uint8 *) PageGetContents(page);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(vmBuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags != (map[mapByte] &gt;&gt; mapOffset &amp; VISIBILITYMAP_VALID_BITS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map[mapByte] |= (flags &lt;&lt; mapOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(vmBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(recptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="heapam.c.html#L8314" title="access/heap/heapam.c:8314">log_heap_visible</a>(rel, heapBuf, vmBuf, cutoff_xid, flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If data checksums are enabled (or <a href="../transam/xlog.c.html#L123" title="access/transam/xlog.c:123">wal_log_hints</a>=on), we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to protect the heap page from being torn.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not, then we must *not* update the heap page's LSN. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this case, the FPI for the heap page was omitted from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL record inserted above, so it would be incorrect to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update the heap page's LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogHintBitIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; heapPage = BufferGetPage(heapBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(heapPage, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(vmBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a> - get status of bits<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Are all tuples on heapBlk visible to all or are marked frozen, according<br/></li>
<li></span><span class="Comment"> * to the visibility map?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, *vmbuf should be InvalidBuffer or a valid buffer returned by an<br/></li>
<li></span><span class="Comment"> * earlier call to <a href="#L191" title="access/heap/visibilitymap.c:191">visibilitymap_pin</a> or <a href="#L336" title="access/heap/visibilitymap.c:336">visibilitymap_get_status</a> on the same<br/></li>
<li></span><span class="Comment"> * relation. On return, *vmbuf is a valid buffer with the map page containing<br/></li>
<li></span><span class="Comment"> * the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> for heapBlk, or InvalidBuffer. The caller is responsible for<br/></li>
<li></span><span class="Comment"> * releasing *vmbuf after it's done testing and setting bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: This function is typically called without a lock on the heap page,<br/></li>
<li></span><span class="Comment"> * so somebody else could change the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> just after we look at it.&nbsp; In fact,<br/></li>
<li></span><span class="Comment"> * since we don't lock the visibility map page either, it's even possible that<br/></li>
<li></span><span class="Comment"> * someone else could have changed the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we look at it, but yet<br/></li>
<li></span><span class="Comment"> * we might see the old value.&nbsp; It is the caller's responsibility to deal with<br/></li>
<li></span><span class="Comment"> * all concurrency issues!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint8<br/></li>
<li><a id="L336">&#x200c;</a><span class="linkable">visibilitymap_get_status</span>(Relation rel, BlockNumber heapBlk, Buffer *vmbuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlock = <a href="#L117" title="access/heap/visibilitymap.c:117">HEAPBLK_TO_MAPBLOCK</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; mapByte = <a href="#L118" title="access/heap/visibilitymap.c:118">HEAPBLK_TO_MAPBYTE</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; mapOffset = <a href="#L119" title="access/heap/visibilitymap.c:119">HEAPBLK_TO_OFFSET</a>(heapBlk);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *map;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_VISIBILITYMAP<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;vm_get_status </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>, RelationGetRelationName(rel), heapBlk);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reuse the old pinned buffer if possible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(*vmbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(*vmbuf) != mapBlock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(*vmbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *vmbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(*vmbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *vmbuf = <a href="#L538" title="access/heap/visibilitymap.c:538">vm_readbuf</a>(rel, mapBlock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(*vmbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; map = PageGetContents(BufferGetPage(*vmbuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A single byte read is atomic.&nbsp; There could be memory-ordering effects<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, but for performance reasons we make it the caller's job to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = ((map[mapByte] &gt;&gt; mapOffset) &amp; VISIBILITYMAP_VALID_BITS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L384" title="access/heap/visibilitymap.c:384">visibilitymap_count</a>&nbsp; - count number of bits set in visibility map<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we ignore the possibility of race conditions when the table is being<br/></li>
<li></span><span class="Comment"> * extended concurrently with the call.&nbsp; New pages added to the table aren't<br/></li>
<li></span><span class="Comment"> * going to be marked all-visible or all-frozen, so they won't affect the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L384">&#x200c;</a></span><span class="linkable">visibilitymap_count</span>(Relation rel, BlockNumber *all_visible, BlockNumber *all_frozen)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlock;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nvisible = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nfrozen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all_visible must be specified */<br/></li>
<li></span>&nbsp; &nbsp; Assert(all_visible);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (mapBlock = <span class="Constant">0</span>;; mapBlock++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; mapBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp;&nbsp; *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read till we fall off the end of the map.&nbsp; We assume that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bytes in the last page are zeroed, so we don't bother excluding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them from the count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mapBuffer = <a href="#L538" title="access/heap/visibilitymap.c:538">vm_readbuf</a>(rel, mapBlock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(mapBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We choose not to lock the page, since the result is going to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately stale anyway if anyone is concurrently setting or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clearing bits, and we only really need an approximate value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; map = (uint64 *) PageGetContents(BufferGetPage(mapBuffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nvisible += pg_popcount_masked((<span class="Type">const</span> <span class="Type">char</span> *) map, <a href="#L108" title="access/heap/visibilitymap.c:108">MAPSIZE</a>, <a href="#L122" title="access/heap/visibilitymap.c:122">VISIBLE_MASK8</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (all_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfrozen += pg_popcount_masked((<span class="Type">const</span> <span class="Type">char</span> *) map, <a href="#L108" title="access/heap/visibilitymap.c:108">MAPSIZE</a>, <a href="#L123" title="access/heap/visibilitymap.c:123">FROZEN_MASK8</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(mapBuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *all_visible = nvisible;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (all_frozen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *all_frozen = nfrozen;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L438" title="access/heap/visibilitymap.c:438">visibilitymap_prepare_truncate</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prepare for truncation of the visibility map<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nheapblocks is the new size of the heap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the number of blocks of new visibility map.<br/></li>
<li></span><span class="Comment"> * If it's InvalidBlockNumber, there is nothing to truncate;<br/></li>
<li></span><span class="Comment"> * otherwise the caller is responsible for calling <a href="../../storage/smgr/smgr.c.html#L703" title="storage/smgr/smgr.c:703">smgrtruncate</a>()<br/></li>
<li></span><span class="Comment"> * to truncate the visibility map pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BlockNumber<br/></li>
<li><a id="L438">&#x200c;</a><span class="linkable">visibilitymap_prepare_truncate</span>(Relation rel, BlockNumber nheapblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber newnblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* last remaining block, byte, and <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber truncBlock = <a href="#L117" title="access/heap/visibilitymap.c:117">HEAPBLK_TO_MAPBLOCK</a>(nheapblocks);<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; truncByte = <a href="#L118" title="access/heap/visibilitymap.c:118">HEAPBLK_TO_MAPBYTE</a>(nheapblocks);<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; truncOffset = <a href="#L119" title="access/heap/visibilitymap.c:119">HEAPBLK_TO_OFFSET</a>(nheapblocks);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef TRACE_VISIBILITYMAP<br/></li>
<li></span>&nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;vm_truncate </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>, RelationGetRelationName(rel), nheapblocks);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no visibility map has been created yet for this relation, there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing to truncate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(RelationGetSmgr(rel), VISIBILITYMAP_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless the new size is exactly at a visibility map page boundary, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tail bits in the last remaining map page, representing truncated heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks, need to be cleared. This is not only tidy, but also necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we don't get a chance to clear the bits if the heap is extended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (truncByte != <span class="Constant">0</span> || truncOffset != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; mapBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *map;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newnblocks = truncBlock + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapBuffer = <a href="#L538" title="access/heap/visibilitymap.c:538">vm_readbuf</a>(rel, truncBlock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(mapBuffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do, the file was already smaller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(mapBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; map = PageGetContents(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(mapBuffer, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NO EREPORT(ERROR) from here till changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear out the unwanted bytes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;map[truncByte + <span class="Constant">1</span>], <span class="Constant">0</span>, <a href="#L108" title="access/heap/visibilitymap.c:108">MAPSIZE</a> - (truncByte + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mask out the unwanted bits of the last remaining byte.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ((1 &lt;&lt; 0) - 1) = 00000000<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ((1 &lt;&lt; 1) - 1) = 00000001<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ((1 &lt;&lt; 6) - 1) = 00111111<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ((1 &lt;&lt; 7) - 1) = 01111111<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; map[truncByte] &amp;= (<span class="Constant">1</span> &lt;&lt; truncOffset) - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Truncation of a relation is WAL-logged at a higher-level, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be called at WAL replay. But if checksums are enabled, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to still write a WAL record to protect against a torn page, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page is flushed to disk <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the truncation WAL record. We cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use <a href="../../storage/buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a> here, because that will not dirty the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(mapBuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../transam/xlogutils.c.html#L50" title="access/transam/xlogutils.c:50">InRecovery</a> &amp;&amp; RelationNeedsWAL(rel) &amp;&amp; XLogHintBitIsNeeded())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a>(mapBuffer, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(mapBuffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newnblocks = truncBlock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(RelationGetSmgr(rel), VISIBILITYMAP_FORKNUM) &lt;= newnblocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do, the file was already smaller than requested size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newnblocks;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read a visibility map page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page doesn't exist, InvalidBuffer is returned, or if 'extend' is<br/></li>
<li></span><span class="Comment"> * true, the visibility map file is extended.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L538">&#x200c;</a><span class="linkable">vm_readbuf</span>(Relation rel, BlockNumber blkno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> extend)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caution: re-using this smgr pointer could fail if the relcache entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gets closed.&nbsp; It's safe as long as we only do smgr-level operations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between here and the last use of the pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; reln = RelationGetSmgr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't cached the size of the visibility map fork yet, check it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reln-&gt;smgr_cached_nblocks[VISIBILITYMAP_FORKNUM] == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(reln, VISIBILITYMAP_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(reln, VISIBILITYMAP_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[VISIBILITYMAP_FORKNUM] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For reading we use ZERO_ON_ERROR mode, and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary. It's always safe to clear bits, so it's better to clear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corrupt pages than error out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the same path below to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> pages when extending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, as a concurrent extension can end up with <a href="#L612" title="access/heap/visibilitymap.c:612">vm_extend</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning an already-initialized page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (blkno &gt;= reln-&gt;smgr_cached_nblocks[VISIBILITYMAP_FORKNUM])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (extend)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L612" title="access/heap/visibilitymap.c:612">vm_extend</a>(rel, blkno + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, VISIBILITYMAP_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_ZERO_ON_ERROR, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initializing the page when needed is trickier than it looks, because of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the possibility of multiple backends doing this concurrently, and our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * desire to not uselessly take the buffer lock in the normal path where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page is OK.&nbsp; We must take the lock to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the page, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recheck page newness after we have the lock, in case someone else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already did it.&nbsp; Also, because we initially check PageIsNew with no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock, it's possible to fall through and return the buffer while someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else is still initializing the page (i.e., we might see pd_upper as set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but other page header fields are still zeroes).&nbsp; This is harmless for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callers that will take a buffer lock themselves, but some callers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inspect the page without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock at all.&nbsp; The latter is OK only so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * long as it doesn't depend on the page header having correct contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Current usage is safe because PageGetContents() does not require that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(BufferGetPage(buf)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(BufferGetPage(buf), BLCKSZ, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Ensure that the visibility map fork is at least vm_nblocks long, extending<br/></li>
<li></span><span class="Comment"> * it if necessary with zeroed pages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L612">&#x200c;</a><span class="linkable">vm_extend</span>(Relation rel, BlockNumber vm_nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L909" title="storage/buffer/bufmgr.c:909">ExtendBufferedRelTo</a>(BMR_REL(rel), VISIBILITYMAP_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_CREATE_FORK_IF_NEEDED |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_CLEAR_SIZE_CACHE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vm_nblocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RBM_ZERO_ON_ERROR);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send a shared-inval message to force other backends to close <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> smgr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references they may have for this rel, which we are about to change.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a useful optimization because it means that backends don't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to keep checking for creation or extension of the file, which happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infrequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/inval.c.html#L1459" title="utils/cache/inval.c:1459">CacheInvalidateSmgr</a>(RelationGetSmgr(rel)-&gt;smgr_rlocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
