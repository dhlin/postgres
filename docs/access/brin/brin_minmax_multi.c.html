<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/brin/brin_minmax_multi.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/brin/brin_minmax_multi.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L249">DistanceValue</a></li>
<li><a href="#L253">DistanceValue</a></li>
<li><a href="#L238">ExpandedRange</a></li>
<li><a href="#L243">ExpandedRange</a></li>
<li><a href="#L122">MinMaxMultiOptions</a></li>
<li><a href="#L126">MinMaxMultiOptions</a></li>
<li><a href="#L111">MinmaxMultiOpaque</a></li>
<li><a href="#L117">MinmaxMultiOpaque</a></li>
<li><a href="#L170">Ranges</a></li>
<li><a href="#L197">Ranges</a></li>
<li><a href="#L206">SerializedRanges</a></li>
<li><a href="#L221">SerializedRanges</a></li>
<li><a href="#L265">compare_context</a></li>
<li><a href="#L269">compare_context</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L280">AssertArrayOrder</a></li>
<li><a href="#L427">AssertCheckExpandedRanges</a></li>
<li><a href="#L297">AssertCheckRanges</a></li>
<li><a href="#L2413">brin_minmax_multi_add_value</a></li>
<li><a href="#L2550">brin_minmax_multi_consistent</a></li>
<li><a href="#L2081">brin_minmax_multi_distance_date</a></li>
<li><a href="#L1884">brin_minmax_multi_distance_float4</a></li>
<li><a href="#L1910">brin_minmax_multi_distance_float8</a></li>
<li><a href="#L2298">brin_minmax_multi_distance_inet</a></li>
<li><a href="#L1936">brin_minmax_multi_distance_int2</a></li>
<li><a href="#L1954">brin_minmax_multi_distance_int4</a></li>
<li><a href="#L1972">brin_minmax_multi_distance_int8</a></li>
<li><a href="#L2156">brin_minmax_multi_distance_interval</a></li>
<li><a href="#L2213">brin_minmax_multi_distance_macaddr</a></li>
<li><a href="#L2250">brin_minmax_multi_distance_macaddr8</a></li>
<li><a href="#L2022">brin_minmax_multi_distance_numeric</a></li>
<li><a href="#L2192">brin_minmax_multi_distance_pg_lsn</a></li>
<li><a href="#L1991">brin_minmax_multi_distance_tid</a></li>
<li><a href="#L2100">brin_minmax_multi_distance_time</a></li>
<li><a href="#L2138">brin_minmax_multi_distance_timestamp</a></li>
<li><a href="#L2120">brin_minmax_multi_distance_timetz</a></li>
<li><a href="#L2048">brin_minmax_multi_distance_uuid</a></li>
<li><a href="#L2400">brin_minmax_multi_get_values</a></li>
<li><a href="#L1860">brin_minmax_multi_opcinfo</a></li>
<li><a href="#L2963">brin_minmax_multi_options</a></li>
<li><a href="#L2381">brin_minmax_multi_serialize</a></li>
<li><a href="#L2985">brin_minmax_multi_summary_in</a></li>
<li><a href="#L3007">brin_minmax_multi_summary_out</a></li>
<li><a href="#L3126">brin_minmax_multi_summary_recv</a></li>
<li><a href="#L3143">brin_minmax_multi_summary_send</a></li>
<li><a href="#L2736">brin_minmax_multi_union</a></li>
<li><a href="#L722">brin_range_deserialize</a></li>
<li><a href="#L577">brin_range_serialize</a></li>
<li><a href="#L1330">build_distances</a></li>
<li><a href="#L1387">build_expanded_ranges</a></li>
<li><a href="#L1789">compactify_ranges</a></li>
<li><a href="#L1306">compare_distances</a></li>
<li><a href="#L859">compare_expanded_ranges</a></li>
<li><a href="#L897">compare_values</a></li>
<li><a href="#L1416">count_values</a></li>
<li><a href="#L1602">ensure_free_space_in_buffer</a></li>
<li><a href="#L1135">fill_expanded_ranges</a></li>
<li><a href="#L922">has_matching_range</a></li>
<li><a href="#L1232">merge_overlapping_ranges</a></li>
<li><a href="#L2864">minmax_multi_get_procinfo</a></li>
<li><a href="#L2908">minmax_multi_get_strategy_procinfo</a></li>
<li><a href="#L487">minmax_multi_init</a></li>
<li><a href="#L1703">range_add_value</a></li>
<li><a href="#L1046">range_contains_value</a></li>
<li><a href="#L517">range_deduplicate_values</a></li>
<li><a href="#L1477">reduce_expanded_ranges</a></li>
<li><a href="#L1180">sort_expanded_ranges</a></li>
<li><a href="#L1559">store_expanded_ranges</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L106">MINMAX_BUFFER_FACTOR</a></li>
<li><a href="#L109">MINMAX_BUFFER_LOAD_FACTOR</a></li>
<li><a href="#L108">MINMAX_BUFFER_MAX</a></li>
<li><a href="#L107">MINMAX_BUFFER_MIN</a></li>
<li><a href="#L92">MINMAX_MAX_PROCNUMS</a></li>
<li><a href="#L128">MINMAX_MULTI_DEFAULT_VALUES_PER_PAGE</a></li>
<li><a href="#L130">MinMaxMultiGetValuesPerRange</a></li>
<li><a href="#L99">PROCNUM_BASE</a></li>
<li><a href="#L93">PROCNUM_DISTANCE</a></li>
<li><a href="#L135">SAMESIGN</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * brin_minmax_multi.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Implementation of Multi <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>/Max opclass for BRIN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Implements a variant of minmax opclass, where the summary is composed of<br/></li>
<li></span><span class="Comment"> * multiple smaller intervals. This allows us to handle outliers, which<br/></li>
<li></span><span class="Comment"> * usually make the simple minmax opclass inefficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider for example page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with simple minmax interval [1000,2000],<br/></li>
<li></span><span class="Comment"> * and assume a new row gets inserted into the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with value 1000000.<br/></li>
<li></span><span class="Comment"> * Due to that the interval gets [1000,1000000]. I.e. the minmax interval<br/></li>
<li></span><span class="Comment"> * got 1000x wider and won't be useful to eliminate scan keys between 2001<br/></li>
<li></span><span class="Comment"> * and 1000000.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With minmax-multi opclass, we may have [1000,2000] interval initially,<br/></li>
<li></span><span class="Comment"> * but after adding the new row we start tracking it as two interval:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; [1000,2000] and [1000000,1000000]<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows us to still eliminate the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> when the scan keys hit<br/></li>
<li></span><span class="Comment"> * the gap between 2000 and 1000000, making it useful in cases when the<br/></li>
<li></span><span class="Comment"> * simple minmax opclass gets inefficient.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The number of intervals tracked per page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is somewhat flexible.<br/></li>
<li></span><span class="Comment"> * What is restricted is the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, and the limit<br/></li>
<li></span><span class="Comment"> * is currently 32 (see values_per_range reloption). Collapsed intervals<br/></li>
<li></span><span class="Comment"> * (with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> minimum and maximum value) are stored as a single value,<br/></li>
<li></span><span class="Comment"> * while regular intervals require two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> gets too high (by adding new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the<br/></li>
<li></span><span class="Comment"> * summary), we <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> some of the intervals to free space for more <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * This is done in a greedy way - we simply pick the two closest intervals,<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them, and <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> this until the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to store gets<br/></li>
<li></span><span class="Comment"> * sufficiently low (below 50% of maximum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>), but that is mostly<br/></li>
<li></span><span class="Comment"> * arbitrary threshold and may be changed easily).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To pick the closest intervals we use the &quot;distance&quot; support procedure,<br/></li>
<li></span><span class="Comment"> * which measures space between two ranges (i.e. the length of an interval).<br/></li>
<li></span><span class="Comment"> * The computed value may be an approximation - in the worst case we will<br/></li>
<li></span><span class="Comment"> * <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> two ranges that are slightly less optimal at that step, but the<br/></li>
<li></span><span class="Comment"> * index should still produce correct results.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The compactions (reducing the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>) is fairly expensive, as<br/></li>
<li></span><span class="Comment"> * it requires calling the distance <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, sorting etc. So when building<br/></li>
<li></span><span class="Comment"> * the summary, we use a significantly larger buffer, and only enforce the<br/></li>
<li></span><span class="Comment"> * exact limit at the very end. This improves performance, and it also helps<br/></li>
<li></span><span class="Comment"> * with building better ranges (due to the greedy approach).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/brin/brin_minmax_multi.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* needed for PGSQL_AF_INET */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_tuple.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/stratnum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amop.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/date.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/float.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inet.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_lsn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/uuid.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Additional SQL level support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Procedure numbers must not use <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> reserved for BRIN itself; see<br/></li>
<li></span><span class="Comment"> * brin_internal.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L92">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MINMAX_MAX_PROCNUMS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* maximum support procs we need */<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_DISTANCE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* required, distance between <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subtract this from procnum to obtain index in <a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a> arrays<br/></li>
<li></span><span class="Comment"> * (Must be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to minimum of private procnums).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L99">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_BASE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sizing the insert buffer - we use 10x the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> specified<br/></li>
<li></span><span class="Comment"> * in the reloption, but we cap it to 8192 not to get too large. When<br/></li>
<li></span><span class="Comment"> * the buffer gets full, we reduce the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> by half.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MINMAX_BUFFER_FACTOR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MINMAX_BUFFER_MIN</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">256<br/></li>
<li><a id="L108">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MINMAX_BUFFER_MAX</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">8192<br/></li>
<li><a id="L109">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">MINMAX_BUFFER_LOAD_FACTOR</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0.5<br/></li>
<li></span><br/></li>
<li><a id="L111">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MinmaxMultiOpaque</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; extra_procinfos[<a href="#L92" title="access/brin/brin_minmax_multi.c:92">MINMAX_MAX_PROCNUMS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; extra_proc_missing[<a href="#L92" title="access/brin/brin_minmax_multi.c:92">MINMAX_MAX_PROCNUMS</a>];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cached_subtype;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; strategy_procinfos[BTMaxStrategyNumber];<br/></li>
<li><a id="L117">&#x200c;</a>} <span class="linkable">MinmaxMultiOpaque</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Storage type for BRIN's minmax reloptions<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">MinMaxMultiOptions</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; vl_len_;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena header (do not touch directly!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valuesPerRange; <span class="Comment">/* number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li><a id="L126">&#x200c;</a></span>} <span class="linkable">MinMaxMultiOptions</span>;<br/></li>
<li><br/></li>
<li><a id="L128">&#x200c;</a><span class="PreProc">#define <span class="linkable">MINMAX_MULTI_DEFAULT_VALUES_PER_PAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">32<br/></li>
<li></span><br/></li>
<li><a id="L130">&#x200c;</a><span class="PreProc">#define <span class="linkable">MinMaxMultiGetValuesPerRange</span>(opts) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; ((opts) &amp;&amp; (((<a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a> *) (opts))-&gt;valuesPerRange != </span><span class="Constant">0</span><span class="PreProc">) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((<a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a> *) (opts))-&gt;valuesPerRange : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L128" title="access/brin/brin_minmax_multi.c:128">MINMAX_MULTI_DEFAULT_VALUES_PER_PAGE</a>)<br/></li>
<li></span><br/></li>
<li><a id="L135">&#x200c;</a><span class="PreProc">#define <span class="linkable">SAMESIGN</span>(a,b) (((a) &lt; </span><span class="Constant">0</span><span class="PreProc">) == ((b) &lt; </span><span class="Constant">0</span><span class="PreProc">))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The summary of minmax-multi indexes has two representations - <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> for<br/></li>
<li></span><span class="Comment"> * convenient processing, and <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> for storage in bytea value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> struct stores the boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a single array, but we<br/></li>
<li></span><span class="Comment"> * treat regular and single-point ranges differently to save space. For<br/></li>
<li></span><span class="Comment"> * regular ranges (with different boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>) we have to store both<br/></li>
<li></span><span class="Comment"> * the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> and <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, while for &quot;single-point ranges&quot;<br/></li>
<li></span><span class="Comment"> * we only need to store a single value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The '<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>' array stores boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for regular ranges first (there<br/></li>
<li></span><span class="Comment"> * are 2*nranges <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to store), and then the nvalues boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for<br/></li>
<li></span><span class="Comment"> * single-point ranges. That is, we have (2*nranges + nvalues) boundary<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +-------------------------+----------------------------------+<br/></li>
<li></span><span class="Comment"> * | ranges (2 * nranges of) | single point <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (nvalues of) |<br/></li>
<li></span><span class="Comment"> * +-------------------------+----------------------------------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows us to quickly add new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and store outliers without<br/></li>
<li></span><span class="Comment"> * having to widen <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the existing <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'nsorted' denotes how many of 'nvalues' in the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] array are sorted.<br/></li>
<li></span><span class="Comment"> * When nsorted == nvalues, all single point <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are sorted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We never store more than maxvalues <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (as set by values_per_range<br/></li>
<li></span><span class="Comment"> * reloption). If needed we <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> some of the ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To minimize <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> overhead, we always allocate the full array with<br/></li>
<li></span><span class="Comment"> * space for maxvalues elements. This should be fine as long as the<br/></li>
<li></span><span class="Comment"> * maxvalues is reasonably small (64 seems fine), which is the case<br/></li>
<li></span><span class="Comment"> * thanks to values_per_range reloption being limited to 256.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L170">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">Ranges</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cache information that we need quite often. */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* (2*nranges + nvalues) &lt;= maxvalues */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nranges;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of ranges in the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsorted;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of nvalues which are sorted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvalues;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of point <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] array */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxvalues;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of elements in the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] array */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We simply add the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into a large buffer, without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * steps (sorting, deduplication, ...). The buffer is a multiple of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so the compaction happens less often,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * amortizing the costs. We keep the actual target and <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requested number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> at the very end, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> serializing to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on-disk representation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* requested number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_maxvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> stored for this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> - either raw <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, or ranges */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L197">&#x200c;</a>} <span class="linkable">Ranges</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On-disk the summary is stored as a bytea value, with a simple header<br/></li>
<li></span><span class="Comment"> * with basic metadata, followed by the boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. It has a varlena<br/></li>
<li></span><span class="Comment"> * header, so can be treated as varlena directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L577" title="access/brin/brin_minmax_multi.c:577">brin_range_serialize</a>/<a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a> for serialization details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L206">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">SerializedRanges</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* varlena header (do not touch directly!) */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; vl_len_;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* type of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> stored in the data array */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* (2*nranges + nvalues) &lt;= maxvalues */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nranges;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of ranges in the array (stored) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvalues;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the data array (all) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxvalues;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* maximum number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (reloption) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* contains the actual data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L221">&#x200c;</a>} <span class="linkable">SerializedRanges</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *<a href="#L577" title="access/brin/brin_minmax_multi.c:577">brin_range_serialize</a>(<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a>(<span class="Type">int</span> maxvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Used to represent ranges expanded to make merging and combining easier.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each expanded <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is essentially an interval, represented by min/max<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, along with a flag whether it's a collapsed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (in which case<br/></li>
<li></span><span class="Comment"> * the min and max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>). We have the flag to handle by-ref<br/></li>
<li></span><span class="Comment"> * data types - we can't simply <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the datums, and this saves some<br/></li>
<li></span><span class="Comment"> * calls to the type-specific comparator function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L238">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">ExpandedRange</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; minval;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> boundary */<br/></li>
<li></span>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; maxval;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> boundary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collapsed;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if minval==maxval */<br/></li>
<li><a id="L243">&#x200c;</a></span>} <span class="linkable">ExpandedRange</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Represents a distance between two ranges (identified by index into<br/></li>
<li></span><span class="Comment"> * an array of extended ranges).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L249">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">DistanceValue</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li><a id="L253">&#x200c;</a>} <span class="linkable">DistanceValue</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Cache for support and strategy procedures. */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> FmgrInfo *<a href="#L2864" title="access/brin/brin_minmax_multi.c:2864">minmax_multi_get_procinfo</a>(BrinDesc *bdesc, uint16 attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 procnum);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> FmgrInfo *<a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(BrinDesc *bdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 attno, Oid subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 strategynum);<br/></li>
<li><br/></li>
<li><a id="L265">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">compare_context</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpFn;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid;<br/></li>
<li><a id="L269">&#x200c;</a>} <span class="linkable">compare_context</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that the order of the array <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is correct, using the <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a><br/></li>
<li></span><span class="Comment"> * function (which should be BTLessStrategyNumber).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L280">&#x200c;</a></span><span class="linkable">AssertArrayOrder</span>(FmgrInfo *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, Oid colloid, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">int</span> nvalues)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; (nvalues - <span class="Constant">1</span>); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lt = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, colloid, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i], <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i + <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(DatumGetBool(lt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comprehensive check of the <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> structure.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="linkable">AssertCheckRanges</span>(<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges, FmgrInfo *cmpFn, Oid colloid)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* some basic sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ranges-&gt;nranges &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(ranges-&gt;nsorted &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(ranges-&gt;nvalues &gt;= ranges-&gt;nsorted);<br/></li>
<li>&nbsp; &nbsp; Assert(ranges-&gt;maxvalues &gt;= <span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nvalues);<br/></li>
<li>&nbsp; &nbsp; Assert(ranges-&gt;typid != InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First the ranges - there are 2*nranges boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to be strictly ordered (<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> would mean the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collapsed, and should be stored as a point). This also guarantees that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the ranges do not overlap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L280" title="access/brin/brin_minmax_multi.c:280">AssertArrayOrder</a>(cmpFn, colloid, ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Constant">2</span> * ranges-&gt;nranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* then the single-point ranges (with nvalues boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> ) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L280" title="access/brin/brin_minmax_multi.c:280">AssertArrayOrder</a>(cmpFn, colloid, &amp;ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges-&gt;nsorted);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not covered by ranges (both sorted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and unsorted)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ranges-&gt;nranges &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ranges-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; compar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; minvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; maxvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges + i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpFn, colloid, value, minvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the value is smaller than the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound in the first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then it cannot possibly be in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpFn, colloid, maxvalue, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, if the value is larger than the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * final <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, then it cannot possibly be inside <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bsearch the ranges to see if 'value' fits within <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = ranges-&gt;nranges - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* last <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; midpoint = (start + end) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this means we ran out of ranges in the last step */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start &gt; end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the min/max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * midpoint];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * midpoint + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is the value smaller than the minval? If yes, we'll recurse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the left side of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpFn, colloid, value, minvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* smaller than the smallest value in this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = (midpoint - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is the value greater than the minval? If yes, we'll recurse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the right side of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpFn, colloid, maxvalue, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* larger than the largest value in this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = (midpoint + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hey, we found a matching <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the unsorted part must not be in the sorted part */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ranges-&gt;nsorted &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.colloid = ranges-&gt;colloid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.cmpFn = ranges-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = ranges-&gt;nsorted; i &lt; ranges-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges + i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(bsearch_arg(&amp;value, &amp;ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges-&gt;nsorted, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>, (<span class="Type">void</span> *) &amp;cxt) == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that the expanded ranges (built when reducing the number of ranges<br/></li>
<li></span><span class="Comment"> * by combining some of them) are correctly sorted and do not overlap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L427">&#x200c;</a></span><span class="linkable">AssertCheckExpandedRanges</span>(BrinDesc *bdesc, Oid colloid, AttrNumber attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr, <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *ranges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> nranges)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *eq;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *lt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; eq = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lt = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> independently should be valid, i.e. that for the boundary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (<a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> &lt;= <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; minval = ranges[i].minval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; maxval = ranges[i].maxval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ranges[i].collapsed)&nbsp; &nbsp; <span class="Comment">/* collapsed: minval == maxval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(eq, colloid, minval, maxval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* non-collapsed: minval &lt; maxval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(lt, colloid, minval, maxval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(DatumGetBool(r));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And the ranges should be ordered and must not overlap, i.e. <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> &lt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> for boundaries of consecutive ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nranges - <span class="Constant">1</span>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; maxval = ranges[i].maxval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; minval = ranges[i + <span class="Constant">1</span>].minval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(lt, colloid, maxval, minval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(DatumGetBool(r));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L487" title="access/brin/brin_minmax_multi.c:487">minmax_multi_init</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Initialize the deserialized <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> list, allocate all the memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only in-memory representation of the ranges, so we allocate<br/></li>
<li></span><span class="Comment"> * enough space for the maximum number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (so as not to have to do<br/></li>
<li></span><span class="Comment"> * repallocs as the ranges grow).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<br/></li>
<li><a id="L487">&#x200c;</a><span class="linkable">minmax_multi_init</span>(<span class="Type">int</span> maxvalues)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(maxvalues &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = offsetof(<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>); <span class="Comment">/* fixed header */<br/></li>
<li></span>&nbsp; &nbsp; len += maxvalues * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum);&nbsp; &nbsp; <span class="Comment">/* Datum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ranges = (<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ranges-&gt;maxvalues = maxvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ranges;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L517" title="access/brin/brin_minmax_multi.c:517">range_deduplicate_values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Deduplicate the part with <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the simple points.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is meant to be a cheaper way of reducing the size of the ranges. It<br/></li>
<li></span><span class="Comment"> * does not touch the ranges, and only sorts the other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> - it does not<br/></li>
<li></span><span class="Comment"> * call the distance <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which may be quite expensive, etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not duplicate with the ranges, because we check<br/></li>
<li></span><span class="Comment"> * that <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> adding a new value. Same for the sorted part of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L517">&#x200c;</a></span><span class="linkable">range_deduplicate_values</span>(<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start;<br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no unsorted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, we're done (this probably can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen, as we're adding <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to unsorted part).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nsorted == <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; cxt.colloid = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;colloid;<br/></li>
<li>&nbsp; &nbsp; cxt.cmpFn = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> start right after the ranges (which are always sorted) */<br/></li>
<li></span>&nbsp; &nbsp; start = <span class="Constant">2</span> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This might do a <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> sort, to leverage that the first part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array is already sorted. If the sorted part is large, it might be quite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> faster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort_arg(&amp;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[start],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>, &amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* same as preceding value, so store it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>(&amp;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[start + i - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[start + i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;cxt) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[start + n] = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[start + i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are sorted */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues = n;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nsorted = n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L297" title="access/brin/brin_minmax_multi.c:297">AssertCheckRanges</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;colloid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L577" title="access/brin/brin_minmax_multi.c:577">brin_range_serialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Serialize the in-memory representation into a <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> varlena value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simply copy the header and then also the individual <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, as stored<br/></li>
<li></span><span class="Comment"> * in the in-memory value array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *<br/></li>
<li><a id="L577">&#x200c;</a><span class="linkable">brin_range_serialize</span>(<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvalues;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* simple sanity checks */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nsorted &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;target_maxvalues &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* at this point the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> should be compacted to the target size */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<span class="Constant">2</span> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges + <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues &lt;= <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;target_maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;target_maxvalues &lt;= <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries are always sorted */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues &gt;= <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nsorted);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deduplicate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, if there's unsorted part */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L517" title="access/brin/brin_minmax_multi.c:517">range_deduplicate_values</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see how many Datum <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we actually have */<br/></li>
<li></span>&nbsp; &nbsp; nvalues = <span class="Constant">2</span> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges + <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typid = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;typid;<br/></li>
<li>&nbsp; &nbsp; typbyval = <a href="../../utils/cache/lsyscache.c.html#L2222" title="utils/cache/lsyscache.c:2222">get_typbyval</a>(typid);<br/></li>
<li>&nbsp; &nbsp; typlen = <a href="../../utils/cache/lsyscache.c.html#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* header is always needed */<br/></li>
<li></span>&nbsp; &nbsp; len = offsetof(<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a>, data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The space needed depends on data type - for fixed-length data types<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (by-value and some by-reference) it's pretty simple, just multiply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (attlen * nvalues) and we're done. For variable-length by-reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * types we need to actually walk all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and sum the lengths.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len += VARSIZE_ANY(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">2</span>)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't forget to include the null terminator ;-) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len += strlen(DatumGetCString(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i])) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-length types (even by-reference) */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(typlen &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len += nvalues * typlen;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate the serialized object, copy the basic information. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serialized object is a varlena, so update the header.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; serialized = (<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(serialized, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; serialized-&gt;typid = typid;<br/></li>
<li>&nbsp; &nbsp; serialized-&gt;nranges = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges;<br/></li>
<li>&nbsp; &nbsp; serialized-&gt;nvalues = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues;<br/></li>
<li>&nbsp; &nbsp; serialized-&gt;maxvalues = <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;target_maxvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> copy also the boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (like the length calculation this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depends on the particular data type).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ptr = serialized-&gt;data;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start of the serialized data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typbyval)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple by-value data types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For byval types, we need to copy just the significant bytes -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can't use memcpy directly, as that assumes little-endian<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behavior.&nbsp; store_att_byval does almost what we need, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requires a properly aligned buffer - the output buffer does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantee that. So we simply use a local Datum variable (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * guarantees proper alignment), and then copy the value from it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; store_att_byval(&amp;tmp, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i], typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, &amp;tmp, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* fixed-length by-ref types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetPointer(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]), typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = VARSIZE_ANY(DatumGetPointer(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetPointer(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]), tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">2</span>)&nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = strlen(DatumGetCString(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i])) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(ptr, DatumGetCString(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]), tmp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we haven't overflown the buffer end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= ((<span class="Type">char</span> *) serialized + len));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* exact size */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ptr == ((<span class="Type">char</span> *) serialized + len));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> serialized;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Serialize the in-memory representation into a <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> varlena value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simply copy the header and then also the individual <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, as stored<br/></li>
<li></span><span class="Comment"> * in the in-memory value array.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<br/></li>
<li><a id="L722">&#x200c;</a><span class="linkable">brin_range_deserialize</span>(<span class="Type">int</span> maxvalues, <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvalues;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *dataptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typbyval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typlen;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(serialized-&gt;nranges &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(serialized-&gt;nvalues &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(serialized-&gt;maxvalues &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nvalues = <span class="Constant">2</span> * serialized-&gt;nranges + serialized-&gt;nvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nvalues &lt;= serialized-&gt;maxvalues);<br/></li>
<li>&nbsp; &nbsp; Assert(serialized-&gt;maxvalues &lt;= maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="#L487" title="access/brin/brin_minmax_multi.c:487">minmax_multi_init</a>(maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy the header info */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges = serialized-&gt;nranges;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues = serialized-&gt;nvalues;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nsorted = serialized-&gt;nvalues;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues = maxvalues;<br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;target_maxvalues = serialized-&gt;maxvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;typid = serialized-&gt;typid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typbyval = <a href="../../utils/cache/lsyscache.c.html#L2222" title="utils/cache/lsyscache.c:2222">get_typbyval</a>(serialized-&gt;typid);<br/></li>
<li>&nbsp; &nbsp; typlen = <a href="../../utils/cache/lsyscache.c.html#L2197" title="utils/cache/lsyscache.c:2197">get_typlen</a>(serialized-&gt;typid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> deconstruct the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> into Datum array. We have to copy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data because the serialized representation ignores alignment, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want to rely on it being kept around anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ptr = serialized-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't want to allocate many pieces, so we just allocate everything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in one chunk. How much space will we need?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We don't need to copy simple by-value data types.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; datalen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dataptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; (i &lt; nvalues) &amp;&amp; (!typbyval); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fixed-length by-ref types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen += MAXALIGN(typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen += MAXALIGN(VARSIZE_ANY(ptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += VARSIZE_ANY(ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">2</span>)&nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; slen = strlen(ptr) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen += MAXALIGN(slen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += slen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (datalen &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dataptr = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore the source pointer (might have been modified when calculating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the space we need to allocate).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ptr = serialized-&gt;data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (typbyval)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple by-value data types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; v = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;v, ptr, typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = fetch_att(&amp;v, <span class="Constant">true</span>, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen &gt; <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* fixed-length by-ref types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = PointerGetDatum(dataptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dataptr, ptr, typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataptr += MAXALIGN(typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* varlena */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = PointerGetDatum(dataptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dataptr, ptr, VARSIZE_ANY(ptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataptr += MAXALIGN(VARSIZE_ANY(ptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += VARSIZE_ANY(ptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (typlen == -<span class="Constant">2</span>)&nbsp; &nbsp; <span class="Comment">/* cstring */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; slen = strlen(ptr) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = PointerGetDatum(dataptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(dataptr, ptr, slen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataptr += MAXALIGN(slen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr += slen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* make sure we haven't overflown the buffer end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ptr &lt;= ((<span class="Type">char</span> *) serialized + VARSIZE_ANY(serialized)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should have consumed the whole input value exactly */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ptr == ((<span class="Type">char</span> *) serialized + VARSIZE_ANY(serialized)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return the deserialized value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L859" title="access/brin/brin_minmax_multi.c:859">compare_expanded_ranges</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compare the expanded ranges - first by minimum, then by maximum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do guarantee that ranges in a single <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> object do not overlap, so it<br/></li>
<li></span><span class="Comment"> * may seem strange that we don't order just by minimum. But when merging two<br/></li>
<li></span><span class="Comment"> * <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> (which happens in the union function), the ranges may in fact<br/></li>
<li></span><span class="Comment"> * overlap. So we do <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> both.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">compare_expanded_ranges</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *ra = (<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *rb = (<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *) b;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> *cxt = (<a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> minvals */<br/></li>
<li></span>&nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;cmpFn, cxt-&gt;colloid, ra-&gt;minval, rb-&gt;minval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;cmpFn, cxt-&gt;colloid, rb-&gt;minval, ra-&gt;minval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* then <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> maxvals */<br/></li>
<li></span>&nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;cmpFn, cxt-&gt;colloid, ra-&gt;maxval, rb-&gt;maxval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;cmpFn, cxt-&gt;colloid, rb-&gt;maxval, ra-&gt;maxval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Compare the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L897">&#x200c;</a></span><span class="linkable">compare_values</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *da = (Datum *) a;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *db = (Datum *) b;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> *cxt = (<a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;cmpFn, cxt-&gt;colloid, *da, *db);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;cmpFn, cxt-&gt;colloid, *db, *da);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check if the new value matches one of the existing ranges.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L922">&#x200c;</a></span><span class="linkable">has_matching_range</span>(BrinDesc *bdesc, Oid colloid, <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, AttrNumber attno, Oid typid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; compar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; minvalue;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; maxvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpLessFn;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpGreaterFn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* binary search on ranges */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ranges-&gt;nranges == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; minvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; maxvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, need to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the new value with boundaries of all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ranges. First check if it's less than the absolute minimum, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the first value in the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmpLessFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpLessFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, minvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* smaller than the smallest value in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> list */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it to the existing maximum (last value in the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array). But only if we haven't already ruled out a possible match in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the minvalue check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmpGreaterFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpGreaterFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, maxvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So we know it's in the general min/max, the question is whether it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * falls in one of the ranges or gaps. We'll do a binary search on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * individual ranges - for each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> we check equality (value falls into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>), and then check ranges either above or below the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; start = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; end = (ranges-&gt;nranges - <span class="Constant">1</span>);&nbsp; &nbsp; <span class="Comment">/* last <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">true</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; midpoint = (start + end) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this means we ran out of ranges in the last step */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start &gt; end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the min/max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; minvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * midpoint];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxvalue = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * midpoint + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is the value smaller than the minval? If yes, we'll recurse to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left side of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpLessFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, minvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* smaller than the smallest value in this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; end = (midpoint - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Is the value greater than the minval? If yes, we'll recurse to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right side of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpGreaterFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, maxvalue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* larger than the largest value in this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; start = (midpoint + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hey, we found a matching <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1046" title="access/brin/brin_minmax_multi.c:1046">range_contains_value</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; See if the new value is already contained in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We first inspect the list of intervals. We use a small trick - we check<br/></li>
<li></span><span class="Comment"> * the value against min/max of the whole <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (min of the first interval,<br/></li>
<li></span><span class="Comment"> * max of the last one) first, and only inspect the individual intervals if<br/></li>
<li></span><span class="Comment"> * this passes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the value matches <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> of the intervals, we check the exact <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * We simply loop through them and invoke equality operator on them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The last parameter (full) determines whether we need to search all the<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, including the unsorted part. With full=false, the unsorted part<br/></li>
<li></span><span class="Comment"> * is not searched, which may produce false negatives and duplicate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * (in the unsorted part only), but when we're building the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that's<br/></li>
<li></span><span class="Comment"> * fine - we'll deduplicate <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> serialization, and it can only happen<br/></li>
<li></span><span class="Comment"> * if there already are unsorted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (so it was already modified).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Serialized ranges don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unsorted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so this can't cause<br/></li>
<li></span><span class="Comment"> * false negatives during querying.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1046">&#x200c;</a></span><span class="linkable">range_contains_value</span>(BrinDesc *bdesc, Oid colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumber attno, Form_pg_attribute attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges, Datum <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> full)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpEqualFn;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typid = attr-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First inspect the ranges, if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. We first check the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, and only when there's still a chance of getting a match we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inspect the individual ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L922" title="access/brin/brin_minmax_multi.c:922">has_matching_range</a>(bdesc, colloid, ranges, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, attno, typid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmpEqualFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is no matching <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so let's inspect the sorted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do a sequential search for small numbers of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and binary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search once we have more than 16 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. This threshold is somewhat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arbitrary, as it depends on how expensive the comparison function is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> If we use the threshold here, maybe we should do the same thing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L922" title="access/brin/brin_minmax_multi.c:922">has_matching_range</a>? Or maybe we should do the bin search all the time?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We could use the same optimization as for ranges, to check if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value is between min/max, to maybe rule out all sorted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * having to inspect all of them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ranges-&gt;nsorted &gt;= <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.colloid = ranges-&gt;colloid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.cmpFn = ranges-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bsearch_arg(&amp;<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, &amp;ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;nsorted, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>, (<span class="Type">void</span> *) &amp;cxt) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">2</span> * ranges-&gt;nranges; i &lt; <span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nsorted; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; compar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpEqualFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found an exact match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If not asked to inspect the unsorted part, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!full)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Inspect the unsorted part. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nsorted; i &lt; <span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; compar;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpEqualFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found an exact match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the value is not covered by this BRIN tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Expand ranges from <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> into <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> array. This expects the<br/></li>
<li></span><span class="Comment"> * eranges to be pre-allocated and with the correct size - there needs to be<br/></li>
<li></span><span class="Comment"> * (nranges + nvalues) elements.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The order of expanded ranges is arbitrary. We do expand the ranges first,<br/></li>
<li></span><span class="Comment"> * and this part is sorted. But then we expand the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and this part may<br/></li>
<li></span><span class="Comment"> * be unsorted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1135">&#x200c;</a></span><span class="linkable">fill_expanded_ranges</span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges, <span class="Type">int</span> neranges, <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the output array has the right size. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(neranges == (ranges-&gt;nranges + ranges-&gt;nvalues));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ranges-&gt;nranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].minval = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].maxval = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * i + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].collapsed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(idx &lt;= neranges);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ranges-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].minval = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges + i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].maxval = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges + i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].collapsed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(idx &lt;= neranges);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we produce the expected number of elements? */<br/></li>
<li></span>&nbsp; &nbsp; Assert(idx == neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sort and deduplicate expanded ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The ranges may be deduplicated - we're simply appending <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, without<br/></li>
<li></span><span class="Comment"> * checking for duplicates etc. So maybe the deduplication will reduce the<br/></li>
<li></span><span class="Comment"> * number of ranges enough, and we won't have to compute the distances etc.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of expanded ranges.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1180">&#x200c;</a></span><span class="linkable">sort_expanded_ranges</span>(FmgrInfo *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, Oid colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges, <span class="Type">int</span> neranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(neranges &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; cxt.colloid = colloid;<br/></li>
<li>&nbsp; &nbsp; cxt.cmpFn = <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We do qsort on all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, but we could also leverage the fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that some of the input data is already sorted (all the ranges and maybe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some of the points) and do <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort_arg(eranges, neranges, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L859" title="access/brin/brin_minmax_multi.c:859">compare_expanded_ranges</a>, &amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deduplicate the ranges - simply <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> each <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to the preceding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one, and <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the duplicate ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; n = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; neranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the current <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the preceding one, do nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L859" title="access/brin/brin_minmax_multi.c:859">compare_expanded_ranges</a>(&amp;eranges[i - <span class="Constant">1</span>], &amp;eranges[i], (<span class="Type">void</span> *) &amp;cxt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, copy it to n-th place (if not already there) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i != n)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;eranges[n], &amp;eranges[i], <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((n &gt; <span class="Constant">0</span>) &amp;&amp; (n &lt;= neranges));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When combining multiple <a href="../../utils/adt/geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (in union function), some of the<br/></li>
<li></span><span class="Comment"> * ranges may overlap. We simply <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the overlapping ranges to fix that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> This assumes the expanded ranges were previously sorted (by minval<br/></li>
<li></span><span class="Comment"> * and then maxval). We leverage this when detecting overlap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1232">&#x200c;</a></span><span class="linkable">merge_overlapping_ranges</span>(FmgrInfo *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, Oid colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges, <span class="Type">int</span> neranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Merge ranges (idx) and (idx+1) if they overlap. */<br/></li>
<li></span>&nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (idx &lt; (neranges - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparing [?,maxval] vs. [minval,?] - the ranges overlap if (minval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &lt; maxval)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].maxval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eranges[idx + <span class="Constant">1</span>].minval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nope, maxval &lt; minval, so no overlap. And we know the ranges are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ordered, so there are no more overlaps, because all the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ranges have greater or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> minval.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* proceed to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So ranges 'idx' and 'idx+1' do overlap, but we don't know if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'idx+1' is contained in 'idx', or if they overlap only partially.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bounds and keep the larger one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].maxval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eranges[idx + <span class="Constant">1</span>].maxval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(r))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].maxval = eranges[idx + <span class="Constant">1</span>].maxval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> certainly is no longer collapsed (irrespectively of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous state).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eranges[idx].collapsed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now get rid of the (idx+1) <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> entirely by shifting the remaining<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ranges by 1. There are neranges elements, and we need to move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * elements from (idx+2). That means the number of elements to move is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * [ncranges - (idx+2)].<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;eranges[idx + <span class="Constant">1</span>], &amp;eranges[idx + <span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (neranges - (idx + <span class="Constant">2</span>)) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Decrease the number of ranges, and <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> (with the same <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it might overlap with additional ranges thanks to the <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; neranges--;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> neranges;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Simple comparator for distance <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, comparing the double value.<br/></li>
<li></span><span class="Comment"> * This is intentionally sorting the distances in descending order, i.e.<br/></li>
<li></span><span class="Comment"> * the longer gaps will be at the front.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1306">&#x200c;</a></span><span class="linkable">compare_distances</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *da = (<a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *) a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *db = (<a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (da-&gt;value &lt; db-&gt;value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (da-&gt;value &gt; db-&gt;value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an array of expanded ranges, compute size of the gaps between each<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; For neranges there are (neranges-1) gaps.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We simply call the &quot;distance&quot; function to compute the (max-min) for pairs<br/></li>
<li></span><span class="Comment"> * of consecutive ranges. The function may be fairly expensive, so we do that<br/></li>
<li></span><span class="Comment"> * just once (and then use it to pick as many ranges to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> as possible).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See <a href="#L1477" title="access/brin/brin_minmax_multi.c:1477">reduce_expanded_ranges</a> for details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *<br/></li>
<li><a id="L1330">&#x200c;</a><span class="linkable">build_distances</span>(FmgrInfo *distanceFn, Oid colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges, <span class="Type">int</span> neranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistances;<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *distances;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(neranges &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there's only a single <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, there's no distance to calculate. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (neranges == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ndistances = (neranges - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; distances = (<a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a>) * ndistances);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Walk through the ranges once and compute the distance between the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ranges so that we can sort them once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ndistances; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = eranges[i].maxval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = eranges[i + <span class="Constant">1</span>].minval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* compute length of the gap (between max/min) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; r = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(distanceFn, colloid, <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember the index of the gap the distance is for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; distances[i].index = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; distances[i].value = DatumGetFloat8(r);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort the distances in descending order, so that the <a href="../../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> gaps are at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the front.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort(distances, ndistances, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a>), <a href="#L1306" title="access/brin/brin_minmax_multi.c:1306">compare_distances</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> distances;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Builds expanded ranges for the existing ranges (and single-point ranges),<br/></li>
<li></span><span class="Comment"> * and also the new value (which did not fit into the array).&nbsp; This expanded<br/></li>
<li></span><span class="Comment"> * representation makes the processing a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> easier, as it allows handling<br/></li>
<li></span><span class="Comment"> * ranges and points the same way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We sort and deduplicate the expanded ranges - this is necessary, because<br/></li>
<li></span><span class="Comment"> * the points may be unsorted. And moreover the two parts (ranges and<br/></li>
<li></span><span class="Comment"> * points) are sorted on their own.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *<br/></li>
<li><a id="L1387">&#x200c;</a><span class="linkable">build_expanded_ranges</span>(FmgrInfo *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, Oid colloid, <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *nranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neranges;<br/></li>
<li>&nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* both ranges and points are expanded into a separate <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; neranges = ranges-&gt;nranges + ranges-&gt;nvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; eranges = (<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(neranges * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill the expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1135" title="access/brin/brin_minmax_multi.c:1135">fill_expanded_ranges</a>(eranges, neranges, ranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort and deduplicate the expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; neranges = <a href="#L1180" title="access/brin/brin_minmax_multi.c:1180">sort_expanded_ranges</a>(<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, colloid, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember how many ranges we built */<br/></li>
<li></span>&nbsp; &nbsp; *nranges = neranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> eranges;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Counts boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> needed to store the ranges. Each single-point<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is stored using a single value, each regular <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> needs two.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1416">&#x200c;</a></span><span class="linkable">count_values</span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *cranges, <span class="Type">int</span> ncranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ncranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cranges[i].collapsed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count += <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1477" title="access/brin/brin_minmax_multi.c:1477">reduce_expanded_ranges</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; reduce the ranges until the number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> is low enough<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Combines ranges until the number of boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> drops below the<br/></li>
<li></span><span class="Comment"> * threshold specified by max_values. This happens by merging enough<br/></li>
<li></span><span class="Comment"> * ranges by the distance between them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the number of result ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We simply use the global min/max and then add boundaries for enough<br/></li>
<li></span><span class="Comment"> * largest gaps. Each gap adds 2 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so we simply use (target/2-1)<br/></li>
<li></span><span class="Comment"> * distances. Then we simply sort all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> - each two <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment"> * a boundary of a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (possibly collapsed).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Some of the ranges may be collapsed (i.e. the min/max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment"> * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>), but we ignore that for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. We could <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the process,<br/></li>
<li></span><span class="Comment"> * adding a couple more gaps recursively.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> The ranges to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> are selected solely using the distance. But<br/></li>
<li></span><span class="Comment"> * that may not be the best strategy, for example when multiple gaps<br/></li>
<li></span><span class="Comment"> * are of <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> (or very similar) length.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Consider for example points 1, 2, 3, .., 64, which have gaps of the<br/></li>
<li></span><span class="Comment"> * same length 1 of course. In that case, we tend to pick the first<br/></li>
<li></span><span class="Comment"> * gap of that length, which leads to this:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; step 1:&nbsp; [1, 2], 3, 4, 5, .., 64<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; step 2:&nbsp; [1, 3], 4, 5,&nbsp; &nbsp; .., 64<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; step 3:&nbsp; [1, 4], 5,&nbsp; &nbsp; &nbsp;&nbsp; .., 64<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; ...<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * So in the end we'll have one &quot;large&quot; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and multiple small points.<br/></li>
<li></span><span class="Comment"> * That may be fine, but it seems a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> strange and non-optimal. Maybe<br/></li>
<li></span><span class="Comment"> * we should consider other things when picking ranges to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> - e.g.<br/></li>
<li></span><span class="Comment"> * length of the ranges? Or perhaps randomize the choice of ranges, with<br/></li>
<li></span><span class="Comment"> * probability inversely proportional to the distance (the gap lengths<br/></li>
<li></span><span class="Comment"> * may be very close, but not exactly the same).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Or maybe we could just handle this by using random value as a<br/></li>
<li></span><span class="Comment"> * tie-break, or by adding random noise to the actual distance.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1477">&#x200c;</a></span><span class="linkable">reduce_expanded_ranges</span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges, <span class="Type">int</span> neranges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *distances, <span class="Type">int</span> max_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>, Oid colloid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nvalues;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L265" title="access/brin/brin_minmax_multi.c:265">compare_context</a> cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* total number of gaps between ranges */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndistances = (neranges - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of gaps to keep */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keep = (max_values / <span class="Constant">2</span> - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maybe we have a sufficiently low number of ranges already?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This should happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we actually do the expensive stuff like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorting, so maybe this should be just an assert.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (keep &gt;= ndistances)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> neranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; cxt.colloid = colloid;<br/></li>
<li>&nbsp; &nbsp; cxt.cmpFn = <a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate space for the boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; nvalues = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = (Datum *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * max_values);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add the global min/max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, from the first/last <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nvalues++] = eranges[<span class="Constant">0</span>].minval;<br/></li>
<li>&nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nvalues++] = eranges[neranges - <span class="Constant">1</span>].maxval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for enough gaps */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; keep; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index of the gap between (index) and (index+1) ranges */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index = distances[i].index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((index &gt;= <span class="Constant">0</span>) &amp;&amp; ((index + <span class="Constant">1</span>) &lt; neranges));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add max from the preceding <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, minval from the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nvalues++] = eranges[index].maxval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[nvalues++] = eranges[index + <span class="Constant">1</span>].minval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(nvalues &lt;= max_values);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We should have an even number of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nvalues % <span class="Constant">2</span> == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sort the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> using the comparator function, and form ranges from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorted result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort_arg(<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nvalues, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>, &amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have nvalues boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, which means nvalues/2 ranges. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; (nvalues / <span class="Constant">2</span>); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[i].minval = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; eranges[i].maxval = <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * i + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are the same, it's a collapsed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; eranges[i].collapsed = (<a href="#L897" title="access/brin/brin_minmax_multi.c:897">compare_values</a>(&amp;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * i + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;cxt) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (nvalues / <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store the boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from ExpandedRanges back into 'ranges' (using<br/></li>
<li></span><span class="Comment"> * only the minimal number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> needed).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1559">&#x200c;</a></span><span class="linkable">store_expanded_ranges</span>(<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges, <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges, <span class="Type">int</span> neranges)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* first copy in the regular ranges */<br/></li>
<li></span>&nbsp; &nbsp; ranges-&gt;nranges = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; neranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!eranges[i].collapsed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx++] = eranges[i].minval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx++] = eranges[i].maxval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;nranges++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> copy in the collapsed ones */<br/></li>
<li></span>&nbsp; &nbsp; ranges-&gt;nvalues = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; neranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eranges[i].collapsed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx++] = eranges[i].minval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;nvalues++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are sorted */<br/></li>
<li></span>&nbsp; &nbsp; ranges-&gt;nsorted = ranges-&gt;nvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1416" title="access/brin/brin_minmax_multi.c:1416">count_values</a>(eranges, neranges) == <span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nvalues);<br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nvalues &lt;= ranges-&gt;maxvalues);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Consider freeing space in the ranges. Checks if there's space for at least<br/></li>
<li></span><span class="Comment"> * one new value, and performs compaction if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the value was actually modified.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1602">&#x200c;</a></span><span class="linkable">ensure_free_space_in_buffer</span>(BrinDesc *bdesc, Oid colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attno, Form_pg_attribute attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext ctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpFn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *distanceFn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neranges;<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *distances;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is free space in the buffer, we're done without having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modify anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<span class="Constant">2</span> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges + <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues &lt; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we'll certainly need the comparator, so just look it up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; cmpFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deduplicate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, if there's an unsorted part */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L517" title="access/brin/brin_minmax_multi.c:517">range_deduplicate_values</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Did we reduce enough free space by just the deduplication?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't simply check against <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues again. The deduplication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have freed very little space (e.g. just one value), forcing us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do deduplication very often. In that case, it's better to do the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compaction and reduce more space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<span class="Constant">2</span> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nranges + <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;nvalues &lt;= <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues * <a href="#L109" title="access/brin/brin_minmax_multi.c:109">MINMAX_BUFFER_LOAD_FACTOR</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> some of the existing ranges, to reduce the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we have to store.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The distanceFn calls (which may internally call e.g. <a href="../../utils/adt/numeric.c.html#L2490" title="utils/adt/numeric.c:2490">numeric_le</a>) may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate quite a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of memory, and we must not leak it (we might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to do this repeatedly, even for a single BRIN page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>). Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd have problems e.g. when building new indexes. So we use a memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context and make sure we free the memory at the end (so if we call the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distance function many times, it might be an issue, but meh).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;minmax-multi context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; eranges = <a href="#L1387" title="access/brin/brin_minmax_multi.c:1387">build_expanded_ranges</a>(cmpFn, colloid, <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, &amp;neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the expanded representation of ranges correct? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L427" title="access/brin/brin_minmax_multi.c:427">AssertCheckExpandedRanges</a>(bdesc, colloid, attno, attr, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and we'll also need the 'distance' procedure */<br/></li>
<li></span>&nbsp; &nbsp; distanceFn = <a href="#L2864" title="access/brin/brin_minmax_multi.c:2864">minmax_multi_get_procinfo</a>(bdesc, attno, <a href="#L93" title="access/brin/brin_minmax_multi.c:93">PROCNUM_DISTANCE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build array of gap distances and sort them in ascending order */<br/></li>
<li></span>&nbsp; &nbsp; distances = <a href="#L1330" title="access/brin/brin_minmax_multi.c:1330">build_distances</a>(distanceFn, colloid, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Combine ranges until we release at least 50% of the space. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * threshold is somewhat arbitrary, perhaps needs tuning. We must not use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too low or high value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; neranges = <a href="#L1477" title="access/brin/brin_minmax_multi.c:1477">reduce_expanded_ranges</a>(eranges, neranges, distances,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues * <a href="#L109" title="access/brin/brin_minmax_multi.c:109">MINMAX_BUFFER_LOAD_FACTOR</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpFn, colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the result of reducing expanded ranges correct? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L427" title="access/brin/brin_minmax_multi.c:427">AssertCheckExpandedRanges</a>(bdesc, colloid, attno, attr, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we've sufficiently reduced the number of ranges. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L1416" title="access/brin/brin_minmax_multi.c:1416">count_values</a>(eranges, neranges) &lt;= <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;maxvalues * <a href="#L109" title="access/brin/brin_minmax_multi.c:109">MINMAX_BUFFER_LOAD_FACTOR</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* decompose the expanded ranges into regular ranges and single <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1559" title="access/brin/brin_minmax_multi.c:1559">store_expanded_ranges</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Did we break the ranges somehow? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="access/brin/brin_minmax_multi.c:297">AssertCheckRanges</a>(<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, cmpFn, colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1703" title="access/brin/brin_minmax_multi.c:1703">range_add_value</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Add the new value to the minmax-multi <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1703">&#x200c;</a></span><span class="linkable">range_add_value</span>(BrinDesc *bdesc, Oid colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber attno, Form_pg_attribute attr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges, Datum <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpFn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; modified = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we'll certainly need the comparator, so just look it up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; cmpFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* comprehensive checks of the input ranges */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="access/brin/brin_minmax_multi.c:297">AssertCheckRanges</a>(ranges, cmpFn, colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure there's enough free space in the buffer. We only <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the buffer is full, which means it had to be modified as we size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it to be larger than what is stored on disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This needs to happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we check if the value is contained in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, because the value might be in the unsorted part, and we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check that in <a href="#L1046" title="access/brin/brin_minmax_multi.c:1046">range_contains_value</a>. The deduplication would then move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it to the sorted part, and we'd add the value too, which violates the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rule that we never have duplicates with the ranges or sorted <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might also deduplicate and recheck if the value is contained, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that seems like overkill. We'd need to deduplicate anyway, so why not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; modified = <a href="#L1602" title="access/brin/brin_minmax_multi.c:1602">ensure_free_space_in_buffer</a>(bdesc, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno, attr, ranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Bail out if the value already is covered by the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could also add <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> until we hit values_per_range, and then do the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deduplication in a batch, hoping for better efficiency. But that would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mean we actually modify the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> every time, which means having to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * serialize the value, which does <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>, walks the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, copies them,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * etc. Not exactly cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So instead we do the check, which should be fairly cheap - assuming the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparator function is not very expensive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This also implies the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> array can't contain duplicate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1046" title="access/brin/brin_minmax_multi.c:1046">range_contains_value</a>(bdesc, colloid, attno, attr, ranges, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> modified;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a copy of the value, if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, attr-&gt;attbyval, attr-&gt;attlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there's space in the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> array, copy it in and we're done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do want to keep the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> sorted (to speed up searches), so we do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple insertion sort. We could do something more elaborate, e.g. by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorting the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> only <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> and then, but for small counts (e.g. when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maxvalues is 64) this should be fine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges + ranges-&gt;nvalues] = <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>;<br/></li>
<li>&nbsp; &nbsp; ranges-&gt;nvalues++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we added the first value, we can consider it as sorted. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ranges-&gt;nvalues == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;nsorted = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check we haven't broken the ordering of boundary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (checks both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parts, but that doesn't hurt).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="access/brin/brin_minmax_multi.c:297">AssertCheckRanges</a>(ranges, cmpFn, colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> contains the value we just added. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L1046" title="access/brin/brin_minmax_multi.c:1046">range_contains_value</a>(bdesc, colloid, attno, attr, ranges, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Constant">true</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* yep, we've modified the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> representation of data collected during &quot;batch mode&quot;.<br/></li>
<li></span><span class="Comment"> * This is similar to <a href="#L1477" title="access/brin/brin_minmax_multi.c:1477">reduce_expanded_ranges</a>, except that we can't assume<br/></li>
<li></span><span class="Comment"> * the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are sorted and there may be duplicate <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1789">&#x200c;</a></span><span class="linkable">compactify_ranges</span>(BrinDesc *bdesc, <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *ranges, <span class="Type">int</span> max_values)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpFn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *distanceFn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neranges;<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *distances;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContext ctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do we need to actually compactify anything?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There are two reasons why compaction may be needed - firstly, there may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be too many <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, or some of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> may be unsorted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((ranges-&gt;nranges * <span class="Constant">2</span> + ranges-&gt;nvalues &lt;= max_values) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ranges-&gt;nsorted == ranges-&gt;nvalues))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we'll certainly need the comparator, so just look it up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; cmpFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, ranges-&gt;attno, ranges-&gt;typid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and we'll also need the 'distance' procedure */<br/></li>
<li></span>&nbsp; &nbsp; distanceFn = <a href="#L2864" title="access/brin/brin_minmax_multi.c:2864">minmax_multi_get_procinfo</a>(bdesc, ranges-&gt;attno, <a href="#L93" title="access/brin/brin_minmax_multi.c:93">PROCNUM_DISTANCE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The distanceFn calls (which may internally call e.g. <a href="../../utils/adt/numeric.c.html#L2490" title="utils/adt/numeric.c:2490">numeric_le</a>) may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate quite a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of memory, and we must not leak it. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd have problems e.g. when building indexes. So we create a local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context and make sure we free the memory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leaving this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function (not after every call).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;minmax-multi context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; eranges = <a href="#L1387" title="access/brin/brin_minmax_multi.c:1387">build_expanded_ranges</a>(cmpFn, ranges-&gt;colloid, ranges, &amp;neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build array of gap distances and sort them in ascending order */<br/></li>
<li></span>&nbsp; &nbsp; distances = <a href="#L1330" title="access/brin/brin_minmax_multi.c:1330">build_distances</a>(distanceFn, ranges-&gt;colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Combine ranges until we get below max_values. We don't use <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scale<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * factor, because this is used during serialization, and we don't expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more tuples to be inserted anytime soon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; neranges = <a href="#L1477" title="access/brin/brin_minmax_multi.c:1477">reduce_expanded_ranges</a>(eranges, neranges, distances,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_values, cmpFn, ranges-&gt;colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1416" title="access/brin/brin_minmax_multi.c:1416">count_values</a>(eranges, neranges) &lt;= max_values);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform back into regular ranges and single <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1559" title="access/brin/brin_minmax_multi.c:1559">store_expanded_ranges</a>(ranges, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check all the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> invariants */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L297" title="access/brin/brin_minmax_multi.c:297">AssertCheckRanges</a>(ranges, cmpFn, ranges-&gt;colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(ctx);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L1860">&#x200c;</a><span class="linkable">brin_minmax_multi_opcinfo</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinOpcInfo *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opaque-&gt;strategy_procinfos is initialized lazily; here it is set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all-uninitialized by <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> which sets fn_oid to InvalidOid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(MAXALIGN(SizeofBrinOpcInfo(<span class="Constant">1</span>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_nstored = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_regular_nulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_opaque = (<a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN((<span class="Type">char</span> *) result + SizeofBrinOpcInfo(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_typcache[<span class="Constant">0</span>] = <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(PG_BRIN_MINMAX_MULTI_SUMMARYOID, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two float4 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (plain subtraction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1884">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_float4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_FLOAT4(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">float</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_FLOAT4(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if both <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are NaN, then we consider them the same */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) &amp;&amp; isnan(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if one value is NaN, use infinite distance */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) || isnan(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_infinity());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> &lt;= <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> - (<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two float8 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (plain subtraction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1910">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_float8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_FLOAT8(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_FLOAT8(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if both <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are NaN, then we consider them the same */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) &amp;&amp; isnan(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">0.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if one value is NaN, use infinite distance */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isnan(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>) || isnan(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(get_float8_infinity());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> &lt;= <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> - <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two int2 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (plain subtraction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1936">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_int2</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INT16(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INT16(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> &lt;= <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> - (<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two int4 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (plain subtraction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1954">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_int4</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INT32(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INT32(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> &lt;= <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> - (<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two int8 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (plain subtraction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1972">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_int8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_INT64(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> &lt;= <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8((<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> - (<span class="Type">double</span>) <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two tid <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (by mapping them to float8 and<br/></li>
<li></span><span class="Comment"> * then subtracting them).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1991">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_tid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; da1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; da2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointer pa1 = (ItemPointer) PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; ItemPointer pa2 = (ItemPointer) PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(pa1, pa2) &lt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the no-check variants here, because user-supplied <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have (ip_posid == 0). See <a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; da1 = ItemPointerGetBlockNumberNoCheck(pa1) * MaxHeapTuplesPerPage +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumberNoCheck(pa1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; da2 = ItemPointerGetBlockNumberNoCheck(pa2) * MaxHeapTuplesPerPage +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumberNoCheck(pa2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(da2 - da1);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two <a href="../../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (plain subtraction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2022">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_numeric</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/numeric.c.html#L2490" title="utils/adt/numeric.c:2490">numeric_le</a>, <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; d = DirectFunctionCall2(<a href="../../utils/adt/numeric.c.html#L2925" title="utils/adt/numeric.c:2925">numeric_sub</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>, <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);&nbsp; &nbsp; <span class="Comment">/* <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> - <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(DirectFunctionCall1(<a href="../../utils/adt/numeric.c.html#L4628" title="utils/adt/numeric.c:4628">numeric_float8</a>, d));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the approximate distance between two UUID <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We do not need a perfectly accurate value, so we approximate the<br/></li>
<li></span><span class="Comment"> * deltas (which would have to be 128-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers) with a 64-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> float.<br/></li>
<li></span><span class="Comment"> * The small inaccuracies do not matter in practice, in the worst case<br/></li>
<li></span><span class="Comment"> * we'll decide to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> ranges that are not the closest ones.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2048">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_uuid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a> = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a> = PG_GETARG_DATUM(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *u1 = DatumGetUUIDP(<a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>);<br/></li>
<li>&nbsp; &nbsp; pg_uuid_t&nbsp; *u2 = DatumGetUUIDP(<a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We know the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> boundaries, but the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> may be collapsed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (i.e. single points), with <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(DatumGetBool(DirectFunctionCall2(<a href="../../utils/adt/uuid.c.html#L183" title="utils/adt/uuid.c:183">uuid_le</a>, <a href="../../catalog/heap.c.html#L142" title="catalog/heap.c:142">a1</a>, <a href="../../catalog/heap.c.html#L156" title="catalog/heap.c:156">a2</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute approximate delta as a double precision value */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = UUID_LEN - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; delta += (<span class="Type">int</span>) u2-&gt;data[i] - (<span class="Type">int</span>) u1-&gt;data[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the approximate distance between two dates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2081">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_date</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal1 = PG_GETARG_DATEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; DateADT&nbsp; &nbsp; &nbsp; &nbsp; dateVal2 = PG_GETARG_DATEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = (float8) dateVal2 - (float8) dateVal1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the approximate distance between two time (without tz) <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * TimeADT is just an int64, so we simply subtract the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2100">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_time</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; ta = PG_GETARG_TIMEADT(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeADT&nbsp; &nbsp; &nbsp; &nbsp; tb = PG_GETARG_TIMEADT(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = (tb - ta);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the approximate distance between two timetz <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simply subtracts the TimeADT (int64) <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> embedded in TimeTzADT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2120">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_timetz</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *ta = PG_GETARG_TIMETZADT_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; TimeTzADT&nbsp; *tb = PG_GETARG_TIMETZADT_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = (tb-&gt;time - ta-&gt;time) + (tb-&gt;zone - ta-&gt;zone) * USECS_PER_SEC;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two timestamp <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2138">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_timestamp</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt1 = PG_GETARG_TIMESTAMP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Timestamp&nbsp; &nbsp; dt2 = PG_GETARG_TIMESTAMP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = (float8) dt2 - (float8) dt1;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two interval <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2156">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_interval</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *ia = PG_GETARG_INTERVAL_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Interval&nbsp;&nbsp; *ib = PG_GETARG_INTERVAL_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; dayfraction;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Delta is (fractional) number of <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> between the intervals. Assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/datetime.c.html#L81" title="utils/adt/datetime.c:81">months</a> have 30 <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> for consistency with <a href="../../utils/adt/timestamp.c.html#L2505" title="utils/adt/timestamp.c:2505">interval_cmp_internal</a>. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't need to be exact, in the worst case we'll build a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficient ranges. But we should not contradict <a href="../../utils/adt/timestamp.c.html#L2577" title="utils/adt/timestamp.c:2577">interval_cmp</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; dayfraction = (ib-&gt;time % USECS_PER_DAY) - (ia-&gt;time % USECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> = (ib-&gt;time / USECS_PER_DAY) - (ia-&gt;time / USECS_PER_DAY);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> += (int64) ib-&gt;day - (int64) ia-&gt;day;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> += ((int64) ib-&gt;month - (int64) ia-&gt;month) * INT64CONST(<span class="Constant">30</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* convert to double precision */<br/></li>
<li></span>&nbsp; &nbsp; delta = (<span class="Type">double</span>) <a href="../../utils/adt/datetime.c.html#L84" title="utils/adt/datetime.c:84">days</a> + dayfraction / (<span class="Type">double</span>) USECS_PER_DAY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two pg_lsn <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * LSN is just an int64 encoding position in the stream, so just subtract<br/></li>
<li></span><span class="Comment"> * those int64 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2192">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_pg_lsn</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsna = PG_GETARG_LSN(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsnb = PG_GETARG_LSN(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = (lsnb - lsna);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two macaddr <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * mac addresses are treated as 6 unsigned chars, so do the same thing we<br/></li>
<li></span><span class="Comment"> * already do for UUID <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2213">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_macaddr</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; macaddr&nbsp; &nbsp; *a = PG_GETARG_MACADDR_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; macaddr&nbsp; &nbsp; *b = PG_GETARG_MACADDR_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = ((float8) b-&gt;f - (float8) a-&gt;f);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;e - (float8) a-&gt;e);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;d - (float8) a-&gt;d);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;c - (float8) a-&gt;c);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;b - (float8) a-&gt;b);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;a - (float8) a-&gt;a);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two macaddr8 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * macaddr8 addresses are 8 unsigned chars, so do the same thing we<br/></li>
<li></span><span class="Comment"> * already do for UUID <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2250">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_macaddr8</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; macaddr8&nbsp;&nbsp; *a = PG_GETARG_MACADDR8_P(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; macaddr8&nbsp;&nbsp; *b = PG_GETARG_MACADDR8_P(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta = ((float8) b-&gt;h - (float8) a-&gt;h);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;g - (float8) a-&gt;g);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;f - (float8) a-&gt;f);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;e - (float8) a-&gt;e);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;d - (float8) a-&gt;d);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;c - (float8) a-&gt;c);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;b - (float8) a-&gt;b);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; delta += ((float8) b-&gt;a - (float8) a-&gt;a);<br/></li>
<li>&nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(delta &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the distance between two inet <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The distance is defined as the difference between 32-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>/128-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment"> * depending on the IP version. The distance is computed by subtracting<br/></li>
<li></span><span class="Comment"> * the bytes and normalizing it to [0,1] <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for each IP family.<br/></li>
<li></span><span class="Comment"> * Addresses from different families are considered to be in maximum<br/></li>
<li></span><span class="Comment"> * distance, which is 1.0.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> Does this need to consider the mask (bits)?&nbsp; For <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it's ignored.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2298">&#x200c;</a><span class="linkable">brin_minmax_multi_distance_inet</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; float8&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *addra,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *addrb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ipa = PG_GETARG_INET_PP(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; inet&nbsp; &nbsp; &nbsp;&nbsp; *ipb = PG_GETARG_INET_PP(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lena,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lenb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the addresses are from different families, consider them to be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maximal possible distance (which is 1.0).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ip_family(ipa) != ip_family(ipb))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_FLOAT8(<span class="Constant">1.0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addra = (<span class="Type">unsigned</span> <span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ip_addrsize(ipa));<br/></li>
<li>&nbsp; &nbsp; memcpy(addra, ip_addr(ipa), ip_addrsize(ipa));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addrb = (<span class="Type">unsigned</span> <span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(ip_addrsize(ipb));<br/></li>
<li>&nbsp; &nbsp; memcpy(addrb, ip_addr(ipb), ip_addrsize(ipb));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The length is calculated from the mask length, because we sort the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * addresses by first address in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so A.B.C.D/24 &lt; A.B.C.1 (the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> starts at A.B.C.0, which is <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> A.B.C.1). We don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to produce a negative delta in this case, so we just cut the extra<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Maybe this should be a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more careful and cut the bits, not just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lena = ip_bits(ipa);<br/></li>
<li>&nbsp; &nbsp; lenb = ip_bits(ipb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = ip_addrsize(ipa);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* apply the network mask to both addresses */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; len; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> mask;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbits = Max(<span class="Constant">0</span>, lena - (i * <span class="Constant">8</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbits &lt; <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = (<span class="Constant">0xFF</span> &lt;&lt; (<span class="Constant">8</span> - nbits));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addra[i] = (addra[i] &amp; mask);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nbits = Max(<span class="Constant">0</span>, lenb - (i * <span class="Constant">8</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nbits &lt; <span class="Constant">8</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mask = (<span class="Constant">0xFF</span> &lt;&lt; (<span class="Constant">8</span> - nbits));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrb[i] = (addrb[i] &amp; mask);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Calculate the difference between the addresses. */<br/></li>
<li></span>&nbsp; &nbsp; delta = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = len - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> a = addra[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> b = addrb[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; delta += (float8) b - (float8) a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; delta /= <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert((delta &gt;= <span class="Constant">0</span>) &amp;&amp; (delta &lt;= <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(addra);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(addrb);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_FLOAT8(delta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2381">&#x200c;</a></span><span class="linkable">brin_minmax_multi_serialize</span>(BrinDesc *bdesc, Datum src, Datum *dst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges = (<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *) DatumGetPointer(src);<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In batch mode, we need to compress the accumulated <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually requested number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>/ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1789" title="access/brin/brin_minmax_multi.c:1789">compactify_ranges</a>(bdesc, ranges, ranges-&gt;target_maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* At this point everything has to be fully sorted. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ranges-&gt;nsorted == ranges-&gt;nvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; s = <a href="#L577" title="access/brin/brin_minmax_multi.c:577">brin_range_serialize</a>(ranges);<br/></li>
<li>&nbsp; &nbsp; dst[<span class="Constant">0</span>] = PointerGetDatum(s);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2400">&#x200c;</a></span><span class="linkable">brin_minmax_multi_get_values</span>(BrinDesc *bdesc, <a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a> *opts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L130" title="access/brin/brin_minmax_multi.c:130">MinMaxMultiGetValuesPerRange</a>(opts);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Examine the given index tuple (which contains the partial status of a<br/></li>
<li></span><span class="Comment"> * certain page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) by comparing it to the given value that comes from<br/></li>
<li></span><span class="Comment"> * another heap tuple.&nbsp; If the new value is outside the min/max <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * specified by the existing tuple <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, update the index tuple and return<br/></li>
<li></span><span class="Comment"> * true.&nbsp; Otherwise, return false and do not modify in this case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2413">&#x200c;</a><span class="linkable">brin_minmax_multi_add_value</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *column = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = PG_GETARG_DATUM(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a> *opts = (<a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a> *) PG_GET_OPCLASS_OPTIONS();<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; modified = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = column-&gt;bv_attno;<br/></li>
<li>&nbsp; &nbsp; attr = TupleDescAttr(bdesc-&gt;bd_tupdesc, attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use the already deserialized value, if possible */<br/></li>
<li></span>&nbsp; &nbsp; ranges = (<a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> *) DatumGetPointer(column-&gt;bv_mem_value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first non-null value, we need to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list. Otherwise, just extract the existing <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> list from BrinValues.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When starting with an empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, we assume this is a batch mode and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we use a larger buffer. The buffer size is derived from the BRIN <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size, number of rows per page, with some sensible min/max <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * small buffer would be bad for performance, but a large buffer might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * require a lot of memory (because of keeping all the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; target_maxvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pagesPerRange = BrinGetPagesPerRange(bdesc-&gt;bd_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* what was specified as a reloption? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; target_maxvalues = <a href="#L2400" title="access/brin/brin_minmax_multi.c:2400">brin_minmax_multi_get_values</a>(bdesc, opts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the insert buffer size - we use 10x the target, capped to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the maximum number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the heap <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. This is more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough, considering the actual number of rows per page is likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, but meh.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(target_maxvalues * <a href="#L106" title="access/brin/brin_minmax_multi.c:106">MINMAX_BUFFER_FACTOR</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxHeapTuplesPerPage * pagesPerRange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* but always at least the original value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = Max(maxvalues, target_maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always cap by MIN/MAX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = Max(maxvalues, <a href="#L107" title="access/brin/brin_minmax_multi.c:107">MINMAX_BUFFER_MIN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(maxvalues, <a href="#L108" title="access/brin/brin_minmax_multi.c:108">MINMAX_BUFFER_MAX</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(column-&gt;bv_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges = <a href="#L487" title="access/brin/brin_minmax_multi.c:487">minmax_multi_init</a>(maxvalues);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;attno = attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;colloid = colloid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;typid = attr-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;target_maxvalues = target_maxvalues;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll certainly need the comparator, so just look it up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_allnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; modified = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_mem_value = PointerGetDatum(ranges);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_serialize = <a href="#L2381" title="access/brin/brin_minmax_multi.c:2381">brin_minmax_multi_serialize</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!ranges)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxvalues;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pagesPerRange = BrinGetPagesPerRange(bdesc-&gt;bd_index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldctx = MemoryContextSwitchTo(column-&gt;bv_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; serialized = (<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *) PG_DETOAST_DATUM(column-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the insert buffer size - we use 10x the target, capped to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the maximum number of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the heap <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. This is more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough, considering the actual number of rows per page is likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>, but meh.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(serialized-&gt;maxvalues * <a href="#L106" title="access/brin/brin_minmax_multi.c:106">MINMAX_BUFFER_FACTOR</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxHeapTuplesPerPage * pagesPerRange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* but always at least the original value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = Max(maxvalues, serialized-&gt;maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* always cap by MIN/MAX */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = Max(maxvalues, <a href="#L107" title="access/brin/brin_minmax_multi.c:107">MINMAX_BUFFER_MIN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxvalues = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(maxvalues, <a href="#L108" title="access/brin/brin_minmax_multi.c:108">MINMAX_BUFFER_MAX</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges = <a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a>(maxvalues, serialized);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;attno = attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;colloid = colloid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;typid = attr-&gt;atttypid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we'll certainly need the comparator, so just look it up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ranges-&gt;<a href="../../regex/regc_locale.c.html#L743" title="regex/regc_locale.c:743">cmp</a> = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_mem_value = PointerGetDatum(ranges);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_serialize = <a href="#L2381" title="access/brin/brin_minmax_multi.c:2381">brin_minmax_multi_serialize</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to add the new value to the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. We need to update the modified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag, so that we serialize the updated summary later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; modified |= <a href="#L1703" title="access/brin/brin_minmax_multi.c:1703">range_add_value</a>(bdesc, colloid, attno, attr, ranges, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(modified);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an index tuple corresponding to a certain page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and a scan key,<br/></li>
<li></span><span class="Comment"> * return whether the scan key is consistent with the index tuple's min/max<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Return true if so, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2550">&#x200c;</a><span class="linkable">brin_minmax_multi_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *column = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; *keys = (ScanKey *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtype;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *finfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rangeno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = column-&gt;bv_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; serialized = (<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *) PG_DETOAST_DATUM(column-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; ranges = <a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a>(serialized-&gt;maxvalues, serialized);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* inspect the ranges, and for each one evaluate the scan keys */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (rangeno = <span class="Constant">0</span>; rangeno &lt; ranges-&gt;nranges; rangeno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; minval = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * rangeno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; maxval = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * rangeno + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is matching, and we'll try to prove otherwise */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matching = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; nkeys; keyno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = keys[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL keys are handled and filtered-out in <a href="brin.c.html#L556" title="access/brin/brin.c:556">bringetbitmap</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(key-&gt;sk_flags &amp; SK_ISNULL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = key-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtype = key-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = key-&gt;sk_argument;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (key-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first value from the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, minval, value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; compar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpFn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* by default this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> does not match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, need to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the new value with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * boundaries of all the ranges. First check if it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * less than the absolute minimum, which is the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value in the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpFn, colloid, minval, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* smaller than the smallest value in this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; compar = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cmpFn, colloid, maxval, value);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* larger than the largest value in this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(compar))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We haven't managed to eliminate this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider it matching.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* last value from the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, maxval, value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid strategy number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> has to match all the scan keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching &amp;= matches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a non-matching key, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matching)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have we found a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> matching all scan keys? if yes, we're done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matching)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> inspect the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. We don't bother with doing a binary search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here, because we're dealing with serialized / fully compacted ranges,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so there should be only very few <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ranges-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val = ranges-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">2</span> * ranges-&gt;nranges + i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is matching, and we'll try to prove otherwise */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matching = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; nkeys; keyno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matches;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = keys[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we've already dealt with NULL keys at the beginning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = key-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtype = key-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = key-&gt;sk_argument;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (key-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, val, value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid strategy number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> has to match all the scan keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matching &amp;= matches;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* once we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a non-matching key, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matching)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have we found a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> matching all scan keys? if yes, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (matching)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given two BrinValues, update the first of them as a union of the summary<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> contained in both.&nbsp; The second one is untouched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2736">&#x200c;</a><span class="linkable">brin_minmax_multi_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *col_a = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *col_b = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized_a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *serialized_b;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges_a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges_b;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *eranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; neranges;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *cmpFn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *distanceFn;<br/></li>
<li>&nbsp; &nbsp; <a href="#L249" title="access/brin/brin_minmax_multi.c:249">DistanceValue</a> *distances;<br/></li>
<li>&nbsp; &nbsp; MemoryContext ctx;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldctx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(col_a-&gt;bv_attno == col_b-&gt;bv_attno);<br/></li>
<li>&nbsp; &nbsp; Assert(!col_a-&gt;bv_allnulls &amp;&amp; !col_b-&gt;bv_allnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = col_a-&gt;bv_attno;<br/></li>
<li>&nbsp; &nbsp; attr = TupleDescAttr(bdesc-&gt;bd_tupdesc, attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; serialized_a = (<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *) PG_DETOAST_DATUM(col_a-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; serialized_b = (<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *) PG_DETOAST_DATUM(col_b-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ranges_a = <a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a>(serialized_a-&gt;maxvalues, serialized_a);<br/></li>
<li>&nbsp; &nbsp; ranges_b = <a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a>(serialized_b-&gt;maxvalues, serialized_b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure neither of the ranges is NULL */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ranges_a &amp;&amp; ranges_b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; neranges = (ranges_a-&gt;nranges + ranges_a-&gt;nvalues) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ranges_b-&gt;nranges + ranges_b-&gt;nvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The distanceFn calls (which may internally call e.g. <a href="../../utils/adt/numeric.c.html#L2490" title="utils/adt/numeric.c:2490">numeric_le</a>) may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate quite a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of memory, and we must not leak it. Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'd have problems e.g. when building indexes. So we create a local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory context and make sure we free the memory <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leaving this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function (not after every call).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ctx = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;minmax-multi context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldctx = MemoryContextSwitchTo(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate and fill */<br/></li>
<li></span>&nbsp; &nbsp; eranges = (<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(neranges * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L238" title="access/brin/brin_minmax_multi.c:238">ExpandedRange</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill the expanded ranges with entries for the first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1135" title="access/brin/brin_minmax_multi.c:1135">fill_expanded_ranges</a>(eranges, ranges_a-&gt;nranges + ranges_a-&gt;nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges_a);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> add <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> ranges for the second <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1135" title="access/brin/brin_minmax_multi.c:1135">fill_expanded_ranges</a>(&amp;eranges[ranges_a-&gt;nranges + ranges_a-&gt;nvalues],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges_b-&gt;nranges + ranges_b-&gt;nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges_b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmpFn = <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>(bdesc, attno, attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the expanded ranges */<br/></li>
<li></span>&nbsp; &nbsp; neranges = <a href="#L1180" title="access/brin/brin_minmax_multi.c:1180">sort_expanded_ranges</a>(cmpFn, colloid, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We've loaded two different lists of expanded ranges, so some of them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may be overlapping. So walk through them and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; neranges = <a href="#L1232" title="access/brin/brin_minmax_multi.c:1232">merge_overlapping_ranges</a>(cmpFn, colloid, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check that the <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> ranges are correct (no overlaps, ordering) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L427" title="access/brin/brin_minmax_multi.c:427">AssertCheckExpandedRanges</a>(bdesc, colloid, attno, attr, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If needed, reduce some of the ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This may be fairly expensive, so maybe we should do it only when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's actually needed (when we have too many ranges).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build array of gap distances and sort them in ascending order */<br/></li>
<li></span>&nbsp; &nbsp; distanceFn = <a href="#L2864" title="access/brin/brin_minmax_multi.c:2864">minmax_multi_get_procinfo</a>(bdesc, attno, <a href="#L93" title="access/brin/brin_minmax_multi.c:93">PROCNUM_DISTANCE</a>);<br/></li>
<li>&nbsp; &nbsp; distances = <a href="#L1330" title="access/brin/brin_minmax_multi.c:1330">build_distances</a>(distanceFn, colloid, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See how many <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> would be needed to store the current ranges, and if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> as many of them to get below the threshold. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collapsed ranges will be stored as a single value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This does not apply the load factor, as we don't expect to add more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so we prefer to keep as many ranges as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Can the maxvalues be different in the two ranges? Perhaps we should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use maximum of those?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; neranges = <a href="#L1477" title="access/brin/brin_minmax_multi.c:1477">reduce_expanded_ranges</a>(eranges, neranges, distances,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ranges_a-&gt;maxvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpFn, colloid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the result of reducing expanded ranges correct? */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L427" title="access/brin/brin_minmax_multi.c:427">AssertCheckExpandedRanges</a>(bdesc, colloid, attno, attr, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> summary */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1559" title="access/brin/brin_minmax_multi.c:1559">store_expanded_ranges</a>(ranges_a, eranges, neranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldctx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(ctx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> and update the serialized value */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(serialized_a);<br/></li>
<li>&nbsp; &nbsp; col_a-&gt;bv_values[<span class="Constant">0</span>] = PointerGetDatum(<a href="#L577" title="access/brin/brin_minmax_multi.c:577">brin_range_serialize</a>(ranges_a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache and return minmax multi opclass support procedure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the procedure corresponding to the given function support number<br/></li>
<li></span><span class="Comment"> * or null if it does not exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FmgrInfo *<br/></li>
<li><a id="L2864">&#x200c;</a><span class="linkable">minmax_multi_get_procinfo</span>(BrinDesc *bdesc, uint16 attno, uint16 procnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a> *opaque;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; basenum = procnum - <a href="brin_inclusion.c.html#L57" title="access/brin/brin_inclusion.c:57">PROCNUM_BASE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cache these in the opaque struct, to avoid repetitive syscache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque = (<a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a> *) bdesc-&gt;bd_info[attno - <span class="Constant">1</span>]-&gt;oi_opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already searched for this proc and didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searching again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;extra_proc_missing[basenum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;extra_procinfos[basenum].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RegProcedureIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(bdesc-&gt;bd_index, attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procnum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;opaque-&gt;extra_procinfos[basenum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(bdesc-&gt;bd_index, attno, procnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bdesc-&gt;bd_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;extra_proc_missing[basenum] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;opaque-&gt;extra_procinfos[basenum];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache and return the procedure for the given strategy.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function mirrors <a href="#L2908" title="access/brin/brin_minmax_multi.c:2908">minmax_multi_get_strategy_procinfo</a>; see notes<br/></li>
<li></span><span class="Comment"> * there.&nbsp; If changes are made here, see that function too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FmgrInfo *<br/></li>
<li><a id="L2908">&#x200c;</a><span class="linkable">minmax_multi_get_strategy_procinfo</span>(BrinDesc *bdesc, uint16 attno, Oid subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint16 strategynum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a> *opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(strategynum &gt;= <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategynum &lt;= BTMaxStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = (<a href="#L111" title="access/brin/brin_minmax_multi.c:111">MinmaxMultiOpaque</a> *) bdesc-&gt;bd_info[attno - <span class="Constant">1</span>]-&gt;oi_opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cache the procedures for the previous subtype in the opaque struct,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to avoid repetitive syscache lookups.&nbsp; If the subtype changed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidate all the cached entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;cached_subtype != subtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= BTMaxStrategyNumber; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;strategy_procinfos[i - <span class="Constant">1</span>].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;cached_subtype = subtype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;strategy_procinfos[strategynum - <span class="Constant">1</span>].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opfamily = bdesc-&gt;bd_index-&gt;rd_opfamily[attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(bdesc-&gt;bd_tupdesc, attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../utils/cache/syscache.c.html#L251" title="utils/cache/syscache.c:251">SearchSysCache4</a>(AMOPSTRATEGY, ObjectIdGetDatum(opfamily),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(attr-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(subtype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(strategynum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategynum, attr-&gt;atttypid, subtype, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> = DatumGetObjectId(<a href="../../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(AMOPSTRATEGY, tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_amop_amopopr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RegProcedureIsValid(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(<a href="../../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;opaque-&gt;strategy_procinfos[strategynum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bdesc-&gt;bd_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;opaque-&gt;strategy_procinfos[strategynum - <span class="Constant">1</span>];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L2963">&#x200c;</a><span class="linkable">brin_minmax_multi_options</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/reloptions.c.html#L734" title="access/common/reloptions.c:734">init_local_reloptions</a>(relopts, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/reloptions.c.html#L918" title="access/common/reloptions.c:918">add_local_int_reloption</a>(relopts, <span class="Constant">&quot;values_per_range&quot;</span>, <span class="Constant">&quot;desc&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="access/brin/brin_minmax_multi.c:128">MINMAX_MULTI_DEFAULT_VALUES_PER_PAGE</a>, <span class="Constant">8</span>, <span class="Constant">256</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offsetof(<a href="#L122" title="access/brin/brin_minmax_multi.c:122">MinMaxMultiOptions</a>, valuesPerRange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2985" title="access/brin/brin_minmax_multi.c:2985">brin_minmax_multi_summary_in</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - input routine for type brin_minmax_multi_summary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * brin_minmax_multi_summary is only used internally to represent summaries<br/></li>
<li></span><span class="Comment"> * in BRIN minmax-multi indexes, so it has no operations of its own, and we<br/></li>
<li></span><span class="Comment"> * disallow input too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L2985">&#x200c;</a><span class="linkable">brin_minmax_multi_summary_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * brin_minmax_multi_summary stores the data in binary form and parsing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * text input is not needed, so disallow this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;brin_minmax_multi_summary&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3007" title="access/brin/brin_minmax_multi.c:3007">brin_minmax_multi_summary_out</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - output routine for type brin_minmax_multi_summary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BRIN minmax-multi summaries are serialized into a bytea value, but we<br/></li>
<li></span><span class="Comment"> * want to output something nicer humans can understand.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3007">&#x200c;</a><span class="linkable">brin_minmax_multi_summary_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; <a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *ranges;<br/></li>
<li>&nbsp; &nbsp; <a href="#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a>&nbsp; &nbsp; &nbsp;&nbsp; *ranges_deserialized;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isvarlena;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outfunc;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; fmgrinfo;<br/></li>
<li>&nbsp; &nbsp; ArrayBuildState *astate_values = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detoast to get value with full 4B header (can't be stored in a toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table, but can use 1B header).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ranges = (<a href="#L206" title="access/brin/brin_minmax_multi.c:206">SerializedRanges</a> *) PG_DETOAST_DATUM(PG_GETARG_DATUM(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* lookup output func for the type */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(ranges-&gt;typid, &amp;outfunc, &amp;isvarlena);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(outfunc, &amp;fmgrinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deserialize the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> info easy-to-process pieces */<br/></li>
<li></span>&nbsp; &nbsp; ranges_deserialized = <a href="#L722" title="access/brin/brin_minmax_multi.c:722">brin_range_deserialize</a>(ranges-&gt;maxvalues, ranges);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str, <span class="Constant">&quot;nranges: </span><span class="Special">%d</span><span class="Constant">&nbsp; nvalues: </span><span class="Special">%d</span><span class="Constant">&nbsp; maxvalues: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges_deserialized-&gt;nranges,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges_deserialized-&gt;nvalues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ranges_deserialized-&gt;maxvalues);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialize ranges */<br/></li>
<li></span>&nbsp; &nbsp; idx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ranges_deserialized-&gt;nranges; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *b;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *c;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = <a href="../../utils/fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;fmgrinfo, ranges_deserialized-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx++]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b = <a href="../../utils/fmgr/fmgr.c.html#L1683" title="utils/fmgr/fmgr.c:1683">OutputFunctionCall</a>(&amp;fmgrinfo, ranges_deserialized-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx++]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;buf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> ... </span><span class="Special">%s</span><span class="Constant">&quot;</span>, a, b);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; c = <a href="../../utils/adt/varlena.c.html#L196" title="utils/adt/varlena.c:196">cstring_to_text_with_len</a>(buf.data, buf.len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate_values = <a href="../../utils/adt/arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(c),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ranges_deserialized-&gt;nranges &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoutput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typIsVarlena;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *extval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(ANYARRAYOID, &amp;typoutput, &amp;typIsVarlena);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../../utils/adt/arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(astate_values, <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extval = <a href="../../utils/fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(typoutput, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;str, <span class="Constant">&quot; ranges: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, extval);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* serialize individual <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; astate_values = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ranges_deserialized-&gt;nvalues; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; a;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; text&nbsp; &nbsp; &nbsp;&nbsp; *b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; a = FunctionCall1(&amp;fmgrinfo, ranges_deserialized-&gt;<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[idx++]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; b = <a href="../../utils/adt/varlena.c.html#L184" title="utils/adt/varlena.c:184">cstring_to_text</a>(DatumGetCString(a));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; astate_values = <a href="../../utils/adt/arrayfuncs.c.html#L5331" title="utils/adt/arrayfuncs.c:5331">accumArrayResult</a>(astate_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(b),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TEXTOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ranges_deserialized-&gt;nvalues &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoutput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typIsVarlena;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *extval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2907" title="utils/cache/lsyscache.c:2907">getTypeOutputInfo</a>(ANYARRAYOID, &amp;typoutput, &amp;typIsVarlena);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../../utils/adt/arrayfuncs.c.html#L5401" title="utils/adt/arrayfuncs.c:5401">makeArrayResult</a>(astate_values, <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; extval = <a href="../../utils/fmgr/fmgr.c.html#L1763" title="utils/fmgr/fmgr.c:1763">OidOutputFunctionCall</a>(typoutput, val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;str, <span class="Constant">&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, extval);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(str.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3126" title="access/brin/brin_minmax_multi.c:3126">brin_minmax_multi_summary_recv</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - binary input routine for type brin_minmax_multi_summary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3126">&#x200c;</a><span class="linkable">brin_minmax_multi_summary_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;brin_minmax_multi_summary&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3143" title="access/brin/brin_minmax_multi.c:3143">brin_minmax_multi_summary_send</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - binary output routine for type brin_minmax_multi_summary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BRIN minmax-multi summaries are serialized in a bytea value (although<br/></li>
<li></span><span class="Comment"> * the type is named differently), so let's just <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L3143">&#x200c;</a><span class="linkable">brin_minmax_multi_summary_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/varlena.c.html#L490" title="utils/adt/varlena.c:490">byteasend</a>(fcinfo);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
