<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/brin/brin_bloom.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/brin/brin_bloom.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L242">BloomFilter</a></li>
<li><a href="#L257">BloomFilter</a></li>
<li><a href="#L434">BloomOpaque</a></li>
<li><a href="#L443">BloomOpaque</a></li>
<li><a href="#L154">BloomOptions</a></li>
<li><a href="#L159">BloomOptions</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L370">bloom_add_value</a></li>
<li><a href="#L407">bloom_contains_value</a></li>
<li><a href="#L271">bloom_filter_size</a></li>
<li><a href="#L707">bloom_get_procinfo</a></li>
<li><a href="#L310">bloom_init</a></li>
<li><a href="#L540">brin_bloom_add_value</a></li>
<li><a href="#L595">brin_bloom_consistent</a></li>
<li><a href="#L497">brin_bloom_get_ndistinct</a></li>
<li><a href="#L450">brin_bloom_opcinfo</a></li>
<li><a href="#L745">brin_bloom_options</a></li>
<li><a href="#L775">brin_bloom_summary_in</a></li>
<li><a href="#L797">brin_bloom_summary_out</a></li>
<li><a href="#L821">brin_bloom_summary_recv</a></li>
<li><a href="#L838">brin_bloom_summary_send</a></li>
<li><a href="#L667">brin_bloom_union</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L194">BLOOM_DEFAULT_FALSE_POSITIVE_RATE</a></li>
<li><a href="#L176">BLOOM_DEFAULT_NDISTINCT_PER_RANGE</a></li>
<li><a href="#L193">BLOOM_MAX_FALSE_POSITIVE_RATE</a></li>
<li><a href="#L142">BLOOM_MAX_PROCNUMS</a></li>
<li><a href="#L192">BLOOM_MIN_FALSE_POSITIVE_RATE</a></li>
<li><a href="#L169">BLOOM_MIN_NDISTINCT_PER_RANGE</a></li>
<li><a href="#L222">BLOOM_SEED_1</a></li>
<li><a href="#L223">BLOOM_SEED_2</a></li>
<li><a href="#L133">BloomEqualStrategyNumber</a></li>
<li><a href="#L201">BloomGetFalsePositiveRate</a></li>
<li><a href="#L196">BloomGetNDistinctPerRange</a></li>
<li><a href="#L211">BloomMaxFilterSize</a></li>
<li><a href="#L149">PROCNUM_BASE</a></li>
<li><a href="#L143">PROCNUM_HASH</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * brin_bloom.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Implementation of Bloom opclass for BRIN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A BRIN opclass summarizing page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> into a bloom filter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bloom filters allow efficient testing whether a given page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> contains<br/></li>
<li></span><span class="Comment"> * a particular value. Therefore, if we summarize each page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> into a small<br/></li>
<li></span><span class="Comment"> * bloom filter, we can easily (and cheaply) test whether it contains <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * we get later.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The index only supports equality operators, similarly to <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes.<br/></li>
<li></span><span class="Comment"> * Bloom indexes are however much smaller, and support only bitmap scans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Don't confuse this with bloom indexes, implemented in a contrib<br/></li>
<li></span><span class="Comment"> * module. That extension implements an entirely new AM, building a bloom<br/></li>
<li></span><span class="Comment"> * filter on multiple columns in a single row. This opclass works with an<br/></li>
<li></span><span class="Comment"> * existing AM (BRIN) and builds bloom filter on a column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> vs. hashes<br/></li>
<li></span><span class="Comment"> * -----------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The original column <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not used directly, but are first hashed<br/></li>
<li></span><span class="Comment"> * using the regular type-specific <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function, producing a uint32 <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment"> * And this <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value is then added to the summary - i.e. it's hashed<br/></li>
<li></span><span class="Comment"> * again and added to the bloom filter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This allows the code to treat all data types (byval/byref/...) the same<br/></li>
<li></span><span class="Comment"> * way, with only minimal space requirements, because we're working with<br/></li>
<li></span><span class="Comment"> * hashes and not the original <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Everything is uint32.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Of course, this assumes the built-in <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function is reasonably good,<br/></li>
<li></span><span class="Comment"> * without too many collisions etc. But that does seem to be the case, at<br/></li>
<li></span><span class="Comment"> * least based on past experience. After all, the same <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are<br/></li>
<li></span><span class="Comment"> * used for <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> indexes, <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partitioning and so on.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hashing scheme<br/></li>
<li></span><span class="Comment"> * --------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bloom filters require a number of independent <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. There are<br/></li>
<li></span><span class="Comment"> * different schemes how to construct them - for example we might use<br/></li>
<li></span><span class="Comment"> * hash_uint32_extended with random seeds, but that seems fairly expensive.<br/></li>
<li></span><span class="Comment"> * We use a scheme requiring only two <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> described in this paper:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Less Hashing, Same Performance:Building a Better Bloom Filter<br/></li>
<li></span><span class="Comment"> * Adam Kirsch, Michael Mitzenmacher, Harvard School of Engineering and<br/></li>
<li></span><span class="Comment"> * Applied Sciences, Cambridge, Massachusetts [DOI 10.1002/rsa.20208]<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The two <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> h1 and h2 are calculated using hard-coded seeds,<br/></li>
<li></span><span class="Comment"> * and then combined using (h1 + i * h2) to generate the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sizing the bloom filter<br/></li>
<li></span><span class="Comment"> * -----------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Size of a bloom filter depends on the number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we will<br/></li>
<li></span><span class="Comment"> * store in it, and the desired false positive rate. The higher the number<br/></li>
<li></span><span class="Comment"> * of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and/or the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> the false positive rate, the larger<br/></li>
<li></span><span class="Comment"> * the bloom filter. On the other hand, we want to keep the index as small<br/></li>
<li></span><span class="Comment"> * as possible - that's one of the basic advantages of BRIN indexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although the number of distinct elements (in a page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) depends on<br/></li>
<li></span><span class="Comment"> * the data, we can consider it fixed. This simplifies the trade-off to<br/></li>
<li></span><span class="Comment"> * just false positive rate vs. size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> level, false positive rate is a probability the bloom<br/></li>
<li></span><span class="Comment"> * filter matches a random value. For the whole index (with sufficiently<br/></li>
<li></span><span class="Comment"> * many page ranges) it represents the fraction of the index ranges (and<br/></li>
<li></span><span class="Comment"> * thus fraction of the table to be scanned) matching the random value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Furthermore, the size of the bloom filter is subject to implementation<br/></li>
<li></span><span class="Comment"> * limits - it has to fit onto a single index page (8kB by default). As<br/></li>
<li></span><span class="Comment"> * the bitmap is inherently random (when &quot;full&quot; about half the bits is set<br/></li>
<li></span><span class="Comment"> * to 1, randomly), compression can't <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> very much.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To reduce the size of a filter (to fit to a page), we have to either<br/></li>
<li></span><span class="Comment"> * <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> higher false positive rate (undesirable), or reduce the number<br/></li>
<li></span><span class="Comment"> * of distinct items to be stored in the filter. We can't alter the input<br/></li>
<li></span><span class="Comment"> * data, of course, but we may make the BRIN page ranges smaller - instead<br/></li>
<li></span><span class="Comment"> * of the default 128 pages (1MB) we may build index with 16-page ranges,<br/></li>
<li></span><span class="Comment"> * or something like that. This should reduce the number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * in the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, making the filter smaller (with fixed false positive<br/></li>
<li></span><span class="Comment"> * rate). Even for random data sets this should <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a>, as the number of rows<br/></li>
<li></span><span class="Comment"> * per heap page is limited (to ~290 with very narrow tables, likely ~20<br/></li>
<li></span><span class="Comment"> * in practice).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Of course, good sizing decisions depend on having the necessary data,<br/></li>
<li></span><span class="Comment"> * i.e. number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (of a given size) and<br/></li>
<li></span><span class="Comment"> * table size (to estimate cost change due to change in false positive<br/></li>
<li></span><span class="Comment"> * rate due to having larger index vs. scanning larger indexes). We may<br/></li>
<li></span><span class="Comment"> * not have that data - for example when building an index on empty table<br/></li>
<li></span><span class="Comment"> * it's not really possible. And for some data we only have estimates for<br/></li>
<li></span><span class="Comment"> * the whole table and we can only estimate per-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (ndistinct).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Another challenge is that while the bloom filter is per-column, it's<br/></li>
<li></span><span class="Comment"> * the whole index tuple that has to fit into a page. And for multi-column<br/></li>
<li></span><span class="Comment"> * indexes that may include pieces we have no control over (not necessarily<br/></li>
<li></span><span class="Comment"> * bloom filters, the other columns may use other BRIN opclasses). So it's<br/></li>
<li></span><span class="Comment"> * not entirely clear how to distribute the space between those columns.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The current logic, implemented in <a href="#L497" title="access/brin/brin_bloom.c:497">brin_bloom_get_ndistinct</a>, attempts to<br/></li>
<li></span><span class="Comment"> * make some basic sizing decisions, based on the size of BRIN ranges, and<br/></li>
<li></span><span class="Comment"> * the maximum number of rows per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/brin/brin_bloom.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_page.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_tuple.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amop.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L133">&#x200c;</a><span class="PreProc">#define <span class="linkable">BloomEqualStrategyNumber</span>&nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Additional SQL level support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. We only have one, which is<br/></li>
<li></span><span class="Comment"> * used to calculate <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of the input value.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Procedure numbers must not use <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> reserved for BRIN itself; see<br/></li>
<li></span><span class="Comment"> * brin_internal.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BLOOM_MAX_PROCNUMS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* maximum support procs we need */<br/></li>
<li><a id="L143">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_HASH</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* required */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subtract this from procnum to obtain index in <a href="#L434" title="access/brin/brin_bloom.c:434">BloomOpaque</a> arrays<br/></li>
<li></span><span class="Comment"> * (Must be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to minimum of private procnums).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_BASE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Storage type for BRIN's reloptions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L154">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BloomOptions</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; vl_len_;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* varlena header (do not touch directly!) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; nDistinctPerRange;&nbsp; &nbsp; <span class="Comment">/* number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; falsePositiveRate;&nbsp; &nbsp; <span class="Comment">/* false positive for bloom filter */<br/></li>
<li><a id="L159">&#x200c;</a></span>} <span class="linkable">BloomOptions</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The current min value (16) is somewhat arbitrary, but it's based<br/></li>
<li></span><span class="Comment"> * on the fact that the filter header is ~20B alone, which is about<br/></li>
<li></span><span class="Comment"> * the same as the filter bitmap for 16 distinct items with 1% false<br/></li>
<li></span><span class="Comment"> * positive rate. So by allowing <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we'd not gain much. In<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, the min should not be larger than MaxHeapTuplesPerPage<br/></li>
<li></span><span class="Comment"> * (~290), which is the theoretical maximum for single-page ranges.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L169">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BLOOM_MIN_NDISTINCT_PER_RANGE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Used to determine number of distinct items, based on the number of rows<br/></li>
<li></span><span class="Comment"> * in a page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. The 10% is somewhat similar to what <a href="../../utils/adt/selfuncs.c.html#L3416" title="utils/adt/selfuncs.c:3416">estimate_num_groups</a><br/></li>
<li></span><span class="Comment"> * does, so we use the same factor here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L176">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BLOOM_DEFAULT_NDISTINCT_PER_RANGE</span>&nbsp; &nbsp; -</span><span class="Constant">0.1</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* 10% of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allowed <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and default value for the false positive <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. The exact<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are somewhat arbitrary, but were chosen considering the various<br/></li>
<li></span><span class="Comment"> * parameters (size of filter vs. page size, etc.).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> the false-positive rate, the more accurate the filter is, but<br/></li>
<li></span><span class="Comment"> * it also gets larger - at some point this eliminates the <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> advantage<br/></li>
<li></span><span class="Comment"> * of BRIN indexes, which is the tiny size. At 0.01% the index is about<br/></li>
<li></span><span class="Comment"> * 10% of the table (assuming 290 distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per 8kB page).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On the other hand, as the false-positive rate increases, larger part of<br/></li>
<li></span><span class="Comment"> * the table has to be scanned due to mismatches - at 25% we're probably<br/></li>
<li></span><span class="Comment"> * close to sequential scan being cheaper.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L192">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BLOOM_MIN_FALSE_POSITIVE_RATE</span>&nbsp; &nbsp; </span><span class="Constant">0.0001</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* 0.01% fp rate */<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BLOOM_MAX_FALSE_POSITIVE_RATE</span>&nbsp; &nbsp; </span><span class="Constant">0.25</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* 25% fp rate */<br/></li>
<li><a id="L194">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BLOOM_DEFAULT_FALSE_POSITIVE_RATE</span>&nbsp; &nbsp; </span><span class="Constant">0.01</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* 1% fp rate */<br/></li>
<li></span><br/></li>
<li><a id="L196">&#x200c;</a><span class="PreProc">#define <span class="linkable">BloomGetNDistinctPerRange</span>(opts) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((opts) &amp;&amp; (((<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *) (opts))-&gt;nDistinctPerRange != </span><span class="Constant">0</span><span class="PreProc">) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (((<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *) (opts))-&gt;nDistinctPerRange) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L176" title="access/brin/brin_bloom.c:176">BLOOM_DEFAULT_NDISTINCT_PER_RANGE</a>)<br/></li>
<li></span><br/></li>
<li><a id="L201">&#x200c;</a><span class="PreProc">#define <span class="linkable">BloomGetFalsePositiveRate</span>(opts) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((opts) &amp;&amp; (((<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *) (opts))-&gt;falsePositiveRate != </span><span class="Constant">0.0</span><span class="PreProc">) ? \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; (((<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *) (opts))-&gt;falsePositiveRate) : \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L194" title="access/brin/brin_bloom.c:194">BLOOM_DEFAULT_FALSE_POSITIVE_RATE</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * And estimate of the largest bloom we can fit onto a page. This is not<br/></li>
<li></span><span class="Comment"> * a perfect guarantee, for a couple of reasons. For example, the row may<br/></li>
<li></span><span class="Comment"> * be larger because the index has multiple columns.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L211">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BloomMaxFilterSize</span> \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; MAXALIGN_DOWN(BLCKSZ - \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (MAXALIGN(SizeOfPageHeaderData + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(ItemIdData)) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(BrinSpecialSpace)) + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SizeOfBrinTuple))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Seeds used to calculate two <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> h1 and h2, which are then used<br/></li>
<li></span><span class="Comment"> * to generate k hashes using the (h1 + i * h2) scheme.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L222">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BLOOM_SEED_1</span>&nbsp; &nbsp; </span><span class="Constant">0x71d924af<br/></li>
<li><a id="L223">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BLOOM_SEED_2</span>&nbsp; &nbsp; </span><span class="Constant">0xba48b314<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bloom Filter<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Represents a bloom filter, built on hashes of the indexed <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. That is,<br/></li>
<li></span><span class="Comment"> * we compute a uint32 <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of the value, and then store this <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> into the<br/></li>
<li></span><span class="Comment"> * bloom filter (and compute additional hashes on it).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We could implement &quot;sparse&quot; bloom filters, keeping only the bytes that<br/></li>
<li></span><span class="Comment"> * are not entirely 0. But while indexes don't support TOAST, the varlena can<br/></li>
<li></span><span class="Comment"> * still be compressed. So this seems unnecessary, because the compression<br/></li>
<li></span><span class="Comment"> * should do the same job.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We can also watch the number of bits set in the bloom filter, and then<br/></li>
<li></span><span class="Comment"> * stop using it (and not store the bitmap, to save space) when the false<br/></li>
<li></span><span class="Comment"> * positive rate gets too high. But even if the false positive rate exceeds the<br/></li>
<li></span><span class="Comment"> * desired value, it still can eliminate some page ranges.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L242">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BloomFilter</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* varlena header (do not touch directly!) */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; vl_len_;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* space for various flags (unused for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fields for the HASHED phase */<br/></li>
<li></span>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; nhashes;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nbits;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of bits in the bitmap (size) */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; nbits_set;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of bits set to 1 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* data of the bloom filter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; data[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L257">&#x200c;</a>} <span class="linkable">BloomFilter</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L271" title="access/brin/brin_bloom.c:271">bloom_filter_size</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Calculate Bloom filter parameters (nbits, nbytes, nhashes).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given expected number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and desired false positive rate,<br/></li>
<li></span><span class="Comment"> * calculates the optimal parameters of the Bloom filter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The resulting parameters are returned through nbytesp (number of bytes),<br/></li>
<li></span><span class="Comment"> * nbitsp (number of bits) and nhashesp (number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>). If a<br/></li>
<li></span><span class="Comment"> * pointer is NULL, the parameter is not returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L271">&#x200c;</a></span><span class="linkable">bloom_filter_size</span>(<span class="Type">int</span> ndistinct, <span class="Type">double</span> false_positive_rate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *nbytesp, <span class="Type">int</span> *nbitsp, <span class="Type">int</span> *nhashesp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; k;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sizing bloom filter: -(n * ln(p)) / (ln(2))^2 */<br/></li>
<li></span>&nbsp; &nbsp; nbits = ceil(-(ndistinct * log(false_positive_rate)) / pow(log(<span class="Constant">2.0</span>), <span class="Constant">2</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* round m to whole bytes */<br/></li>
<li></span>&nbsp; &nbsp; nbytes = ((nbits + <span class="Constant">7</span>) / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; nbits = nbytes * <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * round(log(2.0) * m / ndistinct), but assume round() may not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * available on Windows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; k = log(<span class="Constant">2.0</span>) * nbits / ndistinct;<br/></li>
<li>&nbsp; &nbsp; k = (k - floor(k) &gt;= <span class="Constant">0.5</span>) ? ceil(k) : floor(k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbytesp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nbytesp = nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nbitsp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nbitsp = nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nhashesp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *nhashesp = (<span class="Type">int</span>) k;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L310" title="access/brin/brin_bloom.c:310">bloom_init</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Initialize the Bloom Filter, allocate all the memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The filter is initialized with optimal size for ndistinct expected <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * and the requested false positive rate. The filter is stored as varlena.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *<br/></li>
<li><a id="L310">&#x200c;</a><span class="linkable">bloom_init</span>(<span class="Type">int</span> ndistinct, <span class="Type">double</span> false_positive_rate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbits;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of filter / number of bits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of filter / number of bytes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhashes;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(ndistinct &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(false_positive_rate &gt; <span class="Constant">0</span> &amp;&amp; false_positive_rate &lt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calculate bloom filter size / parameters */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L271" title="access/brin/brin_bloom.c:271">bloom_filter_size</a>(ndistinct, false_positive_rate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nbytes, &amp;nbits, &amp;nhashes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reject filters that are obviously too large to store on a page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initially the bloom filter is just zeroes and so very compressible, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as we add <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> it gets more and more random, and so less and less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compressible. So initially everything fits on the page, but we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get surprising failures later - we want to prevent that, so we reject<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bloom filter that are obviously too large.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> It's not uncommon to oversize the bloom filter a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, to defend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against unexpected data anomalies (parts of table with more distinct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> etc.). But we still need to make sure even the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * oversized filter fits on page, if such need arises.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This check is not perfect, because the index may have multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filters that are small individually, but too large when combined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nbytes &gt; <a href="#L211" title="access/brin/brin_bloom.c:211">BloomMaxFilterSize</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;the bloom filter is too large (</span><span class="Special">%d</span><span class="Constant"> &gt; </span><span class="Special">%zu</span><span class="Constant">)&quot;</span>, nbytes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L211" title="access/brin/brin_bloom.c:211">BloomMaxFilterSize</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allocate the whole filter. Most of it is going to be 0 bits, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varlena is easy to compress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = offsetof(<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a>, data) + nbytes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filter = (<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filter-&gt;flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; filter-&gt;nhashes = nhashes;<br/></li>
<li>&nbsp; &nbsp; filter-&gt;nbits = nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SET_VARSIZE(filter, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> filter;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L370" title="access/brin/brin_bloom.c:370">bloom_add_value</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Add value to the bloom filter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *<br/></li>
<li><a id="L370">&#x200c;</a><span class="linkable">bloom_add_value</span>(<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter, uint32 value, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *updated)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; h1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute the hashes, used for the bloom filter */<br/></li>
<li></span>&nbsp; &nbsp; h1 = hash_bytes_uint32_extended(value, <a href="#L222" title="access/brin/brin_bloom.c:222">BLOOM_SEED_1</a>) % filter-&gt;nbits;<br/></li>
<li>&nbsp; &nbsp; h2 = hash_bytes_uint32_extended(value, <a href="#L223" title="access/brin/brin_bloom.c:223">BLOOM_SEED_2</a>) % filter-&gt;nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute the requested number of hashes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; filter-&gt;nhashes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* h1 + h2 + f(i) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; h = (h1 + i * h2) % filter-&gt;nbits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; byte = (h / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> = (h % <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is not set, set it and remember we did that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(filter-&gt;data[byte] &amp; (<span class="Constant">0x01</span> &lt;&lt; <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;data[byte] |= (<span class="Constant">0x01</span> &lt;&lt; <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;nbits_set++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (updated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *updated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> filter;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L407" title="access/brin/brin_bloom.c:407">bloom_contains_value</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Check if the bloom filter contains a particular value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L407">&#x200c;</a></span><span class="linkable">bloom_contains_value</span>(<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter, uint32 value)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; h1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* calculate the two hashes */<br/></li>
<li></span>&nbsp; &nbsp; h1 = hash_bytes_uint32_extended(value, <a href="#L222" title="access/brin/brin_bloom.c:222">BLOOM_SEED_1</a>) % filter-&gt;nbits;<br/></li>
<li>&nbsp; &nbsp; h2 = hash_bytes_uint32_extended(value, <a href="#L223" title="access/brin/brin_bloom.c:223">BLOOM_SEED_2</a>) % filter-&gt;nbits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* compute the requested number of hashes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; filter-&gt;nhashes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* h1 + h2 + f(i) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; h = (h1 + i * h2) % filter-&gt;nbits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; byte = (h / <span class="Constant">8</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> = (h % <span class="Constant">8</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is not set, the value is not there */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(filter-&gt;data[byte] &amp; (<span class="Constant">0x01</span> &lt;&lt; <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all hashes found in bloom filter */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L434">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BloomOpaque</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> At this point we only need a single proc (to compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>), but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let's keep the array just like inclusion and minmax opclasses, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistency. We may need additional procs in the future.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; extra_procinfos[<a href="#L142" title="access/brin/brin_bloom.c:142">BLOOM_MAX_PROCNUMS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; extra_proc_missing[<a href="#L142" title="access/brin/brin_bloom.c:142">BLOOM_MAX_PROCNUMS</a>];<br/></li>
<li><a id="L443">&#x200c;</a>} <span class="linkable">BloomOpaque</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> FmgrInfo *<a href="#L707" title="access/brin/brin_bloom.c:707">bloom_get_procinfo</a>(BrinDesc *bdesc, uint16 attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 procnum);<br/></li>
<li><br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L450">&#x200c;</a><span class="linkable">brin_bloom_opcinfo</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinOpcInfo *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opaque-&gt;strategy_procinfos is initialized lazily; here it is set to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all-uninitialized by <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a> which sets fn_oid to InvalidOid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bloom indexes only store the filter as a single BYTEA column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; result = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(MAXALIGN(SizeofBrinOpcInfo(<span class="Constant">1</span>)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L434" title="access/brin/brin_bloom.c:434">BloomOpaque</a>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_nstored = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_regular_nulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_opaque = (<a href="#L434" title="access/brin/brin_bloom.c:434">BloomOpaque</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN((<span class="Type">char</span> *) result + SizeofBrinOpcInfo(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_typcache[<span class="Constant">0</span>] = <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(PG_BRIN_BLOOM_SUMMARYOID, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L497" title="access/brin/brin_bloom.c:497">brin_bloom_get_ndistinct</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine the ndistinct value used to size bloom filter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Adjust the ndistinct value based on the pagesPerRange value. First,<br/></li>
<li></span><span class="Comment"> * if it's negative, it's assumed to be relative to maximum number of<br/></li>
<li></span><span class="Comment"> * tuples in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (assuming each page gets MaxHeapTuplesPerPage<br/></li>
<li></span><span class="Comment"> * tuples, which is likely a significant over-estimate). We also clamp<br/></li>
<li></span><span class="Comment"> * the value, not to over-size the bloom filter unnecessarily.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We can only do this when the pagesPerRange value was supplied.<br/></li>
<li></span><span class="Comment"> * If it wasn't, it has to be a read-only access to the index, in which<br/></li>
<li></span><span class="Comment"> * case we don't really care. But perhaps we should fall-back to the<br/></li>
<li></span><span class="Comment"> * default pagesPerRange value?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We might also fetch info about ndistinct estimate for the column,<br/></li>
<li></span><span class="Comment"> * and compute the expected number of distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. But<br/></li>
<li></span><span class="Comment"> * that may be tricky due to data being sorted in various ways, so it<br/></li>
<li></span><span class="Comment"> * seems better to rely on the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> estimate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We might also calculate a better estimate of rows per BRIN <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>,<br/></li>
<li></span><span class="Comment"> * instead of using MaxHeapTuplesPerPage (which probably produces <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * much higher than reality).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L497">&#x200c;</a></span><span class="linkable">brin_bloom_get_ndistinct</span>(BrinDesc *bdesc, <a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *opts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; maxtuples;<br/></li>
<li>&nbsp; &nbsp; BlockNumber pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pagesPerRange = BrinGetPagesPerRange(bdesc-&gt;bd_index);<br/></li>
<li>&nbsp; &nbsp; ndistinct = <a href="#L196" title="access/brin/brin_bloom.c:196">BloomGetNDistinctPerRange</a>(opts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(pagesPerRange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxtuples = MaxHeapTuplesPerPage * pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly to n_distinct, negative <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are relative - in this case to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maximum number of tuples in the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (maxtuples).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndistinct &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndistinct = (-ndistinct) * maxtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Positive <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are to be used directly, but we still apply a couple of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safeties to avoid using unreasonably small bloom filters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndistinct = Max(ndistinct, <a href="#L169" title="access/brin/brin_bloom.c:169">BLOOM_MIN_NDISTINCT_PER_RANGE</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And don't use more than the maximum possible number of tuples, in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, which would be entirely wasteful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ndistinct = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ndistinct, maxtuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">int</span>) ndistinct;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Examine the given index tuple (which contains partial status of a certain<br/></li>
<li></span><span class="Comment"> * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) by comparing it to the given value that comes from another heap<br/></li>
<li></span><span class="Comment"> * tuple.&nbsp; If the new value is outside the bloom filter specified by the<br/></li>
<li></span><span class="Comment"> * existing tuple <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, update the index tuple and return true.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment"> * return false and do not modify in this case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L540">&#x200c;</a><span class="linkable">brin_bloom_add_value</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *column = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = PG_GETARG_DATUM(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *opts = (<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a> *) PG_GET_OPCLASS_OPTIONS();<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *hashFn;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashValue;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; updated = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = column-&gt;bv_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is the first non-null value, we need to <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the bloom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filter. Otherwise just extract the existing bloom filter from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BrinValues.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filter = <a href="#L310" title="access/brin/brin_bloom.c:310">bloom_init</a>(<a href="#L497" title="access/brin/brin_bloom.c:497">brin_bloom_get_ndistinct</a>(bdesc, opts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L201" title="access/brin/brin_bloom.c:201">BloomGetFalsePositiveRate</a>(opts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<span class="Constant">0</span>] = PointerGetDatum(filter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_allnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; updated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; filter = (<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *) PG_DETOAST_DATUM(column-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of the new value, using the supplied <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then add the <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value to the bloom filter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hashFn = <a href="#L707" title="access/brin/brin_bloom.c:707">bloom_get_procinfo</a>(bdesc, attno, <a href="#L143" title="access/brin/brin_bloom.c:143">PROCNUM_HASH</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hashValue = DatumGetUInt32(<a href="../../utils/fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(hashFn, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filter = <a href="#L370" title="access/brin/brin_bloom.c:370">bloom_add_value</a>(filter, hashValue, &amp;updated);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; column-&gt;bv_values[<span class="Constant">0</span>] = PointerGetDatum(filter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(updated);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given an index tuple corresponding to a certain page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> and a scan key,<br/></li>
<li></span><span class="Comment"> * return whether the scan key is consistent with the index tuple's bloom<br/></li>
<li></span><span class="Comment"> * filter.&nbsp; Return true if so, false otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L595">&#x200c;</a><span class="linkable">brin_bloom_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *column = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; *keys = (ScanKey *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys = PG_GETARG_INT32(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; value;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; matches;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *finfo;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashValue;<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filter = (<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *) PG_DETOAST_DATUM(column-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(filter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assume all scan keys match. We'll be searching for a scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * eliminating the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (we can stop on the first such key).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; matches = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; nkeys; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = keys[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL keys are handled and filtered-out in <a href="brin.c.html#L556" title="access/brin/brin.c:556">bringetbitmap</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(key-&gt;sk_flags &amp; SK_ISNULL));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attno = key-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = key-&gt;sk_argument;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (key-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L133" title="access/brin/brin_bloom.c:133">BloomEqualStrategyNumber</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We want to return the current page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> if the bloom<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * filter seems to contain the value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L707" title="access/brin/brin_bloom.c:707">bloom_get_procinfo</a>(bdesc, attno, <a href="#L143" title="access/brin/brin_bloom.c:143">PROCNUM_HASH</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hashValue = DatumGetUInt32(<a href="../../utils/fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(finfo, colloid, value));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches &amp;= <a href="#L407" title="access/brin/brin_bloom.c:407">bloom_contains_value</a>(filter, hashValue);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid strategy number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matches = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!matches)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(matches);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given two BrinValues, update the first of them as a union of the summary<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> contained in both.&nbsp; The second one is untouched.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> We assume the bloom filters have the same parameters for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. In the<br/></li>
<li></span><span class="Comment"> * future we should have 'can union' function, to decide if we can <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a><br/></li>
<li></span><span class="Comment"> * two particular bloom filters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L667">&#x200c;</a><span class="linkable">brin_bloom_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nbytes;<br/></li>
<li>&nbsp; &nbsp; BrinValues *col_a = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *col_b = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter_a;<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter_b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(col_a-&gt;bv_attno == col_b-&gt;bv_attno);<br/></li>
<li>&nbsp; &nbsp; Assert(!col_a-&gt;bv_allnulls &amp;&amp; !col_b-&gt;bv_allnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filter_a = (<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *) PG_DETOAST_DATUM(col_a-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; filter_b = (<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *) PG_DETOAST_DATUM(col_b-&gt;bv_values[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure the filters use the same parameters */<br/></li>
<li></span>&nbsp; &nbsp; Assert(filter_a &amp;&amp; filter_b);<br/></li>
<li>&nbsp; &nbsp; Assert(filter_a-&gt;nbits == filter_b-&gt;nbits);<br/></li>
<li>&nbsp; &nbsp; Assert(filter_a-&gt;nhashes == filter_b-&gt;nhashes);<br/></li>
<li>&nbsp; &nbsp; Assert((filter_a-&gt;nbits &gt; <span class="Constant">0</span>) &amp;&amp; (filter_a-&gt;nbits % <span class="Constant">8</span> == <span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbytes = (filter_a-&gt;nbits) / <span class="Constant">8</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* simply OR the bitmaps */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nbytes; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filter_a-&gt;data[i] |= filter_b-&gt;data[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update the number of bits set in the filter */<br/></li>
<li></span>&nbsp; &nbsp; filter_a-&gt;nbits_set = pg_popcount((<span class="Type">const</span> <span class="Type">char</span> *) filter_a-&gt;data, nbytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache and return inclusion opclass support procedure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the procedure corresponding to the given function support number<br/></li>
<li></span><span class="Comment"> * or null if it does not exist.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FmgrInfo *<br/></li>
<li><a id="L707">&#x200c;</a><span class="linkable">bloom_get_procinfo</span>(BrinDesc *bdesc, uint16 attno, uint16 procnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L434" title="access/brin/brin_bloom.c:434">BloomOpaque</a> *opaque;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; basenum = procnum - <a href="brin_inclusion.c.html#L57" title="access/brin/brin_inclusion.c:57">PROCNUM_BASE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cache these in the opaque struct, to avoid repetitive syscache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque = (<a href="#L434" title="access/brin/brin_bloom.c:434">BloomOpaque</a> *) bdesc-&gt;bd_info[attno - <span class="Constant">1</span>]-&gt;oi_opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already searched for this proc and didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searching again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;extra_proc_missing[basenum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;extra_procinfos[basenum].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RegProcedureIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(bdesc-&gt;bd_index, attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procnum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;opaque-&gt;extra_procinfos[basenum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(bdesc-&gt;bd_index, attno, procnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bdesc-&gt;bd_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;extra_proc_missing[basenum] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;opaque-&gt;extra_procinfos[basenum];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>Datum<br/></li>
<li><a id="L745">&#x200c;</a><span class="linkable">brin_bloom_options</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/reloptions.c.html#L734" title="access/common/reloptions.c:734">init_local_reloptions</a>(relopts, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/reloptions.c.html#L972" title="access/common/reloptions.c:972">add_local_real_reloption</a>(relopts, <span class="Constant">&quot;n_distinct_per_range&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;number of distinct items expected in a BRIN page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L176" title="access/brin/brin_bloom.c:176">BLOOM_DEFAULT_NDISTINCT_PER_RANGE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>, <span class="Constant">INT_MAX</span>, offsetof(<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a>, nDistinctPerRange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/reloptions.c.html#L972" title="access/common/reloptions.c:972">add_local_real_reloption</a>(relopts, <span class="Constant">&quot;false_positive_rate&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;desired false-positive rate for the bloom filters&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L194" title="access/brin/brin_bloom.c:194">BLOOM_DEFAULT_FALSE_POSITIVE_RATE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L192" title="access/brin/brin_bloom.c:192">BLOOM_MIN_FALSE_POSITIVE_RATE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L193" title="access/brin/brin_bloom.c:193">BLOOM_MAX_FALSE_POSITIVE_RATE</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(<a href="#L154" title="access/brin/brin_bloom.c:154">BloomOptions</a>, falsePositiveRate));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L775" title="access/brin/brin_bloom.c:775">brin_bloom_summary_in</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - input routine for type brin_bloom_summary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * brin_bloom_summary is only used internally to represent summaries<br/></li>
<li></span><span class="Comment"> * in BRIN bloom indexes, so it has no operations of its own, and we<br/></li>
<li></span><span class="Comment"> * disallow input too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L775">&#x200c;</a><span class="linkable">brin_bloom_summary_in</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * brin_bloom_summary stores the data in binary form and parsing text<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input is not needed, so disallow this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_brin_bloom_summary&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L797" title="access/brin/brin_bloom.c:797">brin_bloom_summary_out</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - output routine for type brin_bloom_summary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BRIN bloom summaries are serialized into a bytea value, but we want<br/></li>
<li></span><span class="Comment"> * to output something nicer humans can understand.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L797">&#x200c;</a><span class="linkable">brin_bloom_summary_out</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *filter;<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* detoast the data to get value with a full 4B header */<br/></li>
<li></span>&nbsp; &nbsp; filter = (<a href="#L242" title="access/brin/brin_bloom.c:242">BloomFilter</a> *) PG_DETOAST_DATUM(PG_GETARG_DATUM(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">'{'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str, <span class="Constant">&quot;mode: hashed&nbsp; nhashes: </span><span class="Special">%u</span><span class="Constant">&nbsp; nbits: </span><span class="Special">%u</span><span class="Constant">&nbsp; nbits_set: </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; filter-&gt;nhashes, filter-&gt;nbits, filter-&gt;nbits_set);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoChar(&amp;str, <span class="Constant">'}'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_CSTRING(str.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L821" title="access/brin/brin_bloom.c:821">brin_bloom_summary_recv</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - binary input routine for type brin_bloom_summary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L821">&#x200c;</a><span class="linkable">brin_bloom_summary_recv</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> a value of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;pg_brin_bloom_summary&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L838" title="access/brin/brin_bloom.c:838">brin_bloom_summary_send</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; - binary output routine for type brin_bloom_summary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BRIN bloom summaries are serialized in a bytea value (although the<br/></li>
<li></span><span class="Comment"> * type is named differently), so let's just <a href="../../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L838">&#x200c;</a><span class="linkable">brin_bloom_summary_send</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../utils/adt/varlena.c.html#L490" title="utils/adt/varlena.c:490">byteasend</a>(fcinfo);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
