<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/brin/brin_inclusion.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/brin/brin_inclusion.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L76">InclusionOpaque</a></li>
<li><a href="#L82">InclusionOpaque</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L138">brin_inclusion_add_value</a></li>
<li><a href="#L251">brin_inclusion_consistent</a></li>
<li><a href="#L94">brin_inclusion_opcinfo</a></li>
<li><a href="#L475">brin_inclusion_union</a></li>
<li><a href="#L545">inclusion_get_procinfo</a></li>
<li><a href="#L603">inclusion_get_strategy_procinfo</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L73">INCLUSION_CONTAINS_EMPTY</a></li>
<li><a href="#L46">INCLUSION_MAX_PROCNUMS</a></li>
<li><a href="#L71">INCLUSION_UNION</a></li>
<li><a href="#L72">INCLUSION_UNMERGEABLE</a></li>
<li><a href="#L57">PROCNUM_BASE</a></li>
<li><a href="#L49">PROCNUM_CONTAINS</a></li>
<li><a href="#L50">PROCNUM_EMPTY</a></li>
<li><a href="#L47">PROCNUM_MERGE</a></li>
<li><a href="#L48">PROCNUM_MERGEABLE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * brin_inclusion.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Implementation of inclusion opclasses for BRIN<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This module provides framework BRIN support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> for the &quot;inclusion&quot;<br/></li>
<li></span><span class="Comment"> * operator classes.&nbsp; A few SQL-level support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are also required for<br/></li>
<li></span><span class="Comment"> * each opclass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;inclusion&quot; BRIN strategy is useful for types that support R-Tree<br/></li>
<li></span><span class="Comment"> * operations.&nbsp; This implementation is a straight mapping of those operations<br/></li>
<li></span><span class="Comment"> * to the block-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> nature of BRIN, with two exceptions: (a) we explicitly<br/></li>
<li></span><span class="Comment"> * support &quot;empty&quot; elements: at least with <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> types, we need to consider<br/></li>
<li></span><span class="Comment"> * emptiness separately from regular R-Tree strategies; and (b) we need to<br/></li>
<li></span><span class="Comment"> * consider &quot;unmergeable&quot; elements, that is, a set of elements for whose union<br/></li>
<li></span><span class="Comment"> * no representation exists.&nbsp; The only case where that happens as of this<br/></li>
<li></span><span class="Comment"> * writing is the INET type, where IPv6 <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> cannot be merged with IPv4<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/brin/brin_inclusion.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_tuple.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/skey.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_amop.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Additional SQL level support <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Procedure numbers must not use <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> reserved for BRIN itself; see<br/></li>
<li></span><span class="Comment"> * brin_internal.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L46">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">INCLUSION_MAX_PROCNUMS</span>&nbsp; &nbsp; </span><span class="Constant">4</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* maximum support procs we need */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_MERGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* required */<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_MERGEABLE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">12</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* optional */<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_CONTAINS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">13</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* optional */<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_EMPTY</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">14</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* optional */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subtract this from procnum to obtain index in <a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a> arrays<br/></li>
<li></span><span class="Comment"> * (Must be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to minimum of private procnums).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PROCNUM_BASE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*-<br/></li>
<li></span><span class="Comment"> * The <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> stored in the bv_values arrays correspond to:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the union of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> * <a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; whether the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> cannot be merged<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (e.g. an IPv6 address amidst IPv4 addresses)<br/></li>
<li></span><span class="Comment"> * <a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; whether an empty value is present in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; in the block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INCLUSION_UNION</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INCLUSION_UNMERGEABLE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INCLUSION_CONTAINS_EMPTY</span>&nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L76">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">InclusionOpaque</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; extra_procinfos[<a href="#L46" title="access/brin/brin_inclusion.c:46">INCLUSION_MAX_PROCNUMS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; extra_proc_missing[<a href="#L46" title="access/brin/brin_inclusion.c:46">INCLUSION_MAX_PROCNUMS</a>];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cached_subtype;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; strategy_procinfos[RTMaxStrategyNumber];<br/></li>
<li><a id="L82">&#x200c;</a>} <span class="linkable">InclusionOpaque</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> FmgrInfo *<a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(BrinDesc *bdesc, uint16 attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 procnum);<br/></li>
<li><span class="Type">static</span> FmgrInfo *<a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(BrinDesc *bdesc, uint16 attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid subtype, uint16 strategynum);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BRIN inclusion OpcInfo function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L94">&#x200c;</a><span class="linkable">brin_inclusion_opcinfo</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinOpcInfo *result;<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *bool_typcache = <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(BOOLOID, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All members of opaque are initialized lazily; both procinfo arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start out as non-initialized by having fn_oid be InvalidOid, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;missing&quot; to false, by zeroing here.&nbsp; strategy_procinfos elements can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be invalidated when cached_subtype changes by zeroing fn_oid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * extra_procinfo entries are never invalidated, but if a lookup fails<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (which is expected), extra_proc_missing is set to true, indicating not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to look it up again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(MAXALIGN(SizeofBrinOpcInfo(<span class="Constant">3</span>)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a>));<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_nstored = <span class="Constant">3</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_regular_nulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; result-&gt;oi_opaque = (<a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN((<span class="Type">char</span> *) result + SizeofBrinOpcInfo(<span class="Constant">3</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the union */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;oi_typcache[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(typoid, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* includes elements that are not mergeable */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;oi_typcache[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>] = bool_typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* includes the empty <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;oi_typcache[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>] = bool_typcache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(result);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BRIN inclusion add value function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Examine the given index tuple (which contains partial status of a certain<br/></li>
<li></span><span class="Comment"> * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>) by comparing it to the given value that comes from another heap<br/></li>
<li></span><span class="Comment"> * tuple.&nbsp; If the new value is outside the union specified by the existing<br/></li>
<li></span><span class="Comment"> * tuple <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, update the index tuple and return true.&nbsp; Otherwise, return<br/></li>
<li></span><span class="Comment"> * false and do not modify in this case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L138">&#x200c;</a><span class="linkable">brin_inclusion_add_value</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *column = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = PG_GETARG_DATUM(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = PG_GETARG_BOOL(<span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *finfo;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; new = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = column-&gt;bv_attno;<br/></li>
<li>&nbsp; &nbsp; attr = TupleDescAttr(bdesc-&gt;bd_tupdesc, attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the recorded value is null, copy the new value (which we know to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not null), and we're almost done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(<a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, attr-&gt;attbyval, attr-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_allnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No need for further processing if the block <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * containing unmergeable <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(column-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the opclass supports the concept of empty <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, test the passed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new value for emptiness; if it returns true, we need to set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;contains empty&quot; flag in the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> (unless already set).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; finfo = <a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(bdesc, attno, <a href="#L50" title="access/brin/brin_inclusion.c:50">PROCNUM_EMPTY</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (finfo != <span class="Constant">NULL</span> &amp;&amp; DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1129" title="utils/fmgr/fmgr.c:1129">FunctionCall1Coll</a>(finfo, colloid, <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the new value is already contained. */<br/></li>
<li></span>&nbsp; &nbsp; finfo = <a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(bdesc, attno, <a href="#L49" title="access/brin/brin_inclusion.c:49">PROCNUM_CONTAINS</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (finfo != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the new value is mergeable to the existing union.&nbsp; If it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not, mark the value as containing unmergeable elements and get out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: at this point we could remove the value from the union, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's not going to be used <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer.&nbsp; However, the BRIN framework<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't allow for the value not being present.&nbsp; Improve someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; finfo = <a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(bdesc, attno, <a href="#L48" title="access/brin/brin_inclusion.c:48">PROCNUM_MERGEABLE</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (finfo != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the new value to the existing union. */<br/></li>
<li></span>&nbsp; &nbsp; finfo = <a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(bdesc, attno, <a href="#L47" title="access/brin/brin_inclusion.c:47">PROCNUM_MERGE</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(finfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>], <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attbyval &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(result) != DatumGetPointer(column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <a href="../../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(result, attr-&gt;attbyval, attr-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>] = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BRIN inclusion consistent function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We're no longer dealing with NULL keys in the consistent function, that is<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handled by the AM code. That means we should not get <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> all-NULL ranges<br/></li>
<li></span><span class="Comment"> * either, because those can't be consistent with regular (not [IS] NULL) keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All of the strategies are optional.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L251">&#x200c;</a><span class="linkable">brin_inclusion_consistent</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *column = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = (ScanKey) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subtype;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; unionval;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; query;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *finfo;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This opclass uses the old signature with only three arguments. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(PG_NARGS() == <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not be dealing with all-NULL ranges. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!column-&gt;bv_allnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It has to be checked, if it contains elements that are not mergeable. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(column-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = key-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; subtype = key-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; query = key-&gt;sk_argument;<br/></li>
<li>&nbsp; &nbsp; unionval = column-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (key-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Placement strategies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These are implemented by logically negating the result of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * converse placement operator; for this to work, the converse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator must be part of the opclass.&nbsp; An error will be thrown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * by <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>() if the required strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is not part of the opclass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These all return false if either argument is empty, so there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no need to check for empty elements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTOverRightStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverLeftStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTRightStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTLeftStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTRightStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTOverLeftStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTOverAboveStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverBelowStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTAboveStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTBelowStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTAboveStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTOverBelowStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Overlap and contains strategies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These strategies are simple enough that we can simply call the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator and return its result.&nbsp; Empty elements don't change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTOverlapStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainsStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainsElemStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSubStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSubEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Contained by strategies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot just call the original operator for the contained by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategies because some elements can be contained even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the union is not; instead we use the overlap operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We check for empty elements separately as they are not merged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the union but contained by everything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTContainedByStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSuperStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSuperEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTOverlapStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjacent strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We test for overlap first but to be safe we need to call the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * actual adjacent operator also.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An empty <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> cannot be adjacent to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other, so there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no need to check for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTAdjacentStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTOverlapStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTAdjacentStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Basic comparison strategies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is straightforward to support the equality strategies with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the contains operator.&nbsp; Generally, inequality strategies do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make much sense for the types which will be used with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inclusion BRIN family of opclasses, but it is possible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implement them with logical negation of the left-of and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right-of operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: These strategies cannot be used with geometric datatypes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that use comparison of areas!&nbsp; The only exception is the &quot;same&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty elements are considered to be less than the others.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot use the empty support function to check the query is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, because the query can be another data type than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the empty support function argument.&nbsp; So we will return true,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if there is a possibility that empty elements will change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTRightStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTSameStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTContainsStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTLeftStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_DATUM(column-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to check for empty elements */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finfo = <a href="#L603" title="access/brin/brin_inclusion.c:603">inclusion_get_strategy_procinfo</a>(bdesc, attno, subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTLeftStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid, unionval, query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(!DatumGetBool(result));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid strategy number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, key-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_BOOL(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BRIN inclusion union function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given two BrinValues, update the first of them as a union of the summary<br/></li>
<li></span><span class="Comment"> * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> contained in both.&nbsp; The second one is untouched.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L475">&#x200c;</a><span class="linkable">brin_inclusion_union</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc = (BrinDesc *) PG_GETARG_POINTER(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *col_a = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BrinValues *col_b = (BrinValues *) PG_GETARG_POINTER(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colloid = PG_GET_COLLATION();<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *finfo;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(col_a-&gt;bv_attno == col_b-&gt;bv_attno);<br/></li>
<li>&nbsp; &nbsp; Assert(!col_a-&gt;bv_allnulls &amp;&amp; !col_b-&gt;bv_allnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attno = col_a-&gt;bv_attno;<br/></li>
<li>&nbsp; &nbsp; attr = TupleDescAttr(bdesc-&gt;bd_tupdesc, attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If B includes empty elements, mark A similarly, if needed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!DatumGetBool(col_a-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetBool(col_b-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_values[<a href="#L73" title="access/brin/brin_inclusion.c:73">INCLUSION_CONTAINS_EMPTY</a>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if A includes elements that are not mergeable. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(col_a-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If B includes elements that are not mergeable, mark A similarly. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(col_b-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if A and B are mergeable; if not, mark A unmergeable. */<br/></li>
<li></span>&nbsp; &nbsp; finfo = <a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(bdesc, attno, <a href="#L48" title="access/brin/brin_inclusion.c:48">PROCNUM_MERGEABLE</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (finfo != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_b-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>])))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_values[<a href="#L72" title="access/brin/brin_inclusion.c:72">INCLUSION_UNMERGEABLE</a>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> B to A. */<br/></li>
<li></span>&nbsp; &nbsp; finfo = <a href="#L545" title="access/brin/brin_inclusion.c:545">inclusion_get_procinfo</a>(bdesc, attno, <a href="#L47" title="access/brin/brin_inclusion.c:47">PROCNUM_MERGE</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(finfo != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(finfo, colloid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; col_a-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; col_b-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>]);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attr-&gt;attbyval &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(result) != DatumGetPointer(col_a-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(col_a-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>]));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == col_b-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(result, attr-&gt;attbyval, attr-&gt;attlen);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; col_a-&gt;bv_values[<a href="#L71" title="access/brin/brin_inclusion.c:71">INCLUSION_UNION</a>] = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache and return inclusion opclass support procedure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the procedure corresponding to the given function support number<br/></li>
<li></span><span class="Comment"> * or null if it is not exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FmgrInfo *<br/></li>
<li><a id="L545">&#x200c;</a><span class="linkable">inclusion_get_procinfo</span>(BrinDesc *bdesc, uint16 attno, uint16 procnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a> *opaque;<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; basenum = procnum - <a href="#L57" title="access/brin/brin_inclusion.c:57">PROCNUM_BASE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cache these in the opaque struct, to avoid repetitive syscache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque = (<a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a> *) bdesc-&gt;bd_info[attno - <span class="Constant">1</span>]-&gt;oi_opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already searched for this proc and didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it, don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searching again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;extra_proc_missing[basenum])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;extra_procinfos[basenum].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RegProcedureIsValid(<a href="../index/indexam.c.html#L826" title="access/index/indexam.c:826">index_getprocid</a>(bdesc-&gt;bd_index, attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procnum)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;opaque-&gt;extra_procinfos[basenum],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(bdesc-&gt;bd_index, attno, procnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bdesc-&gt;bd_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;extra_proc_missing[basenum] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;opaque-&gt;extra_procinfos[basenum];<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cache and return the procedure of the given strategy<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return the procedure corresponding to the given sub-type and strategy<br/></li>
<li></span><span class="Comment"> * number.&nbsp; The data type of the index will be used as the left hand side of<br/></li>
<li></span><span class="Comment"> * the operator and the given sub-type will be used as the right hand side.<br/></li>
<li></span><span class="Comment"> * Throws an error if the pg_amop row does not exist, but that should not<br/></li>
<li></span><span class="Comment"> * happen with a properly configured opclass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It always throws an error when the data type of the opclass is different<br/></li>
<li></span><span class="Comment"> * from the data type of the column or the expression.&nbsp; That happens when the<br/></li>
<li></span><span class="Comment"> * column data type has implicit cast to the opclass data type.&nbsp; We don't<br/></li>
<li></span><span class="Comment"> * bother casting types, because this situation can easily be avoided by<br/></li>
<li></span><span class="Comment"> * setting storage data type to that of the opclass.&nbsp; The same problem does not<br/></li>
<li></span><span class="Comment"> * apply to the data type of the right hand side, because the type in the<br/></li>
<li></span><span class="Comment"> * ScanKey always matches the opclass' one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this function mirrors <a href="brin_minmax.c.html#L261" title="access/brin/brin_minmax.c:261">minmax_get_strategy_procinfo</a>; if changes are<br/></li>
<li></span><span class="Comment"> * made here, see that function too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FmgrInfo *<br/></li>
<li><a id="L603">&#x200c;</a><span class="linkable">inclusion_get_strategy_procinfo</span>(BrinDesc *bdesc, uint16 attno, Oid subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16 strategynum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a> *opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(strategynum &gt;= <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategynum &lt;= RTMaxStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = (<a href="#L76" title="access/brin/brin_inclusion.c:76">InclusionOpaque</a> *) bdesc-&gt;bd_info[attno - <span class="Constant">1</span>]-&gt;oi_opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cache the procedures for the last sub-type in the opaque struct, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid repetitive syscache lookups.&nbsp; If the sub-type is changed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invalidate all the cached entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;cached_subtype != subtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= RTMaxStrategyNumber; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;strategy_procinfos[i - <span class="Constant">1</span>].fn_oid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;cached_subtype = subtype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;strategy_procinfos[strategynum - <span class="Constant">1</span>].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opfamily = bdesc-&gt;bd_index-&gt;rd_opfamily[attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attr = TupleDescAttr(bdesc-&gt;bd_tupdesc, attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../../utils/cache/syscache.c.html#L251" title="utils/cache/syscache.c:251">SearchSysCache4</a>(AMOPSTRATEGY, ObjectIdGetDatum(opfamily),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(attr-&gt;atttypid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(subtype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(strategynum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategynum, attr-&gt;atttypid, subtype, opfamily);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a> = DatumGetObjectId(<a href="../../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(AMOPSTRATEGY, tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_amop_amopopr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(RegProcedureIsValid(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(<a href="../../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(<a href="../../parser/parse_oper.c.html#L238" title="parser/parse_oper.c:238">oprid</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;opaque-&gt;strategy_procinfos[strategynum - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bdesc-&gt;bd_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> &amp;opaque-&gt;strategy_procinfos[strategynum - <span class="Constant">1</span>];<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
