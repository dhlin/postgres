<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/brin/brin_revmap.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/brin/brin_revmap.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L46">BrinRevmap</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L194">brinGetTupleForHeapBlock</a></li>
<li><a href="#L134">brinLockRevmapPageForUpdate</a></li>
<li><a href="#L323">brinRevmapDesummarizeRange</a></li>
<li><a href="#L112">brinRevmapExtend</a></li>
<li><a href="#L70">brinRevmapInitialize</a></li>
<li><a href="#L100">brinRevmapTerminate</a></li>
<li><a href="#L155">brinSetHeapBlockItemptr</a></li>
<li><a href="#L500">revmap_extend_and_get_blkno</a></li>
<li><a href="#L442">revmap_get_blkno</a></li>
<li><a href="#L463">revmap_get_buffer</a></li>
<li><a href="#L522">revmap_physical_extend</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L40">HEAPBLK_TO_REVMAP_BLK</a></li>
<li><a href="#L42">HEAPBLK_TO_REVMAP_INDEX</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * brin_revmap.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/geo_spgist.c.html#L107" title="utils/adt/geo_spgist.c:107">Range</a> map for BRIN indexes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> map (revmap) is a translation structure for BRIN indexes: for each<br/></li>
<li></span><span class="Comment"> * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> there is one summary tuple, and its location is tracked by the<br/></li>
<li></span><span class="Comment"> * revmap.&nbsp; Whenever a new tuple is inserted into a table that violates the<br/></li>
<li></span><span class="Comment"> * previously recorded summary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, a new tuple is inserted into the index<br/></li>
<li></span><span class="Comment"> * and the revmap is updated to point to it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The revmap is stored in the first pages of the index, immediately following<br/></li>
<li></span><span class="Comment"> * the metapage.&nbsp; When the revmap needs to be expanded, all tuples on the<br/></li>
<li></span><span class="Comment"> * regular BRIN page at that block (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) are moved out of the way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/brin/brin_revmap.c<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_page.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_pageops.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_revmap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_tuple.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/rmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In revmap pages, each item stores an ItemPointerData.&nbsp; These defines let one<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the logical revmap page number and index number of the revmap item for<br/></li>
<li></span><span class="Comment"> * the given heap block number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L40">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLK_TO_REVMAP_BLK</span>(pagesPerRange, heapBlk) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((heapBlk / pagesPerRange) / REVMAP_PAGE_MAXITEMS)<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">HEAPBLK_TO_REVMAP_INDEX</span>(pagesPerRange, heapBlk) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((heapBlk / pagesPerRange) % REVMAP_PAGE_MAXITEMS)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><a id="L46">&#x200c;</a><span class="Type">struct</span> <span class="linkable">BrinRevmap</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rm_irel;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rm_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rm_lastRevmapPage;&nbsp; &nbsp; <span class="Comment">/* cached from the metapage */<br/></li>
<li></span>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rm_metaBuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rm_currBuf;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* typedef appears in brin_revmap.h */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L442" title="access/brin/brin_revmap.c:442">revmap_get_blkno</a>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber heapBlk);<br/></li>
<li><span class="Type">static</span> Buffer <a href="#L463" title="access/brin/brin_revmap.c:463">revmap_get_buffer</a>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk);<br/></li>
<li><span class="Type">static</span> BlockNumber <a href="#L500" title="access/brin/brin_revmap.c:500">revmap_extend_and_get_blkno</a>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber heapBlk);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L522" title="access/brin/brin_revmap.c:522">revmap_physical_extend</a>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize an access object for a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> map.&nbsp; This must be freed by<br/></li>
<li></span><span class="Comment"> * <a href="#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a> when caller is done with it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *<br/></li>
<li><a id="L70">&#x200c;</a><span class="linkable">brinRevmapInitialize</span>(Relation idxrel, BlockNumber *pagesPerRange)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; meta;<br/></li>
<li>&nbsp; &nbsp; BrinMetaPageData *metadata;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; meta = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(idxrel, BRIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(meta, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(meta);<br/></li>
<li>&nbsp; &nbsp; metadata = (BrinMetaPageData *) PageGetContents(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; revmap = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a>));<br/></li>
<li>&nbsp; &nbsp; revmap-&gt;rm_irel = idxrel;<br/></li>
<li>&nbsp; &nbsp; revmap-&gt;rm_pagesPerRange = metadata-&gt;pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; revmap-&gt;rm_lastRevmapPage = metadata-&gt;lastRevmapPage;<br/></li>
<li>&nbsp; &nbsp; revmap-&gt;rm_metaBuf = meta;<br/></li>
<li>&nbsp; &nbsp; revmap-&gt;rm_currBuf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *pagesPerRange = metadata-&gt;pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(meta, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> revmap;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release resources associated with a revmap access object.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L100">&#x200c;</a></span><span class="linkable">brinRevmapTerminate</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(revmap-&gt;rm_metaBuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (revmap-&gt;rm_currBuf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(revmap-&gt;rm_currBuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(revmap);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Extend the revmap to cover the given heap block number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="linkable">brinRevmapExtend</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlk <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; mapBlk = <a href="#L500" title="access/brin/brin_revmap.c:500">revmap_extend_and_get_blkno</a>(revmap, heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure the buffer we got is in the expected <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mapBlk != InvalidBlockNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapBlk != BRIN_METAPAGE_BLKNO &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapBlk &lt;= revmap-&gt;rm_lastRevmapPage);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to insert an entry into the revmap; the revmap buffer in which the<br/></li>
<li></span><span class="Comment"> * entry is to reside is locked and returned.&nbsp; Most callers should call<br/></li>
<li></span><span class="Comment"> * <a href="#L112" title="access/brin/brin_revmap.c:112">brinRevmapExtend</a> beforehand, as this routine does not extend the revmap if<br/></li>
<li></span><span class="Comment"> * it's not long enough.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned buffer is also recorded in the revmap struct; finishing that<br/></li>
<li></span><span class="Comment"> * releases the buffer, therefore the caller needn't do it explicitly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L134">&#x200c;</a><span class="linkable">brinLockRevmapPageForUpdate</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rmBuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rmBuf = <a href="#L463" title="access/brin/brin_revmap.c:463">revmap_get_buffer</a>(revmap, heapBlk);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(rmBuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rmBuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In the given revmap buffer (locked appropriately by caller), which is used<br/></li>
<li></span><span class="Comment"> * in a BRIN index of pagesPerRange pages per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, set the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * corresponding to heap block number heapBlk to the given TID.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Once the operation is complete, the caller must update the LSN on the<br/></li>
<li></span><span class="Comment"> * returned buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used both in regular operation and during WAL replay.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L155">&#x200c;</a></span><span class="linkable">brinSetHeapBlockItemptr</span>(Buffer buf, BlockNumber pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber heapBlk, ItemPointerData tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RevmapContents *contents;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData *iptr;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The correct page should already be pinned and locked */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; contents = (RevmapContents *) PageGetContents(page);<br/></li>
<li>&nbsp; &nbsp; iptr = (ItemPointerData *) contents-&gt;rm_tids;<br/></li>
<li>&nbsp; &nbsp; iptr += <a href="#L42" title="access/brin/brin_revmap.c:42">HEAPBLK_TO_REVMAP_INDEX</a>(pagesPerRange, heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsValid(&amp;tid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSet(iptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(&amp;tid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(&amp;tid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerSetInvalid(iptr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch the BrinTuple for a given heap block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The buffer containing the tuple is locked, and returned in *buf.&nbsp; The<br/></li>
<li></span><span class="Comment"> * returned tuple points to the shared buffer and must not be freed; if caller<br/></li>
<li></span><span class="Comment"> * wants to use it after releasing the buffer lock, it must create its own<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'ed copy.&nbsp; As an optimization, the caller can pass a pinned buffer<br/></li>
<li></span><span class="Comment"> * *buf on entry, which will avoid a pin-unpin cycle when the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple is on<br/></li>
<li></span><span class="Comment"> * the same page as a previous one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no tuple is found for the given heap <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, returns NULL. In that case,<br/></li>
<li></span><span class="Comment"> * *buf might still be updated (and pin must be released by caller), but it's<br/></li>
<li></span><span class="Comment"> * not locked.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The output tuple offset within the buffer is returned in *off, and its size<br/></li>
<li></span><span class="Comment"> * is returned in *size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BrinTuple *<br/></li>
<li><a id="L194">&#x200c;</a><span class="linkable">brinGetTupleForHeapBlock</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer *buf, OffsetNumber *off, Size *size, <span class="Type">int</span> mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel = revmap-&gt;rm_irel;<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlk;<br/></li>
<li>&nbsp; &nbsp; RevmapContents *contents;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData *iptr;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blk;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *tup;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData previptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* normalize the heap block number to be the first page in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; heapBlk = (heapBlk / revmap-&gt;rm_pagesPerRange) * revmap-&gt;rm_pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the revmap page number we need.&nbsp; If Invalid is returned (i.e.,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the revmap page hasn't been created yet), the requested page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not summarized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mapBlk = <a href="#L442" title="access/brin/brin_revmap.c:442">revmap_get_blkno</a>(revmap, heapBlk);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mapBlk == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *off = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;previptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (revmap-&gt;rm_currBuf == InvalidBuffer ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(revmap-&gt;rm_currBuf) != mapBlk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (revmap-&gt;rm_currBuf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(revmap-&gt;rm_currBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(mapBlk != InvalidBlockNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; revmap-&gt;rm_currBuf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(revmap-&gt;rm_irel, mapBlk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_currBuf, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; contents = (RevmapContents *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetContents(BufferGetPage(revmap-&gt;rm_currBuf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iptr = contents-&gt;rm_tids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iptr += <a href="#L42" title="access/brin/brin_revmap.c:42">HEAPBLK_TO_REVMAP_INDEX</a>(revmap-&gt;rm_pagesPerRange, heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemPointerIsValid(iptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_currBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the TID we got in a previous iteration, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and save the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current TID we got from the revmap; if we loop, we can sanity-check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one we get is different.&nbsp; Otherwise we might be stuck<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * looping forever if the revmap is somehow badly broken.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemPointerIsValid(&amp;previptr) &amp;&amp; <a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;previptr, iptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;corrupted BRIN index: inconsistent <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> map&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; previptr = *iptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blk = ItemPointerGetBlockNumber(iptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *off = ItemPointerGetOffsetNumber(iptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_currBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ok, got a pointer to where the BrinTuple should be. Fetch it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(*buf) || <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(*buf) != blk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(*buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(*buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(idxRel, blk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buf, mode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(*buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we land on a revmap page, start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BRIN_IS_REGULAR_PAGE(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the offset number is greater than what's in the page, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> was desummarized concurrently. Just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return NULL to handle that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*off &gt; PageGetMaxOffsetNumber(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, *off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsUsed(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup = (BrinTuple *) PageGetItem(page, lp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tup-&gt;bt_blkno == heapBlk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *size = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found it! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No luck. Assume that the revmap was updated concurrently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(*buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not reached, but keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> an index tuple, marking a page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as unsummarized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Index must be locked in ShareUpdateExclusiveLock mode.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return false if caller should retry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">brinRevmapDesummarizeRange</span>(Relation idxrel, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap;<br/></li>
<li>&nbsp; &nbsp; BlockNumber pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; RevmapContents *contents;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData *iptr;<br/></li>
<li>&nbsp; &nbsp; ItemPointerData invalidIptr;<br/></li>
<li>&nbsp; &nbsp; BlockNumber revmapBlk;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; revmapBuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; regBuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; revmapPg;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; regPg;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber revmapOffset;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber regOffset;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; revmap = <a href="#L70" title="access/brin/brin_revmap.c:70">brinRevmapInitialize</a>(idxrel, &amp;pagesPerRange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; revmapBlk = <a href="#L442" title="access/brin/brin_revmap.c:442">revmap_get_blkno</a>(revmap, heapBlk);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(revmapBlk))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* revmap page doesn't exist: <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> not summarized, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(revmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Lock the revmap page, obtain the index tuple pointer from it */<br/></li>
<li></span>&nbsp; &nbsp; revmapBuf = <a href="#L134" title="access/brin/brin_revmap.c:134">brinLockRevmapPageForUpdate</a>(revmap, heapBlk);<br/></li>
<li>&nbsp; &nbsp; revmapPg = BufferGetPage(revmapBuf);<br/></li>
<li>&nbsp; &nbsp; revmapOffset = <a href="#L42" title="access/brin/brin_revmap.c:42">HEAPBLK_TO_REVMAP_INDEX</a>(revmap-&gt;rm_pagesPerRange, heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; contents = (RevmapContents *) PageGetContents(revmapPg);<br/></li>
<li>&nbsp; &nbsp; iptr = contents-&gt;rm_tids;<br/></li>
<li>&nbsp; &nbsp; iptr += revmapOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ItemPointerIsValid(iptr))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no index tuple: <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> not summarized, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmapBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(revmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regBuf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(idxrel, ItemPointerGetBlockNumber(iptr));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(regBuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; regPg = BufferGetPage(regBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if this is no longer a regular page, tell caller to start over */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BRIN_IS_REGULAR_PAGE(regPg))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmapBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(regBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(revmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; regOffset = ItemPointerGetOffsetNumber(iptr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (regOffset &gt; PageGetMaxOffsetNumber(regPg))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted BRIN index: inconsistent <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> map&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lp = PageGetItemId(regPg, regOffset);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ItemIdIsUsed(lp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;corrupted BRIN index: inconsistent <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> map&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Placeholder tuples only appear during unfinished summarization, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hold ShareUpdateExclusiveLock, so this function cannot run concurrently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with that.&nbsp; So <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> placeholder tuples that exist are leftovers from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crashed or aborted summarization; remove them silently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ItemPointerSetInvalid(&amp;invalidIptr);<br/></li>
<li>&nbsp; &nbsp; <a href="#L155" title="access/brin/brin_revmap.c:155">brinSetHeapBlockItemptr</a>(revmapBuf, revmap-&gt;rm_pagesPerRange, heapBlk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invalidIptr);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1295" title="storage/page/bufpage.c:1295">PageIndexTupleDeleteNoCompact</a>(regPg, regOffset);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> record free space in FSM? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(regBuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(revmapBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(idxrel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_brin_desummarize xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.pagesPerRange = revmap-&gt;rm_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.heapBlk = heapBlk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.regOffset = regOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfBrinDesummarize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, revmapBuf, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, regBuf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BRIN_ID, XLOG_BRIN_DESUMMARIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(revmapPg, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(regPg, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(regBuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmapBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(revmap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a heap block number, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the corresponding physical revmap block<br/></li>
<li></span><span class="Comment"> * number and return it.&nbsp; If the revmap page hasn't been allocated yet, return<br/></li>
<li></span><span class="Comment"> * InvalidBlockNumber.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L442">&#x200c;</a><span class="linkable">revmap_get_blkno</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber targetblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* obtain revmap block number, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> 1 for metapage block */<br/></li>
<li></span>&nbsp; &nbsp; targetblk = <a href="#L40" title="access/brin/brin_revmap.c:40">HEAPBLK_TO_REVMAP_BLK</a>(revmap-&gt;rm_pagesPerRange, heapBlk) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Normal case: the revmap page is already allocated */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (targetblk &lt;= revmap-&gt;rm_lastRevmapPage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> targetblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidBlockNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain and return a buffer containing the revmap page for the given heap<br/></li>
<li></span><span class="Comment"> * page.&nbsp; The revmap must have been previously extended to cover that page.<br/></li>
<li></span><span class="Comment"> * The returned buffer is also recorded in the revmap struct; finishing that<br/></li>
<li></span><span class="Comment"> * releases the buffer, therefore the caller needn't do it explicitly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L463">&#x200c;</a><span class="linkable">revmap_get_buffer</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Translate the heap block number to physical index location. */<br/></li>
<li></span>&nbsp; &nbsp; mapBlk = <a href="#L442" title="access/brin/brin_revmap.c:442">revmap_get_blkno</a>(revmap, heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mapBlk == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;revmap does not cover heap block </span><span class="Special">%u</span><span class="Constant">&quot;</span>, heapBlk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ensure the buffer we got is in the expected <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(mapBlk != BRIN_METAPAGE_BLKNO &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; mapBlk &lt;= revmap-&gt;rm_lastRevmapPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain the buffer from which we need to read.&nbsp; If we already have the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct buffer in our access struct, use that; otherwise, release that,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (if valid) and read the one we need.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (revmap-&gt;rm_currBuf == InvalidBuffer ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapBlk != <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(revmap-&gt;rm_currBuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (revmap-&gt;rm_currBuf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(revmap-&gt;rm_currBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; revmap-&gt;rm_currBuf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(revmap-&gt;rm_irel, mapBlk);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> revmap-&gt;rm_currBuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a heap block number, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the corresponding physical revmap block<br/></li>
<li></span><span class="Comment"> * number and return it. If the revmap page hasn't been allocated yet, extend<br/></li>
<li></span><span class="Comment"> * the revmap until it is.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BlockNumber<br/></li>
<li><a id="L500">&#x200c;</a><span class="linkable">revmap_extend_and_get_blkno</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap, BlockNumber heapBlk)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber targetblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* obtain revmap block number, <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> 1 for metapage block */<br/></li>
<li></span>&nbsp; &nbsp; targetblk = <a href="#L40" title="access/brin/brin_revmap.c:40">HEAPBLK_TO_REVMAP_BLK</a>(revmap-&gt;rm_pagesPerRange, heapBlk) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extend the revmap, if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (targetblk &gt; revmap-&gt;rm_lastRevmapPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L522" title="access/brin/brin_revmap.c:522">revmap_physical_extend</a>(revmap);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> targetblk;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to extend the revmap by one page.&nbsp; This might not happen for a number of<br/></li>
<li></span><span class="Comment"> * reasons; caller is expected to retry until the expected outcome is obtained.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L522">&#x200c;</a></span><span class="linkable">revmap_physical_extend</span>(<a href="#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; BrinMetaPageData *metadata;<br/></li>
<li>&nbsp; &nbsp; BlockNumber mapBlk;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; irel = revmap-&gt;rm_irel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lock the metapage. This locks out concurrent extensions of the revmap,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but note that we still need to grab the relation extension lock because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another backend can extend the index with regular BRIN pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_metaBuf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(revmap-&gt;rm_metaBuf);<br/></li>
<li>&nbsp; &nbsp; metadata = (BrinMetaPageData *) PageGetContents(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that our cached lastRevmapPage value was up-to-date; if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wasn't, update the cached copy and have caller start over.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metadata-&gt;lastRevmapPage != revmap-&gt;rm_lastRevmapPage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; revmap-&gt;rm_lastRevmapPage = metadata-&gt;lastRevmapPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_metaBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; mapBlk = metadata-&gt;lastRevmapPage + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nblocks = RelationGetNumberOfBlocks(irel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mapBlk &lt; nblocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(irel, mapBlk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(irel), MAIN_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_LOCK_FIRST);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf) != mapBlk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Very rare corner case: somebody extended the relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrently after we read its length.&nbsp; If this happens, give<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up and have caller start over.&nbsp; We will have to evacuate that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page from under whoever is using it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_metaBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that it's a regular block (or an empty page) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(page) &amp;&amp; !BRIN_IS_REGULAR_PAGE(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected page type 0x</span><span class="Special">%04X</span><span class="Constant"> in BRIN index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinPageType(page),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(irel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the page is in use, evacuate it and restart */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="brin_pageops.c.html#L524" title="access/brin/brin_pageops.c:524">brin_start_evacuating_page</a>(irel, buf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_metaBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_pageops.c.html#L564" title="access/brin/brin_pageops.c:564">brin_evacuate_page</a>(irel, revmap-&gt;rm_pagesPerRange, revmap, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have caller start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ok, we have <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> locked the metapage and the target block. Re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the target block as a revmap page, and update the metapage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the rm_tids array is initialized to all invalid by <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="brin_pageops.c.html#L475" title="access/brin/brin_pageops.c:475">brin_page_init</a>(page, BRIN_PAGETYPE_REVMAP);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metadata-&gt;lastRevmapPage = mapBlk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.&nbsp; (We must do this here because pre-v11 versions of PG did not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set the metapage's pd_lower correctly, so a pg_upgraded index might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain the wrong value.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) metapage)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metadata + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BrinMetaPageData)) - (<span class="Type">char</span> *) metapage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(revmap-&gt;rm_metaBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(revmap-&gt;rm_irel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_brin_revmap_extend xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.targetBlk = mapBlk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfBrinRevmapExtend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, revmap-&gt;rm_metaBuf, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, buf, REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BRIN_ID, XLOG_BRIN_REVMAP_EXTEND);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapage, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(revmap-&gt;rm_metaBuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
