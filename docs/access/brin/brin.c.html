<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/brin/brin.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/brin/brin.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L152">BrinBuildState</a></li>
<li><a href="#L183">BrinBuildState</a></li>
<li><a href="#L189">BrinInsertState</a></li>
<li><a href="#L194">BrinInsertState</a></li>
<li><a href="#L119">BrinLeader</a></li>
<li><a href="#L146">BrinLeader</a></li>
<li><a href="#L199">BrinOpaque</a></li>
<li><a href="#L204">BrinOpaque</a></li>
<li><a href="#L57">BrinShared</a></li>
<li><a href="#L105">BrinShared</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L2352">_brin_begin_parallel</a></li>
<li><a href="#L2536">_brin_end_parallel</a></li>
<li><a href="#L2766">_brin_leader_participate_as_worker</a></li>
<li><a href="#L2851">_brin_parallel_build_main</a></li>
<li><a href="#L2755">_brin_parallel_estimate_shared</a></li>
<li><a href="#L2567">_brin_parallel_heapscan</a></li>
<li><a href="#L2608">_brin_parallel_merge</a></li>
<li><a href="#L2794">_brin_parallel_scan_and_build</a></li>
<li><a href="#L2194">add_values_to_range</a></li>
<li><a href="#L1637">brinGetStats</a></li>
<li><a href="#L1570">brin_build_desc</a></li>
<li><a href="#L2941">brin_build_empty_tuple</a></li>
<li><a href="#L1480">brin_desummarize_range</a></li>
<li><a href="#L2978">brin_fill_empty_ranges</a></li>
<li><a href="#L1625">brin_free_desc</a></li>
<li><a href="#L1354">brin_summarize_new_values</a></li>
<li><a href="#L1369">brin_summarize_range</a></li>
<li><a href="#L2161">brin_vacuum_scan</a></li>
<li><a href="#L528">brinbeginscan</a></li>
<li><a href="#L1093">brinbuild</a></li>
<li><a href="#L983">brinbuildCallback</a></li>
<li><a href="#L1034">brinbuildCallbackParallel</a></li>
<li><a href="#L1262">brinbuildempty</a></li>
<li><a href="#L1291">brinbulkdelete</a></li>
<li><a href="#L966">brinendscan</a></li>
<li><a href="#L556">bringetbitmap</a></li>
<li><a href="#L247">brinhandler</a></li>
<li><a href="#L335">brininsert</a></li>
<li><a href="#L503">brininsertcleanup</a></li>
<li><a href="#L1336">brinoptions</a></li>
<li><a href="#L946">brinrescan</a></li>
<li><a href="#L1876">brinsummarize</a></li>
<li><a href="#L1306">brinvacuumcleanup</a></li>
<li><a href="#L2288">check_null_keys</a></li>
<li><a href="#L1974">form_and_insert_tuple</a></li>
<li><a href="#L1995">form_and_spill_tuple</a></li>
<li><a href="#L1658">initialize_brin_buildstate</a></li>
<li><a href="#L306">initialize_brin_insertstate</a></li>
<li><a href="#L1750">summarize_range</a></li>
<li><a href="#L1705">terminate_brin_buildstate</a></li>
<li><a href="#L2020">union_tuples</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L206">BRIN_ALL_BLOCKRANGES</a></li>
<li><a href="#L47">PARALLEL_KEY_BRIN_SHARED</a></li>
<li><a href="#L51">PARALLEL_KEY_BUFFER_USAGE</a></li>
<li><a href="#L49">PARALLEL_KEY_QUERY_TEXT</a></li>
<li><a href="#L48">PARALLEL_KEY_TUPLESORT</a></li>
<li><a href="#L50">PARALLEL_KEY_WAL_USAGE</a></li>
<li><a href="#L113">ParallelTableScanFromBrinShared</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * brin.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Implementation of BRIN indexes for Postgres<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See src/backend/access/brin/README for details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/brin/brin.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">TODO<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; * ScalarArrayOpExpr (amsearcharray -&gt; SK_SEARCHARRAY)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/brin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_page.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_pageops.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/brin_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/freespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pgrminclude ignore */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Magic numbers for parallel state sharing */<br/></li>
<li><a id="L47">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_BRIN_SHARED</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xB000000000000001</span><span class="PreProc">)<br/></li>
<li><a id="L48">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_TUPLESORT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xB000000000000002</span><span class="PreProc">)<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_QUERY_TEXT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xB000000000000003</span><span class="PreProc">)<br/></li>
<li><a id="L50">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_WAL_USAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xB000000000000004</span><span class="PreProc">)<br/></li>
<li><a id="L51">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_BUFFER_USAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xB000000000000005</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status for index builds performed in parallel.&nbsp; This is allocated in a<br/></li>
<li></span><span class="Comment"> * dynamic shared memory segment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BrinShared</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These fields are not modified during the build.&nbsp; They primarily exist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the benefit of worker processes that need to create state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding to that used by the leader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaprelid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isconcurrent;<br/></li>
<li>&nbsp; &nbsp; BlockNumber pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scantuplesortstates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workersdonecv is used to monitor the progress of workers.&nbsp; All parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * participants must indicate that they are done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leader can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results built by the workers (and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leader can write the data into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable workersdonecv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mutex protects all fields <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> heapdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These fields contain status information of interest to BRIN index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * builds that must work just the same when an index is built in parallel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mutable state that is maintained by workers, and reported back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader at end of the scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nparticipantsdone is number of worker processes finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reltuples is the total number of input heap tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indtuples is the total number of tuples that made it into the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipantsdone;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ParallelTableScanDescData data follows. Can't directly embed here, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementations of the parallel table scan desc interface might need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stronger alignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L105">&#x200c;</a></span>} <span class="linkable">BrinShared</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return pointer to a <a href="#L57" title="access/brin/brin.c:57">BrinShared</a>'s parallel table scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * c.f. <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a> as to why BUFFERALIGN is used, rather than just<br/></li>
<li></span><span class="Comment"> * MAXALIGN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L113">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ParallelTableScanFromBrinShared</span>(shared) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (ParallelTableScanDesc) ((</span><span class="Type">char</span><span class="PreProc"> *) (shared) + BUFFERALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L57" title="access/brin/brin.c:57">BrinShared</a>)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status for leader in parallel index build.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L119">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BrinLeader</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* parallel context itself */<br/></li>
<li></span>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nparticipanttuplesorts is the exact number of worker processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully launched, plus one leader process if it participates as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker (only DISABLE_LEADER_PARTICIPATION builds avoid leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * participating as a worker).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipanttuplesorts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Leader process convenience pointers to shared state (leader avoids TOC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookups).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * brinshared is the shared state for entire build.&nbsp; sharedsort is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared, tuplesort-managed state passed to each process tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot is the snapshot used by the scan iff an MVCC snapshot is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *brinshared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufferusage;<br/></li>
<li><a id="L146">&#x200c;</a>} <span class="linkable">BrinLeader</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use a <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> during initial construction of a BRIN index.<br/></li>
<li></span><span class="Comment"> * The running state is kept in a BrinMemTuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L152">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BrinBuildState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; bs_irel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; bs_numtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; bs_reltuples;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; bs_currentInsertBuf;<br/></li>
<li>&nbsp; &nbsp; BlockNumber bs_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; BlockNumber bs_currRangeStart;<br/></li>
<li>&nbsp; &nbsp; BlockNumber bs_maxRangeStart;<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *bs_rmAccess;<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bs_bdesc;<br/></li>
<li>&nbsp; &nbsp; BrinMemTuple *bs_dtuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *bs_emptyTuple;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; bs_emptyTupleLen;<br/></li>
<li>&nbsp; &nbsp; MemoryContext bs_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bs_leader is only present when a parallel index build is performed, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only in the leader process. (Actually, only the leader process has a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L119" title="access/brin/brin.c:119">BrinLeader</a> *bs_leader;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bs_worker_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The sortstate is used by workers (including the leader). It has to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * part of the build state, because that's the only thing passed to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build callback etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *bs_sortstate;<br/></li>
<li><a id="L183">&#x200c;</a>} <span class="linkable">BrinBuildState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use a <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> to capture running state spanning multiple<br/></li>
<li></span><span class="Comment"> * <a href="#L335" title="access/brin/brin.c:335">brininsert</a> invocations, within the same command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BrinInsertState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *bis_rmAccess;<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bis_desc;<br/></li>
<li>&nbsp; &nbsp; BlockNumber bis_pages_per_range;<br/></li>
<li><a id="L194">&#x200c;</a>} <span class="linkable">BrinInsertState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Struct used as &quot;opaque&quot; during index scans<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L199">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BrinOpaque</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber bo_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *bo_rmAccess;<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bo_bdesc;<br/></li>
<li><a id="L204">&#x200c;</a>} <span class="linkable">BrinOpaque</span>;<br/></li>
<li><br/></li>
<li><a id="L206">&#x200c;</a><span class="PreProc">#define <span class="linkable">BRIN_ALL_BLOCKRANGES</span>&nbsp; &nbsp; InvalidBlockNumber<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *<a href="#L1658" title="access/brin/brin.c:1658">initialize_brin_buildstate</a>(Relation idxRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber tablePages);<br/></li>
<li><span class="Type">static</span> <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *<a href="#L306" title="access/brin/brin.c:306">initialize_brin_insertstate</a>(Relation idxRel, IndexInfo *indexInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1705" title="access/brin/brin.c:1705">terminate_brin_buildstate</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1876" title="access/brin/brin.c:1876">brinsummarize</a>(Relation index, Relation heapRel, BlockNumber pageRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> include_partial, <span class="Type">double</span> *numSummarized, <span class="Type">double</span> *numExisting);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1974" title="access/brin/brin.c:1974">form_and_insert_tuple</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1995" title="access/brin/brin.c:1995">form_and_spill_tuple</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2020" title="access/brin/brin.c:2020">union_tuples</a>(BrinDesc *bdesc, BrinMemTuple *a,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BrinTuple *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2161" title="access/brin/brin.c:2161">brin_vacuum_scan</a>(Relation idxrel, BufferAccessStrategy strategy);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2194" title="access/brin/brin.c:2194">add_values_to_range</a>(Relation idxRel, BrinDesc *bdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinMemTuple *dtup, <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2288" title="access/brin/brin.c:2288">check_null_keys</a>(BrinValues *bval, ScanKey *nullkeys, <span class="Type">int</span> nnullkeys);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2978" title="access/brin/brin.c:2978">brin_fill_empty_ranges</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber prevRange, BlockNumber nextRange);<br/></li>
<li><br/></li>
<li><span class="Comment">/* parallel index builds */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L2352" title="access/brin/brin.c:2352">_brin_begin_parallel</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate, Relation heap, Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isconcurrent, <span class="Type">int</span> request);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2536" title="access/brin/brin.c:2536">_brin_end_parallel</a>(<a href="#L119" title="access/brin/brin.c:119">BrinLeader</a> *brinleader, <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state);<br/></li>
<li><span class="Type">static</span> Size <a href="#L2755" title="access/brin/brin.c:2755">_brin_parallel_estimate_shared</a>(Relation heap, Snapshot snapshot);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2567" title="access/brin/brin.c:2567">_brin_parallel_heapscan</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L2608" title="access/brin/brin.c:2608">_brin_parallel_merge</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2766" title="access/brin/brin.c:2766">_brin_leader_participate_as_worker</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation heap, Relation index);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2794" title="access/brin/brin.c:2794">_brin_parallel_scan_and_build</a>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *brinshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation heap, Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sortmem, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> progress);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BRIN handler function: return IndexAmRoutine with access method parameters<br/></li>
<li></span><span class="Comment"> * and callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L247">&#x200c;</a><span class="linkable">brinhandler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstrategies = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsupport = BRIN_LAST_OPTIONAL_PROCNUM;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptsprocnum = BRIN_PROCNUM_OPTIONS;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorder = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorderbyop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbackward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanmulticol = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptionalkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearcharray = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearchnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstorage = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amclusterable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ampredlocks = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanparallel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbuildparallel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcaninclude = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amusemaintenanceworkmem = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsummarizing = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelvacuumoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VACUUM_OPTION_PARALLEL_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amkeytype = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuild = <a href="#L1093" title="access/brin/brin.c:1093">brinbuild</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildempty = <a href="#L1262" title="access/brin/brin.c:1262">brinbuildempty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsert = <a href="#L335" title="access/brin/brin.c:335">brininsert</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsertcleanup = <a href="#L503" title="access/brin/brin.c:503">brininsertcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambulkdelete = <a href="#L1291" title="access/brin/brin.c:1291">brinbulkdelete</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amvacuumcleanup = <a href="#L1306" title="access/brin/brin.c:1306">brinvacuumcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanreturn = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcostestimate = <a href="../../utils/adt/selfuncs.c.html#L7973" title="utils/adt/selfuncs.c:7973">brincostestimate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptions = <a href="#L1336" title="access/brin/brin.c:1336">brinoptions</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amproperty = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildphasename = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> = <a href="brin_validate.c.html#L37" title="access/brin/brin_validate.c:37">brinvalidate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amadjustmembers = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambeginscan = <a href="#L528" title="access/brin/brin.c:528">brinbeginscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrescan = <a href="#L946" title="access/brin/brin.c:946">brinrescan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgettuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgetbitmap = <a href="#L556" title="access/brin/brin.c:556">bringetbitmap</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amendscan = <a href="#L966" title="access/brin/brin.c:966">brinendscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ammarkpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrestrpos = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amestimateparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminitparallelscan = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelrescan = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(amroutine);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> to maintain state to be used across multiple<br/></li>
<li></span><span class="Comment"> * tuple inserts, within the same command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *<br/></li>
<li><a id="L306">&#x200c;</a><span class="linkable">initialize_brin_insertstate</span>(Relation idxRel, IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *bistate;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(indexInfo-&gt;ii_Context);<br/></li>
<li>&nbsp; &nbsp; bistate = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a>));<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;bis_desc = <a href="#L1570" title="access/brin/brin.c:1570">brin_build_desc</a>(idxRel);<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;bis_rmAccess = <a href="brin_revmap.c.html#L70" title="access/brin/brin_revmap.c:70">brinRevmapInitialize</a>(idxRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;bistate-&gt;bis_pages_per_range);<br/></li>
<li>&nbsp; &nbsp; indexInfo-&gt;ii_AmCache = bistate;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bistate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A tuple in the heap is being inserted.&nbsp; To keep a brin index up to date,<br/></li>
<li></span><span class="Comment"> * we need to obtain the relevant index tuple and <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> its stored <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * with those of the new tuple.&nbsp; If the tuple <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not consistent with<br/></li>
<li></span><span class="Comment"> * the summary tuple, we need to update the index tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If autosummarization is enabled, check if we need to summarize the previous<br/></li>
<li></span><span class="Comment"> * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is not currently summarized (i.e. the revmap returns NULL for<br/></li>
<li></span><span class="Comment"> * it), there's nothing to do for this tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L335">&#x200c;</a></span><span class="linkable">brininsert</span>(Relation idxRel, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer heaptid, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexUniqueCheck checkUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexUnchanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; BlockNumber origHeapBlk;<br/></li>
<li>&nbsp; &nbsp; BlockNumber heapBlk;<br/></li>
<li>&nbsp; &nbsp; <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *bistate = (<a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *) indexInfo-&gt;ii_AmCache;<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap;<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tupcxt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; autosummarize = BrinGetAutoSummarize(idxRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through in this statement, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the insert state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we keep for all the inserts in the command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bistate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bistate = <a href="#L306" title="access/brin/brin.c:306">initialize_brin_insertstate</a>(idxRel, indexInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; revmap = bistate-&gt;bis_rmAccess;<br/></li>
<li>&nbsp; &nbsp; bdesc = bistate-&gt;bis_desc;<br/></li>
<li>&nbsp; &nbsp; pagesPerRange = bistate-&gt;bis_pages_per_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * origHeapBlk is the block number where the insertion occurred.&nbsp; heapBlk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is the first block in the corresponding page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; origHeapBlk = ItemPointerGetBlockNumber(heaptid);<br/></li>
<li>&nbsp; &nbsp; heapBlk = (origHeapBlk / pagesPerRange) * pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_insert = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *brtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinMemTuple *dtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If auto-summarization is enabled and we just inserted the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple into the first block of a new non-first page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, request a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * summarization run of the previous <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (autosummarize &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapBlk &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapBlk == origHeapBlk &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(heaptid) == FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber lastPageRange = heapBlk - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *lastPageTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastPageTuple =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_revmap.c.html#L194" title="access/brin/brin_revmap.c:194">brinGetTupleForHeapBlock</a>(revmap, lastPageRange, &amp;buf, &amp;off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!lastPageTuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recorded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recorded = <a href="../../postmaster/autovacuum.c.html#L3201" title="postmaster/autovacuum.c:3201">AutoVacuumRequestWork</a>(AVW_BRINSummarizeRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(idxRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lastPageRange);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!recorded)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;request for BRIN <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> summarization for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> page </span><span class="Special">%u</span><span class="Constant"> was not recorded&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(idxRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastPageRange)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; brtup = <a href="brin_revmap.c.html#L194" title="access/brin/brin_revmap.c:194">brinGetTupleForHeapBlock</a>(revmap, heapBlk, &amp;buf, &amp;off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, BUFFER_LOCK_SHARE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is unsummarized, there's nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!brtup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through in this <a href="#L335" title="access/brin/brin.c:335">brininsert</a> call? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tupcxt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupcxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L335" title="access/brin/brin.c:335">brininsert</a> cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(tupcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dtup = <a href="brin_tuple.c.html#L553" title="access/brin/brin_tuple.c:553">brin_deform_tuple</a>(bdesc, brtup, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; need_insert = <a href="#L2194" title="access/brin/brin.c:2194">add_values_to_range</a>(idxRel, bdesc, dtup, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!need_insert)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple is consistent with the new <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so there's nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; lp = PageGetItemId(page, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; origsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *origtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; samepage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make a copy of the old tuple, so that we can <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-acquiring the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origsz = ItemIdGetLength(lp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origtup = <a href="brin_tuple.c.html#L446" title="access/brin/brin_tuple.c:446">brin_copy_tuple</a>(brtup, origsz, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before releasing the lock, check if we can attempt a same-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update.&nbsp; Another process could insert a tuple concurrently in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same page though, so downstream we must be prepared to cope<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if this turns out to not be possible after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(bdesc, heapBlk, dtup, &amp;newsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; samepage = <a href="brin_pageops.c.html#L323" title="access/brin/brin_pageops.c:323">brin_can_do_samepage_update</a>(buf, origsz, newsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to update the tuple.&nbsp; If this doesn't work for whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reason, we need to restart from the top; the revmap might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointing at a different tuple for this block <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recompute to ensure both our new heap tuple and the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inserter's are covered by the combined tuple.&nbsp; It might be that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't need to update at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="brin_pageops.c.html#L53" title="access/brin/brin_pageops.c:53">brin_doupdate</a>(idxRel, pagesPerRange, revmap, heapBlk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; buf, off, origtup, origsz, newtup, newsz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; samepage))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no luck; start over */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(tupcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* success! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupcxt != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tupcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback to clean up the <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> once all tuple inserts are done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L503">&#x200c;</a></span><span class="linkable">brininsertcleanup</span>(Relation index, IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *bistate = (<a href="#L189" title="access/brin/brin.c:189">BrinInsertState</a> *) indexInfo-&gt;ii_AmCache;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* bail out if cache not initialized */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_AmCache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean up the revmap. Note that the brinDesc has already been cleaned up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as part of its own memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="brin_revmap.c.html#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(bistate-&gt;bis_rmAccess);<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;bis_rmAccess = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; bistate-&gt;bis_desc = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize state for a BRIN index scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We read the metapage here to determine the pages-per-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> number that this<br/></li>
<li></span><span class="Comment"> * index was built with.&nbsp; Note that since this cannot be changed while we're<br/></li>
<li></span><span class="Comment"> * holding lock on index, it's not necessary to recompute it during <a href="#L946" title="access/brin/brin.c:946">brinrescan</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexScanDesc<br/></li>
<li><a id="L528">&#x200c;</a><span class="linkable">brinbeginscan</span>(Relation r, <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/brin/brin.c:199">BrinOpaque</a> *opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../index/genam.c.html#L78" title="access/index/genam.c:78">RelationGetIndexScan</a>(r, nkeys, norderbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = palloc_object(<a href="#L199" title="access/brin/brin.c:199">BrinOpaque</a>);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;bo_rmAccess = <a href="brin_revmap.c.html#L70" title="access/brin/brin_revmap.c:70">brinRevmapInitialize</a>(r, &amp;opaque-&gt;bo_pagesPerRange);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;bo_bdesc = <a href="#L1570" title="access/brin/brin.c:1570">brin_build_desc</a>(r);<br/></li>
<li>&nbsp; &nbsp; scan-&gt;opaque = opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute the index scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This works by reading index TIDs from the revmap, and obtaining the index<br/></li>
<li></span><span class="Comment"> * tuples pointed to by them; the summary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the index tuples are<br/></li>
<li></span><span class="Comment"> * compared to the scan keys.&nbsp; We return into the TID bitmap all the pages in<br/></li>
<li></span><span class="Comment"> * ranges corresponding to index tuples that match the scan keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a TID from the revmap is read as InvalidTID, we know that <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is<br/></li>
<li></span><span class="Comment"> * unsummarized.&nbsp; Pages in those ranges need to be returned regardless of scan<br/></li>
<li></span><span class="Comment"> * keys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L556">&#x200c;</a><span class="linkable">bringetbitmap</span>(IndexScanDesc scan, <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; idxRel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/brin/brin.c:199">BrinOpaque</a> *opaque;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber heapBlk;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *consistentFn;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext perRangeCxt;<br/></li>
<li>&nbsp; &nbsp; BrinMemTuple *dtup;<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *btup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; btupsz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp;&nbsp; **keys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; **nullkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nkeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nnullkeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *tmp <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = (<a href="#L199" title="access/brin/brin.c:199">BrinOpaque</a> *) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; bdesc = opaque-&gt;bo_bdesc;<br/></li>
<li>&nbsp; &nbsp; pgstat_count_index_scan(idxRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to know the size of the table so that we know how long to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * iterate on the revmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heapOid = <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(RelationGetRelid(idxRel), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; heapRel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapOid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; nblocks = RelationGetNumberOfBlocks(heapRel);<br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make room for the consistent support procedures of indexed columns.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't look them up here; we do that lazily the first time we see a scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key reference each of them.&nbsp; We rely on zeroing fn_oid to InvalidOid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; consistentFn = palloc0_array(FmgrInfo, bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make room for per-attribute lists of scan keys that we'll pass to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistent support procedure. We don't know which attributes have scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys, so we allocate space for all attributes. That may use more memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's probably cheaper than determining which attributes are used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We keep null and regular keys separate, so that we can pass just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular keys to the consistent function easily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To reduce the allocation overhead, we allocate one big chunk and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * carve it into smaller arrays ourselves. All the pieces have exactly the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same lifetime, so that's OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> The widest index can have 32 attributes, so the amount of wasted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory is negligible. We could invent a more <a href="../../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> approach (with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just space for used attributes) but that would make the matching more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complex so it's not a good trade-off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey *) * bdesc-&gt;bd_tupdesc-&gt;natts) +&nbsp; &nbsp; <span class="Comment">/* regular keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey) * scan-&gt;numberOfKeys) * bdesc-&gt;bd_tupdesc-&gt;natts +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * bdesc-&gt;bd_tupdesc-&gt;natts) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey *) * bdesc-&gt;bd_tupdesc-&gt;natts) +&nbsp; &nbsp; <span class="Comment">/* NULL keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey) * scan-&gt;numberOfKeys) * bdesc-&gt;bd_tupdesc-&gt;natts +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ptr = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len);<br/></li>
<li>&nbsp; &nbsp; tmp = ptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keys = (ScanKey **) ptr;<br/></li>
<li>&nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey *) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nullkeys = (ScanKey **) ptr;<br/></li>
<li>&nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey *) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nkeys = (<span class="Type">int</span> *) ptr;<br/></li>
<li>&nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nnullkeys = (<span class="Type">int</span> *) ptr;<br/></li>
<li>&nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; bdesc-&gt;bd_tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keys[i] = (ScanKey *) ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey) * scan-&gt;numberOfKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nullkeys[i] = (ScanKey *) ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr += MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKey) * scan-&gt;numberOfKeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tmp + len == ptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* zero the number of keys */<br/></li>
<li></span>&nbsp; &nbsp; memset(nkeys, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; memset(nnullkeys, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * bdesc-&gt;bd_tupdesc-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Preprocess the scan keys - split them into per-attribute arrays. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> keyno = <span class="Constant">0</span>; keyno &lt; scan-&gt;numberOfKeys; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = &amp;scan-&gt;keyData[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; keyattno = key-&gt;sk_attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The collation of the scan key must match the collation used in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index column (but only if the search is not IS NULL/ IS NOT NULL).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we shouldn't be using this index ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((key-&gt;sk_flags &amp; SK_ISNULL) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (key-&gt;sk_collation ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(bdesc-&gt;bd_tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyattno - <span class="Constant">1</span>)-&gt;attcollation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First time we see this index attribute, so init as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of an overkill - we don't know how many scan keys are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there for this attribute, so we simply allocate the largest number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible (as if all keys were for this attribute). This may waste a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of memory, but we only expect small number of scan keys in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * general, so this should be negligible, and repeated <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a> calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are not free either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (consistentFn[keyattno - <span class="Constant">1</span>].fn_oid == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *tmp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time we see this attribute, so no key/null keys. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nkeys[keyattno - <span class="Constant">1</span>] == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nnullkeys[keyattno - <span class="Constant">1</span>] == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(idxRel, keyattno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BRIN_PROCNUM_CONSISTENT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L580" title="utils/fmgr/fmgr.c:580">fmgr_info_copy</a>(&amp;consistentFn[keyattno - <span class="Constant">1</span>], tmp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add key to the proper per-attribute array. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullkeys[keyattno - <span class="Constant">1</span>][nnullkeys[keyattno - <span class="Constant">1</span>]] = key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnullkeys[keyattno - <span class="Constant">1</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keys[keyattno - <span class="Constant">1</span>][nkeys[keyattno - <span class="Constant">1</span>]] = key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeys[keyattno - <span class="Constant">1</span>]++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate an initial in-memory tuple, out of the per-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> memcxt */<br/></li>
<li></span>&nbsp; &nbsp; dtup = <a href="brin_tuple.c.html#L482" title="access/brin/brin_tuple.c:482">brin_new_memtuple</a>(bdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Setup and use a per-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> memory context, which is reset every time we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop below.&nbsp; This avoids having to free the tuples within the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perRangeCxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L556" title="access/brin/brin.c:556">bringetbitmap</a> cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(perRangeCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now scan the revmap.&nbsp; We start by querying for heap page 0,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incrementing by the number of pages per <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>; this gives us a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * view of the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (heapBlk = <span class="Constant">0</span>; heapBlk &lt; nblocks; heapBlk += opaque-&gt;bo_pagesPerRange)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; gottuple = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(perRangeCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="brin_revmap.c.html#L194" title="access/brin/brin_revmap.c:194">brinGetTupleForHeapBlock</a>(opaque-&gt;bo_rmAccess, heapBlk, &amp;buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;off, &amp;size, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gottuple = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btup = <a href="brin_tuple.c.html#L446" title="access/brin/brin_tuple.c:446">brin_copy_tuple</a>(tup, size, btup, &amp;btupsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For page ranges with no indexed tuple, we must return the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>; otherwise, <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> it to the scan keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!gottuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dtup = <a href="brin_tuple.c.html#L553" title="access/brin/brin_tuple.c:553">brin_deform_tuple</a>(bdesc, btup, dtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dtup-&gt;bt_placeholder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Placeholder tuples are always returned, regardless of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> stored in them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compare scan keys with summary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> stored for the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If scan keys are matched, the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> must be added to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the bitmap.&nbsp; We initially assume the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added; in particular this serves the case where there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (attno = <span class="Constant">1</span>; attno &lt;= bdesc-&gt;bd_tupdesc-&gt;natts; attno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinValues *bval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; add;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> attributes without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scan keys (both regular and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * IS [NOT] NULL)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nkeys[attno - <span class="Constant">1</span>] == <span class="Constant">0</span> &amp;&amp; nnullkeys[attno - <span class="Constant">1</span>] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bval = &amp;dtup-&gt;bt_columns[attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the BRIN tuple indicates that this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is empty,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it: there's nothing to match.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to examine the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dtup-&gt;bt_empty_range)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First check if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IS [NOT] NULL scan keys,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and if we're violating them. In that case we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminate early, without invoking the support function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As there may be more keys, we can only determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mismatch within this loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bdesc-&gt;bd_info[attno - <span class="Constant">1</span>]-&gt;oi_regular_nulls &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2288" title="access/brin/brin.c:2288">check_null_keys</a>(bval, nullkeys[attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nnullkeys[attno - <span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the IS [NOT] NULL keys failed, the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as a whole can't pass. So terminate the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So either there are no IS [NOT] NULL keys, or all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed. If there are no regular scan keys, we're done -<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> matches. If there are regular keys, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is marked as 'all nulls' it can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly pass (we're assuming the operators are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strict).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No regular scan keys - page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as a whole passes. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!nkeys[attno - <span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((nkeys[attno - <span class="Constant">1</span>] &gt; <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (nkeys[attno - <span class="Constant">1</span>] &lt;= scan-&gt;numberOfKeys));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it is all nulls, it cannot possibly be consistent. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bval-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Collation from the first key (has to be the same for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all keys for the same attribute).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = keys[attno - <span class="Constant">1</span>][<span class="Constant">0</span>]-&gt;sk_collation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether the scan key is consistent with the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; if so, have the pages in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the output bitmap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The opclass may or may not support processing of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * multiple scan keys. We can determine that based on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * number of arguments - <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> with extra parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (number of scan keys) do support this, otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to simply pass the scan keys one by one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (consistentFn[attno - <span class="Constant">1</span>].fn_nargs &gt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check all keys at once */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add = <a href="../../utils/fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(&amp;consistentFn[attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(bdesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(bval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(keys[attno - <span class="Constant">1</span>]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(nkeys[attno - <span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = DatumGetBool(add);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check keys one by one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When there are multiple scan keys, failure to meet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the criteria for a single one of them is enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * discard the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as a whole, so break out of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop as soon as a false return value is obtained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; nkeys[attno - <span class="Constant">1</span>]; keyno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; add = <a href="../../utils/fmgr/fmgr.c.html#L1171" title="utils/fmgr/fmgr.c:1171">FunctionCall3Coll</a>(&amp;consistentFn[attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keys[attno - <span class="Constant">1</span>][keyno]-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(bdesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(bval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(keys[attno - <span class="Constant">1</span>][keyno]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a> = DatumGetBool(add);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found a scan key eliminating the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to check additional ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add the pages in the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to the output bitmap, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../regex/regc_cvec.c.html#L90" title="regex/regc_cvec.c:90">addrange</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber pageno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (pageno = heapBlk;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageno &lt;= <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(nblocks, heapBlk + opaque-&gt;bo_pagesPerRange) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pageno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L443" title="nodes/tidbitmap.c:443">tbm_add_page</a>(tbm, pageno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalpages++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(perRangeCxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(perRangeCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buf != InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> We have an approximation of the number of *pages* that our scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returns, but we don't have a precise idea of the number of heap tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> totalpages * <span class="Constant">10</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state for a BRIN index scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L946">&#x200c;</a></span><span class="linkable">brinrescan</span>(IndexScanDesc scan, ScanKey scankey, <span class="Type">int</span> nscankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey orderbys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other index AMs preprocess the scan keys at this point, or sometime<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * early during the scan; this lets them <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> by removing redundant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys, or doing early returns when they are impossible to satisfy; see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../nbtree/nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a> for an example.&nbsp; Something like that could be added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here someday, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scankey &amp;&amp; scan-&gt;numberOfKeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(scan-&gt;keyData, scankey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Close down a BRIN index scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L966">&#x200c;</a></span><span class="linkable">brinendscan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L199" title="access/brin/brin.c:199">BrinOpaque</a> *opaque = (<a href="#L199" title="access/brin/brin.c:199">BrinOpaque</a> *) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(opaque-&gt;bo_rmAccess);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1625" title="access/brin/brin.c:1625">brin_free_desc</a>(opaque-&gt;bo_bdesc);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(opaque);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-heap-tuple callback for table_index_build_scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we don't worry about the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> at the end of the table here; it is<br/></li>
<li></span><span class="Comment"> * present in the build state struct after we're called the last time, but not<br/></li>
<li></span><span class="Comment"> * inserted into the index.&nbsp; Caller must ensure to do so, if appropriate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L983">&#x200c;</a></span><span class="linkable">brinbuildCallback</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *brstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state = (<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *) brstate;<br/></li>
<li>&nbsp; &nbsp; BlockNumber thisblock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; thisblock = ItemPointerGetBlockNumber(tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're in a block that belongs to a future <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, summarize what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've got and start afresh.&nbsp; Note the scan might have skipped many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages, if they were devoid of live tuples; make sure to insert index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples for those too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (thisblock &gt; state-&gt;bs_currRangeStart + state-&gt;bs_pagesPerRange - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BRIN_elog((DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L983" title="access/brin/brin.c:983">brinbuildCallback</a>: completed a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%u</span><span class="Constant">--</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_currRangeStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_currRangeStart + state-&gt;bs_pagesPerRange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create the index tuple and insert it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1974" title="access/brin/brin.c:1974">form_and_insert_tuple</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set state to correspond to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_currRangeStart += state-&gt;bs_pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state for it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_tuple.c.html#L511" title="access/brin/brin_tuple.c:511">brin_memtuple_initialize</a>(state-&gt;bs_dtuple, state-&gt;bs_bdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate the current tuple into the running state */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2194" title="access/brin/brin.c:2194">add_values_to_range</a>(index, state-&gt;bs_bdesc, state-&gt;bs_dtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-heap-tuple callback for table_index_build_scan with parallelism.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A version of the callback used by parallel index builds. The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> difference<br/></li>
<li></span><span class="Comment"> * is that instead of writing the BRIN tuples into the index, we write them<br/></li>
<li></span><span class="Comment"> * into a shared tuplesort, and leave the insertion up to the leader (which may<br/></li>
<li></span><span class="Comment"> * reorder them a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> etc.). The callback also does not generate empty ranges,<br/></li>
<li></span><span class="Comment"> * those will be added by the leader when merging results from workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1034">&#x200c;</a></span><span class="linkable">brinbuildCallbackParallel</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *brstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state = (<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *) brstate;<br/></li>
<li>&nbsp; &nbsp; BlockNumber thisblock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; thisblock = ItemPointerGetBlockNumber(tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're in a block that belongs to a different <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, summarize what<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we've got and start afresh.&nbsp; Note the scan might have skipped many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages, if they were devoid of live tuples; we do not create empty BRIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ranges here - the leader is responsible for filling them in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike serial builds, parallel index builds allow synchronized seqscans<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (because that's what parallel scans do). This means the block may wrap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * around to the beginning of the relation, so the condition needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for both future and past ranges.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((thisblock &lt; state-&gt;bs_currRangeStart) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (thisblock &gt; state-&gt;bs_currRangeStart + state-&gt;bs_pagesPerRange - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BRIN_elog((DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L1034" title="access/brin/brin.c:1034">brinbuildCallbackParallel</a>: completed a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%u</span><span class="Constant">--</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_currRangeStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_currRangeStart + state-&gt;bs_pagesPerRange));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* create the index tuple and write it into the tuplesort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1995" title="access/brin/brin.c:1995">form_and_spill_tuple</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set state to correspond to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (for this block).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This skips ranges that are either empty (and so we don't get <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples to summarize), or processed by other workers. We can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differentiate those cases here easily, so we leave it up to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leader to fill empty ranges where needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_currRangeStart<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = state-&gt;bs_pagesPerRange * (thisblock / state-&gt;bs_pagesPerRange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state for it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_tuple.c.html#L511" title="access/brin/brin_tuple.c:511">brin_memtuple_initialize</a>(state-&gt;bs_dtuple, state-&gt;bs_bdesc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate the current tuple into the running state */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L2194" title="access/brin/brin.c:2194">add_values_to_range</a>(index, state-&gt;bs_bdesc, state-&gt;bs_dtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1093" title="access/brin/brin.c:1093">brinbuild</a>() -- build a new BRIN index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBuildResult *<br/></li>
<li><a id="L1093">&#x200c;</a><span class="linkable">brinbuild</span>(Relation heap, Relation index, IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexBuildResult *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; idxtuples;<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap;<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; meta;<br/></li>
<li>&nbsp; &nbsp; BlockNumber pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect to be called exactly once for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationGetNumberOfBlocks(index) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already contains data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Critical section not required, because on error the creation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole relation will be rolled back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; meta = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(index), MAIN_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EB_LOCK_FIRST | EB_SKIP_EXTENSION_LOCK);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(meta) == BRIN_METAPAGE_BLKNO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="brin_pageops.c.html#L486" title="access/brin/brin_pageops.c:486">brin_metapage_init</a>(BufferGetPage(meta), BrinGetPagesPerRange(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BRIN_CURRENT_VERSION);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(meta);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(index))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_brin_createidx xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.version = BRIN_CURRENT_VERSION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.pagesPerRange = BrinGetPagesPerRange(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfBrinCreateIdx);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, meta, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BRIN_ID, XLOG_BRIN_CREATE_INDEX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(meta);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(meta);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize our state, including the deformed tuple state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; revmap = <a href="brin_revmap.c.html#L70" title="access/brin/brin_revmap.c:70">brinRevmapInitialize</a>(index, &amp;pagesPerRange);<br/></li>
<li>&nbsp; &nbsp; state = <a href="#L1658" title="access/brin/brin.c:1658">initialize_brin_buildstate</a>(index, revmap, pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetNumberOfBlocks(heap));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attempt to launch parallel worker scan when required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> <a href="../../optimizer/plan/planner.c.html#L6657" title="optimizer/plan/planner.c:6657">plan_create_index_workers</a> makes the number of workers dependent on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, requiring 32MB for each worker. That makes sense<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for btree, but not for BRIN, which can do with much less memory. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maybe make that somehow less strict, optionally?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_ParallelWorkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2352" title="access/brin/brin.c:2352">_brin_begin_parallel</a>(state, heap, index, indexInfo-&gt;ii_Concurrent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_ParallelWorkers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parallel build requested and at least one worker process was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully launched, set up coordination state, wait for workers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complete. Then read all tuples from the shared tuplesort and insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them into the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In serial mode, simply scan the table and build the index one index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple at a time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;bs_leader)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortCoordinate coordinate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate = (SortCoordinate) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortCoordinateData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate-&gt;isWorker = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate-&gt;nParticipants =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_leader-&gt;nparticipanttuplesorts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate-&gt;sharedsort = state-&gt;bs_leader-&gt;sharedsort;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Begin leader tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In cases where parallelism is involved, the leader receives the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same share of <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> as a serial sort (it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generally treated in the same way as a serial sort once we return).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Parallel worker Tuplesortstates will have received only a fraction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We rely on the lifetime of the Leader <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> almost not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overlapping with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a>'s lifetime.&nbsp; There may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be some small overlap, but that's okay because we rely on leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> only allocating a small, fixed amount of memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here. When its <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>() is called (by our caller),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and significant amounts of memory are likely to be used, all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workers must have already freed almost all memory held by their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuplesortstates (they are about to go away completely, too).&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overall effect is that <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> always represents an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * absolute high watermark on the amount of memory used by a CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INDEX operation, regardless of the use of parallelism or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * factor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_sortstate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L555" title="utils/sort/tuplesortvariants.c:555">tuplesort_begin_index_brin</a>(<a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TUPLESORT_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* scan the relation and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> per-worker results */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = <a href="#L2608" title="access/brin/brin.c:2608">_brin_parallel_merge</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2536" title="access/brin/brin.c:2536">_brin_end_parallel</a>(state-&gt;bs_leader, state);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no parallel index build */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now scan the relation.&nbsp; No syncscan allowed here because we want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the heap blocks in physical order (we want to produce the ranges<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting from block 0, and the callback also relies on this to not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate summary for the same <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> twice).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = table_index_build_scan(heap, index, indexInfo, <span class="Constant">false</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L983" title="access/brin/brin.c:983">brinbuildCallback</a>, (<span class="Type">void</span> *) state, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process the final batch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Note this does not update state-&gt;bs_currRangeStart, i.e. it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stays set to the last <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> added to the index. This is OK, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's what <a href="#L2978" title="access/brin/brin.c:2978">brin_fill_empty_ranges</a> expects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1974" title="access/brin/brin.c:1974">form_and_insert_tuple</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Backfill the final ranges with empty data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This saves us from doing what amounts to full table scans when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index with a predicate like WHERE (nonnull_column IS NULL), or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other very selective predicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2978" title="access/brin/brin.c:2978">brin_fill_empty_ranges</a>(state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_currRangeStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_maxRangeStart);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release resources */<br/></li>
<li></span>&nbsp; &nbsp; idxtuples = state-&gt;bs_numtuples;<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(state-&gt;bs_rmAccess);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1705" title="access/brin/brin.c:1705">terminate_brin_buildstate</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return statistics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = palloc_object(IndexBuildResult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;heap_tuples = reltuples;<br/></li>
<li>&nbsp; &nbsp; result-&gt;index_tuples = idxtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1262">&#x200c;</a></span><span class="linkable">brinbuildempty</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* An empty BRIN index has a metapage only. */<br/></li>
<li></span>&nbsp; &nbsp; metabuf = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(index), INIT_FORKNUM, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EB_LOCK_FIRST | EB_SKIP_EXTENSION_LOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize and xlog metabuffer. */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li>&nbsp; &nbsp; <a href="brin_pageops.c.html#L486" title="access/brin/brin_pageops.c:486">brin_metapage_init</a>(BufferGetPage(metabuf), BrinGetPagesPerRange(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BRIN_CURRENT_VERSION);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L1237" title="access/transam/xloginsert.c:1237">log_newpage_buffer</a>(metabuf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1291" title="access/brin/brin.c:1291">brinbulkdelete</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Since there are no per-heap-tuple index tuples in BRIN indexes,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; there's not a lot we can do here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> we could mark item tuples as &quot;dirty&quot; (when a minimum or maximum heap<br/></li>
<li></span><span class="Comment"> * tuple is deleted), meaning the need to re-run summarization on the affected<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.&nbsp; Would need to add an extra flag in brintuples for that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L1291">&#x200c;</a><span class="linkable">brinbulkdelete</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate stats if first time through, else re-use existing struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = palloc0_object(IndexBulkDeleteResult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This routine is in <a href="../../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> of &quot;vacuuming&quot; a BRIN index: we just summarize<br/></li>
<li></span><span class="Comment"> * ranges that are currently unsummarized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L1306">&#x200c;</a><span class="linkable">brinvacuumcleanup</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op in ANALYZE ONLY mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;analyze_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = palloc0_object(IndexBulkDeleteResult);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;num_pages = RelationGetNumberOfBlocks(info-&gt;index);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* rest of stats is initialized by zeroing */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; heapRel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(<a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(RelationGetRelid(info-&gt;index), <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2161" title="access/brin/brin.c:2161">brin_vacuum_scan</a>(info-&gt;index, info-&gt;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1876" title="access/brin/brin.c:1876">brinsummarize</a>(info-&gt;index, heapRel, <a href="#L206" title="access/brin/brin.c:206">BRIN_ALL_BLOCKRANGES</a>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;stats-&gt;num_index_tuples, &amp;stats-&gt;num_index_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * reloptions processor for BRIN indexes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>bytea *<br/></li>
<li><a id="L1336">&#x200c;</a><span class="linkable">brinoptions</span>(Datum reloptions, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> relopt_parse_elt tab[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;pages_per_range&quot;</span>, RELOPT_TYPE_INT, offsetof(BrinOptions, pagesPerRange)},<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;autosummarize&quot;</span>, RELOPT_TYPE_BOOL, offsetof(BrinOptions, autosummarize)}<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (bytea *) <a href="../common/reloptions.c.html#L1908" title="access/common/reloptions.c:1908">build_reloptions</a>(reloptions, validate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELOPT_KIND_BRIN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BrinOptions),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab, lengthof(tab));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL-callable function to scan through an index and summarize all ranges<br/></li>
<li></span><span class="Comment"> * that are not currently summarized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1354">&#x200c;</a><span class="linkable">brin_summarize_new_values</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; relation = PG_GETARG_DATUM(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> DirectFunctionCall2(<a href="#L1369" title="access/brin/brin.c:1369">brin_summarize_range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((int64) <a href="#L206" title="access/brin/brin.c:206">BRIN_ALL_BLOCKRANGES</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL-callable function to summarize the indicated page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, if not already<br/></li>
<li></span><span class="Comment"> * summarized.&nbsp; If the second argument is <a href="#L206" title="access/brin/brin.c:206">BRIN_ALL_BLOCKRANGES</a>, all<br/></li>
<li></span><span class="Comment"> * unsummarized ranges are summarized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1369">&#x200c;</a><span class="linkable">brin_summarize_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; heapBlk64 = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BlockNumber heapBlk;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapoid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; numSummarized = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery is in progress&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;BRIN control <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> cannot be executed during recovery.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (heapBlk64 &gt; <a href="#L206" title="access/brin/brin.c:206">BRIN_ALL_BLOCKRANGES</a> || heapBlk64 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;block number out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) heapBlk64)));<br/></li>
<li>&nbsp; &nbsp; heapBlk = (BlockNumber) heapBlk64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must lock table <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> index to avoid deadlocks.&nbsp; However, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed indexoid isn't an index then <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>() will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rather than emitting a not-very-helpful error message, postpone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complaining, expecting that the is-it-an-index test below will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heapoid = <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(indexoid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(heapoid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapRel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapoid, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Autovacuum calls us.&nbsp; For its benefit, switch to the table owner's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * userid, so that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run as that user.&nbsp; Also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock down security-restricted operations and arrange to make GUC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * variable changes local to this command.&nbsp; This is harmless, albeit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unnecessary, when called from SQL, because we fail shortly if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user does not own the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(heapRel-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel = <a href="../../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapRel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set these just to suppress &quot;uninitialized variable&quot; warnings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; save_userid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_sec_context = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRel = <a href="../index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be a BRIN index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_rel-&gt;relkind != RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRel-&gt;rd_rel-&gt;relam != BRIN_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a BRIN index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User must own the index (comparable to privileges needed for VACUUM) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heapRel != <span class="Constant">NULL</span> &amp;&amp; !<a href="../../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, indexoid, save_userid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we did the <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a> call above without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barely possible that a race against an index drop/recreation could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * netted us the wrong table.&nbsp; Recheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heapRel == <span class="Constant">NULL</span> || heapoid != <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(indexoid, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open parent table of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see <a href="../gin/ginfast.c.html#L1031" title="access/gin/ginfast.c:1031">gin_clean_pending_list</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_index-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1876" title="access/brin/brin.c:1876">brinsummarize</a>(indexRel, heapRel, heapBlk, <span class="Constant">true</span>, &amp;numSummarized, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not valid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes executed by index <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(indexRel, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(heapRel, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_INT32((int32) numSummarized);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL-callable interface to mark a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as no longer summarized<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L1480">&#x200c;</a><span class="linkable">brin_desummarize_range</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; heapBlk64 = PG_GETARG_INT64(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; BlockNumber heapBlk;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapoid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;recovery is in progress&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;BRIN control <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> cannot be executed during recovery.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (heapBlk64 &gt; MaxBlockNumber || heapBlk64 &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;block number out of <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>: </span><span class="Special">%lld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span> <span class="Type">long</span>) heapBlk64)));<br/></li>
<li>&nbsp; &nbsp; heapBlk = (BlockNumber) heapBlk64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must lock table <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> index to avoid deadlocks.&nbsp; However, if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed indexoid isn't an index then <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>() will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rather than emitting a not-very-helpful error message, postpone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complaining, expecting that the is-it-an-index test below will fail.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L1369" title="access/brin/brin.c:1369">brin_summarize_range</a>(), autovacuum never calls this.&nbsp; Hence, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't switch userid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heapoid = <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(indexoid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(heapoid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapRel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapoid, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; heapRel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRel = <a href="../index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexoid, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must be a BRIN index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_rel-&gt;relkind != RELKIND_INDEX ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRel-&gt;rd_rel-&gt;relam != BRIN_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a BRIN index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User must own the index (comparable to privileges needed for VACUUM) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../catalog/aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(RelationRelationId, indexoid, <a href="../../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we did the <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a> call above without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lock, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barely possible that a race against an index drop/recreation could have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * netted us the wrong table.&nbsp; Recheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (heapRel == <span class="Constant">NULL</span> || heapoid != <a href="../../catalog/index.c.html#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(indexoid, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open parent table of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* see <a href="../gin/ginfast.c.html#L1031" title="access/gin/ginfast.c:1031">gin_clean_pending_list</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRel-&gt;rd_index-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the revmap does the hard work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; done = <a href="brin_revmap.c.html#L323" title="access/brin/brin_revmap.c:323">brinRevmapDesummarizeRange</a>(indexRel, heapBlk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (!done);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not valid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(indexRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(indexRel, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(heapRel, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a BrinDesc used to create or scan a BRIN index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BrinDesc *<br/></li>
<li><a id="L1570">&#x200c;</a><span class="linkable">brin_build_desc</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinOpcInfo **opcinfo;<br/></li>
<li>&nbsp; &nbsp; BrinDesc&nbsp;&nbsp; *bdesc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; totalstored = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; totalsize;<br/></li>
<li>&nbsp; &nbsp; MemoryContext cxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;brin desc cxt&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(cxt);<br/></li>
<li>&nbsp; &nbsp; tupdesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain BrinOpcInfo for each indexed column.&nbsp; While at it, accumulate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the number of columns stored, since the number is opclass-defined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opcinfo = palloc_array(BrinOpcInfo *, tupdesc-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; tupdesc-&gt;natts; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *opcInfoFn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, keyno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcInfoFn = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(rel, keyno + <span class="Constant">1</span>, BRIN_PROCNUM_OPCINFO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opcinfo[keyno] = (BrinOpcInfo *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetPointer(FunctionCall1(opcInfoFn, attr-&gt;atttypid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; totalstored += opcinfo[keyno]-&gt;oi_nstored;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate our result struct and fill it in */<br/></li>
<li></span>&nbsp; &nbsp; totalsize = offsetof(BrinDesc, bd_info) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BrinOpcInfo *) * tupdesc-&gt;natts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bdesc = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(totalsize);<br/></li>
<li>&nbsp; &nbsp; bdesc-&gt;bd_context = cxt;<br/></li>
<li>&nbsp; &nbsp; bdesc-&gt;bd_index = rel;<br/></li>
<li>&nbsp; &nbsp; bdesc-&gt;bd_tupdesc = tupdesc;<br/></li>
<li>&nbsp; &nbsp; bdesc-&gt;bd_disktdesc = <span class="Constant">NULL</span>; <span class="Comment">/* generated lazily */<br/></li>
<li></span>&nbsp; &nbsp; bdesc-&gt;bd_totalstored = totalstored;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; tupdesc-&gt;natts; keyno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bdesc-&gt;bd_info[keyno] = opcinfo[keyno];<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(opcinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bdesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1625">&#x200c;</a></span><span class="linkable">brin_free_desc</span>(BrinDesc *bdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure the tupdesc is still valid */<br/></li>
<li></span>&nbsp; &nbsp; Assert(bdesc-&gt;bd_tupdesc-&gt;tdrefcount &gt;= <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no need for retail <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(bdesc-&gt;bd_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Fetch index's statistical data into *stats<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1637">&#x200c;</a></span><span class="linkable">brinGetStats</span>(Relation index, BrinStatsData *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapage;<br/></li>
<li>&nbsp; &nbsp; BrinMetaPageData *metadata;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuffer = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(index, BRIN_METAPAGE_BLKNO);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(metabuffer, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; metapage = BufferGetPage(metabuffer);<br/></li>
<li>&nbsp; &nbsp; metadata = (BrinMetaPageData *) PageGetContents(metapage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stats-&gt;pagesPerRange = metadata-&gt;pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;revmapNumPages = metadata-&gt;lastRevmapPage - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize a <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> appropriate to create tuples on the given index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *<br/></li>
<li><a id="L1658">&#x200c;</a><span class="linkable">initialize_brin_buildstate</span>(Relation idxRel, <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber pagesPerRange, BlockNumber tablePages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state;<br/></li>
<li>&nbsp; &nbsp; BlockNumber lastRange = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state = palloc_object(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_irel = idxRel;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_numtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_reltuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_currentInsertBuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_pagesPerRange = pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_currRangeStart = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_rmAccess = revmap;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_bdesc = <a href="#L1570" title="access/brin/brin.c:1570">brin_build_desc</a>(idxRel);<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_dtuple = <a href="brin_tuple.c.html#L482" title="access/brin/brin_tuple.c:482">brin_new_memtuple</a>(state-&gt;bs_bdesc);<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_leader = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_worker_id = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_sortstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_context = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_emptyTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_emptyTupleLen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember the memory context to use for an empty tuple, if needed. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;bs_context = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_emptyTuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_emptyTupleLen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calculate the start of the last page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. Page numbers are 0-based,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so to calculate the index we need to subtract one. The integer division<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gives us the index of the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tablePages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lastRange = ((tablePages - <span class="Constant">1</span>) / pagesPerRange) * pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now calculate the start of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;bs_maxRangeStart = lastRange + state-&gt;bs_pagesPerRange;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Release resources associated with a <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1705">&#x200c;</a></span><span class="linkable">terminate_brin_buildstate</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the last index buffer used.&nbsp; We might as well ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whatever free space remains in that page is available in FSM, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsInvalid(state-&gt;bs_currentInsertBuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; freespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(state-&gt;bs_currentInsertBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freespace = <a href="../../storage/page/bufpage.c.html#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a>(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blk = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(state-&gt;bs_currentInsertBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(state-&gt;bs_currentInsertBuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L194" title="storage/freespace/freespace.c:194">RecordPageWithFreeSpace</a>(state-&gt;bs_irel, blk, freespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(state-&gt;bs_irel, blk, blk + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1625" title="access/brin/brin.c:1625">brin_free_desc</a>(state-&gt;bs_bdesc);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;bs_dtuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On the given BRIN index, summarize the heap page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that corresponds<br/></li>
<li></span><span class="Comment"> * to the heap block number given.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine can run in parallel with insertions into the heap.&nbsp; To avoid<br/></li>
<li></span><span class="Comment"> * missing those <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the summary tuple, we first insert a placeholder<br/></li>
<li></span><span class="Comment"> * index tuple into the index, then execute the heap scan; transactions<br/></li>
<li></span><span class="Comment"> * concurrent with the scan update the placeholder tuple.&nbsp; After the scan, we<br/></li>
<li></span><span class="Comment"> * union the placeholder tuple with the one computed by this routine.&nbsp; The<br/></li>
<li></span><span class="Comment"> * update of the index value happens in a loop, so that if somebody updates<br/></li>
<li></span><span class="Comment"> * the placeholder tuple after we read it, we detect the case and try again.<br/></li>
<li></span><span class="Comment"> * This ensures that the concurrently inserted tuples are not lost.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A further corner case is this routine being asked to summarize the partial<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> at the end of the table.&nbsp; heapNumBlocks is the (possibly outdated)<br/></li>
<li></span><span class="Comment"> * table size; if we notice that the requested <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> lies beyond that size,<br/></li>
<li></span><span class="Comment"> * we re-compute the table size after inserting the placeholder tuple, to<br/></li>
<li></span><span class="Comment"> * avoid missing pages that were appended recently.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1750">&#x200c;</a></span><span class="linkable">summarize_range</span>(IndexInfo *indexInfo, <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber heapBlk, BlockNumber heapNumBlks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; phbuf;<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *phtup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; phsz;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offset;<br/></li>
<li>&nbsp; &nbsp; BlockNumber scanNumBlks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the placeholder tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; phbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; phtup = <a href="brin_tuple.c.html#L388" title="access/brin/brin_tuple.c:388">brin_form_placeholder_tuple</a>(state-&gt;bs_bdesc, heapBlk, &amp;phsz);<br/></li>
<li>&nbsp; &nbsp; offset = <a href="brin_pageops.c.html#L342" title="access/brin/brin_pageops.c:342">brin_doinsert</a>(state-&gt;bs_irel, state-&gt;bs_pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;bs_rmAccess, &amp;phbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heapBlk, phtup, phsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> end.&nbsp; We hold ShareUpdateExclusive lock on table, so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot shrink concurrently (but it can grow).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(heapBlk % state-&gt;bs_pagesPerRange == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (heapBlk + state-&gt;bs_pagesPerRange &gt; heapNumBlks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're asked to scan what we believe to be the final <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table (i.e. a <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that might be partial) we need to recompute our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idea of what the latest page is after inserting the placeholder<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.&nbsp; Anyone that grows the table later will update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * placeholder tuple, so it doesn't matter that we won't scan these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages ourselves.&nbsp; Careful: the table might have been extended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beyond the current <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so clamp our result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fortunately, this should occur infrequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scanNumBlks = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(RelationGetNumberOfBlocks(heapRel) - heapBlk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_pagesPerRange);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Easy case: <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is known to be complete */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scanNumBlks = state-&gt;bs_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Execute the partial heap scan covering the heap blocks in the specified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, summarizing the heap tuples in it.&nbsp; This scan stops just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short of <a href="#L983" title="access/brin/brin.c:983">brinbuildCallback</a> creating the new index entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that it is critical we use the &quot;<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> visible&quot; mode of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table_index_build_range_scan here: otherwise, we would <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserted by transactions that are still in progress, among other corner<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;bs_currRangeStart = heapBlk;<br/></li>
<li>&nbsp; &nbsp; table_index_build_range_scan(heapRel, state-&gt;bs_irel, indexInfo, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heapBlk, scanNumBlks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L983" title="access/brin/brin.c:983">brinbuildCallback</a>, (<span class="Type">void</span> *) state, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we update the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> obtained by the scan with the placeholder<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple.&nbsp; We do this in a loop which only terminates if we're able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the placeholder tuple successfully; if we are not, this means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somebody else modified the placeholder tuple after we read it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *newtup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; didupdate;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; samepage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update the summary tuple and try to update.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newtup = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(state-&gt;bs_bdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heapBlk, state-&gt;bs_dtuple, &amp;newsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; samepage = <a href="brin_pageops.c.html#L323" title="access/brin/brin_pageops.c:323">brin_can_do_samepage_update</a>(phbuf, phsz, newsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; didupdate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_pageops.c.html#L53" title="access/brin/brin_pageops.c:53">brin_doupdate</a>(state-&gt;bs_irel, state-&gt;bs_pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_rmAccess, heapBlk, phbuf, offset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; phtup, phsz, newtup, newsize, samepage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_tuple.c.html#L433" title="access/brin/brin_tuple.c:433">brin_free_tuple</a>(phtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_tuple.c.html#L433" title="access/brin/brin_tuple.c:433">brin_free_tuple</a>(newtup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the update succeeded, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (didupdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the update didn't work, it might be because somebody updated the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * placeholder tuple concurrently.&nbsp; Extract the new version, union it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> we have from the scan, and start over.&nbsp; (There are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other reasons for the update to fail, but it's simple to treat them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; phtup = <a href="brin_revmap.c.html#L194" title="access/brin/brin_revmap.c:194">brinGetTupleForHeapBlock</a>(state-&gt;bs_rmAccess, heapBlk, &amp;phbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;offset, &amp;phsz, BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the placeholder tuple must exist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (phtup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing placeholder tuple&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; phtup = <a href="brin_tuple.c.html#L446" title="access/brin/brin_tuple.c:446">brin_copy_tuple</a>(phtup, phsz, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(phbuf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> it into the tuple from the heap scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2020" title="access/brin/brin.c:2020">union_tuples</a>(state-&gt;bs_bdesc, state-&gt;bs_dtuple, phtup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(phbuf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Summarize page ranges that are not already summarized.&nbsp; If pageRange is<br/></li>
<li></span><span class="Comment"> * <a href="#L206" title="access/brin/brin.c:206">BRIN_ALL_BLOCKRANGES</a> then the whole table is scanned; otherwise, only the<br/></li>
<li></span><span class="Comment"> * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> containing the given heap page number is scanned.<br/></li>
<li></span><span class="Comment"> * If include_partial is true, then the partial <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> at the end of the table<br/></li>
<li></span><span class="Comment"> * is summarized, otherwise not.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each new index tuple inserted, *numSummarized (if not NULL) is<br/></li>
<li></span><span class="Comment"> * incremented; for each existing tuple, *numExisting (if not NULL) is<br/></li>
<li></span><span class="Comment"> * incremented.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1876">&#x200c;</a></span><span class="linkable">brinsummarize</span>(Relation index, Relation heapRel, BlockNumber pageRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> include_partial, <span class="Type">double</span> *numSummarized, <span class="Type">double</span> *numExisting)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="brin_revmap.c.html#L46" title="access/brin/brin_revmap.c:46">BrinRevmap</a> *revmap;<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; BlockNumber heapNumBlocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; BlockNumber startBlk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; revmap = <a href="brin_revmap.c.html#L70" title="access/brin/brin_revmap.c:70">brinRevmapInitialize</a>(index, &amp;pagesPerRange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* determine <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of pages to process */<br/></li>
<li></span>&nbsp; &nbsp; heapNumBlocks = RelationGetNumberOfBlocks(heapRel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pageRange == <a href="#L206" title="access/brin/brin.c:206">BRIN_ALL_BLOCKRANGES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startBlk = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; startBlk = (pageRange / pagesPerRange) * pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapNumBlocks = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(heapNumBlocks, startBlk + pagesPerRange);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (startBlk &gt; heapNumBlocks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Nothing to do if start point is beyond end of table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_revmap.c.html#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(revmap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the revmap to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> unsummarized items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; startBlk &lt; heapNumBlocks; startBlk += pagesPerRange)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unless requested to summarize even a partial <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, go away <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we think the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is partial.&nbsp; Caller would pass true when it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is typically run once bulk data loading is done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L1354" title="access/brin/brin.c:1354">brin_summarize_new_values</a>), and false when it is typically the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result of arbitrarily-scheduled maintenance command (vacuuming).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!include_partial &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (startBlk + pagesPerRange &gt; heapNumBlocks))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="brin_revmap.c.html#L194" title="access/brin/brin_revmap.c:194">brinGetTupleForHeapBlock</a>(revmap, startBlk, &amp;buf, &amp;off, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BUFFER_LOCK_SHARE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no revmap entry for this heap <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. Summarize it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first time through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexInfo);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L1658" title="access/brin/brin.c:1658">initialize_brin_buildstate</a>(index, revmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidBlockNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo = <a href="../../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(index);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1750" title="access/brin/brin.c:1750">summarize_range</a>(indexInfo, state, heapRel, startBlk, heapNumBlocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> state for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_tuple.c.html#L511" title="access/brin/brin_tuple.c:511">brin_memtuple_initialize</a>(state-&gt;bs_dtuple, state-&gt;bs_bdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numSummarized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *numSummarized += <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numExisting)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *numExisting += <span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free resources */<br/></li>
<li></span>&nbsp; &nbsp; <a href="brin_revmap.c.html#L100" title="access/brin/brin_revmap.c:100">brinRevmapTerminate</a>(revmap);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1705" title="access/brin/brin.c:1705">terminate_brin_buildstate</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(indexInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a deformed tuple in the build state, convert it into the on-disk<br/></li>
<li></span><span class="Comment"> * format and insert it into the index, making the revmap point to it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1974">&#x200c;</a></span><span class="linkable">form_and_insert_tuple</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *tup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(state-&gt;bs_bdesc, state-&gt;bs_currRangeStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_dtuple, &amp;size);<br/></li>
<li>&nbsp; &nbsp; <a href="brin_pageops.c.html#L342" title="access/brin/brin_pageops.c:342">brin_doinsert</a>(state-&gt;bs_irel, state-&gt;bs_pagesPerRange, state-&gt;bs_rmAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;bs_currentInsertBuf, state-&gt;bs_currRangeStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup, size);<br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_numtuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a deformed tuple in the build state, convert it into the on-disk<br/></li>
<li></span><span class="Comment"> * format and write it to a (shared) tuplesort (the leader will insert it<br/></li>
<li></span><span class="Comment"> * into the index later).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1995">&#x200c;</a></span><span class="linkable">form_and_spill_tuple</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *tup;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't insert empty tuples in parallel build */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;bs_dtuple-&gt;bt_empty_range)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(state-&gt;bs_bdesc, state-&gt;bs_currRangeStart,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_dtuple, &amp;size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write the BRIN tuple to the tuplesort */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L788" title="utils/sort/tuplesortvariants.c:788">tuplesort_putbrintuple</a>(state-&gt;bs_sortstate, tup, size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_numtuples++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given two deformed tuples, adjust the first one so that it's consistent<br/></li>
<li></span><span class="Comment"> * with the summary <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in both.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2020">&#x200c;</a></span><span class="linkable">union_tuples</span>(BrinDesc *bdesc, BrinMemTuple *a, BrinTuple *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li>&nbsp; &nbsp; BrinMemTuple *db;<br/></li>
<li>&nbsp; &nbsp; MemoryContext cxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use our own memory context to avoid retail <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> */<br/></li>
<li></span>&nbsp; &nbsp; cxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;brin union&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(cxt);<br/></li>
<li>&nbsp; &nbsp; db = <a href="brin_tuple.c.html#L553" title="access/brin/brin_tuple.c:553">brin_deform_tuple</a>(bdesc, b, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check if the ranges are empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If at least one of them is empty, we don't need to call per-key union<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> at all. If &quot;b&quot; is empty, we just use &quot;a&quot; as the result (it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be empty fine, but that's fine). If &quot;a&quot; is empty but &quot;b&quot; is not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we use &quot;b&quot; as the result (but we have to copy the data into &quot;a&quot; first).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only when both ranges are non-empty, we actually do the per-key <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If &quot;b&quot; is empty - ignore it and just use &quot;a&quot; (even if it's empty etc.). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (db-&gt;bt_empty_range)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the per-key <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we know &quot;b&quot; is not empty. If &quot;a&quot; is empty, then &quot;b&quot; is the result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But we need to copy the data from &quot;b&quot; to &quot;a&quot; first, because that's how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we pass result out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to copy all the global/per-key flags etc. too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a-&gt;bt_empty_range)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; bdesc-&gt;bd_tupdesc-&gt;natts; keyno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinValues *col_a = &amp;a-&gt;bt_columns[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinValues *col_b = &amp;db-&gt;bt_columns[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinOpcInfo *opcinfo = bdesc-&gt;bd_info[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_allnulls = col_b-&gt;bv_allnulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_hasnulls = col_b-&gt;bv_hasnulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If &quot;b&quot; has no data, we're done. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (col_b-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; opcinfo-&gt;oi_nstored; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(col_b-&gt;bv_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcinfo-&gt;oi_typcache[i]-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcinfo-&gt;oi_typcache[i]-&gt;typlen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;a&quot; started empty, but &quot;b&quot; was not empty, so remember that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; a-&gt;bt_empty_range = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the per-key <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we know neither <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is empty. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; bdesc-&gt;bd_tupdesc-&gt;natts; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *unionFn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinValues *col_a = &amp;a-&gt;bt_columns[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinValues *col_b = &amp;db-&gt;bt_columns[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinOpcInfo *opcinfo = bdesc-&gt;bd_info[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opcinfo-&gt;oi_regular_nulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Does the &quot;b&quot; summary represent <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; b_has_nulls = (col_b-&gt;bv_hasnulls || col_b-&gt;bv_allnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust &quot;hasnulls&quot;. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!col_a-&gt;bv_allnulls &amp;&amp; b_has_nulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_hasnulls = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there are no <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in B, there's nothing left to do. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (col_b-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust &quot;allnulls&quot;.&nbsp; If A doesn't have <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, just copy the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from B into A, and we're done.&nbsp; We cannot run the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators in this case, because <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in A might contain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * garbage.&nbsp; Note we already established that B contains <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also adjust &quot;hasnulls&quot; in order not to forget the summary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represents NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. This is not redundant with the earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update, because that only happens when allnulls=false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (col_a-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_allnulls = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_hasnulls = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; opcinfo-&gt;oi_nstored; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col_a-&gt;bv_values[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/datum.c.html#L132" title="utils/adt/datum.c:132">datumCopy</a>(col_b-&gt;bv_values[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcinfo-&gt;oi_typcache[i]-&gt;typbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcinfo-&gt;oi_typcache[i]-&gt;typlen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unionFn = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(bdesc-&gt;bd_index, keyno + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BRIN_PROCNUM_UNION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L1171" title="utils/fmgr/fmgr.c:1171">FunctionCall3Coll</a>(unionFn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bdesc-&gt;bd_index-&gt;rd_indcollation[keyno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(bdesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(col_a),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(col_b));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2161" title="access/brin/brin.c:2161">brin_vacuum_scan</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Do a complete scan of the index during VACUUM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine scans the complete index looking for uncataloged index pages,<br/></li>
<li></span><span class="Comment"> * i.e. those that might have been lost due to a crash after index extension<br/></li>
<li></span><span class="Comment"> * and such.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2161">&#x200c;</a></span><span class="linkable">brin_vacuum_scan</span>(Relation idxrel, BufferAccessStrategy strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the index in physical order, and clean up <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible mess in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nblocks = RelationGetNumberOfBlocks(idxrel);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (blkno = <span class="Constant">0</span>; blkno &lt; nblocks; blkno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(idxrel, MAIN_FORKNUM, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RBM_NORMAL, strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_pageops.c.html#L624" title="access/brin/brin_pageops.c:624">brin_page_cleanup</a>(idxrel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update all <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> pages in the index's FSM, as well.&nbsp; This ensures not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only that we propagate leaf-page FSM updates made by <a href="brin_pageops.c.html#L624" title="access/brin/brin_pageops.c:624">brin_page_cleanup</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but also that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing damage or out-of-dateness is repaired.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/freespace/freespace.c.html#L358" title="storage/freespace/freespace.c:358">FreeSpaceMapVacuum</a>(idxrel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2194">&#x200c;</a></span><span class="linkable">add_values_to_range</span>(Relation idxRel, BrinDesc *bdesc, BrinMemTuple *dtup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type">const</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *nulls)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> starts empty, we're certainly going to modify it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; modified = dtup-&gt;bt_empty_range;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compare the key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of the new tuple to the stored index <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deformed tuple will get updated if the new tuple doesn't fit the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (note this means we can't break out of the loop early).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a note of whether this happens, so that we know to insert the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modified tuple later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; bdesc-&gt;bd_tupdesc-&gt;natts; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinValues *bval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *addValue;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_nulls;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bval = &amp;dtup-&gt;bt_columns[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> have actual NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>? Either of the flags can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set, but we ignore the state <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> adding first row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to remember this, because we'll modify the flags and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to know if the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> started as empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; has_nulls = ((!dtup-&gt;bt_empty_range) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (bval-&gt;bv_hasnulls || bval-&gt;bv_allnulls));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the value we're adding is NULL, handle it locally. Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call the BRIN_PROCNUM_ADDVALUE procedure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bdesc-&gt;bd_info[keyno]-&gt;oi_regular_nulls &amp;&amp; nulls[keyno])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the new value is null, we record that we saw it if it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first one; otherwise, there's nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bval-&gt;bv_hasnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bval-&gt;bv_hasnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; modified = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; addValue = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(idxRel, keyno + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BRIN_PROCNUM_ADDVALUE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../utils/fmgr/fmgr.c.html#L1196" title="utils/fmgr/fmgr.c:1196">FunctionCall4Coll</a>(addValue,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idxRel-&gt;rd_indcollation[keyno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(bdesc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PointerGetDatum(bval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[keyno],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nulls[keyno]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if that returned true, we need to insert the updated tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; modified |= DatumGetBool(result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> was had actual NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (i.e. did not start empty),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure we don't forget about the NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Either the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allnulls flag is still set to true, or (if the opclass cleared it)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need to set hasnulls=true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This can only happen when the opclass modified the tuple, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the modified flag should be set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_nulls &amp;&amp; !(bval-&gt;bv_hasnulls || bval-&gt;bv_allnulls))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(modified);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bval-&gt;bv_hasnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After updating summaries for all the keys, mark it as not empty.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're actually changing the flag value (i.e. tuple started as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * empty), we should have modified the tuple. So we should not see empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> that was not modified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!dtup-&gt;bt_empty_range || modified);<br/></li>
<li>&nbsp; &nbsp; dtup-&gt;bt_empty_range = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> modified;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2288">&#x200c;</a></span><span class="linkable">check_null_keys</span>(BrinValues *bval, ScanKey *nullkeys, <span class="Type">int</span> nnullkeys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First check if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> IS [NOT] NULL scan keys, and if we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * violating them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; nnullkeys; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = nullkeys[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(key-&gt;sk_attno == bval-&gt;bv_attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle only IS NULL/IS NOT NULL tests */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(key-&gt;sk_flags &amp; SK_ISNULL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_SEARCHNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* IS NULL scan key, but <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> has no NULLs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bval-&gt;bv_allnulls &amp;&amp; !bval-&gt;bv_hasnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_SEARCHNOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For IS NOT NULL, we can only <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ranges that are known to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only nulls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bval-&gt;bv_allnulls)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Neither IS NULL nor IS NOT NULL was used; assume all indexable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators are strict and thus return false with NULL value in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the scan key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create parallel context, and launch workers for leader.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buildstate argument should be initialized (with the exception of the<br/></li>
<li></span><span class="Comment"> * tuplesort states, which may later be created based on shared<br/></li>
<li></span><span class="Comment"> * state initially set up here).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isconcurrent indicates if operation is CREATE INDEX CONCURRENTLY.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * request is the target number of parallel worker processes to launch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets buildstate's <a href="#L119" title="access/brin/brin.c:119">BrinLeader</a>, which caller must use to shut down parallel<br/></li>
<li></span><span class="Comment"> * mode by passing it to <a href="#L2536" title="access/brin/brin.c:2536">_brin_end_parallel</a>() at the very end of its index<br/></li>
<li></span><span class="Comment"> * build.&nbsp; If not even a single worker process can be launched, this is<br/></li>
<li></span><span class="Comment"> * never set, and caller should proceed with a serial index build.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2352">&#x200c;</a></span><span class="linkable">_brin_begin_parallel</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate, Relation heap, Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isconcurrent, <span class="Type">int</span> request)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scantuplesortstates;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; estbrinshared;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; estsort;<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *brinshared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort;<br/></li>
<li>&nbsp; &nbsp; <a href="#L119" title="access/brin/brin.c:119">BrinLeader</a> *brinleader = (<a href="#L119" title="access/brin/brin.c:119">BrinLeader</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L119" title="access/brin/brin.c:119">BrinLeader</a>));<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufferusage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; leaderparticipates = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querylen;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DISABLE_LEADER_PARTICIPATION<br/></li>
<li></span>&nbsp; &nbsp; leaderparticipates = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Enter parallel mode, and create context for parallel build of brin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xact.c.html#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a>();<br/></li>
<li>&nbsp; &nbsp; Assert(request &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pcxt = <a href="../transam/parallel.c.html#L167" title="access/transam/parallel.c:167">CreateParallelContext</a>(<span class="Constant">&quot;postgres&quot;</span>, <span class="Constant">&quot;<a href="#L2851" title="access/brin/brin.c:2851">_brin_parallel_build_main</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; request);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scantuplesortstates = leaderparticipates ? request + <span class="Constant">1</span> : request;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare for scan of the base relation.&nbsp; In a normal index build, we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SnapshotAny because we must retrieve all tuples and do our own time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * qual checks (because we have to index RECENTLY_DEAD tuples).&nbsp; In a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent build, we take a regular MVCC snapshot and index whatever's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * live according to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isconcurrent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = SnapshotAny;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate size for our own <a href="#L47" title="access/brin/brin.c:47">PARALLEL_KEY_BRIN_SHARED</a> workspace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estbrinshared = <a href="#L2755" title="access/brin/brin.c:2755">_brin_parallel_estimate_shared</a>(heap, snapshot);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, estbrinshared);<br/></li>
<li>&nbsp; &nbsp; estsort = <a href="../../utils/sort/tuplesort.c.html#L2955" title="utils/sort/tuplesort.c:2955">tuplesort_estimate_shared</a>(scantuplesortstates);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, estsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate space for WalUsage and BufferUsage -- <a href="../../executor/execParallel.c.html#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and <a href="../../executor/execParallel.c.html#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no extensions loaded that care, we could <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no way of knowing whether anyone's looking at <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>, so do it unconditionally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, estimate <a href="../../executor/execParallel.c.html#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a> space */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querylen = strlen(<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, querylen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querylen = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everyone's had a chance to ask for space, so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> create the DSM */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L205" title="access/transam/parallel.c:205">InitializeParallelDSM</a>(pcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no DSM segment was available, back out (do serial build) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;seg == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsMVCCSnapshot(snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/parallel.c.html#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xact.c.html#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store shared build state, for which we reserved space */<br/></li>
<li></span>&nbsp; &nbsp; brinshared = (<a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, estbrinshared);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize immutable state */<br/></li>
<li></span>&nbsp; &nbsp; brinshared-&gt;heaprelid = RelationGetRelid(heap);<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;indexrelid = RelationGetRelid(index);<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;isconcurrent = isconcurrent;<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;scantuplesortstates = scantuplesortstates;<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;pagesPerRange = buildstate-&gt;bs_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;brinshared-&gt;workersdonecv);<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;brinshared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize mutable state */<br/></li>
<li></span>&nbsp; &nbsp; brinshared-&gt;nparticipantsdone = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;reltuples = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;indtuples = <span class="Constant">0.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../table/tableam.c.html#L145" title="access/table/tableam.c:145">table_parallelscan_initialize</a>(heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="access/brin/brin.c:113">ParallelTableScanFromBrinShared</a>(brinshared),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store shared tuplesort-private state, for which we reserved space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> opaque state using tuplesort routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sharedsort = (<a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, estsort);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L2976" title="utils/sort/tuplesort.c:2976">tuplesort_initialize_shared</a>(sharedsort, scantuplesortstates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store shared tuplesort-private state, for which we reserved space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> opaque state using tuplesort routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L47" title="access/brin/brin.c:47">PARALLEL_KEY_BRIN_SHARED</a>, brinshared);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L48" title="access/brin/brin.c:48">PARALLEL_KEY_TUPLESORT</a>, sharedsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store query string for workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sharedquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sharedquery = (<span class="Type">char</span> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, querylen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sharedquery, <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>, querylen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../../executor/execParallel.c.html#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a>, sharedquery);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for each worker's WalUsage and BufferUsage; no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; walusage = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../../executor/execParallel.c.html#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a>, walusage);<br/></li>
<li>&nbsp; &nbsp; bufferusage = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../../executor/execParallel.c.html#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>, bufferusage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Launch workers, saving status for leader/caller */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L552" title="access/transam/parallel.c:552">LaunchParallelWorkers</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;pcxt = pcxt;<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;nparticipanttuplesorts = pcxt-&gt;nworkers_launched;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (leaderparticipates)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; brinleader-&gt;nparticipanttuplesorts++;<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;brinshared = brinshared;<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;sharedsort = sharedsort;<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;snapshot = snapshot;<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;walusage = walusage;<br/></li>
<li>&nbsp; &nbsp; brinleader-&gt;bufferusage = bufferusage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no workers were successfully launched, back out (do serial build) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers_launched == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2536" title="access/brin/brin.c:2536">_brin_end_parallel</a>(brinleader, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save leader state <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that it's clear build will be parallel */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;bs_leader = brinleader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Join heap scan ourselves */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leaderparticipates)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2766" title="access/brin/brin.c:2766">_brin_leader_participate_as_worker</a>(buildstate, heap, index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller needs to wait for all launched workers when we return.&nbsp; Make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that the failure-to-start case will not hang forever.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L672" title="access/transam/parallel.c:672">WaitForParallelWorkersToAttach</a>(pcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shut down workers, destroy parallel context, and end parallel mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2536">&#x200c;</a></span><span class="linkable">_brin_end_parallel</span>(<a href="#L119" title="access/brin/brin.c:119">BrinLeader</a> *brinleader, <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> worker processes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>(brinleader-&gt;pcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next, accumulate WAL usage.&nbsp; (This must wait for the workers to finish,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or we might get incomplete data.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; brinleader-&gt;pcxt-&gt;nworkers_launched; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L218" title="executor/instrument.c:218">InstrAccumParallelQuery</a>(&amp;brinleader-&gt;bufferusage[i], &amp;brinleader-&gt;walusage[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free last reference to MVCC snapshot, if one was used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsMVCCSnapshot(brinleader-&gt;snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(brinleader-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(brinleader-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xact.c.html#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Within leader, wait for end of heap scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, parallel heap scan started by <a href="#L2352" title="access/brin/brin.c:2352">_brin_begin_parallel</a>() will<br/></li>
<li></span><span class="Comment"> * already be underway within worker processes (when leader participates<br/></li>
<li></span><span class="Comment"> * as a worker, we should end up here just as workers are finishing).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the total number of heap tuples scanned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2567">&#x200c;</a></span><span class="linkable">_brin_parallel_heapscan</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *brinshared = state-&gt;bs_leader-&gt;brinshared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipanttuplesorts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nparticipanttuplesorts = state-&gt;bs_leader-&gt;nparticipanttuplesorts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;brinshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (brinshared-&gt;nparticipantsdone == nparticipanttuplesorts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* copy the data into leader state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_reltuples = brinshared-&gt;reltuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_numtuples = brinshared-&gt;indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;brinshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;brinshared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;brinshared-&gt;workersdonecv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;bs_reltuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Within leader, wait for end of heap scan and <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> per-worker results.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for all workers to finish, <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the per-worker results into<br/></li>
<li></span><span class="Comment"> * the complete index. The results from each worker are sorted by block number<br/></li>
<li></span><span class="Comment"> * (start of the page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>). While combinig the per-worker results we <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment"> * summaries for the same page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, and also fill-in empty summaries for<br/></li>
<li></span><span class="Comment"> * ranges without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the total number of heap tuples scanned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L2608">&#x200c;</a></span><span class="linkable">_brin_parallel_merge</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BrinTuple&nbsp; *btup;<br/></li>
<li>&nbsp; &nbsp; BrinMemTuple *memtuple = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplen;<br/></li>
<li>&nbsp; &nbsp; BlockNumber prevblkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; MemoryContext rangeCxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldCxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wait for workers to scan table and produce partial results */<br/></li>
<li></span>&nbsp; &nbsp; reltuples = <a href="#L2567" title="access/brin/brin.c:2567">_brin_parallel_heapscan</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* do the actual sort in the leader */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(state-&gt;bs_sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize BrinMemTuple we'll use to union summaries from workers (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case they happened to produce parts of the same page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; memtuple = <a href="brin_tuple.c.html#L482" title="access/brin/brin_tuple.c:482">brin_new_memtuple</a>(state-&gt;bs_bdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a memory context we'll reset to <a href="../../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> results for a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (received from the workers). We don't expect huge number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overlaps under regular circumstances, because for large tables the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chunk size is likely larger than the BRIN page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>), but it can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen, and the union <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> may do all kinds of stuff. So we better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reset the context once in a while.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rangeCxt = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;brin union&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldCxt = MemoryContextSwitchTo(rangeCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the BRIN tuples from the shared tuplesort, sorted by block number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That probably gives us an index that is cheaper to scan, thanks to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mostly getting data from the same index page as <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((btup = <a href="../../utils/sort/tuplesortvariants.c.html#L970" title="utils/sort/tuplesortvariants.c:970">tuplesort_getbrintuple</a>(state-&gt;bs_sortstate, &amp;tuplen, <span class="Constant">true</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="brin_minmax_multi.c.html#L170" title="access/brin/brin_minmax_multi.c:170">Ranges</a> should be multiples of pages_per_range for the index. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(btup-&gt;bt_blkno % state-&gt;bs_leader-&gt;brinshared-&gt;pagesPerRange == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do we need to union summaries for the same page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first brin tuple we read, then just deform it into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the memtuple, and continue with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one from tuplesort. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * however may need to insert empty summaries into the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's the same block as the last we saw, we simply union the brin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple into it, and we're done - we don't even need to insert empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ranges, because that was done earlier when we saw the first brin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple (for this <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finally, if it's not the first brin tuple, and it's not the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, we need to do the insert and then deform the tuple into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the memtuple. Then we'll insert empty ranges <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the new brin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple, if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prevblkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First brin tuples, just deform into memtuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtuple = <a href="brin_tuple.c.html#L553" title="access/brin/brin_tuple.c:553">brin_deform_tuple</a>(state-&gt;bs_bdesc, btup, memtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue to insert empty pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> thisblock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (memtuple-&gt;bt_blkno == btup-&gt;bt_blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Not the first brin tuple, but same page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> as the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one, so we can <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> it into the memtuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2020" title="access/brin/brin.c:2020">union_tuples</a>(state-&gt;bs_bdesc, memtuple, btup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We got brin tuple for a different page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>, so form a brin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple from the memtuple, insert it, and re-init the memtuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from the new brin tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(state-&gt;bs_bdesc, memtuple-&gt;bt_blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtuple, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_pageops.c.html#L342" title="access/brin/brin_pageops.c:342">brin_doinsert</a>(state-&gt;bs_irel, state-&gt;bs_pagesPerRange, state-&gt;bs_rmAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;bs_currentInsertBuf, tmp-&gt;bt_blkno, tmp, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the per-output-<a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> context. This frees all the memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibly allocated by the union <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and also the BRIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple we just formed and inserted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(rangeCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtuple = <a href="brin_tuple.c.html#L553" title="access/brin/brin_tuple.c:553">brin_deform_tuple</a>(state-&gt;bs_bdesc, btup, memtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* continue to insert empty pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> thisblock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fill empty ranges for all ranges missing in the tuplesort. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2978" title="access/brin/brin.c:2978">brin_fill_empty_ranges</a>(state, prevblkno, btup-&gt;bt_blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prevblkno = btup-&gt;bt_blkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(state-&gt;bs_sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill the BRIN tuple for the last page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> with data. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prevblkno != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinTuple&nbsp; *tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tmp = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(state-&gt;bs_bdesc, memtuple-&gt;bt_blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memtuple, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_pageops.c.html#L342" title="access/brin/brin_pageops.c:342">brin_doinsert</a>(state-&gt;bs_irel, state-&gt;bs_pagesPerRange, state-&gt;bs_rmAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;bs_currentInsertBuf, tmp-&gt;bt_blkno, tmp, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tmp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill empty ranges at the end, for all ranges missing in the tuplesort. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2978" title="access/brin/brin.c:2978">brin_fill_empty_ranges</a>(state, prevblkno, state-&gt;bs_maxRangeStart);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch back to the original memory context, and destroy the one we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created to isolate the union_tuple calls.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldCxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(rangeCxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> reltuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns size of shared memory required to store state for a parallel<br/></li>
<li></span><span class="Comment"> * brin index build based on the snapshot its parallel scan will use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L2755">&#x200c;</a><span class="linkable">_brin_parallel_estimate_shared</span>(Relation heap, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* c.f. <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a> as to why BUFFERALIGN is used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(BUFFERALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L57" title="access/brin/brin.c:57">BrinShared</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/tableam.c.html#L130" title="access/table/tableam.c:130">table_parallelscan_estimate</a>(heap, snapshot));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Within leader, participate as a parallel worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2766">&#x200c;</a></span><span class="linkable">_brin_leader_participate_as_worker</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate, Relation heap, Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L119" title="access/brin/brin.c:119">BrinLeader</a> *brinleader = buildstate-&gt;bs_leader;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortmem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might as well use reliable figure when doling out <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (when requested number of workers were not launched, this will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somewhat higher than it is for other workers).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sortmem = <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> / brinleader-&gt;nparticipanttuplesorts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform work common to all participants */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2794" title="access/brin/brin.c:2794">_brin_parallel_scan_and_build</a>(buildstate, brinleader-&gt;brinshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brinleader-&gt;sharedsort, heap, index, sortmem, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a worker's portion of a parallel sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This generates a tuplesort for the worker portion of the table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sortmem is the amount of working memory to use within each worker,<br/></li>
<li></span><span class="Comment"> * expressed in KBs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When this returns, workers are done, and need only release resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2794">&#x200c;</a></span><span class="linkable">_brin_parallel_scan_and_build</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *brinshared, <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation heap, Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> sortmem, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortCoordinate coordinate;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize local tuplesort coordination state */<br/></li>
<li></span>&nbsp; &nbsp; coordinate = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortCoordinateData));<br/></li>
<li>&nbsp; &nbsp; coordinate-&gt;isWorker = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; coordinate-&gt;nParticipants = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; coordinate-&gt;sharedsort = sharedsort;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin &quot;partial&quot; tuplesort */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;bs_sortstate = <a href="../../utils/sort/tuplesortvariants.c.html#L555" title="utils/sort/tuplesortvariants.c:555">tuplesort_begin_index_brin</a>(sortmem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TUPLESORT_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Join parallel scan */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo = <a href="../../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(index);<br/></li>
<li>&nbsp; &nbsp; indexInfo-&gt;ii_Concurrent = brinshared-&gt;isconcurrent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../table/tableam.c.html#L165" title="access/table/tableam.c:165">table_beginscan_parallel</a>(heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L113" title="access/brin/brin.c:113">ParallelTableScanFromBrinShared</a>(brinshared));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reltuples = table_index_build_scan(heap, index, indexInfo, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1034" title="access/brin/brin.c:1034">brinbuildCallbackParallel</a>, state, scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* insert the last item */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1995" title="access/brin/brin.c:1995">form_and_spill_tuple</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sort the BRIN ranges built by this worker */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(state-&gt;bs_sortstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;bs_reltuples += reltuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done.&nbsp; Record ambuild statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;brinshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;nparticipantsdone++;<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;reltuples += state-&gt;bs_reltuples;<br/></li>
<li>&nbsp; &nbsp; brinshared-&gt;indtuples += state-&gt;bs_numtuples;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;brinshared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify leader */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L259" title="storage/lmgr/condition_variable.c:259">ConditionVariableSignal</a>(&amp;brinshared-&gt;workersdonecv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(state-&gt;bs_sortstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform work within a launched parallel process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2851">&#x200c;</a></span><span class="linkable">_brin_parallel_build_main</span>(<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, <a href="../../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a> *toc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sharedquery;<br/></li>
<li>&nbsp; &nbsp; <a href="#L57" title="access/brin/brin.c:57">BrinShared</a> *brinshared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort;<br/></li>
<li>&nbsp; &nbsp; <a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *buildstate;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; heapLockmode;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; indexLockmode;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufferusage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortmem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only possible status flag that can be set to the parallel worker is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PROC_IN_SAFE_IC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags == PROC_IN_SAFE_IC));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> for individual workers first */<br/></li>
<li></span>&nbsp; &nbsp; sharedquery = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../../executor/execParallel.c.html#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = sharedquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report the query string from leader */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up brin shared state */<br/></li>
<li></span>&nbsp; &nbsp; brinshared = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L47" title="access/brin/brin.c:47">PARALLEL_KEY_BRIN_SHARED</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open relations using lock modes known to be obtained by index.c */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!brinshared-&gt;isconcurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapLockmode = ShareLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexLockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapLockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexLockmode = RowExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open relations within worker */<br/></li>
<li></span>&nbsp; &nbsp; heapRel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(brinshared-&gt;heaprelid, heapLockmode);<br/></li>
<li>&nbsp; &nbsp; indexRel = <a href="../index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(brinshared-&gt;indexrelid, indexLockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buildstate = <a href="#L1658" title="access/brin/brin.c:1658">initialize_brin_buildstate</a>(indexRel, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; brinshared-&gt;pagesPerRange,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up shared state private to tuplesort.c */<br/></li>
<li></span>&nbsp; &nbsp; sharedsort = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L48" title="access/brin/brin.c:48">PARALLEL_KEY_TUPLESORT</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L2999" title="utils/sort/tuplesort.c:2999">tuplesort_attach_shared</a>(sharedsort, seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to track buffer usage during parallel execution */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/instrument.c.html#L200" title="executor/instrument.c:200">InstrStartParallelQuery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might as well use reliable figure when doling out <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (when requested number of workers were not launched, this will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somewhat higher than it is for other workers).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sortmem = <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> / brinshared-&gt;scantuplesortstates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2794" title="access/brin/brin.c:2794">_brin_parallel_scan_and_build</a>(buildstate, brinshared, sharedsort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRel, indexRel, sortmem, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report WAL/buffer usage during parallel execution */<br/></li>
<li></span>&nbsp; &nbsp; bufferusage = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../../executor/execParallel.c.html#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; walusage = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../../executor/execParallel.c.html#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/instrument.c.html#L208" title="executor/instrument.c:208">InstrEndParallelQuery</a>(&amp;bufferusage[<a href="../transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;walusage[<a href="../transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, indexLockmode);<br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRel, heapLockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2941" title="access/brin/brin.c:2941">brin_build_empty_tuple</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Maybe <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a BRIN tuple representing empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a BRIN tuple representing an empty page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> starting at the<br/></li>
<li></span><span class="Comment"> * specified block number. The empty tuple is initialized only once, when it's<br/></li>
<li></span><span class="Comment"> * needed for the first time, stored in the memory context bs_context to ensure<br/></li>
<li></span><span class="Comment"> * proper life span, and reused on following calls. All empty tuples are<br/></li>
<li></span><span class="Comment"> * exactly the same except for the bt_blkno field, which is set to the value<br/></li>
<li></span><span class="Comment"> * in blkno parameter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2941">&#x200c;</a></span><span class="linkable">brin_build_empty_tuple</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First time an empty tuple is requested? If yes, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;bs_emptyTuple == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BrinMemTuple *dtuple = <a href="brin_tuple.c.html#L482" title="access/brin/brin_tuple.c:482">brin_new_memtuple</a>(state-&gt;bs_bdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate the tuple in context for the whole index build. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(state-&gt;bs_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_emptyTuple = <a href="brin_tuple.c.html#L99" title="access/brin/brin_tuple.c:99">brin_form_tuple</a>(state-&gt;bs_bdesc, blkno, dtuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;state-&gt;bs_emptyTupleLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we already have an empty tuple, just update the block. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;bs_emptyTuple-&gt;bt_blkno = blkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2978" title="access/brin/brin.c:2978">brin_fill_empty_ranges</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Add BRIN index tuples representing empty page ranges.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * prevRange/nextRange determine for which page ranges to add empty summaries.<br/></li>
<li></span><span class="Comment"> * Both boundaries are exclusive, i.e. only ranges starting at blkno for which<br/></li>
<li></span><span class="Comment"> * (prevRange &lt; blkno &lt; nextRange) will be added to the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If prevRange is InvalidBlockNumber, this means there was no previous page<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> (i.e. the first empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> to add is for blkno=0).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The empty tuple is built only once, and then reused for all future calls.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2978">&#x200c;</a></span><span class="linkable">brin_fill_empty_ranges</span>(<a href="#L152" title="access/brin/brin.c:152">BrinBuildState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber prevRange, BlockNumber nextRange)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we already summarized some ranges, we need to start with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one. Otherwise start from the first <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; blkno = (prevRange == InvalidBlockNumber) ? <span class="Constant">0</span> : (prevRange + state-&gt;bs_pagesPerRange);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate empty ranges until we hit the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> non-empty <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (blkno &lt; nextRange)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Did we already build the empty tuple? If not, do it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2941" title="access/brin/brin.c:2941">brin_build_empty_tuple</a>(state, blkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="brin_pageops.c.html#L342" title="access/brin/brin_pageops.c:342">brin_doinsert</a>(state-&gt;bs_irel, state-&gt;bs_pagesPerRange, state-&gt;bs_rmAccess,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state-&gt;bs_currentInsertBuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno, state-&gt;bs_emptyTuple, state-&gt;bs_emptyTupleLen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blkno += state-&gt;bs_pagesPerRange;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
