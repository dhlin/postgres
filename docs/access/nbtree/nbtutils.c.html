<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtutils.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtutils.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L4379">btvacinfo</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L4365">BTOneVacInfo</a></li>
<li><a href="#L4369">BTOneVacInfo</a></li>
<li><a href="#L42">BTScanKeyPreproc</a></li>
<li><a href="#L47">BTScanKeyPreproc</a></li>
<li><a href="#L35">BTSortArrayContext</a></li>
<li><a href="#L40">BTSortArrayContext</a></li>
<li><a href="#L4371">BTVacInfo</a></li>
<li><a href="#L4377">BTVacInfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L4533">BTreeShmemInit</a></li>
<li><a href="#L4520">BTreeShmemSize</a></li>
<li><a href="#L1789">_bt_advance_array_keys</a></li>
<li><a href="#L1381">_bt_advance_array_keys_increment</a></li>
<li><a href="#L5139">_bt_allequalimage</a></li>
<li><a href="#L1201">_bt_binsrch_array_skey</a></li>
<li><a href="#L3686">_bt_check_compare</a></li>
<li><a href="#L4921">_bt_check_natts</a></li>
<li><a href="#L3892">_bt_check_rowcompare</a></li>
<li><a href="#L5081">_bt_check_third_page</a></li>
<li><a href="#L3512">_bt_checkkeys</a></li>
<li><a href="#L4076">_bt_checkkeys_look_ahead</a></li>
<li><a href="#L1099">_bt_compare_array_elements</a></li>
<li><a href="#L976">_bt_compare_array_scankey_args</a></li>
<li><a href="#L1131">_bt_compare_array_skey</a></li>
<li><a href="#L3126">_bt_compare_scankey_args</a></li>
<li><a href="#L4483">_bt_end_vacuum</a></li>
<li><a href="#L4511">_bt_end_vacuum_callback</a></li>
<li><a href="#L789">_bt_find_extreme_element</a></li>
<li><a href="#L3333">_bt_fix_scankey_strategy</a></li>
<li><a href="#L221">_bt_freestack</a></li>
<li><a href="#L4800">_bt_keep_natts</a></li>
<li><a href="#L4874">_bt_keep_natts_fast</a></li>
<li><a href="#L4175">_bt_killitems</a></li>
<li><a href="#L3442">_bt_mark_scankey_required</a></li>
<li><a href="#L893">_bt_merge_arrays</a></li>
<li><a href="#L129">_bt_mkscankey</a></li>
<li><a href="#L269">_bt_preprocess_array_keys</a></li>
<li><a href="#L551">_bt_preprocess_array_keys_final</a></li>
<li><a href="#L2556">_bt_preprocess_keys</a></li>
<li><a href="#L1467">_bt_rewind_nonrequired_arrays</a></li>
<li><a href="#L712">_bt_setup_array_cmp</a></li>
<li><a href="#L849">_bt_sort_array_elements</a></li>
<li><a href="#L1343">_bt_start_array_keys</a></li>
<li><a href="#L1668">_bt_start_prim_scan</a></li>
<li><a href="#L4426">_bt_start_vacuum</a></li>
<li><a href="#L4655">_bt_truncate</a></li>
<li><a href="#L1544">_bt_tuple_before_array_skeys</a></li>
<li><a href="#L4392">_bt_vacuum_cycleid</a></li>
<li><a href="#L3010">_bt_verify_arrays_bt_first</a></li>
<li><a href="#L3048">_bt_verify_keys_with_arraykeys</a></li>
<li><a href="#L4607">btbuildphasename</a></li>
<li><a href="#L4561">btoptions</a></li>
<li><a href="#L4584">btproperty</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L33">LOOK_AHEAD_DEFAULT_DISTANCE</a></li>
<li><a href="#L32">LOOK_AHEAD_REQUIRED_RECHECKS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtutils.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Utility code for Postgres btree implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtutils.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/qunique.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L32">&#x200c;</a><span class="PreProc">#define <span class="linkable">LOOK_AHEAD_REQUIRED_RECHECKS</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">3<br/></li>
<li><a id="L33">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LOOK_AHEAD_DEFAULT_DISTANCE</span>&nbsp; &nbsp;&nbsp; </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><a id="L35">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTSortArrayContext</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *sortproc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reverse;<br/></li>
<li><a id="L40">&#x200c;</a>} <span class="linkable">BTSortArrayContext</span>;<br/></li>
<li><br/></li>
<li><a id="L42">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTScanKeyPreproc</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; skey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ikey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx;<br/></li>
<li><a id="L47">&#x200c;</a>} <span class="linkable">BTScanKeyPreproc</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L712" title="access/nbtree/nbtutils.c:712">_bt_setup_array_cmp</a>(IndexScanDesc scan, ScanKey skey, Oid elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *orderproc, FmgrInfo **sortprocp);<br/></li>
<li><span class="Type">static</span> Datum <a href="#L789" title="access/nbtree/nbtutils.c:789">_bt_find_extreme_element</a>(IndexScanDesc scan, ScanKey skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid elemtype, StrategyNumber strat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *elems, <span class="Type">int</span> nelems);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L849" title="access/nbtree/nbtutils.c:849">_bt_sort_array_elements</a>(ScanKey skey, FmgrInfo *sortproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reverse, Datum *elems, <span class="Type">int</span> nelems);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L893" title="access/nbtree/nbtutils.c:893">_bt_merge_arrays</a>(IndexScanDesc scan, ScanKey skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *sortproc, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reverse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid origelemtype, Oid nextelemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *elems_orig, <span class="Type">int</span> *nelems_orig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *elems_next, <span class="Type">int</span> nelems_next);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L976" title="access/nbtree/nbtutils.c:976">_bt_compare_array_scankey_args</a>(IndexScanDesc scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey arraysk, ScanKey skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *orderproc, BTArrayKeyInfo *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *qual_ok);<br/></li>
<li><span class="Type">static</span> ScanKey <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a>(IndexScanDesc scan);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L551" title="access/nbtree/nbtutils.c:551">_bt_preprocess_array_keys_final</a>(IndexScanDesc scan, <span class="Type">int</span> *keyDataMap);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1099" title="access/nbtree/nbtutils.c:1099">_bt_compare_array_elements</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> int32 <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(FmgrInfo *orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum tupdatum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arrdatum, ScanKey cur);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1201" title="access/nbtree/nbtutils.c:1201">_bt_binsrch_array_skey</a>(FmgrInfo *orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> cur_elem_trig, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum tupdatum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTArrayKeyInfo *array, ScanKey cur,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 *set_elem_result);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1381" title="access/nbtree/nbtutils.c:1381">_bt_advance_array_keys_increment</a>(IndexScanDesc scan, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1467" title="access/nbtree/nbtutils.c:1467">_bt_rewind_nonrequired_arrays</a>(IndexScanDesc scan, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(IndexScanDesc scan, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple tuple, TupleDesc tupdesc, <span class="Type">int</span> tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> readpagetup, <span class="Type">int</span> sktrig, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *scanBehind);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a>(IndexScanDesc scan, BTReadPageState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple tuple, <span class="Type">int</span> tupnatts, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sktrig, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sktrig_required);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3010" title="access/nbtree/nbtutils.c:3010">_bt_verify_arrays_bt_first</a>(IndexScanDesc scan, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3048" title="access/nbtree/nbtutils.c:3048">_bt_verify_keys_with_arraykeys</a>(IndexScanDesc scan);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a>(IndexScanDesc scan, ScanKey op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey leftarg, ScanKey rightarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTArrayKeyInfo *array, FmgrInfo *orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *result);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3333" title="access/nbtree/nbtutils.c:3333">_bt_fix_scankey_strategy</a>(ScanKey skey, int16 *indoption);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3442" title="access/nbtree/nbtutils.c:3442">_bt_mark_scankey_required</a>(ScanKey skey);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>(IndexScanDesc scan, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple tuple, <span class="Type">int</span> tupnatts, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> advancenonrequired, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> prechecked, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> firstmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *continuescan, <span class="Type">int</span> *ikey);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3892" title="access/nbtree/nbtutils.c:3892">_bt_check_rowcompare</a>(ScanKey skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple tuple, <span class="Type">int</span> tupnatts, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirection dir, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *continuescan);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4076" title="access/nbtree/nbtutils.c:4076">_bt_checkkeys_look_ahead</a>(IndexScanDesc scan, BTReadPageState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> tupnatts, TupleDesc tupdesc);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a>(Relation rel, IndexTuple lastleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple firstright, BTScanInsert itup_key);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L129" title="access/nbtree/nbtutils.c:129">_bt_mkscankey</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build an insertion scan key that contains comparison data from itup<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as well as comparator routines appropriate to the key datatypes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The result is intended for use with <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>() and <a href="#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>().<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Callers that don't need to fill out the insertion scankey arguments<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (e.g. they use an ad-hoc comparison routine, or only need a scankey<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for <a href="#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>()) can pass a NULL index tuple.&nbsp; The scankey will<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; be initialized as if an &quot;all truncated&quot; pivot tuple was passed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note that we may occasionally have to share lock the metapage to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; determine whether or not the keys in the index are expected to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; unique (i.e. if this is a &quot;heapkeyspace&quot; index).&nbsp; We assume a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heapkeyspace index when caller passes a NULL tuple, allowing index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; build callers to avoid accessing the non-existent metapage.&nbsp; We<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; also assume that the index is _not_ allequalimage when a NULL tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; is passed; CREATE INDEX callers call <a href="#L5139" title="access/nbtree/nbtutils.c:5139">_bt_allequalimage</a>() to set the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; field themselves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BTScanInsert<br/></li>
<li><a id="L129">&#x200c;</a><span class="linkable">_bt_mkscankey</span>(Relation rel, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanInsert key;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; skey;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; itupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnkeyatts;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *indoption;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupnatts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; indnkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; indoption = rel-&gt;rd_indoption;<br/></li>
<li>&nbsp; &nbsp; tupnatts = itup ? BTreeTupleGetNAtts(itup, rel) : <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(tupnatts &lt;= IndexRelationGetNumberOfAttributes(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll execute search using scan key constructed on key columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Truncated attributes and non-key attributes are omitted from the final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; key = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(BTScanInsertData, scankeys) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (itup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L739" title="access/nbtree/nbtpage.c:739">_bt_metaversion</a>(rel, &amp;key-&gt;heapkeyspace, &amp;key-&gt;allequalimage);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Utility statement callers can set these fields themselves */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;heapkeyspace = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;allequalimage = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; key-&gt;anynullkeys = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* initial assumption */<br/></li>
<li></span>&nbsp; &nbsp; key-&gt;nextkey = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* usual case, required by <a href="nbtree.c.html#L182" title="access/nbtree/nbtree.c:182">btinsert</a> */<br/></li>
<li></span>&nbsp; &nbsp; key-&gt;backward = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* usual case, required by <a href="nbtree.c.html#L182" title="access/nbtree/nbtree.c:182">btinsert</a> */<br/></li>
<li></span>&nbsp; &nbsp; key-&gt;keysz = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(indnkeyatts, tupnatts);<br/></li>
<li>&nbsp; &nbsp; key-&gt;scantid = key-&gt;heapkeyspace &amp;&amp; itup ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetHeapTID(itup) : <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; skey = key-&gt;scankeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indnkeyatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *procinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; null;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can use the cached (default) support procs since no cross-type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comparison can be needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; procinfo = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(rel, i + <span class="Constant">1</span>, BTORDER_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Key arguments built from truncated attributes (or when caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provides no tuple) are defensively represented as NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never be used.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; tupnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = index_getattr(itup, i + <span class="Constant">1</span>, itupdesc, &amp;null);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arg = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flags = (null ? SK_ISNULL : <span class="Constant">0</span>) | (indoption[i] &lt;&lt; SK_BT_INDOPTION_SHIFT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L101" title="access/common/scankey.c:101">ScanKeyEntryInitializeWithInfo</a>(&amp;skey[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (AttrNumber) (i + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidStrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_indcollation[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; procinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> key attribute is NULL (or truncated) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;anynullkeys = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In NULLS NOT DISTINCT mode, we pretend that there are no null keys, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that full uniqueness check is done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_index-&gt;indnullsnotdistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;anynullkeys = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> key;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * free a retracement stack made by <a href="nbtsearch.c.html#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L221">&#x200c;</a></span><span class="linkable">_bt_freestack</span>(BTStack stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTStack&nbsp; &nbsp; &nbsp; &nbsp; ostack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (stack != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ostack = stack;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack = stack-&gt;bts_parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ostack);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a>() -- Preprocess SK_SEARCHARRAY scan keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> SK_SEARCHARRAY scan keys, deconstruct the array(s) and<br/></li>
<li></span><span class="Comment"> * set up BTArrayKeyInfo info for each one that is an equality-type key.<br/></li>
<li></span><span class="Comment"> * Returns modified scan keys as input for further, standard preprocessing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently we perform two kinds of preprocessing to deal with redundancies.<br/></li>
<li></span><span class="Comment"> * For inequality array keys, it's sufficient to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the extreme <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> * value and replace the whole array with that scalar value.&nbsp; This eliminates<br/></li>
<li></span><span class="Comment"> * all but one array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> as redundant.&nbsp; Similarly, we are capable of<br/></li>
<li></span><span class="Comment"> * &quot;merging together&quot; multiple equality array keys (from two or more input<br/></li>
<li></span><span class="Comment"> * scan keys) into a single output scan key containing only the intersecting<br/></li>
<li></span><span class="Comment"> * array elements.&nbsp; This can eliminate many redundant array elements, as well<br/></li>
<li></span><span class="Comment"> * as eliminating whole array scan keys as redundant.&nbsp; It can also allow us to<br/></li>
<li></span><span class="Comment"> * detect contradictory quals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is convenient for <a href="#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a> caller to have to deal with no<br/></li>
<li></span><span class="Comment"> * more than one equality strategy array scan key per index attribute.&nbsp; We'll<br/></li>
<li></span><span class="Comment"> * always be able to set things up that way when complete opfamilies are used.<br/></li>
<li></span><span class="Comment"> * Eliminated array scan keys can be recognized as those that have had their<br/></li>
<li></span><span class="Comment"> * sk_strategy field set to InvalidStrategy here by us.&nbsp; Caller should avoid<br/></li>
<li></span><span class="Comment"> * including these in the scan's so-&gt;keyData[] output array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We set the scan key references from the scan's BTArrayKeyInfo info array to<br/></li>
<li></span><span class="Comment"> * offsets into the temp modified input array returned to caller.&nbsp; Scans that<br/></li>
<li></span><span class="Comment"> * have array keys should call <a href="#L551" title="access/nbtree/nbtutils.c:551">_bt_preprocess_array_keys_final</a> when standard<br/></li>
<li></span><span class="Comment"> * preprocessing steps are complete.&nbsp; This will convert the scan key offset<br/></li>
<li></span><span class="Comment"> * references into references to the scan's so-&gt;keyData[] output scan keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the reason we need to return a temp scan key array, rather than just<br/></li>
<li></span><span class="Comment"> * scribbling on scan-&gt;keyData, is that callers are permitted to call <a href="nbtree.c.html#L359" title="access/nbtree/nbtree.c:359">btrescan</a><br/></li>
<li></span><span class="Comment"> * without supplying a new set of scankey data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> ScanKey<br/></li>
<li><a id="L269">&#x200c;</a><span class="linkable">_bt_preprocess_array_keys</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfKeys = scan-&gt;numberOfKeys;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *indoption = rel-&gt;rd_indoption;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numArrayKeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origarrayatt = InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origarraykey = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origelemtype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; arrayKeyData;&nbsp; &nbsp; <span class="Comment">/* modified copy of scan-&gt;keyData */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; Assert(numberOfKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quick check to see if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> array keys */<br/></li>
<li></span>&nbsp; &nbsp; numArrayKeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numberOfKeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur = &amp;scan-&gt;keyData[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_SEARCHARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numArrayKeys++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(cur-&gt;sk_flags &amp; (SK_ROW_HEADER | SK_SEARCHNULL | SK_SEARCHNOTNULL)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> arrays are null as a whole, we can quit right <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Quit if nothing to do. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numArrayKeys == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a scan-lifespan context to hold array-associated data, or reset it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we already have one from a previous rescan cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;arrayContext == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;arrayContext = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;BTree array context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_SMALL_SIZES);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(so-&gt;arrayContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(so-&gt;arrayContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create modifiable copy of scan-&gt;keyData in the workspace context */<br/></li>
<li></span>&nbsp; &nbsp; arrayKeyData = (ScanKey) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; memcpy(arrayKeyData, scan-&gt;keyData, numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space for per-array data in the workspace context */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;arrayKeys = (BTArrayKeyInfo *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numArrayKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTArrayKeyInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate space for ORDER procs used to <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;orderProcs = (FmgrInfo *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(FmgrInfo));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now process each array key */<br/></li>
<li></span>&nbsp; &nbsp; numArrayKeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numberOfKeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; sortproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *sortprocp = &amp;sortproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; reverse;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arrayval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; elmlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; elmbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; elmalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *elem_nulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_nonnulls;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cur = &amp;arrayKeyData[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(cur-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, deconstruct the array into elements.&nbsp; Anything allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here (including a possibly detoasted array value) is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workspace context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arrayval = DatumGetArrayTypeP(cur-&gt;sk_argument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We could cache this data, but not clear it's worth it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/cache/lsyscache.c.html#L2271" title="utils/cache/lsyscache.c:2271">get_typlenbyvalalign</a>(ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;elmlen, &amp;elmbyval, &amp;elmalign);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/adt/arrayfuncs.c.html#L3612" title="utils/adt/arrayfuncs.c:3612">deconstruct_array</a>(arrayval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arrayval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elmlen, elmbyval, elmalign,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;elem_values, &amp;elem_nulls, &amp;num_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compress out <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> null elements.&nbsp; We can ignore them since we assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all btree operators are strict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; num_nonnulls = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; num_elems; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!elem_nulls[j])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_values[num_nonnulls++] = elem_values[j];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We could <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elem_nulls) <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, but not worth the cycles */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If there's no non-nulls, the scan qual is unsatisfiable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (num_nonnulls == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the nominal datatype of the array elements.&nbsp; We have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support the convention that sk_subtype == InvalidOid means the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opclass input type; this is a hack to simplify life for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elemtype = cur-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elemtype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemtype = rel-&gt;rd_opcintype[cur-&gt;sk_attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the comparison operator is not equality, then the array qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * degenerates to a simple comparison against the smallest or largest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-null array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, as appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cur-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L789" title="access/nbtree/nbtutils.c:789">_bt_find_extreme_element</a>(scan, cur, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTGreaterStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elem_values, num_nonnulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* proceed with rest of loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L789" title="access/nbtree/nbtutils.c:789">_bt_find_extreme_element</a>(scan, cur, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTLessStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elem_values, num_nonnulls);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized StrategyNumber: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) cur-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll need a 3-way ORDER proc to perform binary searches for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> matching array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; Set that up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Array scan keys with cross-type equality operators will require a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate same-type ORDER proc for sorting their array.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sortproc just points to the same proc used during binary searches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="access/nbtree/nbtutils.c:712">_bt_setup_array_cmp</a>(scan, cur, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;so-&gt;orderProcs[i], &amp;sortprocp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sort the non-null elements and eliminate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> duplicates.&nbsp; We must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sort in the same ordering used by the index column, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrays can be advanced in lockstep with the scan's progress through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the index's key space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reverse = (indoption[cur-&gt;sk_attno - <span class="Constant">1</span>] &amp; INDOPTION_DESC) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_elems = <a href="#L849" title="access/nbtree/nbtutils.c:849">_bt_sort_array_elements</a>(cur, sortprocp, reverse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem_values, num_nonnulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (origarrayatt == cur-&gt;sk_attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *orig = &amp;so-&gt;arrayKeys[origarraykey];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This array scan key is redundant with a previous equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator array scan key.&nbsp; Merge the two arrays together to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eliminate contradictory non-intersecting elements (or try to).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array back into attribute's original array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(arrayKeyData[orig-&gt;scan_key].sk_attno == cur-&gt;sk_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(arrayKeyData[orig-&gt;scan_key].sk_collation ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_collation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L893" title="access/nbtree/nbtutils.c:893">_bt_merge_arrays</a>(scan, cur, sortprocp, reverse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origelemtype, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; orig-&gt;elem_values, &amp;orig-&gt;num_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elem_values, num_elems))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Successfully eliminated this array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(elem_values);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no intersecting elements remain in the original array,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the scan qual is unsatisfiable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig-&gt;num_elems == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Indicate to <a href="#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a> caller that it must ignore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_strategy = InvalidStrategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unable to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> this array with previous array due to a lack of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * suitable cross-type opfamily support.&nbsp; Will need to keep both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan keys/arrays.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This array is the first for current index attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it turns out to not be the last array (that is, if the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array is redundantly applied to this same index attribute),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll then treat this array as the attribute's &quot;original&quot; array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when merging.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origarrayatt = cur-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origarraykey = numArrayKeys;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origelemtype = elemtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And set up the BTArrayKeyInfo data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="#L551" title="access/nbtree/nbtutils.c:551">_bt_preprocess_array_keys_final</a> will fix-up each array's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan_key field later on, after so-&gt;keyData[] has been finalized.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;arrayKeys[numArrayKeys].scan_key = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;arrayKeys[numArrayKeys].num_elems = num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;arrayKeys[numArrayKeys].elem_values = elem_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; numArrayKeys++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;numArrayKeys = numArrayKeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> arrayKeyData;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L551" title="access/nbtree/nbtutils.c:551">_bt_preprocess_array_keys_final</a>() -- fix up array scan key references<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> performed initial array preprocessing, it<br/></li>
<li></span><span class="Comment"> * set each array's array-&gt;scan_key to the array's arrayKeys[] entry offset<br/></li>
<li></span><span class="Comment"> * (that also work as references into the original scan-&gt;keyData[] array).<br/></li>
<li></span><span class="Comment"> * This function handles translation of the scan key references from the<br/></li>
<li></span><span class="Comment"> * BTArrayKeyInfo info array, from input scan key references (to the keys in<br/></li>
<li></span><span class="Comment"> * scan-&gt;keyData[]), into output references (to the keys in so-&gt;keyData[]).<br/></li>
<li></span><span class="Comment"> * Caller's keyDataMap[] array tells us how to perform this remapping.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also finalizes so-&gt;orderProcs[] for the scan.&nbsp; Arrays already have an ORDER<br/></li>
<li></span><span class="Comment"> * proc, which might need to be repositioned to its so-&gt;keyData[]-wise offset<br/></li>
<li></span><span class="Comment"> * (very much like the remapping that we apply to array-&gt;scan_key references).<br/></li>
<li></span><span class="Comment"> * Non-array equality strategy scan keys (that survived preprocessing) don't<br/></li>
<li></span><span class="Comment"> * yet have an so-&gt;orderProcs[] entry, so we set one for them here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also converts single-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array scan keys into equivalent non-array<br/></li>
<li></span><span class="Comment"> * equality scan keys, which decrements so-&gt;numArrayKeys.&nbsp; It's possible that<br/></li>
<li></span><span class="Comment"> * this will leave this new <a href="nbtree.c.html#L359" title="access/nbtree/nbtree.c:359">btrescan</a> without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> arrays at all.&nbsp; This isn't<br/></li>
<li></span><span class="Comment"> * necessary for correctness; it's just an optimization.&nbsp; Non-array equality<br/></li>
<li></span><span class="Comment"> * scan keys are slightly faster than equivalent array scan keys at runtime.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L551">&#x200c;</a></span><span class="linkable">_bt_preprocess_array_keys_final</span>(IndexScanDesc scan, <span class="Type">int</span> *keyDataMap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_equal_output_ikey <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;qual_ok);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nothing for us to do when <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> only had to deal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with array inequalities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numArrayKeys == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> output_ikey = <span class="Constant">0</span>; output_ikey &lt; so-&gt;numberOfKeys; output_ikey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; outkey = so-&gt;keyData + output_ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; input_ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(outkey-&gt;sk_strategy != InvalidStrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outkey-&gt;sk_strategy != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; input_ikey = keyDataMap[output_ikey];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(last_equal_output_ikey &lt; output_ikey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(last_equal_output_ikey &lt; input_ikey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_equal_output_ikey = output_ikey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're lazy about looking up ORDER procs for non-array keys, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not all input keys become output keys.&nbsp; Take care of it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(outkey-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need for an ORDER proc given an IS NULL scan key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (outkey-&gt;sk_flags &amp; SK_SEARCHNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A non-required scan key doesn't need an ORDER proc, either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (unless it's associated with an array, which this one isn't)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(outkey-&gt;sk_flags &amp; SK_BT_REQFWD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemtype = outkey-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elemtype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elemtype = rel-&gt;rd_opcintype[outkey-&gt;sk_attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L712" title="access/nbtree/nbtutils.c:712">_bt_setup_array_cmp</a>(scan, outkey, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;so-&gt;orderProcs[output_ikey], <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reorder existing array scan key so-&gt;orderProcs[] entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doing this in-place is safe because preprocessing is required to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output all equality strategy scan keys in original input order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (among each group of entries against the same index attribute).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is also the order that the arrays themselves appear in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;orderProcs[output_ikey] = so-&gt;orderProcs[input_ikey];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix-up array-&gt;scan_key references for arrays */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; arrayidx &lt; so-&gt;numArrayKeys; arrayidx++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = &amp;so-&gt;arrayKeys[arrayidx];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(array-&gt;num_elems &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;scan_key == input_ikey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;scan_key = output_ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transform array scan keys that have exactly 1 <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining (following all prior preprocessing) into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equivalent non-array scan keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;num_elems == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outkey-&gt;sk_flags &amp;= ~SK_SEARCHARRAY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outkey-&gt;sk_argument = array-&gt;elem_values[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;numArrayKeys--;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're out of array keys, we can quit right away */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numArrayKeys == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shift other arrays forward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(array, array + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTArrayKeyInfo) *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (so-&gt;numArrayKeys - arrayidx));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't increment arrayidx (there was an entry that was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just shifted forward to the offset at arrayidx, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will still need to be matched)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Match found, so done with this array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parallel index scans require space in shared memory to store the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current array elements (for arrays kept by preprocessing) to schedule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> primitive index scan.&nbsp; The underlying structure is protected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using a spinlock, so defensively limit its size.&nbsp; In practice this can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only affect parallel scans that use an incomplete opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan &amp;&amp; so-&gt;numArrayKeys &gt; INDEX_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;number of array scan keys left by preprocessing (</span><span class="Special">%d</span><span class="Constant">) exceeds the maximum allowed by parallel btree index scans (</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so-&gt;numArrayKeys, INDEX_MAX_KEYS)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L712" title="access/nbtree/nbtutils.c:712">_bt_setup_array_cmp</a>() -- Set up array comparison <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets ORDER proc in caller's orderproc argument, which is used during binary<br/></li>
<li></span><span class="Comment"> * searches of arrays during the index scan.&nbsp; Also sets a same-type ORDER proc<br/></li>
<li></span><span class="Comment"> * in caller's *sortprocp argument, which is used when sorting the array.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Preprocessing calls here with all equality strategy scan keys (when scan<br/></li>
<li></span><span class="Comment"> * uses equality array keys), including those not associated with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> array.<br/></li>
<li></span><span class="Comment"> * See <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> for an explanation of why it'll need to treat<br/></li>
<li></span><span class="Comment"> * simple scalar equality scan keys as degenerate single <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should pass an orderproc pointing to space that'll store the ORDER<br/></li>
<li></span><span class="Comment"> * proc for the scan, and a *sortprocp pointing to its own separate space.<br/></li>
<li></span><span class="Comment"> * When calling here for a non-array scan key, sortprocp arg should be NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the common case where we don't need to deal with cross-type operators,<br/></li>
<li></span><span class="Comment"> * only one ORDER proc is actually required by caller.&nbsp; We'll set *sortprocp<br/></li>
<li></span><span class="Comment"> * to point to the same memory that caller's orderproc continues to point to.<br/></li>
<li></span><span class="Comment"> * Otherwise, *sortprocp will continue to point to caller's own space.&nbsp; Either<br/></li>
<li></span><span class="Comment"> * way, *sortprocp will point to a same-type ORDER proc (since that's the only<br/></li>
<li></span><span class="Comment"> * safe way to sort/deduplicate the array associated with caller's scan key).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L712">&#x200c;</a></span><span class="linkable">_bt_setup_array_cmp</span>(IndexScanDesc scan, ScanKey skey, Oid elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo *orderproc, FmgrInfo **sortprocp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; RegProcedure cmp_proc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype = rel-&gt;rd_opcintype[skey-&gt;sk_attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(skey-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(elemtype));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If scankey operator is not a cross-type comparison, we can use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cached comparison function; otherwise gotta look it up in the catalogs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (elemtype == opcintype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set same-type ORDER procs for caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *orderproc = *<a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(rel, skey-&gt;sk_attno, BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sortprocp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *sortprocp = orderproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the appropriate cross-type comparison function in the opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the opclass input type as the left hand arg type, and the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type as the right hand arg type (since binary searches use an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index tuple's attribute value to search for a matching array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's possible that this would fail, if the opfamily is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incomplete, but only in cases where it's quite likely that <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would fail in just the same way (had we not failed <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it could).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(rel-&gt;rd_opfamily[skey-&gt;sk_attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opcintype, elemtype, BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) for attribute </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC, opcintype, elemtype, skey-&gt;sk_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set cross-type ORDER proc for caller */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(cmp_proc, orderproc, so-&gt;arrayContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done if caller doesn't actually have an array they'll need to sort */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!sortprocp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the appropriate same-type comparison function in the opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's possible that this would fail, if the opfamily is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incomplete, but it seems quite unlikely that an opfamily would omit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-cross-type comparison procs for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> datatype that it supports at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(rel-&gt;rd_opfamily[skey-&gt;sk_attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemtype, elemtype, BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) for attribute </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC, elemtype, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; skey-&gt;sk_attno, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set same-type ORDER proc for caller */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(cmp_proc, *sortprocp, so-&gt;arrayContext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L789" title="access/nbtree/nbtutils.c:789">_bt_find_extreme_element</a>() -- get least or greatest array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scan and skey identify the index column, whose opfamily determines the<br/></li>
<li></span><span class="Comment"> * comparison semantics.&nbsp; strat should be BTLessStrategyNumber to get the<br/></li>
<li></span><span class="Comment"> * least <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>, or BTGreaterStrategyNumber to get the greatest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Datum<br/></li>
<li><a id="L789">&#x200c;</a><span class="linkable">_bt_find_extreme_element</span>(IndexScanDesc scan, ScanKey skey, Oid elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; StrategyNumber strat,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *elems, <span class="Type">int</span> nelems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_op;<br/></li>
<li>&nbsp; &nbsp; RegProcedure cmp_proc;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; flinfo;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the appropriate comparison operator in the opfamily.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it's possible that this would fail, if the opfamily is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incomplete, but it seems quite unlikely that an opfamily would omit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-cross-type comparison operators for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> datatype that it supports<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(skey-&gt;sk_strategy != BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(elemtype));<br/></li>
<li>&nbsp; &nbsp; cmp_op = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(rel-&gt;rd_opfamily[skey-&gt;sk_attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strat);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(cmp_op))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strat, elemtype, elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_opfamily[skey-&gt;sk_attno - <span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(cmp_op);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing oprcode for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>, cmp_op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(cmp_proc, &amp;flinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(nelems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; result = elems[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; nelems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;flinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; skey-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elems[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; result)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = elems[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L849" title="access/nbtree/nbtutils.c:849">_bt_sort_array_elements</a>() -- sort and de-dup array elements<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The array elements are sorted in-place, and the new number of elements<br/></li>
<li></span><span class="Comment"> * after duplicate removal is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * skey identifies the index column whose opfamily determines the comparison<br/></li>
<li></span><span class="Comment"> * semantics, and sortproc is a corresponding ORDER proc.&nbsp; If reverse is true,<br/></li>
<li></span><span class="Comment"> * we sort in descending order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L849">&#x200c;</a></span><span class="linkable">_bt_sort_array_elements</span>(ScanKey skey, FmgrInfo *sortproc, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reverse,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *elems, <span class="Type">int</span> nelems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L35" title="access/nbtree/nbtutils.c:35">BTSortArrayContext</a> cxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nelems &lt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nelems;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no work to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Sort the array elements */<br/></li>
<li></span>&nbsp; &nbsp; cxt.sortproc = sortproc;<br/></li>
<li>&nbsp; &nbsp; cxt.collation = skey-&gt;sk_collation;<br/></li>
<li>&nbsp; &nbsp; cxt.reverse = reverse;<br/></li>
<li>&nbsp; &nbsp; qsort_arg(elems, nelems, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1099" title="access/nbtree/nbtutils.c:1099">_bt_compare_array_elements</a>, &amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now scan the sorted elements and remove duplicates */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> qunique_arg(elems, nelems, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1099" title="access/nbtree/nbtutils.c:1099">_bt_compare_array_elements</a>, &amp;cxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L893" title="access/nbtree/nbtutils.c:893">_bt_merge_arrays</a>() -- <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array's elements into an original array<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called when preprocessing encounters a pair of array equality scan keys,<br/></li>
<li></span><span class="Comment"> * both against the same index attribute (during initial array preprocessing).<br/></li>
<li></span><span class="Comment"> * Merging reorganizes caller's original array (the left hand arg) in-place,<br/></li>
<li></span><span class="Comment"> * without ever copying elements from one array into the other. (Mixing the<br/></li>
<li></span><span class="Comment"> * elements together like this would be wrong, since they don't necessarily<br/></li>
<li></span><span class="Comment"> * use the same underlying <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type, despite all the other similarities.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Both arrays must have already been sorted and deduplicated by calling<br/></li>
<li></span><span class="Comment"> * <a href="#L849" title="access/nbtree/nbtutils.c:849">_bt_sort_array_elements</a>.&nbsp; sortproc is the same-type ORDER proc that was<br/></li>
<li></span><span class="Comment"> * just used to sort and deduplicate caller's &quot;<a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>&quot; array.&nbsp; We'll usually be<br/></li>
<li></span><span class="Comment"> * able to reuse that order PROC to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> the arrays together <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; If not,<br/></li>
<li></span><span class="Comment"> * then we'll perform a separate ORDER proc lookup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the opfamily doesn't supply a complete set of cross-type ORDER procs we<br/></li>
<li></span><span class="Comment"> * may not be able to determine which elements are contradictory.&nbsp; If we have<br/></li>
<li></span><span class="Comment"> * the required ORDER proc then we return true (and validly set *nelems_orig),<br/></li>
<li></span><span class="Comment"> * guaranteeing that at least the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array can be considered redundant.&nbsp; We<br/></li>
<li></span><span class="Comment"> * return false if the required comparisons cannot not be made (caller must<br/></li>
<li></span><span class="Comment"> * keep both arrays when this happens).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L893">&#x200c;</a></span><span class="linkable">_bt_merge_arrays</span>(IndexScanDesc scan, ScanKey skey, FmgrInfo *sortproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reverse, Oid origelemtype, Oid nextelemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *elems_orig, <span class="Type">int</span> *nelems_orig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *elems_next, <span class="Type">int</span> nelems_next)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <a href="#L35" title="access/nbtree/nbtutils.c:35">BTSortArrayContext</a> cxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems_orig_start = *nelems_orig,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems_orig_merged = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *mergeproc = sortproc;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; crosstypeproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(skey-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(origelemtype) &amp;&amp; OidIsValid(nextelemtype));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (origelemtype != nextelemtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure cmp_proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cross-array-<a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>-type merging is required, so can't just reuse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sortproc when merging<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(rel-&gt;rd_opfamily[skey-&gt;sk_attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origelemtype, nextelemtype, BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't make the required comparisons */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have all we need to determine redundancy/contradictoriness */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mergeproc = &amp;crosstypeproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L137" title="utils/fmgr/fmgr.c:137">fmgr_info_cxt</a>(cmp_proc, mergeproc, so-&gt;arrayContext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt.sortproc = mergeproc;<br/></li>
<li>&nbsp; &nbsp; cxt.collation = skey-&gt;sk_collation;<br/></li>
<li>&nbsp; &nbsp; cxt.reverse = reverse;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>, j = <span class="Constant">0</span>; i &lt; nelems_orig_start &amp;&amp; j &lt; nelems_next;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *oelem = elems_orig + i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *nelem = elems_next + j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="#L1099" title="access/nbtree/nbtutils.c:1099">_bt_compare_array_elements</a>(oelem, nelem, &amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elems_orig[nelems_orig_merged++] = *oelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* res &gt; 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nelems_orig = nelems_orig_merged;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare an array scan key to a scalar scan key, eliminating contradictory<br/></li>
<li></span><span class="Comment"> * array elements such that the scalar scan key becomes redundant.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Array elements can be eliminated as contradictory when excluded by some<br/></li>
<li></span><span class="Comment"> * other operator on the same attribute.&nbsp; For example, with an index scan qual<br/></li>
<li></span><span class="Comment"> * &quot;WHERE a IN (1, 2, 3) AND a &lt; 2&quot;, all array elements except the value &quot;1&quot;<br/></li>
<li></span><span class="Comment"> * are eliminated, and the &lt; scan key is eliminated as redundant.&nbsp; Cases where<br/></li>
<li></span><span class="Comment"> * every array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is eliminated by a redundant scalar scan key have an<br/></li>
<li></span><span class="Comment"> * unsatisfiable qual, which we handle by setting *qual_ok=false for caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the opfamily doesn't supply a complete set of cross-type ORDER procs we<br/></li>
<li></span><span class="Comment"> * may not be able to determine which elements are contradictory.&nbsp; If we have<br/></li>
<li></span><span class="Comment"> * the required ORDER proc then we return true (and validly set *qual_ok),<br/></li>
<li></span><span class="Comment"> * guaranteeing that at least the scalar scan key can be considered redundant.<br/></li>
<li></span><span class="Comment"> * We return false if the comparison could not be made (caller must keep both<br/></li>
<li></span><span class="Comment"> * scan keys when this happens).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L976">&#x200c;</a></span><span class="linkable">_bt_compare_array_scankey_args</span>(IndexScanDesc scan, ScanKey arraysk, ScanKey skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FmgrInfo *orderproc, BTArrayKeyInfo *array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *qual_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype = rel-&gt;rd_opcintype[arraysk-&gt;sk_attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpexact = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchelem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_nelems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp; &nbsp; crosstypeproc;<br/></li>
<li>&nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *orderprocp = orderproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(arraysk-&gt;sk_attno == skey-&gt;sk_attno);<br/></li>
<li>&nbsp; &nbsp; Assert(array-&gt;num_elems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!(arraysk-&gt;sk_flags &amp; (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)));<br/></li>
<li>&nbsp; &nbsp; Assert((arraysk-&gt;sk_flags &amp; SK_SEARCHARRAY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arraysk-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; Assert(!(skey-&gt;sk_flags &amp; (SK_ISNULL | SK_ROW_HEADER | SK_ROW_MEMBER)));<br/></li>
<li>&nbsp; &nbsp; Assert(!(skey-&gt;sk_flags &amp; SK_SEARCHARRAY) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; skey-&gt;sk_strategy != BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1201" title="access/nbtree/nbtutils.c:1201">_bt_binsrch_array_skey</a> searches an array for the entry best matching a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * datum of opclass input type for the index's attribute (on-disk type).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can reuse the array's ORDER proc whenever the non-array scan key's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type is a match for the corresponding attribute's input opclass type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we have to do another ORDER proc lookup so that our call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1201" title="access/nbtree/nbtutils.c:1201">_bt_binsrch_array_skey</a> applies the correct comparator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we have to support the convention that sk_subtype == InvalidOid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * means the opclass input type; this is a hack to simplify life for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_subtype != opcintype &amp;&amp; skey-&gt;sk_subtype != InvalidOid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure cmp_proc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraysk_elemtype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need an ORDER proc lookup to detect redundancy/contradictoriness<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with this pair of scankeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scalar scan key's argument will be passed to <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as its tupdatum/lefthand argument (rhs arg is for array elements).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; arraysk_elemtype = arraysk-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arraysk_elemtype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arraysk_elemtype = rel-&gt;rd_opcintype[arraysk-&gt;sk_attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(rel-&gt;rd_opfamily[arraysk-&gt;sk_attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; skey-&gt;sk_subtype, arraysk_elemtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't make the comparison */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *qual_ok = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* suppress compiler warnings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have all we need to determine redundancy/contradictoriness */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; orderprocp = &amp;crosstypeproc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/fmgr/fmgr.c.html#L127" title="utils/fmgr/fmgr.c:127">fmgr_info</a>(cmp_proc, orderprocp);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; matchelem = <a href="#L1201" title="access/nbtree/nbtutils.c:1201">_bt_binsrch_array_skey</a>(orderprocp, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NoMovementScanDirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; skey-&gt;sk_argument, <span class="Constant">false</span>, array,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; arraysk, &amp;cmpresult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (skey-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpexact = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* exclude exact match, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &gt;= cmpexact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchelem++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Resize, keeping elements from the start of the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_nelems = matchelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* qual is unsatisfiable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_nelems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shift matching <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to the start of the array, <a href="../../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;elem_values[<span class="Constant">0</span>] = array-&gt;elem_values[matchelem];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_nelems = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpexact = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* include exact match, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult &gt;= cmpexact)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchelem++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shift matching elements to the start of the array, <a href="../../lib/dshash.c.html#L858" title="lib/dshash.c:858">resize</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_nelems = array-&gt;num_elems - matchelem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memmove(array-&gt;elem_values, array-&gt;elem_values + matchelem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * new_nelems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized StrategyNumber: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) skey-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(new_nelems &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(new_nelems &lt;= array-&gt;num_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; array-&gt;num_elems = new_nelems;<br/></li>
<li>&nbsp; &nbsp; *qual_ok = new_nelems &gt; <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort_arg comparator for sorting array elements<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1099">&#x200c;</a></span><span class="linkable">_bt_compare_array_elements</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; da = *((<span class="Type">const</span> Datum *) a);<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; db = *((<span class="Type">const</span> Datum *) b);<br/></li>
<li>&nbsp; &nbsp; <a href="#L35" title="access/nbtree/nbtutils.c:35">BTSortArrayContext</a> *cxt = (<a href="#L35" title="access/nbtree/nbtutils.c:35">BTSortArrayContext</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(cxt-&gt;sortproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; da, db));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;reverse)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; INVERT_COMPARE_RESULT(<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>() -- apply array comparison function<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compares caller's tuple attribute value to a scan key/array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> * Helper function used during binary searches of SK_SEARCHARRAY arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine returns:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;0 if tupdatum &lt; arrdatum;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0 if tupdatum == arrdatum;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;0 if tupdatum &gt; arrdatum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is essentially the same interface as <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>: both <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the value that they're searching for to a binary search pivot.<br/></li>
<li></span><span class="Comment"> * However, unlike <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>, this function's &quot;tuple argument&quot; comes first,<br/></li>
<li></span><span class="Comment"> * while its &quot;array/scankey argument&quot; comes second.<br/></li>
<li></span><span class="Comment">*/<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> int32<br/></li>
<li><a id="L1131">&#x200c;</a><span class="linkable">_bt_compare_array_skey</span>(FmgrInfo *orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum tupdatum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum arrdatum, ScanKey cur)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(cur-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tupnull)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL tupdatum */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;=&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;&lt;&quot; NOT_NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;&gt;&quot; NOT_NULL */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_ISNULL) <span class="Comment">/* NOT_NULL tupdatum, NULL arrdatum */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT_NULL &quot;&gt;&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT_NULL &quot;&lt;&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>, we need to be careful of cross-type comparisons,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so the left value has to be the value that came from an index tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(orderproc, cur-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdatum, arrdatum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We flip the sign by following the obvious rule: flip whenever the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column is a DESC column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a> does it the wrong way around (flip when *ASC*) in order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to compensate for passing its orderproc arguments backwards.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't need to play these games because we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it natural to pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tupdatum as the left value (and arrdatum as the right value).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_BT_DESC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVERT_COMPARE_RESULT(result);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1201" title="access/nbtree/nbtutils.c:1201">_bt_binsrch_array_skey</a>() -- Binary search for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> matching array key<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an index to the first array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> &gt;= caller's tupdatum argument.<br/></li>
<li></span><span class="Comment"> * This convention is more natural for forwards scan callers, but that can't<br/></li>
<li></span><span class="Comment"> * really matter to backwards scan callers.&nbsp; Both callers require handling for<br/></li>
<li></span><span class="Comment"> * the case where the match we return is &lt; tupdatum, and symmetric handling<br/></li>
<li></span><span class="Comment"> * for the case where our best match is &gt; tupdatum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also sets *set_elem_result to the result <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a> returned<br/></li>
<li></span><span class="Comment"> * when we used it to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the matching array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to tupdatum/tupnull.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * cur_elem_trig indicates if array advancement was triggered by this array's<br/></li>
<li></span><span class="Comment"> * scan key, and that the array is for a required scan key.&nbsp; We can apply this<br/></li>
<li></span><span class="Comment"> * information to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> matching array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the current scan<br/></li>
<li></span><span class="Comment"> * direction using far fewer comparisons (fewer on average, compared to naive<br/></li>
<li></span><span class="Comment"> * binary search).&nbsp; This scheme takes advantage of an important property of<br/></li>
<li></span><span class="Comment"> * required arrays: required arrays always advance in lockstep with the index<br/></li>
<li></span><span class="Comment"> * scan's progress through the index's key space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1201">&#x200c;</a></span><span class="linkable">_bt_binsrch_array_skey</span>(FmgrInfo *orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> cur_elem_trig, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum tupdatum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTArrayKeyInfo *array, ScanKey cur,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 *set_elem_result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low_elem = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid_elem = -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high_elem = array-&gt;num_elems - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; arrdatum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(cur-&gt;sk_flags &amp; SK_SEARCHARRAY);<br/></li>
<li>&nbsp; &nbsp; Assert(cur-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_elem_trig)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!ScanDirectionIsNoMovement(dir));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cur-&gt;sk_flags &amp; SK_BT_REQFWD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the scan key that triggered array advancement is a required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array scan key, it is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> certain that the current array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (plus all prior elements relative to the current scan direction)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot possibly be at or ahead of the corresponding tuple value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> must have called <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * makes sure this is true as a condition of advancing the arrays.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This makes it safe to exclude array elements up to and including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the former-current array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> from our search.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Separately, when array advancement was triggered by a required scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key, the array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> immediately after the former-current <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is often either an exact tupdatum match, or a &quot;close by&quot; near-match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (a near-match tupdatum is one whose key space falls _between_ the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * former-current and new-current array elements).&nbsp; We'll detect both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases via an optimistic comparison of the new search <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (or new search <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound in the case of backwards scans).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low_elem = array-&gt;cur_elem + <span class="Constant">1</span>; <span class="Comment">/* old cur_elem exhausted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare prospective new cur_elem (also the new <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (high_elem &gt;= low_elem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrdatum = array-&gt;elem_values[low_elem];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(orderproc, tupdatum, tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrdatum, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Optimistic comparison optimization worked out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *set_elem_result = result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> low_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid_elem = low_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low_elem++;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this cur_elem exhausted, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (high_elem &lt; low_elem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller needs to perform &quot;beyond end&quot; array advancement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *set_elem_result = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> high_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high_elem = array-&gt;cur_elem - <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* old cur_elem exhausted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compare prospective new cur_elem (also the new <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (high_elem &gt;= low_elem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrdatum = array-&gt;elem_values[high_elem];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(orderproc, tupdatum, tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrdatum, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Optimistic comparison optimization worked out */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *set_elem_result = result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> high_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid_elem = high_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high_elem--;&nbsp; &nbsp; <span class="Comment">/* this cur_elem exhausted, too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (high_elem &lt; low_elem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller needs to perform &quot;beyond end&quot; array advancement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *set_elem_result = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> low_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high_elem &gt; low_elem)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid_elem = low_elem + ((high_elem - low_elem) / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arrdatum = array-&gt;elem_values[mid_elem];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(orderproc, tupdatum, tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrdatum, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's safe to quit as soon as we see an <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This often saves an extra comparison or two...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low_elem = mid_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low_elem = mid_elem + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high_elem = mid_elem;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ...but our caller also cares about how its searched-for tuple datum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compares to the low_elem datum.&nbsp; Must always set *set_elem_result with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the result of that comparison specifically.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (low_elem != mid_elem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(orderproc, tupdatum, tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;elem_values[low_elem], cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *set_elem_result = result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> low_elem;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1343" title="access/nbtree/nbtutils.c:1343">_bt_start_array_keys</a>() -- Initialize array keys at start of a scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set up the cur_elem counters and fill in the first sk_argument value for<br/></li>
<li></span><span class="Comment"> * each array scankey.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1343">&#x200c;</a></span><span class="linkable">_bt_start_array_keys</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;numArrayKeys);<br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;qual_ok);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; so-&gt;numArrayKeys; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *curArrayKey = &amp;so-&gt;arrayKeys[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; skey = &amp;so-&gt;keyData[curArrayKey-&gt;scan_key];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(curArrayKey-&gt;num_elems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(skey-&gt;sk_flags &amp; SK_SEARCHARRAY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curArrayKey-&gt;cur_elem = curArrayKey-&gt;num_elems - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curArrayKey-&gt;cur_elem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_argument = curArrayKey-&gt;elem_values[curArrayKey-&gt;cur_elem];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1381" title="access/nbtree/nbtutils.c:1381">_bt_advance_array_keys_increment</a>() -- Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of array elements<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Advances the array keys by a single increment in the current scan<br/></li>
<li></span><span class="Comment"> * direction.&nbsp; When there are multiple array keys this can roll over from the<br/></li>
<li></span><span class="Comment"> * lowest order array to higher order arrays.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if there is another set of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to consider, false if not.<br/></li>
<li></span><span class="Comment"> * On true result, the scankeys are initialized with the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> * On false result, the scankeys stay the same, and the array keys are not<br/></li>
<li></span><span class="Comment"> * advanced (every array remains at its final <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for scan direction).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1381">&#x200c;</a></span><span class="linkable">_bt_advance_array_keys_increment</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must advance the last array key most quickly, since it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correspond to the lowest-order index column among the available<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * qualifications<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = so-&gt;numArrayKeys - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *curArrayKey = &amp;so-&gt;arrayKeys[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; skey = &amp;so-&gt;keyData[curArrayKey-&gt;scan_key];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_elem = curArrayKey-&gt;cur_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_elems = curArrayKey-&gt;num_elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rolled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir) &amp;&amp; ++cur_elem &gt;= num_elems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_elem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rolled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ScanDirectionIsBackward(dir) &amp;&amp; --cur_elem &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_elem = num_elems - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rolled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curArrayKey-&gt;cur_elem = cur_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_argument = curArrayKey-&gt;elem_values[cur_elem];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rolled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need to advance <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array key, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The array keys are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> exhausted.&nbsp; (There isn't actually a distinct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state that represents array exhaustion, since index scans don't always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end after <a href="nbtree.c.html#L206" title="access/nbtree/nbtree.c:206">btgettuple</a> returns &quot;false&quot;.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Restore the array keys to the state they were in immediately <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were called.&nbsp; This ensures that the arrays only ever ratchet in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current scan direction.&nbsp; Without this, scans would overlook matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples if and when the scan's direction was subsequently reversed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1343" title="access/nbtree/nbtutils.c:1343">_bt_start_array_keys</a>(scan, -dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1467" title="access/nbtree/nbtutils.c:1467">_bt_rewind_nonrequired_arrays</a>() -- Rewind non-required arrays<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called when <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> decides to start a new primitive index<br/></li>
<li></span><span class="Comment"> * scan on the basis of the current scan position being <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the position<br/></li>
<li></span><span class="Comment"> * that <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> is capable of repositioning the scan to by applying an<br/></li>
<li></span><span class="Comment"> * inequality operator required in the opposite-to-scan direction only.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although equality strategy scan keys (for both arrays and non-arrays alike)<br/></li>
<li></span><span class="Comment"> * are either marked required in both directions or in neither direction,<br/></li>
<li></span><span class="Comment"> * there is a sense in which non-required arrays behave like required arrays.<br/></li>
<li></span><span class="Comment"> * With a qual such as &quot;WHERE a IN (100, 200) AND b &gt;= 3 AND c IN (5, 6, 7)&quot;,<br/></li>
<li></span><span class="Comment"> * the scan key on &quot;c&quot; is non-required, but nevertheless enables positioning<br/></li>
<li></span><span class="Comment"> * the scan at the first tuple &gt;= &quot;(100, 3, 5)&quot; on the leaf level during the<br/></li>
<li></span><span class="Comment"> * first descent of the tree by <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>.&nbsp; Later on, there could also be a<br/></li>
<li></span><span class="Comment"> * second descent, that places the scan right <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> tuples &gt;= &quot;(200, 3, 5)&quot;.<br/></li>
<li></span><span class="Comment"> * <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> must never be allowed to build an insertion scan key whose &quot;c&quot;<br/></li>
<li></span><span class="Comment"> * entry is set to a value other than 5, the &quot;c&quot; array's first <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>/value.<br/></li>
<li></span><span class="Comment"> * (Actually, it's the first in the current scan direction.&nbsp; This example uses<br/></li>
<li></span><span class="Comment"> * a forward scan.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calling here resets the array scan key elements for the scan's non-required<br/></li>
<li></span><span class="Comment"> * arrays.&nbsp; This is strictly necessary for correctness in a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of cases<br/></li>
<li></span><span class="Comment"> * involving &quot;required in opposite direction&quot;-triggered primitive index scans.<br/></li>
<li></span><span class="Comment"> * Not all callers are at risk of <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> using a non-required array like<br/></li>
<li></span><span class="Comment"> * this, but advancement always resets the arrays when another primitive scan<br/></li>
<li></span><span class="Comment"> * is scheduled, just to keep things simple.&nbsp; Array advancement even makes<br/></li>
<li></span><span class="Comment"> * sure to reset non-required arrays during scans that have no inequalities.<br/></li>
<li></span><span class="Comment"> * (Advancement still won't call here when there are no inequalities, though<br/></li>
<li></span><span class="Comment"> * that's just because it's all handled indirectly instead.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="#L3010" title="access/nbtree/nbtutils.c:3010">_bt_verify_arrays_bt_first</a> is called by an assertion to enforce that<br/></li>
<li></span><span class="Comment"> * everybody got this right.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1467">&#x200c;</a></span><span class="linkable">_bt_rewind_nonrequired_arrays</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> ikey = <span class="Constant">0</span>; ikey &lt; so-&gt;numberOfKeys; ikey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur = so-&gt;keyData + ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(cur-&gt;sk_flags &amp; SK_SEARCHARRAY) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_strategy != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[arrayidx++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(array-&gt;scan_key == ikey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir = array-&gt;num_elems - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;cur_elem != first_elem_dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;cur_elem = first_elem_dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument = array-&gt;elem_values[first_elem_dir];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>() -- too early to advance required arrays?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We always <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the tuple using the current array keys (which we assume<br/></li>
<li></span><span class="Comment"> * are already set in so-&gt;keyData[]).&nbsp; readpagetup indicates if tuple is the<br/></li>
<li></span><span class="Comment"> * scan's current <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>-wise tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * readpagetup callers must only call here when <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> already set<br/></li>
<li></span><span class="Comment"> * continuescan=false.&nbsp; We <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> these callers deal with <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>'s<br/></li>
<li></span><span class="Comment"> * inability to distinguishing between the &lt; and &gt; cases (it uses equality<br/></li>
<li></span><span class="Comment"> * operator scan keys, whereas we use 3-way ORDER procs).&nbsp; These callers pass<br/></li>
<li></span><span class="Comment"> * a <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>-set sktrig value that indicates which scan key<br/></li>
<li></span><span class="Comment"> * triggered the call (!readpagetup callers just pass us sktrig=0 instead).<br/></li>
<li></span><span class="Comment"> * This information allows us to avoid wastefully checking earlier scan keys<br/></li>
<li></span><span class="Comment"> * that were already deemed to have been satisfied inside <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false when caller's tuple is &gt;= the current required equality scan<br/></li>
<li></span><span class="Comment"> * keys (or &lt;=, in the case of backwards scans).&nbsp; This happens to readpagetup<br/></li>
<li></span><span class="Comment"> * callers when the scan has reached the point of needing its array keys<br/></li>
<li></span><span class="Comment"> * advanced; caller will need to advance required and non-required arrays at<br/></li>
<li></span><span class="Comment"> * scan key offsets &gt;= sktrig, plus scan keys &lt; sktrig iff sktrig rolls over.<br/></li>
<li></span><span class="Comment"> * (When we return false to readpagetup callers, tuple can only be == current<br/></li>
<li></span><span class="Comment"> * required equality scan keys when caller's sktrig indicates that the arrays<br/></li>
<li></span><span class="Comment"> * need to be advanced due to an unsatisfied required inequality key <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true when caller passes a tuple that is &lt; the current set of<br/></li>
<li></span><span class="Comment"> * equality keys for the most significant non-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> required scan key/column<br/></li>
<li></span><span class="Comment"> * (or &gt; the keys, during backwards scans).&nbsp; This happens to readpagetup<br/></li>
<li></span><span class="Comment"> * callers when tuple is still <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of matches for the scan's<br/></li>
<li></span><span class="Comment"> * required equality strategy scan keys.&nbsp; (sktrig can't have indicated that an<br/></li>
<li></span><span class="Comment"> * inequality strategy scan key wasn't satisfied in <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> when we<br/></li>
<li></span><span class="Comment"> * return true.&nbsp; In fact, we automatically return false when passed such an<br/></li>
<li></span><span class="Comment"> * inequality sktrig by readpagetup callers -- <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>'s initial<br/></li>
<li></span><span class="Comment"> * continuescan=false doesn't really need to be confirmed here by us.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * !readpagetup callers optionally pass us *scanBehind, which tracks whether<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> missing truncated attributes might have affected array advancement<br/></li>
<li></span><span class="Comment"> * (compared to what would happen if it was shown the first non-pivot tuple on<br/></li>
<li></span><span class="Comment"> * the page to the right of caller's finaltup/high key tuple instead).&nbsp; It's<br/></li>
<li></span><span class="Comment"> * only possible that we'll set *scanBehind to true when caller passes us a<br/></li>
<li></span><span class="Comment"> * pivot tuple (with truncated -inf attributes) that we return false for.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1544">&#x200c;</a></span><span class="linkable">_bt_tuple_before_array_skeys</span>(IndexScanDesc scan, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple tuple, TupleDesc tupdesc, <span class="Type">int</span> tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> readpagetup, <span class="Type">int</span> sktrig, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *scanBehind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;numArrayKeys);<br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;numberOfKeys);<br/></li>
<li>&nbsp; &nbsp; Assert(sktrig == <span class="Constant">0</span> || readpagetup);<br/></li>
<li>&nbsp; &nbsp; Assert(!readpagetup || scanBehind == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scanBehind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *scanBehind = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> ikey = sktrig; ikey &lt; so-&gt;numberOfKeys; ikey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur = so-&gt;keyData + ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tupdatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tupnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* readpagetup calls require one ORDER proc comparison (at most) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!readpagetup || ikey == sktrig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we reach a non-required scan key, we're completely done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we deliberately don't consider the scan direction here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> caller requires that we track *scanBehind<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without concern for scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD)) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!readpagetup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ikey &gt; sktrig || ikey == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_attno &gt; tupnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!readpagetup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we reach a high key's truncated attribute, assume that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple attribute's value is &gt;= the scan's equality constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan keys (but set *scanBehind to let interested callers know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that a truncated attribute might have affected our answer).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scanBehind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *scanBehind = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Deal with inequality strategy scan keys that <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continuescan=false for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_strategy != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> indicated that a required inequality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan key wasn't satisfied, there's no need to verify anything;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller always calls <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> with this sktrig.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readpagetup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we can't give up, since we must check all required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan keys (required in either direction) in order to correctly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * track *scanBehind for caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tupdatum = index_getattr(tuple, cur-&gt;sk_attno, tupdesc, &amp;tupnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(&amp;so-&gt;orderProcs[ikey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdatum, tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument, cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does this comparison indicate that caller must _not_ advance the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan's arrays just yet?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((ScanDirectionIsForward(dir) &amp;&amp; result &lt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ScanDirectionIsBackward(dir) &amp;&amp; result &gt; <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does this comparison indicate that caller should <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> advance the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan's arrays?&nbsp; (Must be if we get here during a readpagetup call.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (readpagetup || result != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(result != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Inconclusive -- need to check later scan keys, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This must be a finaltup precheck, or a call made from an assertion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(result == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!readpagetup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1668" title="access/nbtree/nbtutils.c:1668">_bt_start_prim_scan</a>() -- start scheduled primitive index scan?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> scheduled another primitive index scan, just<br/></li>
<li></span><span class="Comment"> * as the last one ended.&nbsp; Otherwise returns false, indicating that the array<br/></li>
<li></span><span class="Comment"> * keys are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fully exhausted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only call here during scans with one or more equality type array scan keys,<br/></li>
<li></span><span class="Comment"> * after <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> or <a href="nbtsearch.c.html#L1492" title="access/nbtree/nbtsearch.c:1492">_bt_next</a> return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1668">&#x200c;</a></span><span class="linkable">_bt_start_prim_scan</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;numArrayKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* scanBehind flag doesn't persist across primitive index scans - reset */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Array keys are advanced within <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> when the scan reaches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaf level (more precisely, they're advanced when the scan reaches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of each distinct set of array elements).&nbsp; This process avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> access to leaf pages (across multiple primitive index scans) by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advancing the scan's array keys when it allows the primitive index scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> nearby matching tuples (or when it eliminates ranges of array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key space that can't possibly be satisfied by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index tuple).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> sets a simple flag variable to schedule another primitive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index scan.&nbsp; The flag tells us what to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot rely on <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> always reaching <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>.&nbsp; There are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * various cases where that won't happen.&nbsp; For example, if the index is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completely empty, then <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> won't call <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>/<a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also don't expect a call to <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> during searches for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-existent value that happens to be <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>/higher than <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value in the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't require special handling for these cases -- we don't need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be explicitly instructed to _not_ perform another primitive index scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's up to code under the control of <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> to always set the flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when another primitive index scan will be required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This works correctly, even with the tricky cases listed above, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all involve access to leaf pages &quot;near the boundaries of the key space&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (whether it's from a leftmost/rightmost page, or an imaginary empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaf root page).&nbsp; If <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> cannot be reached by a primitive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index scan for one set of array keys, then it also won't be reached for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later set (&quot;later&quot; in terms of the direction that we scan the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and advance the arrays).&nbsp; The array keys won't have advanced in these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases, but that's the correct behavior (even <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't always advance the arrays at the point they become &quot;exhausted&quot;).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;needPrimScan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L3010" title="access/nbtree/nbtutils.c:3010">_bt_verify_arrays_bt_first</a>(scan, dir));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Flag was set -- must call <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> again, which will reset the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan's needPrimScan flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The top-level index scan ran out of tuples in this scan direction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a>() -- Advance array elements using a tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The scan always gets a new qual as a consequence of calling here (except<br/></li>
<li></span><span class="Comment"> * when we determine that the top-level scan has run out of matching tuples).<br/></li>
<li></span><span class="Comment"> * All later <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> calls also use the same new qual that was first<br/></li>
<li></span><span class="Comment"> * used here (at least until the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call here advances the keys once again).<br/></li>
<li></span><span class="Comment"> * It's convenient to structure <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> rechecks of caller's tuple<br/></li>
<li></span><span class="Comment"> * (using the new qual) as one the steps of advancing the scan's array keys,<br/></li>
<li></span><span class="Comment"> * so this function works as a wrapper around <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>, we'll set pstate.continuescan on behalf of the<br/></li>
<li></span><span class="Comment"> * caller, and return a boolean indicating if caller's tuple satisfies the<br/></li>
<li></span><span class="Comment"> * scan's new qual.&nbsp; But unlike <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>, we set so-&gt;needPrimScan<br/></li>
<li></span><span class="Comment"> * when we set continuescan=false, indicating if a new primitive index scan<br/></li>
<li></span><span class="Comment"> * has been scheduled (otherwise, the top-level scan has run out of tuples in<br/></li>
<li></span><span class="Comment"> * the current scan direction).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must use <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a> to determine if the current<br/></li>
<li></span><span class="Comment"> * place in the scan is &gt;= the current array keys _before_ calling here.<br/></li>
<li></span><span class="Comment"> * We're responsible for ensuring that caller's tuple is &lt;= the newly advanced<br/></li>
<li></span><span class="Comment"> * required array keys once we return.&nbsp; We try to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an exact match, but<br/></li>
<li></span><span class="Comment"> * failing that we'll advance the array keys to whatever set of array elements<br/></li>
<li></span><span class="Comment"> * comes <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> in the key space for the current scan direction.&nbsp; Required array<br/></li>
<li></span><span class="Comment"> * keys &quot;ratchet forwards&quot; (or backwards).&nbsp; They can only advance as the scan<br/></li>
<li></span><span class="Comment"> * itself advances through the index/key space.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (The rules are the same for backwards scans, except that the operators are<br/></li>
<li></span><span class="Comment"> * flipped: just replace the precondition's &gt;= operator with a &lt;=, and the<br/></li>
<li></span><span class="Comment"> * postcondition's &lt;= operator with a &gt;=.&nbsp; In other words, just swap the<br/></li>
<li></span><span class="Comment"> * precondition with the postcondition.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also deal with &quot;advancing&quot; non-required arrays here.&nbsp; Callers whose<br/></li>
<li></span><span class="Comment"> * sktrig scan key is non-required specify sktrig_required=false.&nbsp; These calls<br/></li>
<li></span><span class="Comment"> * are the only exception to the general rule about always advancing the<br/></li>
<li></span><span class="Comment"> * required array keys (the scan may not even have a required array).&nbsp; These<br/></li>
<li></span><span class="Comment"> * callers should just pass a NULL pstate (since there is never <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> question<br/></li>
<li></span><span class="Comment"> * of stopping the scan).&nbsp; No call to <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a> is required<br/></li>
<li></span><span class="Comment"> * ahead of these calls (it's already clear that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required scan keys must<br/></li>
<li></span><span class="Comment"> * be satisfied by caller's tuple).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we deal with non-array required equality strategy scan keys as<br/></li>
<li></span><span class="Comment"> * degenerate single <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> arrays here.&nbsp; Obviously, they can never really<br/></li>
<li></span><span class="Comment"> * advance in the way that real arrays can, but they must still affect how we<br/></li>
<li></span><span class="Comment"> * advance real array scan keys (exactly like true array equality scan keys).<br/></li>
<li></span><span class="Comment"> * We have to keep around a 3-way ORDER proc for these (using the &quot;=&quot; operator<br/></li>
<li></span><span class="Comment"> * won't do), since in general whether the tuple is &lt; or &gt; _any_ unsatisfied<br/></li>
<li></span><span class="Comment"> * required equality key influences how the scan's real arrays must advance.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note also that we may sometimes need to advance the array keys when the<br/></li>
<li></span><span class="Comment"> * existing required array keys (and other required equality keys) are already<br/></li>
<li></span><span class="Comment"> * an exact match for every corresponding value from caller's tuple.&nbsp; We must<br/></li>
<li></span><span class="Comment"> * do this for inequalities that <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> set continuescan=false for.<br/></li>
<li></span><span class="Comment"> * They'll advance the array keys here, just like <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other scan key that<br/></li>
<li></span><span class="Comment"> * <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> stops on.&nbsp; (This can even happen _after_ we advance the<br/></li>
<li></span><span class="Comment"> * array keys, in which case we'll advance the array keys a second time.&nbsp; That<br/></li>
<li></span><span class="Comment"> * way <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> caller always has its required arrays advance to the<br/></li>
<li></span><span class="Comment"> * maximum possible extent that its tuple will allow.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1789">&#x200c;</a></span><span class="linkable">_bt_advance_array_keys</span>(IndexScanDesc scan, BTReadPageState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple tuple, <span class="Type">int</span> tupnatts, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> sktrig, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> sktrig_required)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; ScanDirection dir = pstate ? pstate-&gt;dir : ForwardScanDirection;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; beyond_end_advance = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_required_opposite_direction_only = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oppodir_inequality_sktrig = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_required_satisfied = <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_satisfied = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sktrig_required)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Precondition array state assertion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, tuple, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupnatts, <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>; <span class="Comment">/* reset */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Required scan key wasn't satisfied, so required arrays will have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advance.&nbsp; Invalidate page-level state that tracks whether the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan's required-in-opposite-direction-only keys are known to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfied by page's remaining tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;firstmatch = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't have to invalidate 'prechecked', though */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!pstate-&gt;prechecked);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once we return we'll have a new set of required array keys, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset state used by &quot;look ahead&quot; optimization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;rechecks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;targetdistance = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L3048" title="access/nbtree/nbtutils.c:3048">_bt_verify_keys_with_arraykeys</a>(scan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> ikey = <span class="Constant">0</span>; ikey &lt; so-&gt;numberOfKeys; ikey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur = so-&gt;keyData + ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; tupdatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; required = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_opposite_direction_only = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_elem = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_strategy == BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Manage array state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_SEARCHARRAY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[arrayidx++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(array-&gt;scan_key == ikey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> inequalities required in the opposite direction only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * present here?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((ScanDirectionIsForward(dir) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur-&gt;sk_flags &amp; (SK_BT_REQBKWD))) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ScanDirectionIsBackward(dir) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur-&gt;sk_flags &amp; (SK_BT_REQFWD)))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_required_opposite_direction_only =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required_opposite_direction_only = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Optimization: <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over known-satisfied scan keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ikey &lt; sktrig)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sktrig_required);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; required = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_attno &gt; tupnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set this just like <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sktrig &lt; ikey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle a required non-array scan key that the initial call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> indicated triggered array advancement, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The non-array scan key's strategy will be &lt;, &lt;=, or = during a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forwards scan (or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one of =, &gt;=, or &gt; during a backwards scan).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It follows that the corresponding tuple attribute's value must <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be either &gt; or &gt;= the scan key value (for backwards scans it must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be either &lt; or &lt;= that value).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a required equality strategy scan key, this is just an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimization; <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a> already confirmed that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this scan key places us ahead of caller's tuple.&nbsp; There's no need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> that work <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; (The same underlying principle also gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applied by the cur_elem_trig optimization used to speed up searches<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a required inequality strategy scan key, we _must_ rely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> like this; we aren't capable of directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * evaluating required inequality strategy scan keys here, on our own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ikey == sktrig &amp;&amp; !array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sktrig_required &amp;&amp; required &amp;&amp; all_required_satisfied);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use &quot;beyond end&quot; advancement.&nbsp; See below for an explanation. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beyond_end_advance = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_satisfied = all_required_satisfied = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set a flag that remembers that this was an inequality required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the opposite scan direction only, that nevertheless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * triggered the call here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This only happens when an inequality operator (which must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strict) encounters a group of NULLs that indicate the end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for tuples in the current scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(required_opposite_direction_only))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oppodir_inequality_sktrig = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nothing more for us to do with an inequality strategy scan key that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wasn't the one that <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> stopped on, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: if our later call to <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> (to recheck caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple) sets continuescan=false due to finding this same inequality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unsatisfied (possible when it's required in the scan direction),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll deal with it via a recursive &quot;second pass&quot; call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cur-&gt;sk_strategy != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Nothing for us to do with an equality strategy scan key that isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked required, either -- unless it's a non-required array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!required &amp;&amp; !array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we perform steps for all array scan keys after a required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array scan key whose binary search triggered &quot;beyond end of array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&quot; array advancement due to encountering a tuple attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value &gt; the closest matching array key (or &lt; for backwards scans).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (beyond_end_advance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_elem_dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(dir) || !array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_elem_dir = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final_elem_dir = array-&gt;num_elems - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array &amp;&amp; array-&gt;cur_elem != final_elem_dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;cur_elem = final_elem_dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument = array-&gt;elem_values[final_elem_dir];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we perform steps for all array scan keys after a required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array scan key whose tuple attribute was &lt; the closest matching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array key when we dealt with it (or &gt; for backwards scans).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This earlier required array key already puts us ahead of caller's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple in the key space (for the current scan direction).&nbsp; We must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure that subsequent <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order array keys do not put us too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far ahead (ahead of tuples that have yet to be seen by our caller).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For example, when a tuple &quot;(a, b) = (42, 5)&quot; advances the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys on &quot;a&quot; from 40 to 45, we must also set &quot;b&quot; to whatever the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for &quot;b&quot; is.&nbsp; It would be wrong to allow &quot;b&quot; to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be set based on the tuple value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Perform the same steps with truncated high key attributes.&nbsp; You can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * think of this as a &quot;binary search&quot; for the <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> closest to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value -inf.&nbsp; Again, the arrays must never get ahead of the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!all_required_satisfied || cur-&gt;sk_attno &gt; tupnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir) || !array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir = array-&gt;num_elems - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array &amp;&amp; array-&gt;cur_elem != first_elem_dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;cur_elem = first_elem_dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument = array-&gt;elem_values[first_elem_dir];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Search in scankey's array for the corresponding tuple attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value from caller's tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tupdatum = index_getattr(tuple, cur-&gt;sk_attno, tupdesc, &amp;tupnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_elem_trig = (sktrig_required &amp;&amp; ikey == sktrig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Binary search for closest match that's available from the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_elem = <a href="#L1201" title="access/nbtree/nbtutils.c:1201">_bt_binsrch_array_skey</a>(&amp;so-&gt;orderProcs[ikey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_elem_trig, dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdatum, tupnull, array, cur,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(set_elem &gt;= <span class="Constant">0</span> &amp;&amp; set_elem &lt; array-&gt;num_elems);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sktrig_required &amp;&amp; required);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a required non-array equality strategy scan key, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll treat as a degenerate single <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This scan key's imaginary &quot;array&quot; can't really advance, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can still roll over like <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other array.&nbsp; (Actually, this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no different to real single value arrays, which never advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without rolling over -- they can never truly advance, either.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1131" title="access/nbtree/nbtutils.c:1131">_bt_compare_array_skey</a>(&amp;so-&gt;orderProcs[ikey],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdatum, tupnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument, cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider &quot;beyond end of array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&quot; array advancement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When the tuple attribute value is &gt; the closest matching array key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (or &lt; in the backwards scan case), we need to ratchet this array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forward (backward) by one increment, so that caller's tuple ends up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being &lt; final array value instead (or &gt; final array value instead).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This process has to work for all of the arrays, not just this one:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it must &quot;carry&quot; to higher-order arrays when the set_elem that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just found happens to be the final one for the scan's direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Incrementing (decrementing) set_elem itself isn't good enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Our approach is to provisionally use set_elem as if it was an exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * match <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, then set each later/less significant array to whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its final <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is.&nbsp; Once outside the loop we'll then &quot;increment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this array's set_elem&quot; by calling <a href="#L1381" title="access/nbtree/nbtutils.c:1381">_bt_advance_array_keys_increment</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That way the process rolls over to higher order arrays as needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Under this scheme <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required arrays only ever ratchet forwards<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (or backwards), and always do so to the maximum possible extent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we can know will be safe without seeing the scan's <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> special handling for required scan keys that lack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a real array to advance, nor for redundant scan keys that couldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be eliminated by <a href="#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a>.&nbsp; It won't matter if some of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our &quot;true&quot; array scan keys (or even all of them) are non-required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (required &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((ScanDirectionIsForward(dir) &amp;&amp; result &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (ScanDirectionIsBackward(dir) &amp;&amp; result &lt; <span class="Constant">0</span>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; beyond_end_advance = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(all_required_satisfied &amp;&amp; all_satisfied);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Track whether caller's tuple satisfies our new post-advancement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qual, for required scan keys, as well as for the entire set of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interesting scan keys (all required scan keys plus non-required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array scan keys are considered interesting.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_satisfied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (required)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; all_required_satisfied = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no need to advance the arrays using the best<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available match for a non-required array.&nbsp; Give up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Though note that sktrig_required calls still have to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all the usual post-advancement steps, including the recheck<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call to <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance array keys, even when set_elem isn't an exact match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array &amp;&amp; array-&gt;cur_elem != set_elem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;cur_elem = set_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_argument = array-&gt;elem_values[set_elem];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the array keys incrementally whenever &quot;beyond end of array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>&quot; array advancement happens, so that advancement will carry to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * higher-order arrays (might exhaust all the scan's arrays instead, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ends the top-level scan).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (beyond_end_advance &amp;&amp; !<a href="#L1381" title="access/nbtree/nbtutils.c:1381">_bt_advance_array_keys_increment</a>(scan, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> end_toplevel_scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L3048" title="access/nbtree/nbtutils.c:3048">_bt_verify_keys_with_arraykeys</a>(scan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Does tuple <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> satisfy our new qual?&nbsp; Recheck with <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calls triggered by an unsatisfied required scan key, whose tuple <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * satisfies all required scan keys, but not all nonrequired array keys,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will still require a recheck call to <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>.&nbsp; They'll still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need its &quot;second pass&quot; handling of required inequality scan keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Might have missed a still-unsatisfied required inequality scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that caller didn't detect as the sktrig scan key during its initial<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> call that used the old/original qual.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Calls triggered by an unsatisfied nonrequired array scan key never need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;second pass&quot; handling of required inequalities (nor <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other handling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required scan key).&nbsp; All that matters is whether caller's tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * satisfies the new qual, so it's safe to just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recheck when we've already determined that it can only return 'false'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((sktrig_required &amp;&amp; all_required_satisfied) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!sktrig_required &amp;&amp; all_satisfied))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsktrig = sktrig + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; continuescan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(all_required_satisfied);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recheck <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> on behalf of caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>(scan, dir, tuple, tupnatts, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;continuescan, &amp;nsktrig) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !so-&gt;scanBehind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This tuple satisfies the new qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(all_satisfied &amp;&amp; continuescan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;continuescan = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Consider &quot;second pass&quot; handling of required inequalities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that our <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> call indicated that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan should end due to some unsatisfied inequality that wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initially recognized as such by us.&nbsp; Handle this by calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ourselves recursively, this time indicating that the <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inequality that we missed first time around (and using a set of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required array/equality keys that are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> exact matches for tuple).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We make a strong, general guarantee that every <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here will advance the array keys to the maximum possible extent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we can know to be safe based on caller's tuple alone.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't perform this step, then that guarantee wouldn't quite hold.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!continuescan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; satisfied <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sktrig_required);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(so-&gt;keyData[nsktrig].sk_strategy != BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The tuple must use &quot;beyond end&quot; advancement during the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursive call, so we cannot possibly end up back here when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recursing.&nbsp; We'll consume a small, fixed amount of stack space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!beyond_end_advance);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Advance the array keys a second time using same tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; satisfied = <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a>(scan, pstate, tuple, tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupdesc, nsktrig, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This tuple doesn't satisfy the inequality */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!satisfied);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Some non-required scan key (from new qual) still not satisfied.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All scan keys required in the current scan direction must still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * satisfied, though, so we can trust all_required_satisfied below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we were called just to deal with &quot;advancing&quot; non-required arrays,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is as far as we can go (cannot stop the scan for these callers)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!sktrig_required)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller's tuple doesn't match <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postcondition array state assertion (for still-unsatisfied tuples).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here we have established that the scan's required arrays (scan must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have at least one required array) advanced, without becoming exhausted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller's tuple is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &lt; the newly advanced array keys (or &gt; when this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a backwards scan), except in the case where we only got this far due<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to an unsatisfied non-required scan key.&nbsp; Verify that with an assert.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we don't just quit at this point when all required scan keys were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found to be satisfied because we need to consider edge-cases involving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan keys required in the opposite direction only; those aren't tracked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by all_required_satisfied. (Actually, oppodir_inequality_sktrig <a href="../../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan keys are tracked by all_required_satisfied, since it's convenient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> to behave as if they are required in the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan direction to deal with NULLs.&nbsp; We'll account for that separately.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, tuple, tupdesc, tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !all_required_satisfied);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We generally permit primitive index scans to continue onto the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sibling page when the page's finaltup satisfies all required scan keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the point where we're between pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If caller's tuple is also the page's finaltup, and we see that required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan keys still aren't satisfied, start a new primitive index scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!all_required_satisfied &amp;&amp; pstate-&gt;finaltup == tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> new_prim_scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Proactively check finaltup (don't wait until finaltup is reached by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan) when it might well turn out to not be satisfied later on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if so-&gt;scanBehind hasn't already been set for finaltup by us,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it'll be set during this call to <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>.&nbsp; Either<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way, it'll be set correctly (for the whole page) after this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!all_required_satisfied &amp;&amp; pstate-&gt;finaltup &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, pstate-&gt;finaltup, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTreeTupleGetNAtts(pstate-&gt;finaltup, rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">0</span>, &amp;so-&gt;scanBehind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> new_prim_scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we encounter a truncated finaltup high key attribute, we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimistic about the chances of its corresponding required scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being satisfied when we go on to check it against tuples from this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page's right sibling leaf page.&nbsp; We consider truncated attributes to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * satisfied by required scan keys, which allows the primitive index scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to continue to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> leaf page.&nbsp; We must set so-&gt;scanBehind to true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to remember that the last page's finaltup had &quot;satisfied&quot; required scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys for one or more truncated attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (scan keys required in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * _either_ scan direction).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is a chance that <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> (which checks so-&gt;scanBehind) will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that even the sibling leaf page's finaltup is &lt; the new array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys.&nbsp; When that happens, our optimistic policy will have incurred a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single extra leaf page access that could have been avoided.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A pessimistic policy would give backward scans a gratuitous advantage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * over forward scans.&nbsp; We'd punish forward scans for applying more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurate information from the high key, rather than just using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * final non-pivot tuple as finaltup, in the style of backward scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Being pessimistic would also give some scans with non-required arrays a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * perverse advantage over similar scans that use required arrays instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * You can think of this as a speculative bet on what the scan is likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.&nbsp; It's not much of a gamble, though, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * untruncated prefix of attributes must strictly satisfy the new qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (though it's okay if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-required scan keys fail to be satisfied).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;scanBehind &amp;&amp; has_required_opposite_direction_only)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, we avoid this behavior whenever the scan involves a scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key required in the opposite direction to the scan only, along with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a finaltup with at least one truncated attribute that's associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with a scan key marked required (required in either direction).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> simply won't stop the scan for a scan key that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked required in the opposite scan direction only.&nbsp; That leaves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> reliable way of reconsidering <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> opposite-direction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inequalities if it turns out that starting a new primitive index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan will allow <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead by a great many leaf pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (see <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> section for details of how that works).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> new_prim_scan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle inequalities marked required in the opposite scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They can also signal that we should start a new primitive index scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that the scan is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> positioned where &quot;matching&quot; tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * begin, and that caller's tuple satisfies all scan keys required in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current scan direction.&nbsp; But if caller's tuple still doesn't satisfy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other scan keys that are required in the opposite scan direction only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (e.g., a required &gt;= strategy scan key when scan direction is forward),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's still possible that there are many leaf pages <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the page that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> could <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> straight to.&nbsp; Groveling through all those pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will always give correct answers, but it can be very inefficient.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must avoid needlessly scanning extra pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Separately, it's possible that <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> set continuescan=false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a scan key that's required in the opposite direction only.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a special case, that happens only when <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> sees that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inequality encountered a NULL value.&nbsp; This signals the end of non-NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the current scan direction, which is reason enough to end the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (primitive) scan.&nbsp; If this happens at the start of a large group of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, then we shouldn't expect to be called again until after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scan has already read indefinitely-many leaf pages full of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with NULL suffix <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; We need a separate test for this case so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> our only opportunity to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over such a group of pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (<a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> is expected to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over the group of NULLs by applying a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similar &quot;deduce NOT NULL&quot; rule, where it finishes its insertion scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key by consing up an explicit SK_SEARCHNOTNULL key.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply a test against finaltup to detect and recover from these problem:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if even finaltup doesn't satisfy such an inequality, we just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting a new primitive index scan.&nbsp; When we <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>, we know for sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that all of the tuples on the current page following caller's tuple are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>-wise start of tuples for our new qual.&nbsp; That<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least suggests many more skippable pages beyond the current page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (has_required_opposite_direction_only &amp;&amp; pstate-&gt;finaltup &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (all_required_satisfied || oppodir_inequality_sktrig))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nfinaltupatts = BTreeTupleGetNAtts(pstate-&gt;finaltup, rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanDirection flipped;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; continuescanflip;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opsktrig;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're checking finaltup (which is usually not caller's tuple), so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot reuse work from caller's earlier <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Flip the scan direction when calling <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> this time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that it will set continuescanflip=false when it encounters an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inequality required in the opposite scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!so-&gt;scanBehind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opsktrig = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; flipped = -dir;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>(scan, flipped,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;finaltup, nfinaltupatts, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;continuescanflip, &amp;opsktrig);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we ended up here due to the all_required_satisfied criteria,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * test opsktrig in a way that ensures that finaltup contains the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * prefix of key columns as caller's tuple (a prefix that satisfies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier required-in-current-direction scan keys).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we ended up here due to the oppodir_inequality_sktrig criteria,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * test opsktrig in a way that ensures that the same scan key that our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller found to be unsatisfied (by the scan's tuple) was also the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one unsatisfied just <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> (by finaltup).&nbsp; That way we'll only start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a new primitive scan when we're sure that both tuples _don't_ share<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the same prefix of satisfied equality-constrained attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and that finaltup has a non-NULL attribute value indicated by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unsatisfied scan key at offset opsktrig/sktrig.&nbsp; (This depends on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> not caring about the direction that inequalities<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are required in whenever NULL attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are unsatisfied.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only cares about the scan direction, and its relationship to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether NULLs are stored first or last relative to non-NULLs.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(all_required_satisfied != oppodir_inequality_sktrig);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!continuescanflip &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((all_required_satisfied &amp;&amp; opsktrig &gt; sktrig) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (oppodir_inequality_sktrig &amp;&amp; opsktrig &gt;= sktrig))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(so-&gt;keyData[opsktrig].sk_strategy != BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-required arrays are set to the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for the current scan direction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1467" title="access/nbtree/nbtutils.c:1467">_bt_rewind_nonrequired_arrays</a>(scan, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> new_prim_scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stick with the ongoing primitive index scan for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that later tuples will also turn out to have <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are still &lt; the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-current array keys (or &gt; the current array keys).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our caller will handle this by performing what amounts to a linear<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * search of the page, implemented by calling <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a> for each tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This approach has various advantages over a binary search of the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Repeated binary searches of the page (one binary search for every array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advancement) won't outperform a continuous linear search.&nbsp; While there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are workloads that a naive linear search won't handle well, our caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has a &quot;look ahead&quot; fallback mechanism to deal with that problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;continuescan = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* Override <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> has more tuples to check */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;scanBehind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Optimization: <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> by setting &quot;look ahead&quot; mechanism's offnum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ScanDirectionIsForward(dir));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = pstate-&gt;maxoff + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller's tuple doesn't match the new qual */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">new_prim_scan</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * End this primitive index scan, but schedule another.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: If the scan direction happens to change, this scheduled primitive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index scan won't go ahead after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;continuescan = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* Tell <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> we're done... */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* ...but call <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> again */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L771" title="access/nbtree/nbtree.c:771">_bt_parallel_primscan_schedule</a>(scan, pstate-&gt;prev_scan_page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller's tuple doesn't match the new qual */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Statement">end_toplevel_scan</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * End the current primitive index scan, but don't schedule another.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This ends the entire top-level scan in the current scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: The scan's arrays (including <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-required arrays) are <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their final positions for the current scan direction.&nbsp; If the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * direction happens to change, then the arrays will already be in their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first positions for what will then be the current scan direction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;continuescan = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* Tell <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> we're done... */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* ...don't call <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> again, though */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller's tuple doesn't match <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qual */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a>() -- Preprocess scan keys<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The given search-type keys (taken from scan-&gt;keyData[])<br/></li>
<li></span><span class="Comment"> * are copied to so-&gt;keyData[] with possible transformation.<br/></li>
<li></span><span class="Comment"> * scan-&gt;numberOfKeys is the number of input keys, so-&gt;numberOfKeys gets<br/></li>
<li></span><span class="Comment"> * the number of output keys (possibly less, never greater).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The output keys are marked with additional sk_flags bits beyond the<br/></li>
<li></span><span class="Comment"> * system-standard bits supplied by the caller.&nbsp; The DESC and NULLS_FIRST<br/></li>
<li></span><span class="Comment"> * indoption bits for the relevant index attribute are copied into the flags.<br/></li>
<li></span><span class="Comment"> * Also, for a DESC column, we commute (flip) all the sk_strategy numbers<br/></li>
<li></span><span class="Comment"> * so that the index sorts in the desired direction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One key purpose of this routine is to discover which scan keys must be<br/></li>
<li></span><span class="Comment"> * satisfied to continue the scan.&nbsp; It also attempts to eliminate redundant<br/></li>
<li></span><span class="Comment"> * keys and detect contradictory keys.&nbsp; (If the index opfamily provides<br/></li>
<li></span><span class="Comment"> * incomplete sets of cross-type operators, we may fail to detect redundant<br/></li>
<li></span><span class="Comment"> * or contradictory keys, but we can survive that.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The output keys must be sorted by index attribute.&nbsp; Presently we expect<br/></li>
<li></span><span class="Comment"> * (but verify) that the input keys are already so sorted --- this is done<br/></li>
<li></span><span class="Comment"> * by <a href="../../optimizer/path/indxpath.c.html#L2051" title="optimizer/path/indxpath.c:2051">match_clauses_to_index</a>() in indxpath.c.&nbsp; Some reordering of the keys<br/></li>
<li></span><span class="Comment"> * within each attribute may be done as a byproduct of the processing here.<br/></li>
<li></span><span class="Comment"> * That process must leave array scan keys (within an attribute) in the same<br/></li>
<li></span><span class="Comment"> * order as corresponding entries from the scan's BTArrayKeyInfo array info.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The output keys are marked with flags SK_BT_REQFWD and/or SK_BT_REQBKWD<br/></li>
<li></span><span class="Comment"> * if they must be satisfied in order to continue the scan forward or backward<br/></li>
<li></span><span class="Comment"> * respectively.&nbsp; <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> uses these flags.&nbsp; For example, if the quals<br/></li>
<li></span><span class="Comment"> * are &quot;x = 1 AND y &lt; 4 AND z &lt; 5&quot;, then <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> will reject a tuple<br/></li>
<li></span><span class="Comment"> * (1,2,7), but we must continue the scan in case there are tuples (1,3,z).<br/></li>
<li></span><span class="Comment"> * But once we reach tuples like (1,4,z) we can stop scanning because no<br/></li>
<li></span><span class="Comment"> * later tuples could match.&nbsp; This is reflected by marking the x and y keys,<br/></li>
<li></span><span class="Comment"> * but not the z key, with SK_BT_REQFWD.&nbsp; In general, the keys for leading<br/></li>
<li></span><span class="Comment"> * attributes with &quot;=&quot; keys are marked both SK_BT_REQFWD and SK_BT_REQBKWD.<br/></li>
<li></span><span class="Comment"> * For the first attribute without an &quot;=&quot; key, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;&lt;&quot; and &quot;&lt;=&quot; keys are<br/></li>
<li></span><span class="Comment"> * marked SK_BT_REQFWD while <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;&gt;&quot; and &quot;&gt;=&quot; keys are marked SK_BT_REQBKWD.<br/></li>
<li></span><span class="Comment"> * This can be seen to be correct by considering the above example.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * in particular that if there are no keys for a given attribute, the keys for<br/></li>
<li></span><span class="Comment"> * subsequent attributes can never be required; for instance &quot;WHERE y = 4&quot;<br/></li>
<li></span><span class="Comment"> * requires a full-index scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If possible, redundant keys are eliminated: we keep only the tightest<br/></li>
<li></span><span class="Comment"> * &gt;/&gt;= bound and the tightest &lt;/&lt;= bound, and if there's an = key then<br/></li>
<li></span><span class="Comment"> * that's the only one returned.&nbsp; (So, we return either a single = key,<br/></li>
<li></span><span class="Comment"> * or one or two boundary-condition keys for each attr.)&nbsp; However, if we<br/></li>
<li></span><span class="Comment"> * cannot <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> two keys for lack of a suitable cross-type operator,<br/></li>
<li></span><span class="Comment"> * we cannot eliminate either.&nbsp; If there are two such keys of the same<br/></li>
<li></span><span class="Comment"> * operator strategy, the second one is just pushed into the output array<br/></li>
<li></span><span class="Comment"> * without further processing here.&nbsp; We may also emit both &gt;/&gt;= or both<br/></li>
<li></span><span class="Comment"> * &lt;/&lt;= keys if we can't <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> them.&nbsp; The logic about required keys still<br/></li>
<li></span><span class="Comment"> * works if we don't eliminate redundant keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that one reason we need direction-sensitive required-key flags is<br/></li>
<li></span><span class="Comment"> * precisely that we may not be able to eliminate redundant keys.&nbsp; Suppose<br/></li>
<li></span><span class="Comment"> * we have &quot;x &gt; 4::int AND x &gt; 10::bigint&quot;, and we are unable to determine<br/></li>
<li></span><span class="Comment"> * which key is more restrictive for lack of a suitable cross-type operator.<br/></li>
<li></span><span class="Comment"> * <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> will arbitrarily pick one of the keys to do the initial<br/></li>
<li></span><span class="Comment"> * positioning with.&nbsp; If it picks x &gt; 4, then the x &gt; 10 condition will fail<br/></li>
<li></span><span class="Comment"> * until we reach index entries &gt; 10; but we can't stop the scan just because<br/></li>
<li></span><span class="Comment"> * x &gt; 10 is failing.&nbsp; On the other hand, if we are scanning backwards, then<br/></li>
<li></span><span class="Comment"> * failure of either key is indeed enough to stop the scan.&nbsp; (In general, when<br/></li>
<li></span><span class="Comment"> * inequality keys are present, the initial-positioning code only promises to<br/></li>
<li></span><span class="Comment"> * position <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first possible match, not exactly at the first match,<br/></li>
<li></span><span class="Comment"> * for a forward scan; or after the last match for a backward scan.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a byproduct of this work, we can detect contradictory quals such<br/></li>
<li></span><span class="Comment"> * as &quot;x = 1 AND x &gt; 2&quot;.&nbsp; If we see that, we return so-&gt;qual_ok = false,<br/></li>
<li></span><span class="Comment"> * indicating the scan need not be run at all since no tuples can match.<br/></li>
<li></span><span class="Comment"> * (In this case we do not bother completing the output key array!)<br/></li>
<li></span><span class="Comment"> * Again, missing cross-type operators might cause us to fail to prove the<br/></li>
<li></span><span class="Comment"> * quals contradictory when they really are, but the scan will work correctly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Row comparison keys are currently also treated without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> smarts:<br/></li>
<li></span><span class="Comment"> * we just transfer them into the preprocessed array without <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * editorialization.&nbsp; We can treat them the same as an ordinary inequality<br/></li>
<li></span><span class="Comment"> * comparison on the row's first index column, for the purposes of the logic<br/></li>
<li></span><span class="Comment"> * about required keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the reason we have to copy the preprocessed scan keys into private<br/></li>
<li></span><span class="Comment"> * storage is that we are modifying the array based on comparisons of the<br/></li>
<li></span><span class="Comment"> * key argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, which could change on a rescan.&nbsp; Therefore we can't<br/></li>
<li></span><span class="Comment"> * overwrite the source data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2556">&#x200c;</a></span><span class="linkable">_bt_preprocess_keys</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfKeys = scan-&gt;numberOfKeys;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *indoption = scan-&gt;indexRelation-&gt;rd_indoption;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_numberOfKeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfEqualCols;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; inkeys;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; outkeys;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur;<br/></li>
<li>&nbsp; &nbsp; <a href="#L42" title="access/nbtree/nbtutils.c:42">BTScanKeyPreproc</a> xform[BTMaxStrategyNumber];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; test_result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; arrayKeyData;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *keyDataMap = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numberOfKeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Only need to do preprocessing once per <a href="nbtree.c.html#L359" title="access/nbtree/nbtree.c:359">btrescan</a>, at most.&nbsp; All<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * calls after the first are handled as no-ops.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are array scan keys in so-&gt;keyData[], then the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * array elements must already be present in each array's scan key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify that that happened using an assertion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L3048" title="access/nbtree/nbtutils.c:3048">_bt_verify_keys_with_arraykeys</a>(scan));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> result variables */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;numberOfKeys = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numberOfKeys &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done if qual-less scan */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> keys are SK_SEARCHARRAY type, set up array-key info */<br/></li>
<li></span>&nbsp; &nbsp; arrayKeyData = <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!so-&gt;qual_ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unmatchable array, so give up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Treat arrayKeyData[] (a partially preprocessed copy of scan-&gt;keyData[])<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as our input if <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> just allocated it, else just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use scan-&gt;keyData[]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inkeys = arrayKeyData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also maintain keyDataMap for remapping so-&gt;orderProc[] later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; keyDataMap = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(so-&gt;arrayContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; inkeys = scan-&gt;keyData;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; outkeys = so-&gt;keyData;<br/></li>
<li>&nbsp; &nbsp; cur = &amp;inkeys[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we check that input keys are correctly ordered */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_attno &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;btree index keys must be ordered by attribute&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can short-circuit most of the work if there's just one key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numberOfKeys == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply indoption to scankey (might change sk_strategy!) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3333" title="access/nbtree/nbtutils.c:3333">_bt_fix_scankey_strategy</a>(cur, indoption))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(outkeys, cur, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;numberOfKeys = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can mark the qual as required if it's for first index col */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_attno == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3442" title="access/nbtree/nbtutils.c:3442">_bt_mark_scankey_required</a>(outkeys);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't call <a href="#L551" title="access/nbtree/nbtutils.c:551">_bt_preprocess_array_keys_final</a> in this fast path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (we'll <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> out on the single value array transformation, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's not nearly as important when there's only one scan key)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur-&gt;sk_flags &amp; SK_SEARCHARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur-&gt;sk_strategy != BTEqualStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (so-&gt;arrayKeys[<span class="Constant">0</span>].scan_key == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OidIsValid(so-&gt;orderProcs[<span class="Constant">0</span>].fn_oid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, do the full set of pushups.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; new_numberOfKeys = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; numberOfEqualCols = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize for processing of keys for attr 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xform[i] points to the currently best scan key of strategy type i+1; it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is NULL if we haven't yet found such a key for this attr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; memset(xform, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xform));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop iterates from 0 to numberOfKeys inclusive; we use the last pass to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle after-last-key processing.&nbsp; Actual exit from the loop is at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;break&quot; statement below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>;; cur++, i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; numberOfKeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Apply indoption to scankey (might change sk_strategy!) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3333" title="access/nbtree/nbtutils.c:3333">_bt_fix_scankey_strategy</a>(cur, indoption))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL can't be matched, so give up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are at the end of the keys for a particular attr, finish up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processing and emit the cleaned-up keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == numberOfKeys || cur-&gt;sk_attno != attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorNumberOfEqualCols = numberOfEqualCols;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check input keys are correctly ordered */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; numberOfKeys &amp;&amp; cur-&gt;sk_attno &lt; attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;btree index keys must be ordered by attribute&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If = has been specified, all other keys can be eliminated as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * redundant.&nbsp; If we have a case like key = 1 AND key &gt; 2, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set qual_ok to false and abandon further processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We also have to deal with the case of &quot;key IS NULL&quot;, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unsatisfiable in combination with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other index condition. By<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the time we get here, that's been classified as an equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check, and we've rejected <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> combination of it with a regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * equality condition; but not with other types of conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xform[BTEqualStrategyNumber - <span class="Constant">1</span>].skey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; eq = xform[BTEqualStrategyNumber - <span class="Constant">1</span>].skey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *orderproc = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData &amp;&amp; (eq-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_in_ikey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_arrayidx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_in_ikey = xform[BTEqualStrategyNumber - <span class="Constant">1</span>].ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_arrayidx = xform[BTEqualStrategyNumber - <span class="Constant">1</span>].arrayidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[eq_arrayidx - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderproc = so-&gt;orderProcs + eq_in_ikey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(array-&gt;scan_key == eq_in_ikey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(orderproc-&gt;fn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = BTMaxStrategyNumber; --j &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; chk = xform[j].skey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!chk || j == (BTEqualStrategyNumber - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (eq-&gt;sk_flags &amp; SK_SEARCHNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* IS NULL is contradictory to anything else */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a>(scan, chk, eq, chk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array, orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;test_result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!test_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keys proven mutually contradictory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else discard the redundant non-equality key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!array || array-&gt;num_elems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].skey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].ikey = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else, cannot determine redundancy, keep both keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* track number of attrs for which we have &quot;=&quot; keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numberOfEqualCols++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to keep only one of &lt;, &lt;= */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xform[BTLessStrategyNumber - <span class="Constant">1</span>].skey<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; xform[BTLessEqualStrategyNumber - <span class="Constant">1</span>].skey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; lt = xform[BTLessStrategyNumber - <span class="Constant">1</span>].skey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; le = xform[BTLessEqualStrategyNumber - <span class="Constant">1</span>].skey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a>(scan, le, lt, le, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;test_result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (test_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[BTLessEqualStrategyNumber - <span class="Constant">1</span>].skey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[BTLessStrategyNumber - <span class="Constant">1</span>].skey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try to keep only one of &gt;, &gt;= */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xform[BTGreaterStrategyNumber - <span class="Constant">1</span>].skey<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; xform[BTGreaterEqualStrategyNumber - <span class="Constant">1</span>].skey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; gt = xform[BTGreaterStrategyNumber - <span class="Constant">1</span>].skey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; ge = xform[BTGreaterEqualStrategyNumber - <span class="Constant">1</span>].skey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a>(scan, ge, gt, ge, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;test_result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (test_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[BTGreaterEqualStrategyNumber - <span class="Constant">1</span>].skey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[BTGreaterStrategyNumber - <span class="Constant">1</span>].skey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit the cleaned-up keys into the outkeys[] array, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mark them if they are required.&nbsp; They are required (possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only in one direction) if all attrs <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this one had &quot;=&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = BTMaxStrategyNumber; --j &gt;= <span class="Constant">0</span>;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xform[j].skey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; outkey = &amp;outkeys[new_numberOfKeys++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(outkey, xform[j].skey, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyDataMap[new_numberOfKeys - <span class="Constant">1</span>] = xform[j].ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priorNumberOfEqualCols == attno - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3442" title="access/nbtree/nbtutils.c:3442">_bt_mark_scankey_required</a>(outkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Exit loop here if done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == numberOfKeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> for new attno */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = cur-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memset(xform, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xform));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check strategy this key's operator corresponds to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; j = cur-&gt;sk_strategy - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if row comparison, <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> it directly to the output array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_ROW_HEADER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; outkey = &amp;outkeys[new_numberOfKeys++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(outkey, cur, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyDataMap[new_numberOfKeys - <span class="Constant">1</span>] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numberOfEqualCols == attno - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3442" title="access/nbtree/nbtutils.c:3442">_bt_mark_scankey_required</a>(outkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't support RowCompare using equality; such a qual would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mess up the numberOfEqualCols tracking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(j != (BTEqualStrategyNumber - <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Does this input scan key require further processing as an array?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_strategy == InvalidStrategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> marked this array key redundant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(arrayKeyData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(cur-&gt;sk_flags &amp; SK_SEARCHARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_strategy == BTEqualStrategyNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (cur-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> kept this array key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(arrayKeyData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have we seen a scan key for this same attribute and using this same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator strategy <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xform[j].skey == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nope, so this scan key wins by default (at least for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].skey = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].ikey = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].arrayidx = arrayidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *orderproc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Seen one of these <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, so keep only the more restrictive key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j == (BTEqualStrategyNumber - <span class="Constant">1</span>) &amp;&amp; arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have to set up array keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((cur-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[arrayidx - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderproc = so-&gt;orderProcs + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(array-&gt;scan_key == i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(orderproc-&gt;fn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((xform[j].skey-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[xform[j].arrayidx - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderproc = so-&gt;orderProcs + xform[j].ikey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(array-&gt;scan_key == xform[j].ikey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(OidIsValid(orderproc-&gt;fn_oid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both scan keys might have arrays, in which case we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arbitrarily pass only one of the arrays.&nbsp; That won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matter, since <a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a> is aware that two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SEARCHARRAY scan keys mean that <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed to eliminate redundant arrays through array merging.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a> just returns false when it sees<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this; it won't even try to examine either array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a>(scan, cur, cur, xform[j].skey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; array, orderproc, &amp;test_result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Have all we need to determine redundancy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (test_result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!array || array-&gt;num_elems &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New key is more restrictive, and so replaces old key...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j != (BTEqualStrategyNumber - <span class="Constant">1</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(xform[j].skey-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].skey = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].ikey = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].arrayidx = arrayidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ...unless we have to keep the old key because it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an array that rendered the new key redundant.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to make sure that we don't throw away an array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan key.&nbsp; <a href="#L3126" title="access/nbtree/nbtutils.c:3126">_bt_compare_scankey_args</a> expects us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always keep arrays (and discard non-arrays).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(cur-&gt;sk_flags &amp; SK_SEARCHARRAY));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (j == (BTEqualStrategyNumber - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* key == a &amp;&amp; key == b, but a != b */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;qual_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else old key is more restrictive, keep it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't determine which key is more restrictive.&nbsp; Push<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xform[j] directly to the output array, then set xform[j] to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new scan key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: We do things this way around so that our arrays are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always in the same order as their corresponding scan keys,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even with incomplete opfamilies.&nbsp; <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * depends on this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; outkey = &amp;outkeys[new_numberOfKeys++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(outkey, xform[j].skey, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyDataMap[new_numberOfKeys - <span class="Constant">1</span>] = xform[j].ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numberOfEqualCols == attno - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3442" title="access/nbtree/nbtutils.c:3442">_bt_mark_scankey_required</a>(outkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].skey = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].ikey = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xform[j].arrayidx = arrayidx;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;numberOfKeys = new_numberOfKeys;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we've built a temporary mapping from so-&gt;keyData[] (output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan keys) to scan-&gt;keyData[] (input scan keys), fix array-&gt;scan_key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * references.&nbsp; Also consolidate the so-&gt;orderProc[] array such that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be subscripted using so-&gt;keyData[]-wise offsets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arrayKeyData)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L551" title="access/nbtree/nbtutils.c:551">_bt_preprocess_array_keys_final</a>(scan, keyDataMap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Could <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> arrayKeyData/keyDataMap <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, but not worth the cycles */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify that the scan's qual state matches what we expect at the point that<br/></li>
<li></span><span class="Comment"> * <a href="#L1668" title="access/nbtree/nbtutils.c:1668">_bt_start_prim_scan</a> is about to start a just-scheduled new primitive scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We enforce a rule against non-required array scan keys: they must start out<br/></li>
<li></span><span class="Comment"> * with whatever <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is the first for the scan's current scan direction.<br/></li>
<li></span><span class="Comment"> * See <a href="#L1467" title="access/nbtree/nbtutils.c:1467">_bt_rewind_nonrequired_arrays</a> comments for an explanation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3010">&#x200c;</a></span><span class="linkable">_bt_verify_arrays_bt_first</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> ikey = <span class="Constant">0</span>; ikey &lt; so-&gt;numberOfKeys; ikey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur = so-&gt;keyData + ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(cur-&gt;sk_flags &amp; SK_SEARCHARRAY) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_strategy != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[arrayidx++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((cur-&gt;sk_flags &amp; SK_BT_REQFWD) &amp;&amp; ScanDirectionIsForward(dir)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((cur-&gt;sk_flags &amp; SK_BT_REQBKWD) &amp;&amp; ScanDirectionIsBackward(dir)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; first_elem_dir = array-&gt;num_elems - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;cur_elem != first_elem_dir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L3048" title="access/nbtree/nbtutils.c:3048">_bt_verify_keys_with_arraykeys</a>(scan);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify that the scan's &quot;so-&gt;keyData[]&quot; scan keys are in agreement with<br/></li>
<li></span><span class="Comment"> * its array key state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3048">&#x200c;</a></span><span class="linkable">_bt_verify_keys_with_arraykeys</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_sk_attno = InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayidx = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!so-&gt;qual_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> ikey = <span class="Constant">0</span>; ikey &lt; so-&gt;numberOfKeys; ikey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur = so-&gt;keyData + ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_strategy != BTEqualStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(cur-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; array = &amp;so-&gt;arrayKeys[arrayidx++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;scan_key != ikey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (array-&gt;num_elems &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_argument != array-&gt;elem_values[array-&gt;cur_elem])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (last_sk_attno &gt; cur-&gt;sk_attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; last_sk_attno = cur-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (arrayidx != so-&gt;numArrayKeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compare two scankey <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> using a specified operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The test we want to perform is logically &quot;leftarg op rightarg&quot;, where<br/></li>
<li></span><span class="Comment"> * leftarg and rightarg are the sk_argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in those ScanKeys, and<br/></li>
<li></span><span class="Comment"> * the comparison operator is the one in the op ScanKey.&nbsp; However, in<br/></li>
<li></span><span class="Comment"> * cross-data-type situations we may need to look up the correct operator in<br/></li>
<li></span><span class="Comment"> * the index's opfamily: it is the one having amopstrategy = op-&gt;sk_strategy<br/></li>
<li></span><span class="Comment"> * and amoplefttype/amoprighttype <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the two argument datatypes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the opfamily doesn't supply a complete set of cross-type operators we<br/></li>
<li></span><span class="Comment"> * may not be able to make the comparison.&nbsp; If we can make the comparison<br/></li>
<li></span><span class="Comment"> * we store the operator result in *result and return true.&nbsp; We return false<br/></li>
<li></span><span class="Comment"> * if the comparison could not be made.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If either leftarg or rightarg are an array, we'll apply array-specific<br/></li>
<li></span><span class="Comment"> * rules to determine which array elements are redundant on behalf of caller.<br/></li>
<li></span><span class="Comment"> * It is up to our caller to save whichever of the two scan keys is the array,<br/></li>
<li></span><span class="Comment"> * and discard the non-array scan key (the non-array scan key is guaranteed to<br/></li>
<li></span><span class="Comment"> * be redundant with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> complete opfamily).&nbsp; Caller isn't expected to call<br/></li>
<li></span><span class="Comment"> * here with a pair of array scan keys provided we're dealing with a complete<br/></li>
<li></span><span class="Comment"> * opfamily (<a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> will <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> array keys together to make<br/></li>
<li></span><span class="Comment"> * sure of that).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we'll also shrink caller's array as needed to eliminate redundant<br/></li>
<li></span><span class="Comment"> * array elements.&nbsp; One reason why caller should prefer to discard non-array<br/></li>
<li></span><span class="Comment"> * scan keys is so that we'll have the opportunity to shrink the array<br/></li>
<li></span><span class="Comment"> * multiple times, in multiple calls (for each of several other scan keys on<br/></li>
<li></span><span class="Comment"> * the same index attribute).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: op always points at the same ScanKey as either leftarg or rightarg.<br/></li>
<li></span><span class="Comment"> * Since we don't scribble on the scankeys themselves, this aliasing should<br/></li>
<li></span><span class="Comment"> * cause no trouble.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this routine needs to be insensitive to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DESC option applied<br/></li>
<li></span><span class="Comment"> * to the index column.&nbsp; For example, &quot;x &lt; 4&quot; is a tighter constraint than<br/></li>
<li></span><span class="Comment"> * &quot;x &lt; 5&quot; regardless of which way the index is sorted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3126">&#x200c;</a></span><span class="linkable">_bt_compare_scankey_args</span>(IndexScanDesc scan, ScanKey op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey leftarg, ScanKey rightarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTArrayKeyInfo *array, FmgrInfo *orderproc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *result)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_op;<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, deal with cases where one or both args are NULL.&nbsp; This should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only happen when the scankeys represent IS NULL/NOT NULL conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((leftarg-&gt;sk_flags | rightarg-&gt;sk_flags) &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; leftnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leftarg-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(leftarg-&gt;sk_flags &amp; (SK_SEARCHNULL | SK_SEARCHNOTNULL));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rightarg-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(rightarg-&gt;sk_flags &amp; (SK_SEARCHNULL | SK_SEARCHNOTNULL));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightnull = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We treat NULL as either greater than or less than all other <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since true &gt; false, the tests below work correctly for NULLS LAST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic.&nbsp; If the index is NULLS FIRST, we need to flip the strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; strat = op-&gt;sk_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = BTCommuteStrategyNumber(strat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (strat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = (leftnull &lt; rightnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = (leftnull &lt;= rightnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = (leftnull == rightnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = (leftnull &gt;= rightnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = (leftnull &gt; rightnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized StrategyNumber: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) strat);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If either leftarg or rightarg are equality-type array scankeys, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specialized handling (since by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we know that IS NULL wasn't used)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (array)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; leftarray,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightarray;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftarray = ((leftarg-&gt;sk_flags &amp; SK_SEARCHARRAY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftarg-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightarray = ((rightarg-&gt;sk_flags &amp; SK_SEARCHARRAY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightarg-&gt;sk_strategy == BTEqualStrategyNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L269" title="access/nbtree/nbtutils.c:269">_bt_preprocess_array_keys</a> is responsible for merging together array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan keys, and will do so whenever the opfamily has the required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cross-type support.&nbsp; If it failed to do that, we handle it just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like the case where we can't make the comparison ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leftarray &amp;&amp; rightarray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Can't make the comparison */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* suppress compiler warnings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we need to determine if either one of leftarg or rightarg<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uses an array, then pass this through to a dedicated helper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leftarray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L976" title="access/nbtree/nbtutils.c:976">_bt_compare_array_scankey_args</a>(scan, leftarg, rightarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderproc, array, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rightarray)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L976" title="access/nbtree/nbtutils.c:976">_bt_compare_array_scankey_args</a>(scan, rightarg, leftarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orderproc, array, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The opfamily we need to worry about is identified by the index column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(leftarg-&gt;sk_attno == rightarg-&gt;sk_attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opcintype = rel-&gt;rd_opcintype[leftarg-&gt;sk_attno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the actual datatypes of the ScanKey arguments.&nbsp; We have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support the convention that sk_subtype == InvalidOid means the opclass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * input type; this is a hack to simplify life for <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; lefttype = leftarg-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lefttype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lefttype = opcintype;<br/></li>
<li>&nbsp; &nbsp; righttype = rightarg-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (righttype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; righttype = opcintype;<br/></li>
<li>&nbsp; &nbsp; optype = op-&gt;sk_subtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (optype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; optype = opcintype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If leftarg and rightarg match the types expected for the &quot;op&quot; scankey,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can use its already-looked-up comparison function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lefttype == opcintype &amp;&amp; righttype == optype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *result = DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;op-&gt;sk_func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; op-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftarg-&gt;sk_argument,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightarg-&gt;sk_argument));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, we need to go to the syscache to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the appropriate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator.&nbsp; (This cannot result in infinite recursion, since no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexscan initiated by syscache lookup will use cross-data-type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the sk_strategy was flipped by <a href="#L3333" title="access/nbtree/nbtutils.c:3333">_bt_fix_scankey_strategy</a>, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * un-flip it to get the correct opfamily member.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strat = op-&gt;sk_strategy;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;sk_flags &amp; SK_BT_DESC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strat = BTCommuteStrategyNumber(strat);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmp_op = <a href="../../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(rel-&gt;rd_opfamily[leftarg-&gt;sk_attno - <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lefttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; righttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strat);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(cmp_op))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegProcedure cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(cmp_op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *result = DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1421" title="utils/fmgr/fmgr.c:1421">OidFunctionCall2Coll</a>(cmp_proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftarg-&gt;sk_argument,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightarg-&gt;sk_argument));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't make the comparison */<br/></li>
<li></span>&nbsp; &nbsp; *result = <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* suppress compiler warnings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Adjust a scankey's strategy and flags setting as needed for indoptions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We copy the appropriate indoption value into the scankey sk_flags<br/></li>
<li></span><span class="Comment"> * (shifting to avoid clobbering system-defined flag bits).&nbsp; Also, if<br/></li>
<li></span><span class="Comment"> * the DESC option is set, commute (flip) the operator strategy number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A secondary purpose is to check for IS NULL/NOT NULL scankeys and set up<br/></li>
<li></span><span class="Comment"> * the strategy field correctly for them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lastly, for ordinary scankeys (not IS NULL/NOT NULL), we check for a<br/></li>
<li></span><span class="Comment"> * NULL comparison value.&nbsp; Since all btree operators are assumed strict,<br/></li>
<li></span><span class="Comment"> * a NULL means that the qual cannot be satisfied.&nbsp; We return true if the<br/></li>
<li></span><span class="Comment"> * comparison value isn't NULL, or false if the scan should be abandoned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is applied to the *input* scankey structure; therefore<br/></li>
<li></span><span class="Comment"> * on a rescan we will be looking at already-processed scankeys.&nbsp; Hence<br/></li>
<li></span><span class="Comment"> * we have to be careful not to re-commute the strategy if we already did it.<br/></li>
<li></span><span class="Comment"> * It's a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> ugly to modify the caller's copy of the scankey but in practice<br/></li>
<li></span><span class="Comment"> * there shouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problem, since the index's indoptions are certainly<br/></li>
<li></span><span class="Comment"> * not going to change while the scankey survives.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3333">&#x200c;</a></span><span class="linkable">_bt_fix_scankey_strategy</span>(ScanKey skey, int16 *indoption)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addflags = indoption[skey-&gt;sk_attno - <span class="Constant">1</span>] &lt;&lt; SK_BT_INDOPTION_SHIFT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat all btree operators as strict (even if they're not so marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in pg_proc). This means that it is impossible for an operator condition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with a NULL comparison constant to succeed, and we can reject it right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, we <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> also support &quot;x IS NULL&quot; clauses as search conditions,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so in that case keep going. The <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> has not filled in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular strategy in this case, so set it to BTEqualStrategyNumber<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * --- we can treat IS NULL as an equality operator for purposes of search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise, &quot;x IS NOT NULL&quot; is supported.&nbsp; We treat that as either &quot;less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than NULL&quot; in a NULLS LAST index, or &quot;greater than NULL&quot; in a NULLS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FIRST index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: someday we might have to fill in sk_collation from the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column's collation.&nbsp; At the moment this is a non-issue because we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never actually call the comparison operator on a NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SK_ISNULL shouldn't be set in a row header scankey */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!(skey-&gt;sk_flags &amp; SK_ROW_HEADER));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set indoption flags in scankey (might be done already) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_flags |= addflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set correct strategy for IS NULL or NOT NULL search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_flags &amp; SK_SEARCHNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_strategy = BTEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_subtype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_collation = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (skey-&gt;sk_flags &amp; SK_SEARCHNOTNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_strategy = BTGreaterStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_strategy = BTLessStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_subtype = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_collation = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* regular qual, so it cannot be satisfied */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Needn't do the rest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_strategy == InvalidStrategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Already-eliminated array scan key; don't need to fix anything */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(skey-&gt;sk_flags &amp; SK_SEARCHARRAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust strategy for DESC, if we didn't already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((addflags &amp; SK_BT_DESC) &amp;&amp; !(skey-&gt;sk_flags &amp; SK_BT_DESC))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_strategy = BTCommuteStrategyNumber(skey-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; skey-&gt;sk_flags |= addflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's a row header, fix row member flags and strategies similarly */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_flags &amp; SK_ROW_HEADER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; subkey = (ScanKey) DatumGetPointer(skey-&gt;sk_argument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_flags &amp; SK_ROW_MEMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags = indoption[subkey-&gt;sk_attno - <span class="Constant">1</span>] &lt;&lt; SK_BT_INDOPTION_SHIFT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((addflags &amp; SK_BT_DESC) &amp;&amp; !(subkey-&gt;sk_flags &amp; SK_BT_DESC))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey-&gt;sk_strategy = BTCommuteStrategyNumber(subkey-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey-&gt;sk_flags |= addflags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ROW_END)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mark a scankey as &quot;required to continue the scan&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Depending on the operator type, the key may be required for both scan<br/></li>
<li></span><span class="Comment"> * directions or just one.&nbsp; Also, if the key is a row comparison header,<br/></li>
<li></span><span class="Comment"> * we have to mark its first subsidiary ScanKey as required.&nbsp; (Subsequent<br/></li>
<li></span><span class="Comment"> * subsidiary ScanKeys are normally for <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order columns, and thus<br/></li>
<li></span><span class="Comment"> * cannot be required, since they're after the first non-equality scankey.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: when we set required-key flag bits in a subsidiary scankey, we are<br/></li>
<li></span><span class="Comment"> * scribbling on a data structure belonging to the index AM's caller, not on<br/></li>
<li></span><span class="Comment"> * our private copy.&nbsp; This should be OK because the marking will not change<br/></li>
<li></span><span class="Comment"> * from scan to scan within a query, and so we'd just re-mark the same way<br/></li>
<li></span><span class="Comment"> * anyway on a rescan.&nbsp; Something to keep an eye on though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3442">&#x200c;</a></span><span class="linkable">_bt_mark_scankey_required</span>(ScanKey skey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (skey-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags = SK_BT_REQFWD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags = SK_BT_REQFWD | SK_BT_REQBKWD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags = SK_BT_REQBKWD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized StrategyNumber: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) skey-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addflags = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; skey-&gt;sk_flags |= addflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (skey-&gt;sk_flags &amp; SK_ROW_HEADER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; subkey = (ScanKey) DatumGetPointer(skey-&gt;sk_argument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First subkey should be same column/operator as the header */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_flags &amp; SK_ROW_MEMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_attno == skey-&gt;sk_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_strategy == skey-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subkey-&gt;sk_flags |= addflags;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether an indextuple satisfies all the scankey conditions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if so, false if not.&nbsp; If the tuple fails to pass the qual,<br/></li>
<li></span><span class="Comment"> * we also determine whether there's <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> need to continue the scan beyond<br/></li>
<li></span><span class="Comment"> * this tuple, and set pstate.continuescan accordingly.&nbsp; See comments for<br/></li>
<li></span><span class="Comment"> * <a href="#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a>(), above, about how this is done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Forward scan callers can pass a high key tuple in the hopes of having<br/></li>
<li></span><span class="Comment"> * us set *continuescan to false, and avoiding an unnecessary visit to<br/></li>
<li></span><span class="Comment"> * the page to the right.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Advances the scan's array keys when necessary for arrayKeys=true callers.<br/></li>
<li></span><span class="Comment"> * Caller can avoid all array related side-effects when calling just to do a<br/></li>
<li></span><span class="Comment"> * page continuescan precheck -- pass arrayKeys=false for that.&nbsp; Scans without<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> arrays keys must always pass arrayKeys=false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also stops and starts primitive index scans for arrayKeys=true callers.<br/></li>
<li></span><span class="Comment"> * Scans with array keys are required to set up page state that helps us with<br/></li>
<li></span><span class="Comment"> * this.&nbsp; The page's finaltup tuple (the page high key for a forward scan, or<br/></li>
<li></span><span class="Comment"> * the page's first non-pivot tuple for a backward scan) must be set in<br/></li>
<li></span><span class="Comment"> * pstate.finaltup ahead of the first call here for the page (or possibly the<br/></li>
<li></span><span class="Comment"> * first call after an initial continuescan-setting page precheck call).&nbsp; Set<br/></li>
<li></span><span class="Comment"> * this to NULL for rightmost page (or the leftmost page for backwards scans).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scan: index scan descriptor (containing a search-type scankey)<br/></li>
<li></span><span class="Comment"> * pstate: page level input and output parameters<br/></li>
<li></span><span class="Comment"> * arrayKeys: should we advance the scan's array keys if necessary?<br/></li>
<li></span><span class="Comment"> * tuple: index tuple to test<br/></li>
<li></span><span class="Comment"> * tupnatts: number of attributes in tupnatts (high key may be truncated)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3512">&#x200c;</a></span><span class="linkable">_bt_checkkeys</span>(IndexScanDesc scan, BTReadPageState *pstate, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> arrayKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple tuple, <span class="Type">int</span> tupnatts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(scan-&gt;indexRelation);<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; ScanDirection dir = pstate-&gt;dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ikey = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BTreeTupleGetNAtts(tuple, scan-&gt;indexRelation) == tupnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; res = <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>(scan, dir, tuple, tupnatts, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arrayKeys, pstate-&gt;prechecked, pstate-&gt;firstmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;pstate-&gt;continuescan, &amp;ikey);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!arrayKeys &amp;&amp; so-&gt;numArrayKeys)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a continuescan precheck call for a scan with array keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assert that the scan isn't in danger of becoming confused.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!so-&gt;scanBehind &amp;&amp; !pstate-&gt;prechecked &amp;&amp; !pstate-&gt;firstmatch);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, tuple, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupnatts, <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;prechecked || pstate-&gt;firstmatch)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dcontinuescan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dikey = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Call relied on continuescan/firstmatch prechecks -- assert that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get the same answer without those optimizations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(res == <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>(scan, dir, tuple, tupnatts, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dcontinuescan, &amp;dikey));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pstate-&gt;continuescan == dcontinuescan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only one <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> call is required in the common case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are no equality strategy array scan keys.&nbsp; Otherwise we can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>'s answer unreservedly when it didn't set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pstate.continuescan=false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!arrayKeys || pstate-&gt;continuescan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a> call set continuescan=false in the presence of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality type array keys.&nbsp; This could mean that the tuple is just past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end of matches for the current array keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's also possible that the scan is still _before_ the _start_ of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples matching the current set of array keys.&nbsp; Check for that first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, tuple, tupdesc, tupnatts, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ikey, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple is still <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of matches according to the scan's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required array keys (according to _all_ of its required equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * strategy keys, actually).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> occasionally sets so-&gt;scanBehind to signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the scan's current position/tuples might be significantly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behind (multiple pages behind) its current array keys.&nbsp; When this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happens, we need to be prepared to recover by starting a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primitive index scan here, on our own.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!so-&gt;scanBehind ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so-&gt;keyData[ikey].sk_strategy == BTEqualStrategyNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(so-&gt;scanBehind) &amp;&amp; pstate-&gt;finaltup &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, pstate-&gt;finaltup, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTreeTupleGetNAtts(pstate-&gt;finaltup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;indexRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cut our losses -- start a new primitive index scan <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Override <a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>, continue primitive scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;continuescan = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will end up here repeatedly given a group of tuples &gt; the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous array keys and &lt; the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-current keys (for a backwards<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan it's just the same, though the operators swap positions).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must avoid allowing this linear search process to scan very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * many tuples from well <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of tuples matching the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current array keys (or from well <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the point where we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * once again have to advance the scan's array keys).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We keep the overhead under control by speculatively &quot;looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ahead&quot; to later still-unscanned items from this same leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We'll only attempt this once the number of tuples that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * linear search process has examined starts to get out of hand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;rechecks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;rechecks &gt;= <a href="#L32" title="access/nbtree/nbtutils.c:32">LOOK_AHEAD_REQUIRED_RECHECKS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See if we should <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead within the current leaf page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4076" title="access/nbtree/nbtutils.c:4076">_bt_checkkeys_look_ahead</a>(scan, pstate, tupnatts, tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Might have set pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to a later page offset.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that happens then <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> caller will inexpensively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead to a later tuple from the same page (the one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just after the tuple we successfully &quot;looked ahead&quot; to).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This indextuple doesn't match the current qual, in <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller's tuple is &gt;= the current set of array keys and other equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint scan keys (or &lt;= if this is a backwards scan).&nbsp; It's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clear that we _must_ advance <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required array keys in lockstep with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a>(scan, pstate, tuple, tupnatts, tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ikey, <span class="Constant">true</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether an indextuple satisfies current scan condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if so, false if not.&nbsp; If not, also sets *continuescan to false<br/></li>
<li></span><span class="Comment"> * when it's also not possible for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later tuples to pass the current qual<br/></li>
<li></span><span class="Comment"> * (with the scan's current set of array keys, in the current scan direction),<br/></li>
<li></span><span class="Comment"> * in addition to setting *ikey to the so-&gt;keyData[] subscript/offset for the<br/></li>
<li></span><span class="Comment"> * unsatisfied scan key (needed when caller must consider advancing the scan's<br/></li>
<li></span><span class="Comment"> * array keys).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a subroutine for <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>.&nbsp; We provisionally assume that<br/></li>
<li></span><span class="Comment"> * reaching the end of the current set of required keys (in particular the<br/></li>
<li></span><span class="Comment"> * current required array keys) ends the ongoing (primitive) index scan.<br/></li>
<li></span><span class="Comment"> * Callers without array keys should just end the scan right away when they<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that continuescan has been set to false here by us.&nbsp; Things are more<br/></li>
<li></span><span class="Comment"> * complicated for callers with array keys.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers with array keys must first consider advancing the arrays when<br/></li>
<li></span><span class="Comment"> * continuescan has been set to false here by us.&nbsp; They must then consider if<br/></li>
<li></span><span class="Comment"> * it really does make sense to end the current (primitive) index scan, in<br/></li>
<li></span><span class="Comment"> * light of everything that is known at that point.&nbsp; (In general when we set<br/></li>
<li></span><span class="Comment"> * continuescan=false for these callers it must be treated as provisional.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We deal with advancing unsatisfied non-required arrays directly, though.<br/></li>
<li></span><span class="Comment"> * This is safe, since by definition non-required keys can't end the scan.<br/></li>
<li></span><span class="Comment"> * This is just how we determine if non-required arrays are just unsatisfied<br/></li>
<li></span><span class="Comment"> * by the current array key, or if they're truly unsatisfied (that is, if<br/></li>
<li></span><span class="Comment"> * they're unsatisfied by every possible array key).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Though we advance non-required array keys on our own, that shouldn't have<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> lasting consequences for the scan.&nbsp; By definition, non-required arrays<br/></li>
<li></span><span class="Comment"> * have no fixed relationship with the scan's progress.&nbsp; (There are delicate<br/></li>
<li></span><span class="Comment"> * considerations for non-required arrays when the arrays need to be advanced<br/></li>
<li></span><span class="Comment"> * following our setting continuescan to false, but that doesn't concern us.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass advancenonrequired=false to avoid all array related side effects.<br/></li>
<li></span><span class="Comment"> * This allows <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> caller to avoid infinite recursion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3686">&#x200c;</a></span><span class="linkable">_bt_check_compare</span>(IndexScanDesc scan, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple tuple, <span class="Type">int</span> tupnatts, TupleDesc tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> advancenonrequired, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> prechecked, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> firstmatch,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *continuescan, <span class="Type">int</span> *ikey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *continuescan = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* default assumption */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (; *ikey &lt; so-&gt;numberOfKeys; (*ikey)++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; key = so-&gt;keyData + *ikey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; requiredSameDir = <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requiredOppositeDirOnly = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the key is required in the current scan direction, in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opposite scan direction _only_, or in neither direction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((key-&gt;sk_flags &amp; SK_BT_REQFWD) &amp;&amp; ScanDirectionIsForward(dir)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((key-&gt;sk_flags &amp; SK_BT_REQBKWD) &amp;&amp; ScanDirectionIsBackward(dir)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requiredSameDir = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (((key-&gt;sk_flags &amp; SK_BT_REQFWD) &amp;&amp; ScanDirectionIsBackward(dir)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((key-&gt;sk_flags &amp; SK_BT_REQBKWD) &amp;&amp; ScanDirectionIsForward(dir)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; requiredOppositeDirOnly = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the caller told us the *continuescan flag is known to be true<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the last item on the page, then we know the keys required for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current direction scan should be matched.&nbsp; Otherwise, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *continuescan flag would be set for the current item and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subsequently the last item on the page accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the key is required for the opposite direction scan, we can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the check if the caller tells us there was already at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matching item on the page. Also, we require the *continuescan flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be true for the last item on the page to know there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NULLs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Both cases above work except for the row keys, where NULLs could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * found in the middle of matching <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prechecked &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (requiredSameDir || (requiredOppositeDirOnly &amp;&amp; firstmatch)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(key-&gt;sk_flags &amp; SK_ROW_HEADER))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_attno &gt; tupnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This attribute is truncated (must be high key).&nbsp; The value for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this attribute in the first non-pivot tuple on the page to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right could be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible value.&nbsp; Assume that truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute passes the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(BTreeTupleIsPivot(tuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* row-comparison keys need special processing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_ROW_HEADER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3892" title="access/nbtree/nbtutils.c:3892">_bt_check_rowcompare</a>(key, tuple, tupnatts, tupdesc, dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; continuescan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = index_getattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;sk_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Handle IS NULL/NOT NULL tests */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_SEARCHNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* tuple satisfies this qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(key-&gt;sk_flags &amp; SK_SEARCHNOTNULL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; <span class="Comment">/* tuple satisfies this qual */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple fails this qual.&nbsp; If it's a required qual for the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan direction, then we can conclude no further tuples will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (requiredSameDir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, this indextuple doesn't match the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since NULLs are sorted <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> non-NULLs, we know we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index attr.&nbsp; On a backward scan, we can stop if this qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is one of the &quot;must match&quot; <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>.&nbsp; We can stop regardless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of whether the qual is &gt; or &lt;, so long as it's required,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's not possible for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future tuples to pass. On<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a forward scan, however, we must keep going, because we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have initially positioned to the start of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> also relies on this behavior during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forward scans.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((key-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since NULLs are sorted after non-NULLs, we know we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index attr.&nbsp; On a forward scan, we can stop if this qual is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one of the &quot;must match&quot; <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>.&nbsp; We can stop regardless of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the qual is &gt; or &lt;, so long as it's required,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's not possible for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future tuples to pass. On<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a backward scan, however, we must keep going, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may have initially positioned to the end of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> also relies on this behavior during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backward scans.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((key-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, this indextuple doesn't match the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply the key-checking function, though only if we must.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When a key is required in the opposite-of-scan direction _only_,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then it must already be satisfied if firstmatch=true indicates that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an earlier tuple from this same page satisfied it earlier on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(requiredOppositeDirOnly &amp;&amp; firstmatch) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;key-&gt;sk_func, key-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum, key-&gt;sk_argument)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple fails this qual.&nbsp; If it's a required qual for the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan direction, then we can conclude no further tuples will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: because we stop the scan as soon as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required equality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * qual fails, it is critical that equality quals be used for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * initial positioning in <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>() when they are available. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments in <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (requiredSameDir)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a non-required equality-type array key, the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs to be checked against every possible array key.&nbsp; Handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this by &quot;advancing&quot; the scan key's array to a matching value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (if we're successful then the tuple might match the qual).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (advancenonrequired &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key-&gt;sk_strategy == BTEqualStrategyNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (key-&gt;sk_flags &amp; SK_SEARCHARRAY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a>(scan, <span class="Constant">NULL</span>, tuple, tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc, *ikey, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This indextuple doesn't match the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we get here, the tuple passes all index quals. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test whether an indextuple satisfies a row-comparison scan condition.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true if so, false if not.&nbsp; If not, also clear *continuescan if<br/></li>
<li></span><span class="Comment"> * it's not possible for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future tuples in the current scan direction<br/></li>
<li></span><span class="Comment"> * to pass the qual.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a subroutine for <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>/<a href="#L3686" title="access/nbtree/nbtutils.c:3686">_bt_check_compare</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3892">&#x200c;</a></span><span class="linkable">_bt_check_rowcompare</span>(ScanKey skey, IndexTuple tuple, <span class="Type">int</span> tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc tupdesc, ScanDirection dir, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *continuescan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; subkey = (ScanKey) DatumGetPointer(skey-&gt;sk_argument);<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First subkey should be same as the header says */<br/></li>
<li></span>&nbsp; &nbsp; Assert(subkey-&gt;sk_attno == skey-&gt;sk_attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop over columns of the row condition */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_flags &amp; SK_ROW_MEMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_attno &gt; tupnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This attribute is truncated (must be high key).&nbsp; The value for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this attribute in the first non-pivot tuple on the page to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right could be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> possible value.&nbsp; Assume that truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute passes the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(BTreeTupleIsPivot(tuple));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpresult = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ROW_END)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = index_getattr(tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey-&gt;sk_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupdesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since NULLs are sorted <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> non-NULLs, we know we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> limit of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index attr.&nbsp; On a backward scan, we can stop if this qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is one of the &quot;must match&quot; <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>.&nbsp; We can stop regardless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of whether the qual is &gt; or &lt;, so long as it's required,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's not possible for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future tuples to pass. On<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a forward scan, however, we must keep going, because we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have initially positioned to the start of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> also relies on this behavior during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forward scans.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((subkey-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since NULLs are sorted after non-NULLs, we know we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reached the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> limit of the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index attr.&nbsp; On a forward scan, we can stop if this qual is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one of the &quot;must match&quot; <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a>.&nbsp; We can stop regardless of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether the qual is &gt; or &lt;, so long as it's required,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's not possible for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future tuples to pass. On<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a backward scan, however, we must keep going, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * may have initially positioned to the end of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (<a href="#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> also relies on this behavior during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backward scans.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((subkey-&gt;sk_flags &amp; (SK_BT_REQFWD | SK_BT_REQBKWD)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, this indextuple doesn't match the qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlike the simple-scankey case, this isn't a disallowed case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * But it can never match.&nbsp; If all the earlier row comparison<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns are required for the scan direction, we can stop the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan, because there can't be another tuple that will succeed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey != (ScanKey) DatumGetPointer(skey-&gt;sk_argument))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((subkey-&gt;sk_flags &amp; SK_BT_REQFWD) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((subkey-&gt;sk_flags &amp; SK_BT_REQBKWD) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perform the test --- three-way comparison not <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cmpresult = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;subkey-&gt;sk_func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey-&gt;sk_argument));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_BT_DESC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVERT_COMPARE_RESULT(cmpresult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done comparing if unequal, else advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmpresult != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ROW_END)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subkey++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point cmpresult indicates the overall result of the row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison, and subkey points to the deciding column (or the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column if the result is &quot;=&quot;).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (subkey-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EQ and NE cases aren't allowed here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (cmpresult &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (cmpresult &lt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (cmpresult &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = (cmpresult &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized RowCompareType: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) subkey-&gt;sk_strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple fails this qual.&nbsp; If it's a required qual for the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan direction, then we can conclude no further tuples will pass,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either.&nbsp; Note we have to look at the deciding column, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessarily the first or last column of the row condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((subkey-&gt;sk_flags &amp; SK_BT_REQFWD) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((subkey-&gt;sk_flags &amp; SK_BT_REQBKWD) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *continuescan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine if a scan with array keys should <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over uninteresting tuples.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a subroutine for <a href="#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>.&nbsp; Called when <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>'s linear<br/></li>
<li></span><span class="Comment"> * search process (started after it finishes reading an initial group of<br/></li>
<li></span><span class="Comment"> * matching tuples, used to locate the start of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> group of tuples<br/></li>
<li></span><span class="Comment"> * matching the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set of required array keys) has already scanned an<br/></li>
<li></span><span class="Comment"> * excessive number of tuples whose key space is &quot;between arrays&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we perform look ahead successfully, we'll sets pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>, which<br/></li>
<li></span><span class="Comment"> * instructs <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead to that tuple <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> (could be past the<br/></li>
<li></span><span class="Comment"> * end of the scan's leaf page).&nbsp; Pages where the optimization is effective<br/></li>
<li></span><span class="Comment"> * will generally still need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> several times.&nbsp; Each call here performs<br/></li>
<li></span><span class="Comment"> * only a single &quot;look ahead&quot; comparison of a later tuple, whose distance from<br/></li>
<li></span><span class="Comment"> * the current tuple's offset number is determined by applying heuristics.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4076">&#x200c;</a></span><span class="linkable">_bt_checkkeys_look_ahead</span>(IndexScanDesc scan, BTReadPageState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> tupnatts, TupleDesc tupdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ScanDirection dir = pstate-&gt;dir;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber aheadoffnum;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; ahead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid looking ahead when comparing the page high key */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;offnum &lt; pstate-&gt;minoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't look ahead when there aren't enough tuples remaining on the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (in the current scan direction) for it to be worth our while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;offnum &gt;= pstate-&gt;maxoff - <a href="#L33" title="access/nbtree/nbtutils.c:33">LOOK_AHEAD_DEFAULT_DISTANCE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ScanDirectionIsBackward(dir) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pstate-&gt;offnum &lt;= pstate-&gt;minoff + <a href="#L33" title="access/nbtree/nbtutils.c:33">LOOK_AHEAD_DEFAULT_DISTANCE</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The look ahead distance starts small, and ramps up as each call here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over more tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pstate-&gt;targetdistance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;targetdistance = <a href="#L33" title="access/nbtree/nbtutils.c:33">LOOK_AHEAD_DEFAULT_DISTANCE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;targetdistance *= <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't read past the end (or <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start) of the page, though */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aheadoffnum = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>((<span class="Type">int</span>) pstate-&gt;maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) pstate-&gt;offnum + pstate-&gt;targetdistance);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; aheadoffnum = Max((<span class="Type">int</span>) pstate-&gt;minoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">int</span>) pstate-&gt;offnum - pstate-&gt;targetdistance);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ahead = (IndexTuple) PageGetItem(pstate-&gt;page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PageGetItemId(pstate-&gt;page, aheadoffnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1544" title="access/nbtree/nbtutils.c:1544">_bt_tuple_before_array_skeys</a>(scan, dir, ahead, tupdesc, tupnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Success -- instruct <a href="nbtsearch.c.html#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead to very <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after the one we determined was still <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the current array keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = aheadoffnum + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = aheadoffnum - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failure -- &quot;ahead&quot; tuple is too far ahead (we were too aggressive).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset the number of rechecks, and aggressively reduce the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distance (we're much more aggressive here than we were when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distance was initially ramped up).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;rechecks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;targetdistance = Max(pstate-&gt;targetdistance / <span class="Constant">8</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a> - set LP_DEAD state for items an indexscan caller has<br/></li>
<li></span><span class="Comment"> * told us were killed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scan-&gt;opaque, referenced locally through so, contains information about the<br/></li>
<li></span><span class="Comment"> * current page and killed tuples thereon (generally, this should only be<br/></li>
<li></span><span class="Comment"> * called if so-&gt;numKilled &gt; 0).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller does not have a lock on the page and may or may not have the<br/></li>
<li></span><span class="Comment"> * page pinned in a buffer.&nbsp; Note that read-lock is sufficient for setting<br/></li>
<li></span><span class="Comment"> * LP_DEAD status (which is only a hint).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We match items by heap TID <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> assuming they are the right ones to<br/></li>
<li></span><span class="Comment"> * delete.&nbsp; We cope with cases where items have moved right due to insertions.<br/></li>
<li></span><span class="Comment"> * If an item has moved off the current page due to a split, we'll fail to<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it and do nothing (this is not an error case --- we assume the item<br/></li>
<li></span><span class="Comment"> * will eventually get marked in a future indexscan).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that if we hold a pin on the target page continuously from initially<br/></li>
<li></span><span class="Comment"> * reading the items until applying this function, VACUUM cannot have deleted<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items from the page, and so there is no need to search left from the<br/></li>
<li></span><span class="Comment"> * recorded offset.&nbsp; (This observation also guarantees that the item is still<br/></li>
<li></span><span class="Comment"> * the right one to delete, which might otherwise be questionable since heap<br/></li>
<li></span><span class="Comment"> * TIDs can get recycled.)&nbsp; &nbsp; This holds true even if the page has been modified<br/></li>
<li></span><span class="Comment"> * by inserts and page splits, so there is no need to consult the LSN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the pin was released after reading the page, then we re-read it.&nbsp; If it<br/></li>
<li></span><span class="Comment"> * has been modified since we read it (as determined by the LSN), we dare not<br/></li>
<li></span><span class="Comment"> * flag <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries because it is possible that the old entry was vacuumed<br/></li>
<li></span><span class="Comment"> * away and the TID was re-used by a completely different heap tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4175">&#x200c;</a></span><span class="linkable">_bt_killitems</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber minoff;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numKilled = so-&gt;numKilled;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; killedsomething = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; droppedpin <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BTScanPosIsValid(so-&gt;currPos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Always reset the scan state, so we don't look for same items on other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;numKilled = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsPinned(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have held the pin on this page since we read the index tuples,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so all we need to do is lock it.&nbsp; The pin will have prevented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * re-use of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> TID on the page, so there is no need to check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LSN.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; droppedpin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(scan-&gt;indexRelation, so-&gt;currPos.buf, BT_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; droppedpin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Attempt to re-read the buffer, getting pin and lock. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(scan-&gt;indexRelation, so-&gt;currPos.currPage, BT_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/buffer/bufmgr.c.html#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a>(buf) == so-&gt;currPos.lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Modified while not pinned means hinting is not safe. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(scan-&gt;indexRelation, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; minoff = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numKilled; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex = so-&gt;killedItems[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosItem *kitem = &amp;so-&gt;currPos.items[itemIndex];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum = kitem-&gt;indexOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(itemIndex &gt;= so-&gt;currPos.firstItem &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemIndex &lt;= so-&gt;currPos.lastItem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; minoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pure paranoia */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offnum &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; ituple = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; killtuple = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(ituple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pi = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nposting = BTreeTupleGetNPosting(ituple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We rely on the convention that heap TIDs in the scanpos<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items array are stored in ascending heap TID order for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * group of TIDs that originally came from a posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple.&nbsp; This convention even applies during backwards<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scans, where returning the TIDs in descending order might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seem more natural.&nbsp; This is about effectiveness, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that the page may have been modified in almost <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we first read it (in the !droppedpin case), so it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that this posting list tuple wasn't a posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple when we first encountered its heap TIDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = <span class="Constant">0</span>; j &lt; nposting; j++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer item = BTreeTupleGetPostingN(ituple, j);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(item, &amp;kitem-&gt;heapTid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* out of posting list loop */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * kitem must have matching offnum when heap TIDs match,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * though only in the common case where the page can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have been concurrently modified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(kitem-&gt;indexOffset == offnum || !droppedpin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Read-ahead to later kitems here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We rely on the assumption that not advancing kitem here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will prevent us from considering the posting list tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fully dead by not matching its <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> heap TID in <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop iteration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If, on the other hand, this is the final heap TID in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the posting list tuple, then tuple gets killed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regardless (i.e. we handle the case where the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * kitem is also the last heap TID in the last index tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly -- posting tuple still gets killed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pi &lt; numKilled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kitem = &amp;so-&gt;currPos.items[so-&gt;killedItems[pi++]];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't bother advancing the outermost loop's int iterator to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid processing killed items that relate to the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * offnum/posting list tuple.&nbsp; This micro-optimization hardly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems worth it.&nbsp; (Further iterations of the outermost loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will fail to match on this same posting list's first heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID instead, so we'll advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> offnum/index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple pretty quickly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (j == nposting)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; killtuple = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;ituple-&gt;t_tid, &amp;kitem-&gt;heapTid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; killtuple = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark index item as dead, if it isn't already.&nbsp; Since this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happens while holding a buffer lock possibly in shared mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's possible that multiple processes attempt to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simultaneously, leading to multiple full-page images being sent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to WAL (if <a href="../transam/xlog.c.html#L123" title="access/transam/xlog.c:123">wal_log_hints</a> or data checksums are enabled), which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is undesirable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (killtuple &amp;&amp; !ItemIdIsDead(iid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found the item/all posting list items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemIdMarkDead(iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; killedsomething = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of inner search loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberNext(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since this can be redone later if needed, mark as dirty hint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whenever we mark anything LP_DEAD, we also set the page's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BTP_HAS_GARBAGE flag, which is likewise just a hint.&nbsp; (Note that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only rely on the page-level flag in !heapkeyspace indexes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (killedsomething)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_flags |= BTP_HAS_GARBAGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(so-&gt;currPos.buf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(scan-&gt;indexRelation, so-&gt;currPos.buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The following routines manage a shared-memory area in which we track<br/></li>
<li></span><span class="Comment"> * assignment of &quot;<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle IDs&quot; to currently-active btree vacuuming<br/></li>
<li></span><span class="Comment"> * operations.&nbsp; There is a single counter which increments each time we<br/></li>
<li></span><span class="Comment"> * start a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> to assign it a cycle ID.&nbsp; Since multiple vacuums could<br/></li>
<li></span><span class="Comment"> * be active concurrently, we have to track the cycle ID for each active<br/></li>
<li></span><span class="Comment"> * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>; this requires at most <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> entries (usually far fewer).<br/></li>
<li></span><span class="Comment"> * We assume at most one <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> can be active for a given index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Access to the shared memory area is controlled by BtreeVacuumLock.<br/></li>
<li></span><span class="Comment"> * In principle we could use a separate lmgr locktag for each index,<br/></li>
<li></span><span class="Comment"> * but a single LWLock is much cheaper, and given the short time that<br/></li>
<li></span><span class="Comment"> * the lock is ever held, the concurrency hit should be minimal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L4365">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTOneVacInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LockRelId&nbsp; &nbsp; relid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* global identifier of an index */<br/></li>
<li></span>&nbsp; &nbsp; BTCycleId&nbsp; &nbsp; cycleid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cycle ID for its active VACUUM */<br/></li>
<li><a id="L4369">&#x200c;</a></span>} <span class="linkable">BTOneVacInfo</span>;<br/></li>
<li><br/></li>
<li><a id="L4371">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTVacInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTCycleId&nbsp; &nbsp; cycle_ctr;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cycle ID most recently assigned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_vacuums;&nbsp; &nbsp; <span class="Comment">/* number of currently active VACUUMs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_vacuums;&nbsp; &nbsp; <span class="Comment">/* allocated length of vacuums[] array */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4365" title="access/nbtree/nbtutils.c:4365">BTOneVacInfo</a> vacuums[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L4377">&#x200c;</a>} <span class="linkable">BTVacInfo</span>;<br/></li>
<li><br/></li>
<li><a id="L4379">&#x200c;</a><span class="Type">static</span> <a href="#L4371" title="access/nbtree/nbtutils.c:4371">BTVacInfo</a> *<span class="linkable">btvacinfo</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4392" title="access/nbtree/nbtutils.c:4392">_bt_vacuum_cycleid</a> --- get the active <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle ID for an index,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or zero if there is no active VACUUM<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: for correct interlocking, the caller must already hold pin and<br/></li>
<li></span><span class="Comment"> * exclusive lock on each buffer it will store the cycle ID into.&nbsp; This<br/></li>
<li></span><span class="Comment"> * ensures that even if a VACUUM starts immediately afterwards, it cannot<br/></li>
<li></span><span class="Comment"> * process those pages until the page split is complete.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BTCycleId<br/></li>
<li><a id="L4392">&#x200c;</a><span class="linkable">_bt_vacuum_cycleid</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTCycleId&nbsp; &nbsp; result = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Share lock is enough since this is a read-only operation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BtreeVacuumLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4365" title="access/nbtree/nbtutils.c:4365">BTOneVacInfo</a> *vac = &amp;<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;vacuums[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vac-&gt;relid.relId == rel-&gt;rd_lockInfo.lockRelId.relId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac-&gt;relid.dbId == rel-&gt;rd_lockInfo.lockRelId.dbId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = vac-&gt;cycleid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BtreeVacuumLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4426" title="access/nbtree/nbtutils.c:4426">_bt_start_vacuum</a> --- assign a cycle ID to a just-starting VACUUM operation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the caller must guarantee that it will eventually call<br/></li>
<li></span><span class="Comment"> * <a href="#L4483" title="access/nbtree/nbtutils.c:4483">_bt_end_vacuum</a>, else we'll permanently leak an array slot.&nbsp; To ensure<br/></li>
<li></span><span class="Comment"> * that this happens even in elog(FATAL) scenarios, the appropriate coding<br/></li>
<li></span><span class="Comment"> * is not just a PG_TRY, but<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PG_ENSURE_ERROR_CLEANUP(<a href="#L4511" title="access/nbtree/nbtutils.c:4511">_bt_end_vacuum_callback</a>, PointerGetDatum(rel))<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BTCycleId<br/></li>
<li><a id="L4426">&#x200c;</a><span class="linkable">_bt_start_vacuum</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTCycleId&nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4365" title="access/nbtree/nbtutils.c:4365">BTOneVacInfo</a> *vac;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BtreeVacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assign the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> cycle ID, being careful to avoid zero as well as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reserved high <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = ++(<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;cycle_ctr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result == <span class="Constant">0</span> || result &gt; MAX_BT_CYCLE_ID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;cycle_ctr = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let's just make sure there's no entry already for this index */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vac = &amp;<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;vacuums[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vac-&gt;relid.relId == rel-&gt;rd_lockInfo.lockRelId.relId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac-&gt;relid.dbId == rel-&gt;rd_lockInfo.lockRelId.dbId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unlike most places in the backend, we have to explicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release our LWLock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> throwing an error.&nbsp; This is because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we expect <a href="#L4483" title="access/nbtree/nbtutils.c:4483">_bt_end_vacuum</a>() to be called <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> can run to release LWLocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BtreeVacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;multiple active vacuums for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, add an entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums &gt;= <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;max_vacuums)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BtreeVacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;out of <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a> slots&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; vac = &amp;<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;vacuums[<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums];<br/></li>
<li>&nbsp; &nbsp; vac-&gt;relid = rel-&gt;rd_lockInfo.lockRelId;<br/></li>
<li>&nbsp; &nbsp; vac-&gt;cycleid = result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BtreeVacuumLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4483" title="access/nbtree/nbtutils.c:4483">_bt_end_vacuum</a> --- mark a btree VACUUM operation as done<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is deliberately coded not to complain if no entry is found;<br/></li>
<li></span><span class="Comment"> * this allows the caller to put PG_TRY around the start_vacuum operation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4483">&#x200c;</a></span><span class="linkable">_bt_end_vacuum</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BtreeVacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the array entry */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4365" title="access/nbtree/nbtutils.c:4365">BTOneVacInfo</a> *vac = &amp;<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;vacuums[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vac-&gt;relid.relId == rel-&gt;rd_lockInfo.lockRelId.relId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac-&gt;relid.dbId == rel-&gt;rd_lockInfo.lockRelId.dbId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove it by shifting down the last entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *vac = <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;vacuums[<a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BtreeVacuumLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4483" title="access/nbtree/nbtutils.c:4483">_bt_end_vacuum</a> wrapped as an <a href="../../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback function<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4511">&#x200c;</a></span><span class="linkable">_bt_end_vacuum_callback</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4483" title="access/nbtree/nbtutils.c:4483">_bt_end_vacuum</a>((Relation) DatumGetPointer(arg));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4520" title="access/nbtree/nbtutils.c:4520">BTreeShmemSize</a> --- report amount of shared memory space needed<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L4520">&#x200c;</a><span class="linkable">BTreeShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = offsetof(<a href="#L4371" title="access/nbtree/nbtutils.c:4371">BTVacInfo</a>, vacuums);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L4365" title="access/nbtree/nbtutils.c:4365">BTOneVacInfo</a>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4533" title="access/nbtree/nbtutils.c:4533">BTreeShmemInit</a> --- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> this module's shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4533">&#x200c;</a></span><span class="linkable">BTreeShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a> = (<a href="#L4371" title="access/nbtree/nbtutils.c:4371">BTVacInfo</a> *) <a href="../../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;BTree Vacuum State&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4520" title="access/nbtree/nbtutils.c:4520">BTreeShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize shared memory area */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It doesn't really matter what the cycle counter starts at, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * having it always start the same doesn't seem good.&nbsp; Seed with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * low-order bits of time() instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;cycle_ctr = (BTCycleId) time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;num_vacuums = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4379" title="access/nbtree/nbtutils.c:4379">btvacinfo</a>-&gt;max_vacuums = <a href="../../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li>bytea *<br/></li>
<li><a id="L4561">&#x200c;</a><span class="linkable">btoptions</span>(Datum reloptions, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> validate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">const</span> relopt_parse_elt tab[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;fillfactor&quot;</span>, RELOPT_TYPE_INT, offsetof(BTOptions, fillfactor)},<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;vacuum_cleanup_index_scale_factor&quot;</span>, RELOPT_TYPE_REAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offsetof(BTOptions, vacuum_cleanup_index_scale_factor)},<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<span class="Constant">&quot;deduplicate_items&quot;</span>, RELOPT_TYPE_BOOL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offsetof(BTOptions, deduplicate_items)}<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (bytea *) <a href="../common/reloptions.c.html#L1908" title="access/common/reloptions.c:1908">build_reloptions</a>(reloptions, validate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RELOPT_KIND_BTREE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTOptions),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tab, lengthof(tab));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4584" title="access/nbtree/nbtutils.c:4584">btproperty</a>() -- Check boolean properties of indexes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is optional, but handling AMPROP_RETURNABLE here saves opening the rel<br/></li>
<li></span><span class="Comment"> * to call <a href="nbtree.c.html#L1444" title="access/nbtree/nbtree.c:1444">btcanreturn</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4584">&#x200c;</a></span><span class="linkable">btproperty</span>(Oid index_oid, <span class="Type">int</span> attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexAMProperty prop, <span class="Type">const</span> <span class="Type">char</span> *propname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *res, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (prop)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AMPROP_RETURNABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* answer only for columns, not AM or whole index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, btree can always return data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *res = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* punt to generic code */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4607" title="access/nbtree/nbtutils.c:4607">btbuildphasename</a>() -- Return name of index build phase.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L4607">&#x200c;</a><span class="linkable">btbuildphasename</span>(int64 phasenum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (phasenum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROGRESS_CREATEIDX_SUBPHASE_INITIALIZE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;initializing&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROGRESS_BTREE_PHASE_INDEXBUILD_TABLESCAN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;scanning table&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROGRESS_BTREE_PHASE_PERFORMSORT_1:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;sorting live tuples&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROGRESS_BTREE_PHASE_PERFORMSORT_2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;sorting dead tuples&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROGRESS_BTREE_PHASE_LEAF_LOAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;loading tuples in tree&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>() -- create tuple without unneeded suffix attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns truncated pivot index tuple allocated in caller's memory context,<br/></li>
<li></span><span class="Comment"> * with key attributes copied from caller's firstright argument.&nbsp; If rel is<br/></li>
<li></span><span class="Comment"> * an INCLUDE index, non-key attributes will definitely be truncated away,<br/></li>
<li></span><span class="Comment"> * since they're not part of the key space.&nbsp; More aggressive suffix<br/></li>
<li></span><span class="Comment"> * truncation can take place when it's clear that the returned tuple does not<br/></li>
<li></span><span class="Comment"> * need one or more suffix key attributes.&nbsp; We only need to keep firstright<br/></li>
<li></span><span class="Comment"> * attributes up to and including the first non-lastleft-<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> attribute.<br/></li>
<li></span><span class="Comment"> * Caller's insertion scankey is used to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the tuples; the scankey's<br/></li>
<li></span><span class="Comment"> * argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not considered here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that returned tuple's t_tid offset will hold the number of attributes<br/></li>
<li></span><span class="Comment"> * present, so the original item pointer offset is not represented.&nbsp; Caller<br/></li>
<li></span><span class="Comment"> * should only change truncated tuple's downlink.&nbsp; Note also that truncated<br/></li>
<li></span><span class="Comment"> * key attributes are treated as containing &quot;minus infinity&quot; <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> by<br/></li>
<li></span><span class="Comment"> * <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the worst case (when a heap TID must be appended to distinguish lastleft<br/></li>
<li></span><span class="Comment"> * from firstright), the size of the returned tuple is the size of firstright<br/></li>
<li></span><span class="Comment"> * plus the size of an additional MAXALIGN()'d item pointer.&nbsp; This guarantee<br/></li>
<li></span><span class="Comment"> * is important, since callers need to stay under the 1/3 of a page<br/></li>
<li></span><span class="Comment"> * restriction on tuple size.&nbsp; If this routine is ever taught to truncate<br/></li>
<li></span><span class="Comment"> * within an attribute/datum, it will need to avoid returning an enlarged<br/></li>
<li></span><span class="Comment"> * tuple to caller when truncation + TOAST compression ends up enlarging the<br/></li>
<li></span><span class="Comment"> * final datum.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexTuple<br/></li>
<li><a id="L4655">&#x200c;</a><span class="linkable">_bt_truncate</span>(Relation rel, IndexTuple lastleft, IndexTuple firstright,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTScanInsert itup_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; itupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keepnatts;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; pivot;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tidpivot;<br/></li>
<li>&nbsp; &nbsp; ItemPointer pivotheaptid;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should only ever truncate non-pivot tuples from leaf pages.&nbsp; It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never okay to truncate when splitting an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!BTreeTupleIsPivot(lastleft) &amp;&amp; !BTreeTupleIsPivot(firstright));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine how many attributes must be kept in truncated tuple */<br/></li>
<li></span>&nbsp; &nbsp; keepnatts = <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a>(rel, lastleft, firstright, itup_key);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_NO_TRUNCATE<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Force truncation to be ineffective for testing purposes */<br/></li>
<li></span>&nbsp; &nbsp; keepnatts = nkeyatts + <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pivot = <a href="../common/indextuple.c.html#L576" title="access/common/indextuple.c:576">index_truncate_tuple</a>(itupdesc, firstright,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(keepnatts, nkeyatts));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(pivot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../common/indextuple.c.html#L576" title="access/common/indextuple.c:576">index_truncate_tuple</a>() just returns a straight copy of firstright<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when it has no attributes to truncate.&nbsp; When that happens, we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to truncate away a posting list here instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(keepnatts == nkeyatts || keepnatts == nkeyatts + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(IndexRelationGetNumberOfAttributes(rel) == nkeyatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pivot-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pivot-&gt;t_info |= MAXALIGN(BTreeTupleGetPostingOffset(firstright));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is a distinguishing key attribute within pivot tuple, we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (keepnatts &lt;= nkeyatts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetNAtts(pivot, keepnatts, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pivot;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to store a heap TID in the new pivot tuple, since no non-TID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key attribute value in firstright distinguishes the right side of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split from the left side.&nbsp; nbtree conceptualizes this case as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inability to truncate away <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> key attributes, since heap TID is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * treated as just another key attribute (despite lacking a pg_attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use enlarged space that holds a copy of pivot.&nbsp; We need the extra space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to store a heap TID at the end (using the special pivot tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation).&nbsp; Note that the original pivot already has firstright's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible posting list/non-key attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> removed at this point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newsize = MAXALIGN(IndexTupleSize(pivot)) + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li>&nbsp; &nbsp; tidpivot = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(newsize);<br/></li>
<li>&nbsp; &nbsp; memcpy(tidpivot, pivot, MAXALIGN(IndexTupleSize(pivot)));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cannot leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pivot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store all of firstright's key attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> plus a tiebreaker heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TID value in enlarged pivot tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tidpivot-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; tidpivot-&gt;t_info |= newsize;<br/></li>
<li>&nbsp; &nbsp; BTreeTupleSetNAtts(tidpivot, nkeyatts, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; pivotheaptid = BTreeTupleGetHeapTID(tidpivot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lehman &amp; Yao use lastleft as the leaf high key in all cases, but don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider suffix truncation.&nbsp; It seems like a good idea to follow that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example in cases where no truncation takes place -- use lastleft's heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TID.&nbsp; (This is also the closest value to negative infinity that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * legally usable.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerCopy(BTreeTupleGetMaxHeapTID(lastleft), pivotheaptid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're done.&nbsp; Assert() that heap TID invariants hold <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lehman and Yao require that the downlink to the right page, which is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be inserted into the parent page in the second phase of a page split be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a strict <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound on items on the right page, and a non-strict <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bound for items on the left page.&nbsp; Assert that heap TIDs follow these<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * invariants, since a heap TID value is apparently needed as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tiebreaker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef DEBUG_NO_TRUNCATE<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(BTreeTupleGetMaxHeapTID(lastleft),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetHeapTID(firstright)) &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(pivotheaptid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetHeapTID(lastleft)) &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(pivotheaptid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetHeapTID(firstright)) &lt; <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Those invariants aren't guaranteed to hold for lastleft + firstright<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap TID attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> when they're considered here only because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DEBUG_NO_TRUNCATE is defined (a heap TID is probably not actually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed as a tiebreaker).&nbsp; DEBUG_NO_TRUNCATE must therefore use a heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TID value that always works as a strict <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound for items to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right.&nbsp; In particular, it must avoid using firstright's leading key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> along with lastleft's heap TID value when lastleft's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TID happens to be greater than firstright's TID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerCopy(BTreeTupleGetHeapTID(firstright), pivotheaptid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pivot heap TID should never be fully <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to firstright.&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pivot heap TID will still end up <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to lastleft's heap TID when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's the only usable value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerSetOffsetNumber(pivotheaptid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumberPrev(ItemPointerGetOffsetNumber(pivotheaptid)));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(pivotheaptid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetHeapTID(firstright)) &lt; <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tidpivot;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a> - how many key attributes to keep when truncating.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller provides two tuples that enclose a split point.&nbsp; Caller's insertion<br/></li>
<li></span><span class="Comment"> * scankey is used to <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the tuples; the scankey's argument <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are<br/></li>
<li></span><span class="Comment"> * not considered here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can return a number of attributes that is one greater than the<br/></li>
<li></span><span class="Comment"> * number of key attributes for the index relation.&nbsp; This indicates that the<br/></li>
<li></span><span class="Comment"> * caller must use a heap TID as a unique-ifier in new pivot tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L4800">&#x200c;</a></span><span class="linkable">_bt_keep_natts</span>(Relation rel, IndexTuple lastleft, IndexTuple firstright,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTScanInsert itup_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; itupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keepnatts;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; scankey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtsearch.c.html#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>() treats truncated key attributes as having the value minus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinity, which would break searches within !heapkeyspace indexes.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must still truncate away non-key attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!itup_key-&gt;heapkeyspace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> nkeyatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scankey = itup_key-&gt;scankeys;<br/></li>
<li>&nbsp; &nbsp; keepnatts = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> attnum = <span class="Constant">1</span>; attnum &lt;= nkeyatts; attnum++, scankey++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = index_getattr(lastleft, attnum, itupdesc, &amp;isNull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = index_getattr(firstright, attnum, itupdesc, &amp;isNull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull1 != isNull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull1 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;scankey-&gt;sk_func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scankey-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keepnatts++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Assert that <a href="#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>() agrees with us in passing.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expected in an allequalimage index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!itup_key-&gt;allequalimage ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; keepnatts == <a href="#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(rel, lastleft, firstright));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> keepnatts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a> - fast bitwise variant of <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that a candidate split point can have its effect on<br/></li>
<li></span><span class="Comment"> * suffix truncation inexpensively evaluated ahead of time when finding a<br/></li>
<li></span><span class="Comment"> * split location.&nbsp; A naive bitwise approach to datum comparisons is used to<br/></li>
<li></span><span class="Comment"> * save cycles.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The approach taken here usually provides the same answer as <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a><br/></li>
<li></span><span class="Comment"> * will (for the same pair of tuples from a heapkeyspace index), since the<br/></li>
<li></span><span class="Comment"> * majority of btree opclasses can never indicate that two datums are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment"> * unless they're bitwise <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> after detoasting.&nbsp; When an index only has<br/></li>
<li></span><span class="Comment"> * &quot;<a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> image&quot; columns, routine is guaranteed to give the same result as<br/></li>
<li></span><span class="Comment"> * <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a> would.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers can rely on the fact that attributes considered <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> here are<br/></li>
<li></span><span class="Comment"> * definitely also <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> according to <a href="#L4800" title="access/nbtree/nbtutils.c:4800">_bt_keep_natts</a>, even when the index uses<br/></li>
<li></span><span class="Comment"> * an opclass or collation that is not &quot;allequalimage&quot;/deduplication-safe.<br/></li>
<li></span><span class="Comment"> * This weaker guarantee is good enough for nbtsplitloc.c caller, since false<br/></li>
<li></span><span class="Comment"> * negatives generally only have the effect of making leaf page splits use a<br/></li>
<li></span><span class="Comment"> * more balanced split point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4874">&#x200c;</a></span><span class="linkable">_bt_keep_natts_fast</span>(Relation rel, IndexTuple lastleft, IndexTuple firstright)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; itupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keysz = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keepnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; keepnatts = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> attnum = <span class="Constant">1</span>; attnum &lt;= keysz; attnum++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum1 = index_getattr(lastleft, attnum, itupdesc, &amp;isNull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum2 = index_getattr(firstright, attnum, itupdesc, &amp;isNull2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; att = TupleDescAttr(itupdesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull1 != isNull2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull1 &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../../utils/adt/datum.c.html#L266" title="utils/adt/datum.c:266">datum_image_eq</a>(datum1, datum2, att-&gt;attbyval, att-&gt;attlen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keepnatts++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> keepnatts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; <a href="#L4921" title="access/nbtree/nbtutils.c:4921">_bt_check_natts</a>() -- Verify tuple has expected number of attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns value indicating if the expected number of attributes were found<br/></li>
<li></span><span class="Comment"> * for a particular offset on page.&nbsp; This can be used as a general purpose<br/></li>
<li></span><span class="Comment"> * sanity check.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Testing a tuple directly with BTreeTupleGetNAtts() should generally be<br/></li>
<li></span><span class="Comment"> * preferred to calling here.&nbsp; That's usually more convenient, and is always<br/></li>
<li></span><span class="Comment"> * more explicit.&nbsp; Call here instead when offnum's tuple may be a negative<br/></li>
<li></span><span class="Comment"> * infinity tuple that uses the pre-v11 on-disk representation, or when a low<br/></li>
<li></span><span class="Comment"> * context check is appropriate.&nbsp; This routine is as strict as possible about<br/></li>
<li></span><span class="Comment"> * what is expected on each version of btree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4921">&#x200c;</a></span><span class="linkable">_bt_check_natts</span>(Relation rel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> heapkeyspace, Page page, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; natts = IndexRelationGetNumberOfAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot reliably test a deleted or half-dead page, since they have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dummy high keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (P_IGNORE(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(offnum &gt;= FirstOffsetNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= PageGetMaxOffsetNumber(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));<br/></li>
<li>&nbsp; &nbsp; tupnatts = BTreeTupleGetNAtts(itup, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* !heapkeyspace indexes do not support deduplication */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!heapkeyspace &amp;&amp; BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Posting list tuples should never have &quot;pivot heap TID&quot; <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(itup) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (ItemPointerGetOffsetNumberNoCheck(&amp;itup-&gt;t_tid) &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BT_PIVOT_HEAP_TID_ATTR) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* INCLUDE indexes do not support deduplication */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (natts != nkeyatts &amp;&amp; BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (P_ISLEAF(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &gt;= P_FIRSTDATAKEY(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Non-pivot tuple should never be explicitly marked as a pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPivot(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Leaf tuples that are not the page high key (non-pivot tuples)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never be truncated.&nbsp; (Note that tupnatts must have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inferred, even with a posting list tuple, because only pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples store tupnatts directly.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tupnatts == natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rightmost page doesn't contain a page high key, so tuple was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checked above as ordinary leaf tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!P_RIGHTMOST(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * !heapkeyspace high key tuple contains only key attributes. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that tupnatts will only have been explicitly represented in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * !heapkeyspace indexes that happen to have non-key attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!heapkeyspace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tupnatts == nkeyatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use generic heapkeyspace pivot tuple handling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !P_ISLEAF(opaque) */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum == P_FIRSTDATAKEY(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first tuple on <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page (possibly the first after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its high key) is its negative infinity tuple.&nbsp; Negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infinity tuples are always truncated to zero attributes.&nbsp; They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are a particular kind of pivot tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (heapkeyspace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tupnatts == <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The number of attributes won't be explicitly represented if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * negative infinity tuple was generated during a page split that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occurred with a version of Postgres <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> v11.&nbsp; There must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a problem when there is an explicit representation that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-zero, or when there is no explicit representation and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple is evidently not a pre-pg_upgrade tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prior to v11, downlinks always had P_HIKEY as their offset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Accept that as an alternative indication of a valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * !heapkeyspace negative infinity tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tupnatts == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(&amp;(itup-&gt;t_tid)) == P_HIKEY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * !heapkeyspace downlink tuple with separator key contains only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key attributes.&nbsp; Note that tupnatts will only have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explicitly represented in !heapkeyspace indexes that happen to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have non-key attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!heapkeyspace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> tupnatts == nkeyatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use generic heapkeyspace pivot tuple handling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle heapkeyspace pivot tuples (excluding minus infinity items) */<br/></li>
<li></span>&nbsp; &nbsp; Assert(heapkeyspace);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Explicit representation of the number of attributes is mandatory with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heapkeyspace index pivot tuples, regardless of whether or not there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-key attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPivot(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pivot tuple should not use posting list representation (redundant) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Heap TID is a tiebreaker key attribute, so it cannot be untruncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other key attribute is truncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleGetHeapTID(itup) != <span class="Constant">NULL</span> &amp;&amp; tupnatts != nkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pivot tuple must have at least one untruncated key attribute (minus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinity pivot tuples are the only exception).&nbsp; Pivot tuples can never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * represent that there is a value present for a key attribute that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exceeds pg_index.indnkeyatts for the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> tupnatts &gt; <span class="Constant">0</span> &amp;&amp; tupnatts &lt;= nkeyatts;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; <a href="#L5081" title="access/nbtree/nbtutils.c:5081">_bt_check_third_page</a>() -- check whether tuple fits on a btree page at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We actually need to be able to fit three items on every page, so restrict<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one item to 1/3 the per-page available space.&nbsp; Note that itemsz should<br/></li>
<li></span><span class="Comment"> * not include the ItemId overhead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It might be useful to apply TOAST methods rather than throw an error here.<br/></li>
<li></span><span class="Comment"> * Using out of line storage would break assumptions made by suffix truncation<br/></li>
<li></span><span class="Comment"> * and by contrib/amcheck, though.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L5081">&#x200c;</a></span><span class="linkable">_bt_check_third_page</span>(Relation rel, Relation heap, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> needheaptidspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page page, IndexTuple newtup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemsz = MAXALIGN(IndexTupleSize(newtup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Double check item size against limit */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (itemsz &lt;= BTMaxItemSize(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tuple is probably too large to fit on page, but it's possible that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index uses version 2 or version 3, or that page is an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which case a slightly higher limit applies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!needheaptidspace &amp;&amp; itemsz &lt;= BTMaxItemSizeNoHeapTid(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Internal page insertions cannot fail here, because that would mean that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an earlier leaf level insertion that should have failed didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!P_ISLEAF(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot insert oversized tuple of size </span><span class="Special">%zu</span><span class="Constant"> on <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemsz, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index row size </span><span class="Special">%zu</span><span class="Constant"> exceeds btree version </span><span class="Special">%u</span><span class="Constant"> maximum </span><span class="Special">%zu</span><span class="Constant"> for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needheaptidspace ? BTREE_VERSION : BTREE_NOVAC_VERSION,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needheaptidspace ? BTMaxItemSize(page) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTMaxItemSizeNoHeapTid(page),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Index row references tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(BTreeTupleGetHeapTID(newtup)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(BTreeTupleGetHeapTID(newtup)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(heap)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Values larger than 1/3 of a buffer page cannot be indexed.</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Consider a function index of an MD5 <a href="../../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> of the value, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;or use full text indexing.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/cache/relcache.c.html#L5999" title="utils/cache/relcache.c:5999">errtableconstraint</a>(heap, RelationGetRelationName(rel))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Are all attributes in rel &quot;equality is image equality&quot; attributes?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use each attribute's BTEQUALIMAGE_PROC opclass procedure.&nbsp; If <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * opclass either lacks a BTEQUALIMAGE_PROC procedure or returns false, we<br/></li>
<li></span><span class="Comment"> * return false; otherwise we return true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returned boolean value is stored in index metapage during index builds.<br/></li>
<li></span><span class="Comment"> * Deduplication can only be used when we return true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L5139">&#x200c;</a></span><span class="linkable">_bt_allequalimage</span>(Relation rel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> debugmessage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allequalimage = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* INCLUDE indexes can never support deduplication */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IndexRelationGetNumberOfAttributes(rel) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexRelationGetNumberOfKeyAttributes(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; IndexRelationGetNumberOfKeyAttributes(rel); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opfamily = rel-&gt;rd_opfamily[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opcintype = rel-&gt;rd_opcintype[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = rel-&gt;rd_indcollation[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; equalimageproc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; equalimageproc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(opfamily, opcintype, opcintype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTEQUALIMAGE_PROC);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is no BTEQUALIMAGE_PROC then deduplication is assumed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be unsafe.&nbsp; Otherwise, actually call proc and see what it says.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(equalimageproc) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !DatumGetBool(<a href="../../utils/fmgr/fmgr.c.html#L1411" title="utils/fmgr/fmgr.c:1411">OidFunctionCall1Coll</a>(equalimageproc, collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(opcintype))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allequalimage = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debugmessage)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (allequalimage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> can safely use deduplication&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> cannot use deduplication&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> allequalimage;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
