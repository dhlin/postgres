<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtsort.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtsort.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L202">BTBuildState</a></li>
<li><a href="#L223">BTBuildState</a></li>
<li><a href="#L165">BTLeader</a></li>
<li><a href="#L194">BTLeader</a></li>
<li><a href="#L229">BTPageState</a></li>
<li><a href="#L239">BTPageState</a></li>
<li><a href="#L94">BTShared</a></li>
<li><a href="#L151">BTShared</a></li>
<li><a href="#L80">BTSpool</a></li>
<li><a href="#L87">BTSpool</a></li>
<li><a href="#L244">BTWriteState</a></li>
<li><a href="#L251">BTWriteState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1396">_bt_begin_parallel</a></li>
<li><a href="#L606">_bt_blnewpage</a></li>
<li><a href="#L635">_bt_blwritepage</a></li>
<li><a href="#L577">_bt_build_callback</a></li>
<li><a href="#L784">_bt_buildadd</a></li>
<li><a href="#L1607">_bt_end_parallel</a></li>
<li><a href="#L1687">_bt_leader_participate_as_worker</a></li>
<li><a href="#L536">_bt_leafbuild</a></li>
<li><a href="#L1135">_bt_load</a></li>
<li><a href="#L646">_bt_pagestate</a></li>
<li><a href="#L1740">_bt_parallel_build_main</a></li>
<li><a href="#L1633">_bt_parallel_estimate_shared</a></li>
<li><a href="#L1653">_bt_parallel_heapscan</a></li>
<li><a href="#L1862">_bt_parallel_scan_and_sort</a></li>
<li><a href="#L683">_bt_slideleft</a></li>
<li><a href="#L1029">_bt_sort_dedup_finish_pending</a></li>
<li><a href="#L714">_bt_sortaddtup</a></li>
<li><a href="#L525">_bt_spool</a></li>
<li><a href="#L515">_bt_spooldestroy</a></li>
<li><a href="#L363">_bt_spools_heapscan</a></li>
<li><a href="#L1063">_bt_uppershutdown</a></li>
<li><a href="#L293">btbuild</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L62">PARALLEL_KEY_BTREE_SHARED</a></li>
<li><a href="#L67">PARALLEL_KEY_BUFFER_USAGE</a></li>
<li><a href="#L65">PARALLEL_KEY_QUERY_TEXT</a></li>
<li><a href="#L63">PARALLEL_KEY_TUPLESORT</a></li>
<li><a href="#L64">PARALLEL_KEY_TUPLESORT_SPOOL2</a></li>
<li><a href="#L66">PARALLEL_KEY_WAL_USAGE</a></li>
<li><a href="#L159">ParallelTableScanFromBTShared</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtsort.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build a btree from sorted input by loading leaf pages sequentially.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use tuplesort.c to sort the given index tuples into order.<br/></li>
<li></span><span class="Comment"> * Then we scan the index tuples in order and build the btree pages<br/></li>
<li></span><span class="Comment"> * for each level.&nbsp; We load source tuples into leaf-level pages.<br/></li>
<li></span><span class="Comment"> * Whenever we fill a page at one level, we add a link to it to its<br/></li>
<li></span><span class="Comment"> * parent level (starting a new parent level if necessary).&nbsp; When<br/></li>
<li></span><span class="Comment"> * done, we write out each final page on each level, adding it to<br/></li>
<li></span><span class="Comment"> * its parent level.&nbsp; When we have only one page on a level, it must be<br/></li>
<li></span><span class="Comment"> * the root -- it can be attached to the btree metapage and we are done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is not wise to pack the pages entirely full, since then *<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>*<br/></li>
<li></span><span class="Comment"> * insertion would cause a split (and not only of the leaf page; the need<br/></li>
<li></span><span class="Comment"> * for a split would cascade right up the tree).&nbsp; The steady-state load<br/></li>
<li></span><span class="Comment"> * factor for btrees is usually estimated at 70%.&nbsp; We choose to pack leaf<br/></li>
<li></span><span class="Comment"> * pages to the user-controllable fill factor (default 90%) while <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> pages<br/></li>
<li></span><span class="Comment"> * are always packed to 70%.&nbsp; This gives us reasonable density (there aren't<br/></li>
<li></span><span class="Comment"> * many <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> pages if the keys are reasonable-size) without risking a lot of<br/></li>
<li></span><span class="Comment"> * cascading splits during early insertions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use the bulk smgr loading facility to bypass the buffer cache and<br/></li>
<li></span><span class="Comment"> * WAL-log the pages efficiently.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code isn't concerned about the FSM at all. The caller is responsible<br/></li>
<li></span><span class="Comment"> * for initializing that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtsort.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/instrument.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bulk_write.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pgrminclude ignore */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/sortsupport.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Magic numbers for parallel state sharing */<br/></li>
<li><a id="L62">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_BTREE_SHARED</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xA000000000000001</span><span class="PreProc">)<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_TUPLESORT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xA000000000000002</span><span class="PreProc">)<br/></li>
<li><a id="L64">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_TUPLESORT_SPOOL2</span>&nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xA000000000000003</span><span class="PreProc">)<br/></li>
<li><a id="L65">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_QUERY_TEXT</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xA000000000000004</span><span class="PreProc">)<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_WAL_USAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xA000000000000005</span><span class="PreProc">)<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARALLEL_KEY_BUFFER_USAGE</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0xA000000000000006</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * DISABLE_LEADER_PARTICIPATION disables the leader's participation in<br/></li>
<li></span><span class="Comment"> * parallel index builds.&nbsp; This may be useful as a debugging aid.<br/></li>
<li></span><span class="Comment">#undef DISABLE_LEADER_PARTICIPATION<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status record for spooling/sorting phase.&nbsp; (Note we may have two of<br/></li>
<li></span><span class="Comment"> * these due to the special requirements for uniqueness-checking with<br/></li>
<li></span><span class="Comment"> * dead tuples.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L80">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTSpool</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> *sortstate;&nbsp; &nbsp; <span class="Comment">/* state data for tuplesort.c */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; heap;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isunique;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls_not_distinct;<br/></li>
<li><a id="L87">&#x200c;</a>} <span class="linkable">BTSpool</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status for index builds performed in parallel.&nbsp; This is allocated in a<br/></li>
<li></span><span class="Comment"> * dynamic shared memory segment.&nbsp; Note that there is a separate tuplesort TOC<br/></li>
<li></span><span class="Comment"> * entry, private to tuplesort.c but allocated by this module on its behalf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTShared</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These fields are not modified during the sort.&nbsp; They primarily exist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the benefit of worker processes that need to create <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding to that used by the leader.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heaprelid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isunique;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls_not_distinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isconcurrent;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scantuplesortstates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * workersdonecv is used to monitor the progress of workers.&nbsp; All parallel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * participants must indicate that they are done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leader can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mutable state that workers maintain during scan (and <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leader can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceed to <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>()).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable workersdonecv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mutex protects all fields <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> heapdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These fields contain status information of interest to B-Tree index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * builds that must work just the same when an index is built in parallel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; mutex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mutable state that is maintained by workers, and reported back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leader at end of parallel scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nparticipantsdone is number of worker processes finished.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reltuples is the total number of input heap tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * havedead indicates if RECENTLY_DEAD tuples were encountered during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indtuples is the total number of tuples that made it into the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * brokenhotchain indicates if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker detected a broken HOT chain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during build.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipantsdone;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; havedead;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; brokenhotchain;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ParallelTableScanDescData data follows. Can't directly embed here, as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implementations of the parallel table scan desc interface might need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stronger alignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L151">&#x200c;</a></span>} <span class="linkable">BTShared</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return pointer to a <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>'s parallel table scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * c.f. <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a> as to why BUFFERALIGN is used, rather than just<br/></li>
<li></span><span class="Comment"> * MAXALIGN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ParallelTableScanFromBTShared</span>(shared) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (ParallelTableScanDesc) ((</span><span class="Type">char</span><span class="PreProc"> *) (shared) + BUFFERALIGN(</span><span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status for leader in parallel index build.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L165">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTLeader</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* parallel context itself */<br/></li>
<li></span>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nparticipanttuplesorts is the exact number of worker processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully launched, plus one leader process if it participates as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker (only DISABLE_LEADER_PARTICIPATION builds avoid leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * participating as a worker).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipanttuplesorts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Leader process convenience pointers to shared state (leader avoids TOC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookups).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * btshared is the shared state for entire build.&nbsp; sharedsort is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared, tuplesort-managed state passed to each process tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sharedsort2 is the corresponding btspool2 shared state, used only when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * building unique indexes.&nbsp; snapshot is the snapshot used by the scan iff<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an MVCC snapshot is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>&nbsp;&nbsp; *btshared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort2;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufferusage;<br/></li>
<li><a id="L194">&#x200c;</a>} <span class="linkable">BTLeader</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Working state for <a href="#L293" title="access/nbtree/nbtsort.c:293">btbuild</a> and its callback.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When parallel CREATE INDEX is used, there is a <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> for each<br/></li>
<li></span><span class="Comment"> * participant.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L202">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTBuildState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isunique;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls_not_distinct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; havedead;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heap;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *spool;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * spool2 is needed only when the index is a unique index. Dead tuples are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * put into spool2 instead of spool in order to avoid uniqueness check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *spool2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; indtuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * btleader is only present when a parallel index build is performed, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only in the leader process. (Actually, only the leader has a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a>.&nbsp; Workers have their own spool and spool2, though.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a>&nbsp;&nbsp; *btleader;<br/></li>
<li><a id="L223">&#x200c;</a>} <span class="linkable">BTBuildState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Status record for a btree page being built.&nbsp; We have one of these<br/></li>
<li></span><span class="Comment"> * for each active tree level.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L229">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTPageState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer btps_buf;&nbsp; &nbsp; <span class="Comment">/* workspace for page building */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber btps_blkno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* block # to write this page at */<br/></li>
<li></span>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; btps_lowkey;&nbsp; &nbsp; <span class="Comment">/* page's strict <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound pivot tuple */<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber btps_lastoff;&nbsp; &nbsp; <span class="Comment">/* last item offset loaded */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; btps_lastextra; <span class="Comment">/* last item's extra posting list space */<br/></li>
<li></span>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; btps_level;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tree level (0 = leaf) */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; btps_full;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;full&quot; if less than this much free space */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *btps_next;&nbsp; &nbsp; <span class="Comment">/* link to parent level, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li><a id="L239">&#x200c;</a></span>} <span class="linkable">BTPageState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Overall status record for index writing phase.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTWriteState</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heap;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; index;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate;<br/></li>
<li>&nbsp; &nbsp; BTScanInsert inskey;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* generic insertion scankey */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber btws_pages_alloced; <span class="Comment">/* # pages allocated */<br/></li>
<li><a id="L251">&#x200c;</a></span>} <span class="linkable">BTWriteState</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L363" title="access/nbtree/nbtsort.c:363">_bt_spools_heapscan</a>(Relation heap, Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate, IndexInfo *indexInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L515" title="access/nbtree/nbtsort.c:515">_bt_spooldestroy</a>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L525" title="access/nbtree/nbtsort.c:525">_bt_spool</a>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, ItemPointer self,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L536" title="access/nbtree/nbtsort.c:536">_bt_leafbuild</a>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L577" title="access/nbtree/nbtsort.c:577">_bt_build_callback</a>(Relation index, ItemPointer tid, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive, <span class="Type">void</span> *state);<br/></li>
<li><span class="Type">static</span> BulkWriteBuffer <a href="#L606" title="access/nbtree/nbtsort.c:606">_bt_blnewpage</a>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, uint32 level);<br/></li>
<li><span class="Type">static</span> <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *<a href="#L646" title="access/nbtree/nbtsort.c:646">_bt_pagestate</a>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, uint32 level);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L683" title="access/nbtree/nbtsort.c:683">_bt_slideleft</a>(Page rightmostpage);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L714" title="access/nbtree/nbtsort.c:714">_bt_sortaddtup</a>(Page page, Size itemsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup, OffsetNumber itup_off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newfirstdataitem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup, Size truncextra);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1029" title="access/nbtree/nbtsort.c:1029">_bt_sort_dedup_finish_pending</a>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTDedupState dstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1063" title="access/nbtree/nbtsort.c:1063">_bt_uppershutdown</a>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1135" title="access/nbtree/nbtsort.c:1135">_bt_load</a>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool2);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1396" title="access/nbtree/nbtsort.c:1396">_bt_begin_parallel</a>(<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isconcurrent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> request);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1607" title="access/nbtree/nbtsort.c:1607">_bt_end_parallel</a>(<a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a> *btleader);<br/></li>
<li><span class="Type">static</span> Size <a href="#L1633" title="access/nbtree/nbtsort.c:1633">_bt_parallel_estimate_shared</a>(Relation heap, Snapshot snapshot);<br/></li>
<li><span class="Type">static</span> <span class="Type">double</span> <a href="#L1653" title="access/nbtree/nbtsort.c:1653">_bt_parallel_heapscan</a>(<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *brokenhotchain);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1687" title="access/nbtree/nbtsort.c:1687">_bt_leader_participate_as_worker</a>(<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1862" title="access/nbtree/nbtsort.c:1862">_bt_parallel_scan_and_sort</a>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a> *btshared, <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort2, <span class="Type">int</span> sortmem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> progress);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L293" title="access/nbtree/nbtsort.c:293">btbuild</a>() -- build a new btree index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBuildResult *<br/></li>
<li><a id="L293">&#x200c;</a><span class="linkable">btbuild</span>(Relation heap, Relation index, IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexBuildResult *result;<br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> buildstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BTREE_BUILD_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L510" title="utils/misc/guc_tables.c:510">log_btree_build_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BTREE_BUILD_STATS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; buildstate.isunique = indexInfo-&gt;ii_Unique;<br/></li>
<li>&nbsp; &nbsp; buildstate.nulls_not_distinct = indexInfo-&gt;ii_NullsNotDistinct;<br/></li>
<li>&nbsp; &nbsp; buildstate.havedead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.heap = heap;<br/></li>
<li>&nbsp; &nbsp; buildstate.spool = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.spool2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.indtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.btleader = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect to be called exactly once for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index relation. If that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not the case, big trouble's what we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationGetNumberOfBlocks(index) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already contains data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; reltuples = <a href="#L363" title="access/nbtree/nbtsort.c:363">_bt_spools_heapscan</a>(heap, index, &amp;buildstate, indexInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finish the build by (1) completing the sort of the spool file, (2)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserting the sorted tuples into btree pages and (3) building the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * levels.&nbsp; Finally, it may also be necessary to end use of parallelism.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L536" title="access/nbtree/nbtsort.c:536">_bt_leafbuild</a>(buildstate.spool, buildstate.spool2);<br/></li>
<li>&nbsp; &nbsp; <a href="#L515" title="access/nbtree/nbtsort.c:515">_bt_spooldestroy</a>(buildstate.spool);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate.spool2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L515" title="access/nbtree/nbtsort.c:515">_bt_spooldestroy</a>(buildstate.spool2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate.btleader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1607" title="access/nbtree/nbtsort.c:1607">_bt_end_parallel</a>(buildstate.btleader);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = (IndexBuildResult *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBuildResult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;heap_tuples = reltuples;<br/></li>
<li>&nbsp; &nbsp; result-&gt;index_tuples = buildstate.indtuples;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BTREE_BUILD_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L510" title="utils/misc/guc_tables.c:510">log_btree_build_stats</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;BTREE BUILD STATS&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BTREE_BUILD_STATS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> one or two spool structures, and save them in caller's<br/></li>
<li></span><span class="Comment"> * buildstate argument.&nbsp; May also fill-in fields within indexInfo used by index<br/></li>
<li></span><span class="Comment"> * builds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Scans the heap, possibly in parallel, filling spools with IndexTuples.&nbsp; This<br/></li>
<li></span><span class="Comment"> * routine encapsulates all aspects of managing parallelism.&nbsp; Caller need only<br/></li>
<li></span><span class="Comment"> * call <a href="#L1607" title="access/nbtree/nbtsort.c:1607">_bt_end_parallel</a>() in parallel case after it is done with spool/spool2.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the total number of heap tuples scanned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L363">&#x200c;</a></span><span class="linkable">_bt_spools_heapscan</span>(Relation heap, Relation index, <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *btspool = (<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>));<br/></li>
<li>&nbsp; &nbsp; SortCoordinate coordinate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We size the sort area as <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> rather than <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * speed index creation.&nbsp; This should be OK since a single backend can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * run multiple index creations in parallel (see also: notes on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallelism and <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; btspool-&gt;heap = heap;<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;index = index;<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;isunique = indexInfo-&gt;ii_Unique;<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;nulls_not_distinct = indexInfo-&gt;ii_NullsNotDistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save as primary spool */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;spool = btspool;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report table scan phase started */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_BTREE_PHASE_INDEXBUILD_TABLESCAN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Attempt to launch parallel worker scan when required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_ParallelWorkers &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1396" title="access/nbtree/nbtsort.c:1396">_bt_begin_parallel</a>(buildstate, indexInfo-&gt;ii_Concurrent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_ParallelWorkers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If parallel build requested and at least one worker process was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * successfully launched, set up coordination state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate-&gt;btleader)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate = (SortCoordinate) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortCoordinateData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate-&gt;isWorker = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate-&gt;nParticipants =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;btleader-&gt;nparticipanttuplesorts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate-&gt;sharedsort = buildstate-&gt;btleader-&gt;sharedsort;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Begin serial/leader tuplesort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In cases where parallelism is involved, the leader receives the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * share of <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> as a serial sort (it is generally treated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the same way as a serial sort once we return).&nbsp; Parallel worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Tuplesortstates will have received only a fraction of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We rely on the lifetime of the Leader <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> almost not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overlapping with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a>'s lifetime.&nbsp; There may be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some small overlap, but that's okay because we rely on leader<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/sort/tuplesort.c.html#L186" title="utils/sort/tuplesort.c:186">Tuplesortstate</a> only allocating a small, fixed amount of memory here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When its <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>() is called (by our caller), and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * significant amounts of memory are likely to be used, all workers must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have already freed almost all memory held by their Tuplesortstates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (they are about to go away completely, too).&nbsp; The overall effect is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> always represents an absolute high watermark<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the amount of memory used by a CREATE INDEX operation, regardless of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the use of parallelism or <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other factor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;spool-&gt;sortstate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L352" title="utils/sort/tuplesortvariants.c:352">tuplesort_begin_index_btree</a>(heap, index, buildstate-&gt;isunique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;nulls_not_distinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TUPLESORT_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If building a unique index, put dead tuples in a second spool to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them out of the uniqueness check.&nbsp; We expect that the second spool (for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dead tuples) won't get very full, so we give it only <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Unique)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *btspool2 = (<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortCoordinate coordinate2 = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize secondary spool */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;heap = heap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;index = index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;isunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save as secondary spool */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;spool2 = btspool2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buildstate-&gt;btleader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up non-private state that is passed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/sort/tuplesortvariants.c.html#L352" title="utils/sort/tuplesortvariants.c:352">tuplesort_begin_index_btree</a>() about the basic high level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coordination of a parallel sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coordinate2 = (SortCoordinate) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortCoordinateData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coordinate2-&gt;isWorker = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coordinate2-&gt;nParticipants =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;btleader-&gt;nparticipanttuplesorts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coordinate2-&gt;sharedsort = buildstate-&gt;btleader-&gt;sharedsort2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect that the second one (for dead tuples) won't get very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full, so we give it only <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;spool2-&gt;sortstate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L352" title="utils/sort/tuplesortvariants.c:352">tuplesort_begin_index_btree</a>(heap, index, <span class="Constant">false</span>, <span class="Constant">false</span>, <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coordinate2, TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill spool using either serial or parallel heap scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!buildstate-&gt;btleader)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = table_index_build_scan(heap, index, indexInfo, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L577" title="access/nbtree/nbtsort.c:577">_bt_build_callback</a>, (<span class="Type">void</span> *) buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = <a href="#L1653" title="access/nbtree/nbtsort.c:1653">_bt_parallel_heapscan</a>(buildstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;indexInfo-&gt;ii_BrokenHotChain);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set the progress target for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> phase.&nbsp; Reset the block number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> set by table_index_build_scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_TUPLES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_DONE<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int64 progress_vals[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;indtuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">3</span>, progress_index, progress_vals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* okay, all heap tuples are spooled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate-&gt;spool2 &amp;&amp; !buildstate-&gt;havedead)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spool2 turns out to be unnecessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L515" title="access/nbtree/nbtsort.c:515">_bt_spooldestroy</a>(buildstate-&gt;spool2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;spool2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> reltuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * clean up a spool structure and its substructures.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L515">&#x200c;</a></span><span class="linkable">_bt_spooldestroy</span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(btspool-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(btspool);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * spool an index entry into the sort file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L525">&#x200c;</a></span><span class="linkable">_bt_spool</span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, ItemPointer self, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L752" title="utils/sort/tuplesortvariants.c:752">tuplesort_putindextuplevalues</a>(btspool-&gt;sortstate, btspool-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * given a spool loaded by successive calls to <a href="#L525" title="access/nbtree/nbtsort.c:525">_bt_spool</a>,<br/></li>
<li></span><span class="Comment"> * create an entire btree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L536">&#x200c;</a></span><span class="linkable">_bt_leafbuild</span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> wstate;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BTREE_BUILD_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L510" title="utils/misc/guc_tables.c:510">log_btree_build_stats</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;BTREE BUILD (Spool) STATISTICS&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BTREE_BUILD_STATS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute the sort */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_BTREE_PHASE_PERFORMSORT_1);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(btspool-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btspool2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_BTREE_PHASE_PERFORMSORT_2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(btspool2-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wstate.heap = btspool-&gt;heap;<br/></li>
<li>&nbsp; &nbsp; wstate.index = btspool-&gt;index;<br/></li>
<li>&nbsp; &nbsp; wstate.inskey = <a href="nbtutils.c.html#L129" title="access/nbtree/nbtutils.c:129">_bt_mkscankey</a>(wstate.index, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="nbtutils.c.html#L129" title="access/nbtree/nbtutils.c:129">_bt_mkscankey</a>() won't set allequalimage without metapage */<br/></li>
<li></span>&nbsp; &nbsp; wstate.inskey-&gt;allequalimage = <a href="nbtutils.c.html#L5139" title="access/nbtree/nbtutils.c:5139">_bt_allequalimage</a>(wstate.index, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* reserve the metapage */<br/></li>
<li></span>&nbsp; &nbsp; wstate.btws_pages_alloced = BTREE_METAPAGE + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_BTREE_PHASE_LEAF_LOAD);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1135" title="access/nbtree/nbtsort.c:1135">_bt_load</a>(&amp;wstate, btspool, btspool2);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-tuple callback for table_index_build_scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L577">&#x200c;</a></span><span class="linkable">_bt_build_callback</span>(Relation index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer tid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> tupleIsAlive,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate = (<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *) state;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert the index tuple into the appropriate spool file for subsequent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tupleIsAlive || buildstate-&gt;spool2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L525" title="access/nbtree/nbtsort.c:525">_bt_spool</a>(buildstate-&gt;spool, tid, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* dead tuples are put into spool2 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;havedead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L525" title="access/nbtree/nbtsort.c:525">_bt_spool</a>(buildstate-&gt;spool2, tid, <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buildstate-&gt;indtuples += <span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * allocate workspace for a new, clean btree page, not linked to <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> siblings.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BulkWriteBuffer<br/></li>
<li><a id="L606">&#x200c;</a><span class="linkable">_bt_blnewpage</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, uint32 level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(wstate-&gt;bulkstate);<br/></li>
<li>&nbsp; &nbsp; page = (Page) buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Zero the page and set up standard page header info */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize BT opaque state */<br/></li>
<li></span>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_prev = opaque-&gt;btpo_next = P_NONE;<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_level = level;<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_flags = (level &gt; <span class="Constant">0</span>) ? <span class="Constant">0</span> : BTP_LEAF;<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the P_HIKEY line pointer appear allocated */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * emit a completed btree page, and release the working storage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L635">&#x200c;</a></span><span class="linkable">_bt_blwritepage</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, BulkWriteBuffer buf, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(wstate-&gt;bulkstate, blkno, buf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a> took ownership of 'buf' */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * allocate and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a>.&nbsp; the returned structure<br/></li>
<li></span><span class="Comment"> * is suitable for immediate use by <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *<br/></li>
<li><a id="L646">&#x200c;</a><span class="linkable">_bt_pagestate</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, uint32 level)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state = (<a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create initial page for level */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;btps_buf = <a href="#L606" title="access/nbtree/nbtsort.c:606">_bt_blnewpage</a>(wstate, level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and assign it a page position */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;btps_blkno = wstate-&gt;btws_pages_alloced++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_lowkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> lastoff so first item goes into P_FIRSTKEY */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;btps_lastoff = P_HIKEY;<br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_lastextra = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_level = level;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set &quot;full&quot; threshold based on level.&nbsp; See notes at head of file. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;btps_full = (BLCKSZ * (<span class="Constant">100</span> - BTREE_NONLEAF_FILLFACTOR) / <span class="Constant">100</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;btps_full = BTGetTargetPageFreeSpace(wstate-&gt;index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no parent level, yet */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;btps_next = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Slide the array of ItemIds from the page back one slot (from P_FIRSTKEY to<br/></li>
<li></span><span class="Comment"> * P_HIKEY, overwriting P_HIKEY).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L606" title="access/nbtree/nbtsort.c:606">_bt_blnewpage</a>() makes the P_HIKEY line pointer appear allocated, but the<br/></li>
<li></span><span class="Comment"> * rightmost page on its level is not supposed to get a high key.&nbsp; Now that<br/></li>
<li></span><span class="Comment"> * it's clear that this page is a rightmost page, remove the unneeded empty<br/></li>
<li></span><span class="Comment"> * P_HIKEY line pointer space.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L683">&#x200c;</a></span><span class="linkable">_bt_slideleft</span>(Page rightmostpage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; previi;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(rightmostpage);<br/></li>
<li>&nbsp; &nbsp; Assert(maxoff &gt;= P_FIRSTKEY);<br/></li>
<li>&nbsp; &nbsp; previi = PageGetItemId(rightmostpage, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (off = P_FIRSTKEY; off &lt;= maxoff; off = OffsetNumberNext(off))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; thisii = PageGetItemId(rightmostpage, off);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *previi = *thisii;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; previi = thisii;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ((PageHeader) rightmostpage)-&gt;pd_lower -= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add an item to a page being built.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is very similar to nbtinsert.c's <a href="nbtinsert.c.html#L2630" title="access/nbtree/nbtinsert.c:2630">_bt_pgaddtup</a>(), but this variant<br/></li>
<li></span><span class="Comment"> * raises an error directly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that our nbtsort.c caller does not know yet if the page will be<br/></li>
<li></span><span class="Comment"> * rightmost.&nbsp; Offset P_FIRSTKEY is always assumed to be the first data key by<br/></li>
<li></span><span class="Comment"> * caller.&nbsp; Page that turns out to be the rightmost on its level is fixed by<br/></li>
<li></span><span class="Comment"> * calling <a href="#L683" title="access/nbtree/nbtsort.c:683">_bt_slideleft</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L714">&#x200c;</a></span><span class="linkable">_bt_sortaddtup</span>(Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size itemsize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber itup_off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newfirstdataitem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTupleData trunctuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newfirstdataitem)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trunctuple = *itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trunctuple.t_info = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetNAtts(&amp;trunctuple, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = &amp;trunctuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsize = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) itup, itemsize, itup_off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add item to the index page&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * Add an item to a disk page from the sort output (or add a posting list<br/></li>
<li></span><span class="Comment"> * item formed from the sort output).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We must be careful to observe the page layout conventions of nbtsearch.c:<br/></li>
<li></span><span class="Comment"> * - rightmost pages start data items at P_HIKEY instead of at P_FIRSTKEY.<br/></li>
<li></span><span class="Comment"> * - on non-leaf pages, the key portion of the first item need not be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; stored, we should store only the link.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A leaf page being built looks like:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * +----------------+---------------------------------+<br/></li>
<li></span><span class="Comment"> * | PageHeaderData | linp0 linp1 linp2 ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; |<br/></li>
<li></span><span class="Comment"> * +-----------+----+---------------------------------+<br/></li>
<li></span><span class="Comment"> * | ... linpN |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * +-----------+--------------------------------------+<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp;&nbsp; ^ last&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * +-------------+------------------------------------+<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; | itemN ...&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |<br/></li>
<li></span><span class="Comment"> * +-------------+------------------+-----------------+<br/></li>
<li></span><span class="Comment"> * |&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ... item3 item2 item1 | &quot;special space&quot; |<br/></li>
<li></span><span class="Comment"> * +--------------------------------+-----------------+<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Contrast this with the diagram in bufpage.h; note the mismatch<br/></li>
<li></span><span class="Comment"> * between linps and items.&nbsp; This is because we reserve linp0 as a<br/></li>
<li></span><span class="Comment"> * placeholder for the pointer to the &quot;high key&quot; item; when we have<br/></li>
<li></span><span class="Comment"> * filled up the page, we will set linp0 to point to itemN and clear<br/></li>
<li></span><span class="Comment"> * linpN.&nbsp; On the other hand, if we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> this is the last (rightmost)<br/></li>
<li></span><span class="Comment"> * page, we leave the items alone and slide the linp array over.&nbsp; If<br/></li>
<li></span><span class="Comment"> * the high key is to be truncated, offset 1 is deleted, and we insert<br/></li>
<li></span><span class="Comment"> * the truncated high key at offset 1.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'last' pointer indicates the last offset added to the page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'truncextra' is the size of the posting list in itup, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.&nbsp; This<br/></li>
<li></span><span class="Comment"> * information is stashed for the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call here, when we may benefit<br/></li>
<li></span><span class="Comment"> * from considering the impact of truncating away the posting list on<br/></li>
<li></span><span class="Comment"> * the page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> deciding to finish the page off.&nbsp; Posting lists are<br/></li>
<li></span><span class="Comment"> * often relatively large, so it is worth going to the trouble of<br/></li>
<li></span><span class="Comment"> * accounting for the saving from truncating away the posting list of<br/></li>
<li></span><span class="Comment"> * the tuple that becomes the high key (that may be the only way to<br/></li>
<li></span><span class="Comment"> * get close to target free space on the page).&nbsp; Note that this is<br/></li>
<li></span><span class="Comment"> * only used for the soft fillfactor-wise limit, not the critical hard<br/></li>
<li></span><span class="Comment"> * limit.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L784">&#x200c;</a></span><span class="linkable">_bt_buildadd</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state, IndexTuple itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size truncextra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer nbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; npage;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblkno;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber last_off;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; last_truncextra;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pgspc;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupsz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isleaf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is a handy place to check for cancel interrupts during the btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * load phase of index creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nbuf = state-&gt;btps_buf;<br/></li>
<li>&nbsp; &nbsp; npage = (Page) nbuf;<br/></li>
<li>&nbsp; &nbsp; nblkno = state-&gt;btps_blkno;<br/></li>
<li>&nbsp; &nbsp; last_off = state-&gt;btps_lastoff;<br/></li>
<li>&nbsp; &nbsp; last_truncextra = state-&gt;btps_lastextra;<br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_lastextra = truncextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgspc = <a href="../../storage/page/bufpage.c.html#L907" title="storage/page/bufpage.c:907">PageGetFreeSpace</a>(npage);<br/></li>
<li>&nbsp; &nbsp; itupsz = IndexTupleSize(itup);<br/></li>
<li>&nbsp; &nbsp; itupsz = MAXALIGN(itupsz);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Leaf case has slightly different rules due to suffix truncation */<br/></li>
<li></span>&nbsp; &nbsp; isleaf = (state-&gt;btps_level == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check whether the new item can fit on a btree page on current level at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Every newly built index will treat heap TID as part of the keyspace,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which imposes the requirement that new high keys must occasionally have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a heap TID appended within <a href="nbtutils.c.html#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>().&nbsp; That may leave a new pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple one or two MAXALIGN() quantums larger than the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * firstright tuple it's derived from.&nbsp; v4 deals with the problem by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decreasing the limit on the size of tuples inserted on the leaf level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by the same small amount.&nbsp; Enforce the new v4+ limit on the leaf level,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the old limit on <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> levels, since pivot tuples may need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make use of the reserved space.&nbsp; This should never fail on <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(itupsz &gt; BTMaxItemSize(npage)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L5081" title="access/nbtree/nbtutils.c:5081">_bt_check_third_page</a>(wstate-&gt;index, wstate-&gt;heap, isleaf, npage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check to see if current page will fit new item, with space left over to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * append a heap TID during suffix truncation when page is a leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is guaranteed that we can fit at least 2 non-pivot tuples plus a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * high key with heap TID when finishing off a leaf page, since we rely on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtutils.c.html#L5081" title="access/nbtree/nbtutils.c:5081">_bt_check_third_page</a>() rejecting oversized non-pivot tuples.&nbsp; On<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages we can always fit 3 pivot tuples with larger <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page tuple limit (includes page high key).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most of the time, a page is only &quot;full&quot; in the sense that the soft<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fillfactor-wise limit has been exceeded.&nbsp; However, we must always leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least two items plus a high key on each page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.&nbsp; Disregard fillfactor and insert on &quot;full&quot; current page if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't have the minimum number of items yet.&nbsp; (Note that we deliberately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that suffix truncation neither enlarges nor shrinks new high key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when applying soft limit, except when last tuple has a posting list.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(last_truncextra == <span class="Constant">0</span> || isleaf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgspc &lt; itupsz + (isleaf ? MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData)) : <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (pgspc + last_truncextra &lt; state-&gt;btps_full &amp;&amp; last_off &gt; P_FIRSTKEY))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finish off the page and write it out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BulkWriteBuffer obuf = nbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; opage = npage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber oblkno = nblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; ii;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; hii;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; oitup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create new page of same level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nbuf = <a href="#L606" title="access/nbtree/nbtsort.c:606">_bt_blnewpage</a>(wstate, state-&gt;btps_level);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; npage = (Page) nbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and assign it a page position */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nblkno = wstate-&gt;btws_pages_alloced++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We copy the last item on the page into the new page, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rearrange the old page so that the 'last item' becomes its high key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than a true data item.&nbsp; There had better be at least two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items on the page already, else the page would be empty of useful<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(last_off &gt; P_FIRSTKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ii = PageGetItemId(opage, last_off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oitup = (IndexTuple) PageGetItem(opage, ii);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L714" title="access/nbtree/nbtsort.c:714">_bt_sortaddtup</a>(npage, ItemIdGetLength(ii), oitup, P_FIRSTKEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !isleaf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move 'last' into the high key position on opage.&nbsp; <a href="#L606" title="access/nbtree/nbtsort.c:606">_bt_blnewpage</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allocated empty space for a line pointer when opage was first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created, so this is a matter of rearranging already-allocated space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on page, and initializing high key line pointer. (Actually, leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages must also swap oitup with a truncated version of oitup, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is sometimes larger than oitup, though never by more than the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed to append a heap TID.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; hii = PageGetItemId(opage, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *hii = *ii;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemIdSetUnused(ii);&nbsp; &nbsp; <span class="Comment">/* redundant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((PageHeader) opage)-&gt;pd_lower -= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isleaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; lastleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; truncated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Truncate away <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unneeded attributes from high key on leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level.&nbsp; This is only done at the leaf level because downlinks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages are either negative infinity items, or get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their contents from copying from one level down.&nbsp; See also:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtinsert.c.html#L1467" title="access/nbtree/nbtinsert.c:1467">_bt_split</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't try to bias our choice of split point to make it more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likely that <a href="nbtutils.c.html#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>() can truncate away more attributes,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whereas the split point used within <a href="nbtinsert.c.html#L1467" title="access/nbtree/nbtinsert.c:1467">_bt_split</a>() is chosen much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more delicately.&nbsp; Even still, the lastleft and firstright<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples passed to <a href="nbtutils.c.html#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>() here are at least not fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to each other when deduplication is used, unless there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a large group of duplicates (also, unique index builds usually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have few or no spool2 duplicates).&nbsp; When the split point is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between two unequal tuples, <a href="nbtutils.c.html#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>() will avoid including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a heap TID in the new high key, which is the most important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * benefit of suffix truncation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Overwrite the old item with new truncated high key directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * oitup is already located at the physical beginning of tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * space, so this should directly reuse the existing tuple space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii = PageGetItemId(opage, OffsetNumberPrev(last_off));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastleft = (IndexTuple) PageGetItem(opage, ii);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IndexTupleSize(oitup) &gt; last_truncextra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncated = <a href="nbtutils.c.html#L4655" title="access/nbtree/nbtutils.c:4655">_bt_truncate</a>(wstate-&gt;index, lastleft, oitup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wstate-&gt;inskey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(opage, P_HIKEY, (Item) truncated,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTupleSize(truncated)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add high key to the index page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(truncated);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oitup should continue to point to the page's high key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hii = PageGetItemId(opage, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oitup = (IndexTuple) PageGetItem(opage, hii);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Link the old page into its parent, using its low key.&nbsp; If we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have a parent, we have to create one; this adds a new btree level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;btps_next == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;btps_next = <a href="#L646" title="access/nbtree/nbtsort.c:646">_bt_pagestate</a>(wstate, state-&gt;btps_level + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert((BTreeTupleGetNAtts(state-&gt;btps_lowkey, wstate-&gt;index) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexRelationGetNumberOfKeyAttributes(wstate-&gt;index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetNAtts(state-&gt;btps_lowkey, wstate-&gt;index) &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P_LEFTMOST(BTPageGetOpaque(opage)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BTreeTupleGetNAtts(state-&gt;btps_lowkey, wstate-&gt;index) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !P_LEFTMOST(BTPageGetOpaque(opage)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetDownLink(state-&gt;btps_lowkey, oblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, state-&gt;btps_next, state-&gt;btps_lowkey, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;btps_lowkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save a copy of the high key from the old page.&nbsp; It is also the low<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key for the new page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;btps_lowkey = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(oitup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the sibling links for both pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque oopaque = BTPageGetOpaque(opage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque nopaque = BTPageGetOpaque(npage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oopaque-&gt;btpo_next = nblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nopaque-&gt;btpo_prev = oblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nopaque-&gt;btpo_next = P_NONE;&nbsp; &nbsp; <span class="Comment">/* redundant */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Write out the old page. <a href="#L635" title="access/nbtree/nbtsort.c:635">_bt_blwritepage</a> takes ownership of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'opage' buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L635" title="access/nbtree/nbtsort.c:635">_bt_blwritepage</a>(wstate, obuf, oblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset last_off to point to new page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; last_off = P_FIRSTKEY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here, either original page is still the current page, or a new page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * was created that became the current page.&nbsp; Either way, the current page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definitely has space for new item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the new item is the first for its page, it must also be the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * item on its entire level.&nbsp; On later same-level pages, a low key for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page will be copied from the prior page in the code above.&nbsp; Generate a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * minus infinity low key here instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (last_off == P_HIKEY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;btps_lowkey == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;btps_lowkey = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;btps_lowkey-&gt;t_info = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetNAtts(state-&gt;btps_lowkey, <span class="Constant">0</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the new item into the current page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; last_off = OffsetNumberNext(last_off);<br/></li>
<li>&nbsp; &nbsp; <a href="#L714" title="access/nbtree/nbtsort.c:714">_bt_sortaddtup</a>(npage, itupsz, itup, last_off,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !isleaf &amp;&amp; last_off == P_FIRSTKEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_buf = nbuf;<br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_blkno = nblkno;<br/></li>
<li>&nbsp; &nbsp; state-&gt;btps_lastoff = last_off;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finalize pending posting list tuple, and add it to the index.&nbsp; Final tuple<br/></li>
<li></span><span class="Comment"> * is based on saved base tuple, and saved list of heap TIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is almost like <a href="nbtdedup.c.html#L555" title="access/nbtree/nbtdedup.c:555">_bt_dedup_finish_pending</a>(), but it adds a new tuple<br/></li>
<li></span><span class="Comment"> * using <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1029">&#x200c;</a></span><span class="linkable">_bt_sort_dedup_finish_pending</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTDedupState dstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(dstate-&gt;nitems &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dstate-&gt;nitems == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, state, dstate-&gt;base, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; postingtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; truncextra;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* form a tuple with a posting list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; postingtuple = <a href="nbtdedup.c.html#L864" title="access/nbtree/nbtdedup.c:864">_bt_form_posting</a>(dstate-&gt;base,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;htids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;nhtids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Calculate posting list overhead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; truncextra = IndexTupleSize(postingtuple) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetPostingOffset(postingtuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, state, postingtuple, truncextra);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(postingtuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dstate-&gt;nmaxitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dstate-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dstate-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; dstate-&gt;phystupsize = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finish writing out the completed btree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1063">&#x200c;</a></span><span class="linkable">_bt_uppershutdown</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *s;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rootblkno = P_NONE;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; rootlevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Each iteration of this loop completes one more level of the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (s = state; s != <span class="Constant">NULL</span>; s = s-&gt;btps_next)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = s-&gt;btps_blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque((Page) s-&gt;btps_buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to link the last page on this level to somewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're at the top, it's the root, so attach it to the metapage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, add an entry for it to its parent using its low key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This may cause the last page of the parent level to split, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's not a problem -- we haven't gotten to it yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s-&gt;btps_next == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_flags |= BTP_ROOT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootblkno = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootlevel = s-&gt;btps_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((BTreeTupleGetNAtts(s-&gt;btps_lowkey, wstate-&gt;index) &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexRelationGetNumberOfKeyAttributes(wstate-&gt;index) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetNAtts(s-&gt;btps_lowkey, wstate-&gt;index) &gt; <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P_LEFTMOST(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(BTreeTupleGetNAtts(s-&gt;btps_lowkey, wstate-&gt;index) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !P_LEFTMOST(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetDownLink(s-&gt;btps_lowkey, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, s-&gt;btps_next, s-&gt;btps_lowkey, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(s-&gt;btps_lowkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; s-&gt;btps_lowkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the rightmost page, so the ItemId array needs to be slid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back one slot.&nbsp; Then we can <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> out the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L683" title="access/nbtree/nbtsort.c:683">_bt_slideleft</a>((Page) s-&gt;btps_buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L635" title="access/nbtree/nbtsort.c:635">_bt_blwritepage</a>(wstate, s-&gt;btps_buf, s-&gt;btps_blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; s-&gt;btps_buf = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* writepage took ownership of the buffer */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As the last step in the process, construct the metapage and make it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point to the new root (unless we had no data at all, in which case it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set to point to &quot;P_NONE&quot;).&nbsp; This changes the index to the &quot;valid&quot; state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by filling in a valid magic number in the metapage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metabuf = <a href="../../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(wstate-&gt;bulkstate);<br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L67" title="access/nbtree/nbtpage.c:67">_bt_initmetapage</a>((Page) metabuf, rootblkno, rootlevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; wstate-&gt;inskey-&gt;allequalimage);<br/></li>
<li>&nbsp; &nbsp; <a href="#L635" title="access/nbtree/nbtsort.c:635">_bt_blwritepage</a>(wstate, metabuf, BTREE_METAPAGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read tuples in correct sort order from tuplesort, and load them into<br/></li>
<li></span><span class="Comment"> * btree leaves.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1135">&#x200c;</a></span><span class="linkable">_bt_load</span>(<a href="#L244" title="access/nbtree/nbtsort.c:244">BTWriteState</a> *wstate, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L229" title="access/nbtree/nbtsort.c:229">BTPageState</a> *state = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> = (btspool2 != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; load1;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdes = RelationGetDescr(wstate-&gt;index);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keysz = IndexRelationGetNumberOfKeyAttributes(wstate-&gt;index);<br/></li>
<li>&nbsp; &nbsp; SortSupport sortKeys;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; tuples_done = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; deduplicate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; wstate-&gt;bulkstate = <a href="../../storage/smgr/bulk_write.c.html#L86" title="storage/smgr/bulk_write.c:86">smgr_bulk_start_rel</a>(wstate-&gt;index, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; deduplicate = wstate-&gt;inskey-&gt;allequalimage &amp;&amp; !btspool-&gt;isunique &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTGetDeduplicateItems(wstate-&gt;index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> for dead tuples exists. Now we have to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * btspool and btspool2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the preparation of <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itup = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(btspool-&gt;sortstate, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup2 = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(btspool2-&gt;sortstate, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare SortSupport data for each column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sortKeys = (SortSupport) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(keysz * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortSupportData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; keysz; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortSupport sortKey = sortKeys + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; scanKey = wstate-&gt;inskey-&gt;scankeys + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_cxt = <a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_collation = scanKey-&gt;sk_collation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_nulls_first =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (scanKey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;ssup_attno = scanKey-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Abbreviation is not supported here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortKey-&gt;abbreviate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(sortKey-&gt;ssup_attno != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strategy = (scanKey-&gt;sk_flags &amp; SK_BT_DESC) != <span class="Constant">0</span> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber : BTLessStrategyNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/sortsupport.c.html#L161" title="utils/sort/sortsupport.c:161">PrepareSortSupportFromIndexRel</a>(wstate-&gt;index, strategy, sortKey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load1 = <span class="Constant">true</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* load <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> ? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itup2 == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itup == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (itup != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt;= keysz; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SortSupport entry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attrDatum1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrDatum2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry = sortKeys + i - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrDatum1 = index_getattr(itup, i, tupdes, &amp;isNull1);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrDatum2 = index_getattr(itup2, i, tupdes, &amp;isNull2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = ApplySortComparator(attrDatum1, isNull1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrDatum2, isNull2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; entry);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If key <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, we sort on ItemPointer.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required for btree indexes, since heap TID is treated as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implicit last key attribute in order to ensure that all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys in the index are physically unique.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> = <a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(&amp;itup-&gt;t_tid, &amp;itup2-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load1 = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; load1 = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* When we see first tuple, create first index page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L646" title="access/nbtree/nbtsort.c:646">_bt_pagestate</a>(wstate, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (load1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, state, itup, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(btspool-&gt;sortstate, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, state, itup2, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup2 = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(btspool2-&gt;sortstate, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_TUPLES_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++tuples_done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(sortKeys);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (deduplicate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> is unnecessary, deduplicate into posting lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BTDedupState dstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstate = (BTDedupState) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTDedupStateData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;deduplicate = <span class="Constant">true</span>; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;nmaxitems = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;maxpostingsize = <span class="Constant">0</span>; <span class="Comment">/* set later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Metadata about base tuple of current pending posting list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;base = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;baseoff = InvalidOffsetNumber;&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;basetupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Metadata about current pending posting list TIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;htids = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;phystupsize = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;nintervals = <span class="Constant">0</span>; <span class="Comment">/* unused */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((itup = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(btspool-&gt;sortstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* When we see first tuple, create first index page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L646" title="access/nbtree/nbtsort.c:646">_bt_pagestate</a>(wstate, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Limit size of posting list tuples to 1/10 space we want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave behind on the page, plus space for final item's line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer.&nbsp; This is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the space that we'd like to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave behind on each leaf page when fillfactor is 90,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allowing us to get close to fillfactor% space utilization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when there happen to be a great many duplicates.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * makes higher leaf fillfactor settings ineffective when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * building indexes that have many duplicates, but packing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leaf pages full with few very large tuples doesn't seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like a useful goal.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;maxpostingsize = MAXALIGN_DOWN((BLCKSZ * <span class="Constant">10</span> / <span class="Constant">100</span>)) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(dstate-&gt;maxpostingsize &lt;= BTMaxItemSize((Page) state-&gt;btps_buf) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dstate-&gt;maxpostingsize &lt;= INDEX_SIZE_MASK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dstate-&gt;htids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(dstate-&gt;maxpostingsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start new pending posting list with itup copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(dstate, <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(wstate-&gt;index, dstate-&gt;base,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itup) &gt; keysz &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="nbtdedup.c.html#L484" title="access/nbtree/nbtdedup.c:484">_bt_dedup_save_htid</a>(dstate, itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to base tuple of pending posting list.&nbsp; Heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID from itup has been saved in state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple is not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to pending posting list tuple, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtdedup.c.html#L484" title="access/nbtree/nbtdedup.c:484">_bt_dedup_save_htid</a>() opted to not <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> current item into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pending posting list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1029" title="access/nbtree/nbtsort.c:1029">_bt_sort_dedup_finish_pending</a>(wstate, state, dstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dstate-&gt;base);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start new pending posting list with itup copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(dstate, <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOffsetNumber);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_TUPLES_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++tuples_done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Handle the last item (there must be a last item when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuplesort returned one or more tuples)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1029" title="access/nbtree/nbtsort.c:1029">_bt_sort_dedup_finish_pending</a>(wstate, state, dstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dstate-&gt;base);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dstate-&gt;htids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(dstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* merging and deduplication are both unnecessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((itup = <a href="../../utils/sort/tuplesortvariants.c.html#L949" title="utils/sort/tuplesortvariants.c:949">tuplesort_getindextuple</a>(btspool-&gt;sortstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* When we see first tuple, create first index page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state = <a href="#L646" title="access/nbtree/nbtsort.c:646">_bt_pagestate</a>(wstate, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L784" title="access/nbtree/nbtsort.c:784">_bt_buildadd</a>(wstate, state, itup, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_TUPLES_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ++tuples_done);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close down final pages and write the metapage */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1063" title="access/nbtree/nbtsort.c:1063">_bt_uppershutdown</a>(wstate, state);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L129" title="storage/smgr/bulk_write.c:129">smgr_bulk_finish</a>(wstate-&gt;bulkstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create parallel context, and launch workers for leader.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * buildstate argument should be initialized (with the exception of the<br/></li>
<li></span><span class="Comment"> * tuplesort state in spools, which may later be created based on shared<br/></li>
<li></span><span class="Comment"> * state initially set up here).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isconcurrent indicates if operation is CREATE INDEX CONCURRENTLY.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * request is the target number of parallel worker processes to launch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sets buildstate's <a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a>, which caller must use to shut down parallel<br/></li>
<li></span><span class="Comment"> * mode by passing it to <a href="#L1607" title="access/nbtree/nbtsort.c:1607">_bt_end_parallel</a>() at the very end of its index<br/></li>
<li></span><span class="Comment"> * build.&nbsp; If not even a single worker process can be launched, this is<br/></li>
<li></span><span class="Comment"> * never set, and caller should proceed with a serial index build.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1396">&#x200c;</a></span><span class="linkable">_bt_begin_parallel</span>(<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isconcurrent, <span class="Type">int</span> request)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelContext *pcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scantuplesortstates;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; estbtshared;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; estsort;<br/></li>
<li>&nbsp; &nbsp; <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>&nbsp;&nbsp; *btshared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *btspool = buildstate-&gt;spool;<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a>&nbsp;&nbsp; *btleader = (<a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a>));<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufferusage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; leaderparticipates = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querylen;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DISABLE_LEADER_PARTICIPATION<br/></li>
<li></span>&nbsp; &nbsp; leaderparticipates = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Enter parallel mode, and create context for parallel build of btree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/xact.c.html#L1048" title="access/transam/xact.c:1048">EnterParallelMode</a>();<br/></li>
<li>&nbsp; &nbsp; Assert(request &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; pcxt = <a href="../transam/parallel.c.html#L167" title="access/transam/parallel.c:167">CreateParallelContext</a>(<span class="Constant">&quot;postgres&quot;</span>, <span class="Constant">&quot;<a href="#L1740" title="access/nbtree/nbtsort.c:1740">_bt_parallel_build_main</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; request);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scantuplesortstates = leaderparticipates ? request + <span class="Constant">1</span> : request;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare for scan of the base relation.&nbsp; In a normal index build, we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SnapshotAny because we must retrieve all tuples and do our own time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * qual checks (because we have to index RECENTLY_DEAD tuples).&nbsp; In a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent build, we take a regular MVCC snapshot and index whatever's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * live according to that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isconcurrent)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = SnapshotAny;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate size for our own <a href="#L62" title="access/nbtree/nbtsort.c:62">PARALLEL_KEY_BTREE_SHARED</a> workspace, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../brin/brin.c.html#L48" title="access/brin/brin.c:48">PARALLEL_KEY_TUPLESORT</a> tuplesort workspace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estbtshared = <a href="#L1633" title="access/nbtree/nbtsort.c:1633">_bt_parallel_estimate_shared</a>(btspool-&gt;heap, snapshot);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, estbtshared);<br/></li>
<li>&nbsp; &nbsp; estsort = <a href="../../utils/sort/tuplesort.c.html#L2955" title="utils/sort/tuplesort.c:2955">tuplesort_estimate_shared</a>(scantuplesortstates);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, estsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unique case requires a second spool, and so we may have to account for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another shared workspace for that -- <a href="#L64" title="access/nbtree/nbtsort.c:64">PARALLEL_KEY_TUPLESORT_SPOOL2</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!btspool-&gt;isunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, estsort);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate space for WalUsage and BufferUsage -- <a href="../../executor/execParallel.c.html#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and <a href="../../executor/execParallel.c.html#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no extensions loaded that care, we could <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have no way of knowing whether anyone's looking at <a href="../../executor/instrument.c.html#L22" title="executor/instrument.c:22">pgWalUsage</a> or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../executor/instrument.c.html#L20" title="executor/instrument.c:20">pgBufferUsage</a>, so do it unconditionally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, estimate <a href="../../executor/execParallel.c.html#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a> space */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querylen = strlen(<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_chunk(&amp;pcxt-&gt;estimator, querylen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; shm_toc_estimate_keys(&amp;pcxt-&gt;estimator, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querylen = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Everyone's had a chance to ask for space, so <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> create the DSM */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L205" title="access/transam/parallel.c:205">InitializeParallelDSM</a>(pcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no DSM segment was available, back out (do serial build) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;seg == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsMVCCSnapshot(snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/parallel.c.html#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xact.c.html#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store shared build state, for which we reserved space */<br/></li>
<li></span>&nbsp; &nbsp; btshared = (<a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, estbtshared);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize immutable state */<br/></li>
<li></span>&nbsp; &nbsp; btshared-&gt;heaprelid = RelationGetRelid(btspool-&gt;heap);<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;indexrelid = RelationGetRelid(btspool-&gt;index);<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;isunique = btspool-&gt;isunique;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;nulls_not_distinct = btspool-&gt;nulls_not_distinct;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;isconcurrent = isconcurrent;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;scantuplesortstates = scantuplesortstates;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;btshared-&gt;workersdonecv);<br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;btshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize mutable state */<br/></li>
<li></span>&nbsp; &nbsp; btshared-&gt;nparticipantsdone = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;reltuples = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;havedead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;indtuples = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;brokenhotchain = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../table/tableam.c.html#L145" title="access/table/tableam.c:145">table_parallelscan_initialize</a>(btspool-&gt;heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="access/nbtree/nbtsort.c:159">ParallelTableScanFromBTShared</a>(btshared),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store shared tuplesort-private state, for which we reserved space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> opaque state using tuplesort routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sharedsort = (<a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, estsort);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L2976" title="utils/sort/tuplesort.c:2976">tuplesort_initialize_shared</a>(sharedsort, scantuplesortstates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L62" title="access/nbtree/nbtsort.c:62">PARALLEL_KEY_BTREE_SHARED</a>, btshared);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../brin/brin.c.html#L48" title="access/brin/brin.c:48">PARALLEL_KEY_TUPLESORT</a>, sharedsort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unique case requires a second spool, and associated shared state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!btspool-&gt;isunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sharedsort2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store additional shared tuplesort-private state, for which we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reserved space.&nbsp; Then, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> opaque state using tuplesort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sharedsort2 = (<a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, estsort);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L2976" title="utils/sort/tuplesort.c:2976">tuplesort_initialize_shared</a>(sharedsort2, scantuplesortstates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pcxt-&gt;seg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="#L64" title="access/nbtree/nbtsort.c:64">PARALLEL_KEY_TUPLESORT_SPOOL2</a>, sharedsort2);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Store query string for workers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sharedquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sharedquery = (<span class="Type">char</span> *) <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc, querylen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(sharedquery, <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>, querylen + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../../executor/execParallel.c.html#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a>, sharedquery);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space for each worker's WalUsage and BufferUsage; no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; walusage = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(WalUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../../executor/execParallel.c.html#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a>, walusage);<br/></li>
<li>&nbsp; &nbsp; bufferusage = <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a>(pcxt-&gt;toc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BufferUsage), pcxt-&gt;nworkers));<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/ipc/shm_toc.c.html#L171" title="storage/ipc/shm_toc.c:171">shm_toc_insert</a>(pcxt-&gt;toc, <a href="../../executor/execParallel.c.html#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>, bufferusage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Launch workers, saving status for leader/caller */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L552" title="access/transam/parallel.c:552">LaunchParallelWorkers</a>(pcxt);<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;pcxt = pcxt;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;nparticipanttuplesorts = pcxt-&gt;nworkers_launched;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (leaderparticipates)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btleader-&gt;nparticipanttuplesorts++;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;btshared = btshared;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;sharedsort = sharedsort;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;sharedsort2 = sharedsort2;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;snapshot = snapshot;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;walusage = walusage;<br/></li>
<li>&nbsp; &nbsp; btleader-&gt;bufferusage = bufferusage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no workers were successfully launched, back out (do serial build) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pcxt-&gt;nworkers_launched == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1607" title="access/nbtree/nbtsort.c:1607">_bt_end_parallel</a>(btleader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save leader state <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that it's clear build will be parallel */<br/></li>
<li></span>&nbsp; &nbsp; buildstate-&gt;btleader = btleader;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Join heap scan ourselves */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leaderparticipates)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1687" title="access/nbtree/nbtsort.c:1687">_bt_leader_participate_as_worker</a>(buildstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caller needs to wait for all launched workers when we return.&nbsp; Make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure that the failure-to-start case will not hang forever.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L672" title="access/transam/parallel.c:672">WaitForParallelWorkersToAttach</a>(pcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Shut down workers, destroy parallel context, and end parallel mode.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1607">&#x200c;</a></span><span class="linkable">_bt_end_parallel</span>(<a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a> *btleader)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> worker processes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L775" title="access/transam/parallel.c:775">WaitForParallelWorkersToFinish</a>(btleader-&gt;pcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next, accumulate WAL usage.&nbsp; (This must wait for the workers to finish,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or we might get incomplete data.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; btleader-&gt;pcxt-&gt;nworkers_launched; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../executor/instrument.c.html#L218" title="executor/instrument.c:218">InstrAccumParallelQuery</a>(&amp;btleader-&gt;bufferusage[i], &amp;btleader-&gt;walusage[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free last reference to MVCC snapshot, if one was used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsMVCCSnapshot(btleader-&gt;snapshot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(btleader-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/parallel.c.html#L929" title="access/transam/parallel.c:929">DestroyParallelContext</a>(btleader-&gt;pcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xact.c.html#L1061" title="access/transam/xact.c:1061">ExitParallelMode</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns size of shared memory required to store state for a parallel<br/></li>
<li></span><span class="Comment"> * btree index build based on the snapshot its parallel scan will use.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Size<br/></li>
<li><a id="L1633">&#x200c;</a><span class="linkable">_bt_parallel_estimate_shared</span>(Relation heap, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* c.f. <a href="../../storage/ipc/shm_toc.c.html#L88" title="storage/ipc/shm_toc.c:88">shm_toc_allocate</a> as to why BUFFERALIGN is used */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(BUFFERALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../table/tableam.c.html#L130" title="access/table/tableam.c:130">table_parallelscan_estimate</a>(heap, snapshot));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Within leader, wait for end of heap scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, parallel heap scan started by <a href="#L1396" title="access/nbtree/nbtsort.c:1396">_bt_begin_parallel</a>() will<br/></li>
<li></span><span class="Comment"> * already be underway within worker processes (when leader participates<br/></li>
<li></span><span class="Comment"> * as a worker, we should end up here just as workers are finishing).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fills in fields needed for ambuild statistics, and lets caller set<br/></li>
<li></span><span class="Comment"> * field indicating that some worker encountered a broken HOT chain.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the total number of heap tuples scanned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">double<br/></li>
<li><a id="L1653">&#x200c;</a></span><span class="linkable">_bt_parallel_heapscan</span>(<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *brokenhotchain)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>&nbsp;&nbsp; *btshared = buildstate-&gt;btleader-&gt;btshared;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nparticipanttuplesorts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nparticipanttuplesorts = buildstate-&gt;btleader-&gt;nparticipanttuplesorts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;btshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btshared-&gt;nparticipantsdone == nparticipanttuplesorts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;havedead = btshared-&gt;havedead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buildstate-&gt;indtuples = btshared-&gt;indtuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *brokenhotchain = btshared-&gt;brokenhotchain;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reltuples = btshared-&gt;reltuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;btshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;btshared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;btshared-&gt;workersdonecv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_PARALLEL_CREATE_INDEX_SCAN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> reltuples;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Within leader, participate as a parallel worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1687">&#x200c;</a></span><span class="linkable">_bt_leader_participate_as_worker</span>(<a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> *buildstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="access/nbtree/nbtsort.c:165">BTLeader</a>&nbsp;&nbsp; *btleader = buildstate-&gt;btleader;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *leaderworker;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *leaderworker2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortmem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate memory and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> private spool */<br/></li>
<li></span>&nbsp; &nbsp; leaderworker = (<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>));<br/></li>
<li>&nbsp; &nbsp; leaderworker-&gt;heap = buildstate-&gt;spool-&gt;heap;<br/></li>
<li>&nbsp; &nbsp; leaderworker-&gt;index = buildstate-&gt;spool-&gt;index;<br/></li>
<li>&nbsp; &nbsp; leaderworker-&gt;isunique = buildstate-&gt;spool-&gt;isunique;<br/></li>
<li>&nbsp; &nbsp; leaderworker-&gt;nulls_not_distinct = buildstate-&gt;spool-&gt;nulls_not_distinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize second spool, if required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!btleader-&gt;btshared-&gt;isunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leaderworker2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate memory for worker's own private secondary spool */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leaderworker2 = (<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize worker's own secondary spool */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leaderworker2-&gt;heap = leaderworker-&gt;heap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leaderworker2-&gt;index = leaderworker-&gt;index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leaderworker2-&gt;isunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Might as well use reliable figure when doling out <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (when requested number of workers were not launched, this will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * somewhat higher than it is for other workers).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sortmem = <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> / btleader-&gt;nparticipanttuplesorts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform work common to all participants */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1862" title="access/nbtree/nbtsort.c:1862">_bt_parallel_scan_and_sort</a>(leaderworker, leaderworker2, btleader-&gt;btshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btleader-&gt;sharedsort, btleader-&gt;sharedsort2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortmem, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BTREE_BUILD_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L510" title="utils/misc/guc_tables.c:510">log_btree_build_stats</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;BTREE BUILD (Leader Partial Spool) STATISTICS&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BTREE_BUILD_STATS */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform work within a launched parallel process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1740">&#x200c;</a></span><span class="linkable">_bt_parallel_build_main</span>(<a href="../../storage/ipc/dsm.c.html#L66" title="storage/ipc/dsm.c:66">dsm_segment</a> *seg, <a href="../../storage/ipc/shm_toc.c.html#L26" title="storage/ipc/shm_toc.c:26">shm_toc</a> *toc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sharedquery;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *btspool;<br/></li>
<li>&nbsp; &nbsp; <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>&nbsp; &nbsp; *btspool2;<br/></li>
<li>&nbsp; &nbsp; <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a>&nbsp;&nbsp; *btshared;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort;<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort2;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRel;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; heapLockmode;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; indexLockmode;<br/></li>
<li>&nbsp; &nbsp; WalUsage&nbsp;&nbsp; *walusage;<br/></li>
<li>&nbsp; &nbsp; BufferUsage *bufferusage;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortmem;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BTREE_BUILD_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L510" title="utils/misc/guc_tables.c:510">log_btree_build_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BTREE_BUILD_STATS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only possible status flag that can be set to the parallel worker is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PROC_IN_SAFE_IC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;statusFlags == PROC_IN_SAFE_IC));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> for individual workers first */<br/></li>
<li></span>&nbsp; &nbsp; sharedquery = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../../executor/execParallel.c.html#L64" title="executor/execParallel.c:64">PARALLEL_KEY_QUERY_TEXT</a>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a> = sharedquery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report the query string from leader */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, <a href="../../tcop/postgres.c.html#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up nbtree shared state */<br/></li>
<li></span>&nbsp; &nbsp; btshared = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L62" title="access/nbtree/nbtsort.c:62">PARALLEL_KEY_BTREE_SHARED</a>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open relations using lock modes known to be obtained by index.c */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!btshared-&gt;isconcurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapLockmode = ShareLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexLockmode = AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapLockmode = ShareUpdateExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexLockmode = RowExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open relations within worker */<br/></li>
<li></span>&nbsp; &nbsp; heapRel = <a href="../table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(btshared-&gt;heaprelid, heapLockmode);<br/></li>
<li>&nbsp; &nbsp; indexRel = <a href="../index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(btshared-&gt;indexrelid, indexLockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize worker's own spool */<br/></li>
<li></span>&nbsp; &nbsp; btspool = (<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>));<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;heap = heapRel;<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;index = indexRel;<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;isunique = btshared-&gt;isunique;<br/></li>
<li>&nbsp; &nbsp; btspool-&gt;nulls_not_distinct = btshared-&gt;nulls_not_distinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up shared state private to tuplesort.c */<br/></li>
<li></span>&nbsp; &nbsp; sharedsort = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../brin/brin.c.html#L48" title="access/brin/brin.c:48">PARALLEL_KEY_TUPLESORT</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L2999" title="utils/sort/tuplesort.c:2999">tuplesort_attach_shared</a>(sharedsort, seg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!btshared-&gt;isunique)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btspool2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sharedsort2 = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate memory for worker's own private secondary spool */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; btspool2 = (<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize worker's own secondary spool */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;heap = btspool-&gt;heap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;index = btspool-&gt;index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;isunique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look up shared state private to tuplesort.c */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sharedsort2 = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="#L64" title="access/nbtree/nbtsort.c:64">PARALLEL_KEY_TUPLESORT_SPOOL2</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L2999" title="utils/sort/tuplesort.c:2999">tuplesort_attach_shared</a>(sharedsort2, seg);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to track buffer usage during parallel execution */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../executor/instrument.c.html#L200" title="executor/instrument.c:200">InstrStartParallelQuery</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform sorting of spool, and possibly a spool2 */<br/></li>
<li></span>&nbsp; &nbsp; sortmem = <a href="../../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> / btshared-&gt;scantuplesortstates;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1862" title="access/nbtree/nbtsort.c:1862">_bt_parallel_scan_and_sort</a>(btspool, btspool2, btshared, sharedsort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sharedsort2, sortmem, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report WAL/buffer usage during parallel execution */<br/></li>
<li></span>&nbsp; &nbsp; bufferusage = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../../executor/execParallel.c.html#L60" title="executor/execParallel.c:60">PARALLEL_KEY_BUFFER_USAGE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; walusage = <a href="../../storage/ipc/shm_toc.c.html#L232" title="storage/ipc/shm_toc.c:232">shm_toc_lookup</a>(toc, <a href="../../executor/execParallel.c.html#L66" title="executor/execParallel.c:66">PARALLEL_KEY_WAL_USAGE</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../executor/instrument.c.html#L208" title="executor/instrument.c:208">InstrEndParallelQuery</a>(&amp;bufferusage[<a href="../transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;walusage[<a href="../transam/parallel.c.html#L112" title="access/transam/parallel.c:112">ParallelWorkerNumber</a>]);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef BTREE_BUILD_STATS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../utils/misc/guc_tables.c.html#L510" title="utils/misc/guc_tables.c:510">log_btree_build_stats</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;BTREE BUILD (Worker Partial Spool) STATISTICS&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../tcop/postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* BTREE_BUILD_STATS */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRel, indexLockmode);<br/></li>
<li>&nbsp; &nbsp; <a href="../table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRel, heapLockmode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a worker's portion of a parallel sort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This generates a tuplesort for passed btspool, and a second tuplesort<br/></li>
<li></span><span class="Comment"> * state if a second btspool is need (i.e. for unique index builds).&nbsp; All<br/></li>
<li></span><span class="Comment"> * other spool fields should already be set when this is called.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * sortmem is the amount of working memory to use within each worker,<br/></li>
<li></span><span class="Comment"> * expressed in KBs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When this returns, workers are done, and need only release resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1862">&#x200c;</a></span><span class="linkable">_bt_parallel_scan_and_sort</span>(<a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool, <a href="#L80" title="access/nbtree/nbtsort.c:80">BTSpool</a> *btspool2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L94" title="access/nbtree/nbtsort.c:94">BTShared</a> *btshared, <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/sort/tuplesort.c.html#L346" title="utils/sort/tuplesort.c:346">Sharedsort</a> *sharedsort2, <span class="Type">int</span> sortmem, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortCoordinate coordinate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L202" title="access/nbtree/nbtsort.c:202">BTBuildState</a> buildstate;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; reltuples;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize local tuplesort coordination state */<br/></li>
<li></span>&nbsp; &nbsp; coordinate = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortCoordinateData));<br/></li>
<li>&nbsp; &nbsp; coordinate-&gt;isWorker = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; coordinate-&gt;nParticipants = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; coordinate-&gt;sharedsort = sharedsort;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin &quot;partial&quot; tuplesort */<br/></li>
<li></span>&nbsp; &nbsp; btspool-&gt;sortstate = <a href="../../utils/sort/tuplesortvariants.c.html#L352" title="utils/sort/tuplesortvariants.c:352">tuplesort_begin_index_btree</a>(btspool-&gt;heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btspool-&gt;index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btspool-&gt;isunique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; btspool-&gt;nulls_not_distinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sortmem, coordinate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TUPLESORT_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Just as with serial case, there may be a second spool.&nbsp; If so, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second, dedicated spool2 partial tuplesort is required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (btspool2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SortCoordinate coordinate2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We expect that the second one (for dead tuples) won't get very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full, so we give it only <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> (unless sortmem is less for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker).&nbsp; Worker processes are generally permitted to allocate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> independently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; coordinate2 = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SortCoordinateData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate2-&gt;isWorker = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate2-&gt;nParticipants = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coordinate2-&gt;sharedsort = sharedsort2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btspool2-&gt;sortstate =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesortvariants.c.html#L352" title="utils/sort/tuplesortvariants.c:352">tuplesort_begin_index_btree</a>(btspool-&gt;heap, btspool-&gt;index, <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(sortmem, <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>), coordinate2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in buildstate for <a href="#L577" title="access/nbtree/nbtsort.c:577">_bt_build_callback</a>() */<br/></li>
<li></span>&nbsp; &nbsp; buildstate.isunique = btshared-&gt;isunique;<br/></li>
<li>&nbsp; &nbsp; buildstate.nulls_not_distinct = btshared-&gt;nulls_not_distinct;<br/></li>
<li>&nbsp; &nbsp; buildstate.havedead = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.heap = btspool-&gt;heap;<br/></li>
<li>&nbsp; &nbsp; buildstate.spool = btspool;<br/></li>
<li>&nbsp; &nbsp; buildstate.spool2 = btspool2;<br/></li>
<li>&nbsp; &nbsp; buildstate.indtuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; buildstate.btleader = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Join parallel scan */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo = <a href="../../catalog/index.c.html#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(btspool-&gt;index);<br/></li>
<li>&nbsp; &nbsp; indexInfo-&gt;ii_Concurrent = btshared-&gt;isconcurrent;<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../table/tableam.c.html#L165" title="access/table/tableam.c:165">table_beginscan_parallel</a>(btspool-&gt;heap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="access/nbtree/nbtsort.c:159">ParallelTableScanFromBTShared</a>(btshared));<br/></li>
<li>&nbsp; &nbsp; reltuples = table_index_build_scan(btspool-&gt;heap, btspool-&gt;index, indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, progress, <a href="#L577" title="access/nbtree/nbtsort.c:577">_bt_build_callback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">void</span> *) &amp;buildstate, scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute this worker's part of the sort */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_BTREE_PHASE_PERFORMSORT_1);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(btspool-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btspool2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_BTREE_PHASE_PERFORMSORT_2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(btspool2-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done.&nbsp; Record ambuild statistics, and whether we encountered a broken<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HOT chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;btshared-&gt;mutex);<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;nparticipantsdone++;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;reltuples += reltuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (buildstate.havedead)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btshared-&gt;havedead = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; btshared-&gt;indtuples += buildstate.indtuples;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_BrokenHotChain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btshared-&gt;brokenhotchain = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;btshared-&gt;mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify leader */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L259" title="storage/lmgr/condition_variable.c:259">ConditionVariableSignal</a>(&amp;btshared-&gt;workersdonecv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can end tuplesorts immediately */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(btspool-&gt;sortstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btspool2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(btspool2-&gt;sortstate);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
