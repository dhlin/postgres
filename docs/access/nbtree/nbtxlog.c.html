<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtxlog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtxlog.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L25">opCtx</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L139">_bt_clear_incomplete_split</a></li>
<li><a href="#L82">_bt_restore_meta</a></li>
<li><a href="#L36">_bt_restore_page</a></li>
<li><a href="#L1091">btree_mask</a></li>
<li><a href="#L1014">btree_redo</a></li>
<li><a href="#L1081">btree_xlog_cleanup</a></li>
<li><a href="#L464">btree_xlog_dedup</a></li>
<li><a href="#L651">btree_xlog_delete</a></li>
<li><a href="#L160">btree_xlog_insert</a></li>
<li><a href="#L713">btree_xlog_mark_page_halfdead</a></li>
<li><a href="#L937">btree_xlog_newroot</a></li>
<li><a href="#L1003">btree_xlog_reuse_page</a></li>
<li><a href="#L251">btree_xlog_split</a></li>
<li><a href="#L1073">btree_xlog_startup</a></li>
<li><a href="#L798">btree_xlog_unlink_page</a></li>
<li><a href="#L557">btree_xlog_updates</a></li>
<li><a href="#L598">btree_xlog_vacuum</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtxlog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; WAL replay logic for btrees.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtxlog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/bufmask.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/standby.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L25">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">opCtx</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* working memory for operations */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L36" title="access/nbtree/nbtxlog.c:36">_bt_restore_page</a> -- re-enter all the index tuples on a page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page is freshly init'd, and *from (length len) is a copy of what<br/></li>
<li></span><span class="Comment"> * had been its <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> part (pd_upper to pd_special).&nbsp; We assume that the<br/></li>
<li></span><span class="Comment"> * tuples had been added to the page in item-number order, and therefore<br/></li>
<li></span><span class="Comment"> * the one with highest item number appears first (lowest on the page).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L36">&#x200c;</a></span><span class="linkable">_bt_restore_page</span>(Page page, <span class="Type">char</span> *from, <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTupleData itupdata;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *end = from + len;<br/></li>
<li>&nbsp; &nbsp; Item&nbsp; &nbsp; &nbsp; &nbsp; items[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; itemsizes[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To get the items back in the original order, we add them to the page in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reverse.&nbsp; To figure out where one tuple ends and another begins, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to scan them in forward order first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (from &lt; end)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As we step through the items, 'from' won't always be properly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aligned, so we need to use memcpy().&nbsp; Further, we use Item (which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is just a char*) here for our items array for the same reason;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wouldn't want the compiler or anyone thinking that an item is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aligned when it isn't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;itupdata, from, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = IndexTupleSize(&amp;itupdata);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = MAXALIGN(itemsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; items[i] = (Item) from;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsizes[i] = itemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; from += itemsz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nitems = i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = nitems - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, items[i], itemsizes[i], nitems - i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L36" title="access/nbtree/nbtxlog.c:36">_bt_restore_page</a>: cannot add item to page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L82">&#x200c;</a></span><span class="linkable">_bt_restore_meta</span>(XLogReaderState *record, uint8 block_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *md;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque pageop;<br/></li>
<li>&nbsp; &nbsp; xl_btree_metadata *xlrec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuf = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, block_id);<br/></li>
<li>&nbsp; &nbsp; ptr = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, block_id, &amp;len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(len == <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_btree_metadata));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(metabuf) == BTREE_METAPAGE);<br/></li>
<li>&nbsp; &nbsp; xlrec = (xl_btree_metadata *) ptr;<br/></li>
<li>&nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(metapg, BufferGetPageSize(metabuf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; md = BTPageGetMeta(metapg);<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_magic = BTREE_MAGIC;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_version = xlrec-&gt;version;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_root = xlrec-&gt;root;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_level = xlrec-&gt;level;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_fastroot = xlrec-&gt;fastroot;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_fastlevel = xlrec-&gt;fastlevel;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cannot log BTREE_MIN_VERSION index metapage without upgrade */<br/></li>
<li></span>&nbsp; &nbsp; Assert(md-&gt;btm_version &gt;= BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_last_cleanup_num_delpages = xlrec-&gt;last_cleanup_num_delpages;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_last_cleanup_num_heap_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; md-&gt;btm_allequalimage = xlrec-&gt;allequalimage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageop = BTPageGetOpaque(metapg);<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_flags = BTP_META;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) metapg)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) md + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData)) - (<span class="Type">char</span> *) metapg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(metapg, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(metabuf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L139" title="access/nbtree/nbtxlog.c:139">_bt_clear_incomplete_split</a> -- clear INCOMPLETE_SPLIT flag on a page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a common subroutine of the redo <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of all the WAL record<br/></li>
<li></span><span class="Comment"> * types that can insert a downlink: insert, split, and newroot.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="linkable">_bt_clear_incomplete_split</span>(XLogReaderState *record, uint8 block_id)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, block_id, &amp;buf) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque pageop = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(P_INCOMPLETE_SPLIT(pageop));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_flags &amp;= ~BTP_INCOMPLETE_SPLIT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L160">&#x200c;</a></span><span class="linkable">btree_xlog_insert</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isleaf, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ismeta, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> posting,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_insert *xlrec = (xl_btree_insert *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Insertion to an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page finishes an incomplete split at the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * level.&nbsp; Clear the incomplete-split flag in the child.&nbsp; Note: during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal operation, the child and parent pages are locked at the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time (the locks are coupled), so that clearing the flag and inserting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the downlink appear atomic to other backends.&nbsp; We don't bother with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that during replay, because readers don't care about the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incomplete-split flag and there cannot be updates happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isleaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="access/nbtree/nbtxlog.c:139">_bt_clear_incomplete_split</a>(record, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *datapos = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!posting)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple retail insertion */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) datapos, datalen, xlrec-&gt;offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add new item&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; oposting,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nposting;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; postingoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A posting list split occurred during leaf page insertion.&nbsp; WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record data will start with an offset number representing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point in an existing posting list that a split occurs at.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use <a href="nbtdedup.c.html#L1022" title="access/nbtree/nbtdedup.c:1022">_bt_swap_posting</a>() to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> posting list split steps from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primary.&nbsp; Note that newitem from WAL record is 'orignewitem',<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not the final version of newitem that is actually inserted on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postingoff = *((uint16 *) datapos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datapos += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen -= <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, OffsetNumberPrev(xlrec-&gt;offnum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oposting = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use mutable, aligned newitem copy in <a href="nbtdedup.c.html#L1022" title="access/nbtree/nbtdedup.c:1022">_bt_swap_posting</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(isleaf &amp;&amp; postingoff &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitem = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>((IndexTuple) datapos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nposting = <a href="nbtdedup.c.html#L1022" title="access/nbtree/nbtdedup.c:1022">_bt_swap_posting</a>(newitem, oposting, postingoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace existing posting list with post-split version */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(oposting, nposting, MAXALIGN(IndexTupleSize(nposting)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> &quot;final&quot; new item (not orignewitem from WAL stream) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IndexTupleSize(newitem) == datalen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) newitem, datalen, xlrec-&gt;offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to add posting split new item&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: in normal operation, we'd update the metapage while still holding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock on the page we inserted into.&nbsp; But during replay it's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary to hold that lock, since no other index updates can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happening concurrently, and readers will cope fine with following an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * obsolete link from the metapage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ismeta)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="access/nbtree/nbtxlog.c:82">_bt_restore_meta</a>(record, <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L251">&#x200c;</a></span><span class="linkable">btree_xlog_split</span>(<span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newitemonleft, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_split *xlrec = (xl_btree_split *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isleaf = (xlrec-&gt;level == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; rpage;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque ropaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *datapos;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; datalen;<br/></li>
<li>&nbsp; &nbsp; BlockNumber origpagenumber;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rightpagenumber;<br/></li>
<li>&nbsp; &nbsp; BlockNumber spagenumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;origpagenumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;rightpagenumber);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../transam/xlogreader.c.html#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(record, <span class="Constant">2</span>, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, &amp;spagenumber, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spagenumber = P_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the incomplete split flag on the appropriate child page one level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down when origpage/buf is an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page (there must have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cascading page splits during original execution in the event of an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page split).&nbsp; This is like the corresponding <a href="#L160" title="access/nbtree/nbtxlog.c:160">btree_xlog_insert</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages.&nbsp; We're not clearing the incomplete split flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the current page split here (you can think of this as part of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert of newitem that the page split action needs to perform in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passing).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Like in <a href="#L160" title="access/nbtree/nbtxlog.c:160">btree_xlog_insert</a>, this can be done <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locking other pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We never need to couple cross-level locks in REDO routines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isleaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="access/nbtree/nbtxlog.c:139">_bt_clear_incomplete_split</a>(record, <span class="Constant">3</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reconstruct right (new) sibling page from scratch */<br/></li>
<li></span>&nbsp; &nbsp; rbuf = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; datapos = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">1</span>, &amp;datalen);<br/></li>
<li>&nbsp; &nbsp; rpage = (Page) BufferGetPage(rbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(rpage, BufferGetPageSize(rbuf));<br/></li>
<li>&nbsp; &nbsp; ropaque = BTPageGetOpaque(rpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ropaque-&gt;btpo_prev = origpagenumber;<br/></li>
<li>&nbsp; &nbsp; ropaque-&gt;btpo_next = spagenumber;<br/></li>
<li>&nbsp; &nbsp; ropaque-&gt;btpo_level = xlrec-&gt;level;<br/></li>
<li>&nbsp; &nbsp; ropaque-&gt;btpo_flags = isleaf ? BTP_LEAF : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ropaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L36" title="access/nbtree/nbtxlog.c:36">_bt_restore_page</a>(rpage, datapos, datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(rpage, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(rbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now reconstruct original page (left half of split) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buf) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To retain the same physical order of the tuples that they had, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a temporary empty page for the left page and add all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * items to that in item number order.&nbsp; This mirrors how <a href="nbtinsert.c.html#L1467" title="access/nbtree/nbtinsert.c:1467">_bt_split</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works.&nbsp; Retaining the same physical order makes WAL consistency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking possible.&nbsp; See also <a href="#L36" title="access/nbtree/nbtxlog.c:36">_bt_restore_page</a>(), which does the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same for the right page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; origpage = (Page) BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque oopaque = BTPageGetOpaque(origpage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber off;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; newitem = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_hikey = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nposting = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newitemsz = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_hikeysz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; leftpage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber leftoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replacepostingoff = InvalidOffsetNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datapos = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;datalen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newitemonleft || xlrec-&gt;postingoff != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitem = (IndexTuple) datapos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitemsz = MAXALIGN(IndexTupleSize(newitem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datapos += newitemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datalen -= newitemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;postingoff != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; oposting;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Posting list must be at offset number <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> new item's */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replacepostingoff = OffsetNumberPrev(xlrec-&gt;newitemoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use mutable, aligned newitem copy in <a href="nbtdedup.c.html#L1022" title="access/nbtree/nbtdedup.c:1022">_bt_swap_posting</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitem = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(newitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(origpage, replacepostingoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oposting = (IndexTuple) PageGetItem(origpage, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nposting = <a href="nbtdedup.c.html#L1022" title="access/nbtree/nbtdedup.c:1022">_bt_swap_posting</a>(newitem, oposting,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;postingoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract left hikey and its size.&nbsp; We assume that 16-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> alignment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is enough to apply IndexTupleSize (since it's fetching from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uint16 field).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; left_hikey = (IndexTuple) datapos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; left_hikeysz = MAXALIGN(IndexTupleSize(left_hikey));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datapos += left_hikeysz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datalen -= left_hikeysz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(datalen == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftpage = <a href="../../storage/page/bufpage.c.html#L402" title="storage/page/bufpage.c:402">PageGetTempPageCopySpecial</a>(origpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add high key tuple from WAL record to temp page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leftoff = P_HIKEY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(leftpage, (Item) left_hikey, left_hikeysz, P_HIKEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add high key to left page after split&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftoff = OffsetNumberNext(leftoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (off = P_FIRSTDATAKEY(oopaque); off &lt; xlrec-&gt;firstrightoff; off++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add replacement posting list when required */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (off == replacepostingoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(newitemonleft ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;firstrightoff == xlrec-&gt;newitemoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(leftpage, (Item) nposting,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(IndexTupleSize(nposting)), leftoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add new posting list item to left page after split&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftoff = OffsetNumberNext(leftoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't insert oposting */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* add the new item if it was inserted on left page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (newitemonleft &amp;&amp; off == xlrec-&gt;newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(leftpage, (Item) newitem, newitemsz, leftoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add new item to left page after split&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftoff = OffsetNumberNext(leftoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(origpage, off);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsz = ItemIdGetLength(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = (IndexTuple) PageGetItem(origpage, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(leftpage, (Item) item, itemsz, leftoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add old item to left page after split&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftoff = OffsetNumberNext(leftoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cope with possibility that newitem goes at the end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newitemonleft &amp;&amp; off == xlrec-&gt;newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(leftpage, (Item) newitem, newitemsz, leftoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;failed to add new item to left page after split&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftoff = OffsetNumberNext(leftoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L424" title="storage/page/bufpage.c:424">PageRestoreTempPage</a>(leftpage, origpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fix opaque fields */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oopaque-&gt;btpo_flags = BTP_INCOMPLETE_SPLIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isleaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oopaque-&gt;btpo_flags |= BTP_LEAF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oopaque-&gt;btpo_next = rightpagenumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oopaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(origpage, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix left-link of the page to the right of the new right sibling */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (spagenumber != P_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; sbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">2</span>, &amp;sbuf) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; spage = (Page) BufferGetPage(sbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque spageop = BTPageGetOpaque(spage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; spageop-&gt;btpo_prev = rightpagenumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(spage, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(sbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(sbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(sbuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, release the remaining buffers.&nbsp; sbuf, rbuf, and buf must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * released together, so that readers cannot observe inconsistencies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(rbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L464">&#x200c;</a></span><span class="linkable">btree_xlog_dedup</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_dedup *xlrec = (xl_btree_dedup *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buf) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTDedupState state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTDedupInterval *intervals;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; newpage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state = (BTDedupState) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTDedupStateData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;deduplicate = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nmaxitems = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Conservatively use larger maxpostingsize than primary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxpostingsize = BTMaxItemSize(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;base = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;baseoff = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;basetupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;htids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;maxpostingsize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;phystupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nintervals = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minoff = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newpage = <a href="../../storage/page/bufpage.c.html#L402" title="storage/page/bufpage.c:402">PageGetTempPageCopySpecial</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz = ItemIdGetLength(itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; item = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(newpage, (Item) item, itemsz, P_HIKEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;deduplication failed to add highkey&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intervals = (BTDedupInterval *) ptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (offnum = minoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum == minoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(state, itup, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;nintervals &lt; xlrec-&gt;nintervals &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;baseoff == intervals[state-&gt;nintervals].baseoff &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;nitems &lt; intervals[state-&gt;nintervals].nitems)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="nbtdedup.c.html#L484" title="access/nbtree/nbtdedup.c:484">_bt_dedup_save_htid</a>(state, itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;deduplication failed to add heap tid to pending posting list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L555" title="access/nbtree/nbtdedup.c:555">_bt_dedup_finish_pending</a>(newpage, state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(state, itup, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L555" title="access/nbtree/nbtdedup.c:555">_bt_dedup_finish_pending</a>(newpage, state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;nintervals == xlrec-&gt;nintervals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(memcmp(state-&gt;intervals, intervals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nintervals * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTDedupInterval)) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_HAS_GARBAGE(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque nopaque = BTPageGetOpaque(newpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nopaque-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L424" title="storage/page/bufpage.c:424">PageRestoreTempPage</a>(newpage, page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L557">&#x200c;</a></span><span class="linkable">btree_xlog_updates</span>(Page page, OffsetNumber *updatedoffsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xl_btree_update *updates, <span class="Type">int</span> nupdated)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTVacuumPosting vacposting;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; origtuple;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdated; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, updatedoffsets[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; origtuple = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacposting = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(BTVacuumPostingData, deletetids) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updates-&gt;ndeletedtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;updatedoffset = updatedoffsets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;itup = origtuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;ndeletedtids = updates-&gt;ndeletedtids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(vacposting-&gt;deletetids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">char</span> *) updates + SizeOfBtreeUpdate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updates-&gt;ndeletedtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L924" title="access/nbtree/nbtdedup.c:924">_bt_update_posting</a>(vacposting);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Overwrite updated version of tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = MAXALIGN(IndexTupleSize(vacposting-&gt;itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(page, updatedoffsets[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Item) vacposting-&gt;itup, itemsz))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to update partially dead item&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacposting-&gt;itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacposting);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> xl_btree_update from array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; updates = (xl_btree_update *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) updates + SizeOfBtreeUpdate +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updates-&gt;ndeletedtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L598">&#x200c;</a></span><span class="linkable">btree_xlog_vacuum</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_vacuum *xlrec = (xl_btree_vacuum *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to take a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock here, just like <a href="nbtree.c.html#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a>(). However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it isn't necessary to exhaustively get a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on every block in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index during recovery (just getting a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on pages with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * items to kill suffices).&nbsp; See nbtree/README for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L351" title="access/transam/xlogutils.c:351">XLogReadBufferForRedoExtended</a>(record, <span class="Constant">0</span>, RBM_NORMAL, <span class="Constant">true</span>, &amp;buffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;nupdated &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *updatedoffsets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_btree_update *updates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatedoffsets = (OffsetNumber *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ptr + xlrec-&gt;ndeleted * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updates = (xl_btree_update *) ((<span class="Type">char</span> *) updatedoffsets +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;nupdated *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L557" title="access/nbtree/nbtxlog.c:557">btree_xlog_updates</a>(page, updatedoffsets, updates, xlrec-&gt;nupdated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;ndeleted &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, (OffsetNumber *) ptr, xlrec-&gt;ndeleted);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark the page as not containing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items --- see comments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in <a href="nbtpage.c.html#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L651">&#x200c;</a></span><span class="linkable">btree_xlog_delete</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_delete *xlrec = (xl_btree_delete *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflict processing to do, it must happen <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xlogreader.c.html#L1971" title="access/transam/xlogreader.c:1971">XLogRecGetBlockTag</a>(record, <span class="Constant">0</span>, &amp;rlocator, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L467" title="storage/ipc/standby.c:467">ResolveRecoveryConflictWithSnapshot</a>(xlrec-&gt;snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec-&gt;isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to take a <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock to apply these changes. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nbtree/README for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">0</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;nupdated &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *updatedoffsets;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_btree_update *updates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatedoffsets = (OffsetNumber *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ptr + xlrec-&gt;ndeleted * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updates = (xl_btree_update *) ((<span class="Type">char</span> *) updatedoffsets +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;nupdated *<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L557" title="access/nbtree/nbtxlog.c:557">btree_xlog_updates</a>(page, updatedoffsets, updates, xlrec-&gt;nupdated);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;ndeleted &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, (OffsetNumber *) ptr, xlrec-&gt;ndeleted);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the page as not containing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LP_DEAD items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L713">&#x200c;</a></span><span class="linkable">btree_xlog_mark_page_halfdead</span>(uint8 info, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_mark_page_halfdead *xlrec = (xl_btree_mark_page_halfdead *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque pageop;<br/></li>
<li>&nbsp; &nbsp; IndexTupleData trunctuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal operation, we would lock all the pages this WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * touches <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them.&nbsp; In WAL replay, it should be okay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to lock just one page at a time, since no concurrent index updates can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be happening, and readers should not care whether they arrive at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target page or not (since it's surely empty).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* to-be-deleted subtree's parent page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;buffer) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber poffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber nextoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber rightsib;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; poffset = xlrec-&gt;poffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextoffset = OffsetNumberNext(poffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, nextoffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightsib = BTreeTupleGetDownLink(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, poffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetDownLink(itup, rightsib);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nextoffset = OffsetNumberNext(poffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, nextoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't need to couple cross-level locks in REDO routines, so release<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock on <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(buffer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rewrite the leaf page as a halfdead page */<br/></li>
<li></span>&nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(buffer));<br/></li>
<li>&nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_prev = xlrec-&gt;leftblk;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_next = xlrec-&gt;rightblk;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_flags = BTP_HALF_DEAD | BTP_LEAF;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a dummy high key item that points to top parent page (value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is InvalidBlockNumber when the top parent page is the leaf page itself)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(&amp;trunctuple, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData));<br/></li>
<li>&nbsp; &nbsp; trunctuple.t_info = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData);<br/></li>
<li>&nbsp; &nbsp; BTreeTupleSetTopParent(&amp;trunctuple, xlrec-&gt;topparent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) &amp;trunctuple, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData), P_HIKEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not add dummy high key to half-dead page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L798">&#x200c;</a></span><span class="linkable">btree_xlog_unlink_page</span>(uint8 info, XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_unlink_page *xlrec = (xl_btree_unlink_page *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; BlockNumber leftsib;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rightsib;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; level;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isleaf;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId safexid;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; leftbuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; target;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rightbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque pageop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; leftsib = xlrec-&gt;leftsib;<br/></li>
<li>&nbsp; &nbsp; rightsib = xlrec-&gt;rightsib;<br/></li>
<li>&nbsp; &nbsp; level = xlrec-&gt;level;<br/></li>
<li>&nbsp; &nbsp; isleaf = (level == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; safexid = xlrec-&gt;safexid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No leaftopparent for level 0 (leaf page) or level 1 target */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!BlockNumberIsValid(xlrec-&gt;leaftopparent) || level &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In normal operation, we would lock all the pages this WAL record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * touches <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> changing <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of them.&nbsp; In WAL replay, we at least lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pages in the same standard left-to-right order (leftsib, target,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rightsib), and don't release the sibling locks until the target is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * marked deleted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix right-link of left sibling, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leftsib != P_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">1</span>, &amp;leftbuf) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(leftbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_next = rightsib;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leftbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leftbuf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rewrite target page as empty deleted page */<br/></li>
<li></span>&nbsp; &nbsp; target = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(target));<br/></li>
<li>&nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_prev = leftsib;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_next = rightsib;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_level = level;<br/></li>
<li>&nbsp; &nbsp; BTPageSetDeleted(page, safexid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isleaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_flags |= BTP_LEAF;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix left-link of right sibling */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>(record, <span class="Constant">2</span>, &amp;rightbuf) == BLK_NEEDS_REDO)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(rightbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_prev = leftsib;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(rightbuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release siblings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(leftbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(leftbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(rightbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(rightbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release target */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we deleted a parent of the targeted leaf page, instead of the leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself, update the leaf to point to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> remaining child in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to-be-deleted subtree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecHasBlockRef(record, <span class="Constant">3</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no real data on the page, so we just re-create it from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scratch using the information from the WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't end up here when the target page is also the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leafbuf page.&nbsp; There is no need to add a dummy hikey item with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * top parent link when deleting leafbuf because it's the last page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll delete in the subtree undergoing deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; leafbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTupleData trunctuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!isleaf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leafbuf = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">3</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) BufferGetPage(leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(leafbuf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_flags = BTP_HALF_DEAD | BTP_LEAF;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_prev = xlrec-&gt;leafleftsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_next = xlrec-&gt;leafrightsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add a dummy hikey item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(&amp;trunctuple, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; trunctuple.t_info = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetTopParent(&amp;trunctuple, xlrec-&gt;leaftopparent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(page, (Item) &amp;trunctuple, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData), P_HIKEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not add dummy high key to half-dead page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(leafbuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update metapage if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_BTREE_UNLINK_PAGE_META)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="access/nbtree/nbtxlog.c:82">_bt_restore_meta</a>(record, <span class="Constant">4</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L937">&#x200c;</a></span><span class="linkable">btree_xlog_newroot</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; xl_btree_newroot *xlrec = (xl_btree_newroot *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque pageop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ptr;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buffer = <a href="../transam/xlogutils.c.html#L326" title="access/transam/xlogutils.c:326">XLogInitBufferForRedo</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; page = (Page) BufferGetPage(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(buffer));<br/></li>
<li>&nbsp; &nbsp; pageop = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_flags = BTP_ROOT;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_prev = pageop-&gt;btpo_next = P_NONE;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_level = xlrec-&gt;level;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pageop-&gt;btpo_flags |= BTP_LEAF;<br/></li>
<li>&nbsp; &nbsp; pageop-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;level &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ptr = <a href="../transam/xlogreader.c.html#L2025" title="access/transam/xlogreader.c:2025">XLogRecGetBlockData</a>(record, <span class="Constant">0</span>, &amp;len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L36" title="access/nbtree/nbtxlog.c:36">_bt_restore_page</a>(page, ptr, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear the incomplete-split flag in left child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="access/nbtree/nbtxlog.c:139">_bt_clear_incomplete_split</a>(record, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PageSetLSN(page, lsn);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buffer);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4867" title="storage/buffer/bufmgr.c:4867">UnlockReleaseBuffer</a>(buffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L82" title="access/nbtree/nbtxlog.c:82">_bt_restore_meta</a>(record, <span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In general VACUUM must defer recycling as a way of avoiding certain race<br/></li>
<li></span><span class="Comment"> * conditions.&nbsp; Deleted pages contain a safexid value that is used by VACUUM<br/></li>
<li></span><span class="Comment"> * to determine whether or not it's safe to place a page that was deleted by<br/></li>
<li></span><span class="Comment"> * VACUUM earlier into the FSM <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; See nbtree/README.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As far as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend operating during original execution is concerned, the<br/></li>
<li></span><span class="Comment"> * FSM is a cache of recycle-safe pages; the mere presence of the page in the<br/></li>
<li></span><span class="Comment"> * FSM indicates that the page must already be safe to recycle (actually,<br/></li>
<li></span><span class="Comment"> * <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>() verifies it's safe using BTPageIsRecyclable(), but that's just<br/></li>
<li></span><span class="Comment"> * because it would be unwise to completely trust the FSM, given its current<br/></li>
<li></span><span class="Comment"> * limitations).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This isn't sufficient to prevent similar concurrent recycling race<br/></li>
<li></span><span class="Comment"> * conditions during Hot Standby, though.&nbsp; For that we need to log a<br/></li>
<li></span><span class="Comment"> * xl_btree_reuse_page record at the point that a page is actually recycled<br/></li>
<li></span><span class="Comment"> * and reused for an entirely unrelated page inside <a href="nbtinsert.c.html#L1467" title="access/nbtree/nbtinsert.c:1467">_bt_split</a>().&nbsp; These<br/></li>
<li></span><span class="Comment"> * <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> include the same safexid value from the original deleted page,<br/></li>
<li></span><span class="Comment"> * stored in the record's snapshotConflictHorizon field.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../storage/ipc/procarray.c.html#L4270" title="storage/ipc/procarray.c:4270">GlobalVisCheckRemovableFullXid</a>() test in BTPageIsRecyclable() is used<br/></li>
<li></span><span class="Comment"> * to determine if it's safe to recycle a page.&nbsp; This mirrors our own test:<br/></li>
<li></span><span class="Comment"> * the PGPROC-&gt;xmin &gt; limitXmin test inside <a href="../../storage/ipc/procarray.c.html#L3404" title="storage/ipc/procarray.c:3404">GetConflictingVirtualXIDs</a>().<br/></li>
<li></span><span class="Comment"> * Consequently, one XID value achieves the same exclusion effect on primary<br/></li>
<li></span><span class="Comment"> * and standby.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1003">&#x200c;</a></span><span class="linkable">btree_xlog_reuse_page</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_btree_reuse_page *xlrec = (xl_btree_reuse_page *) XLogRecGetData(record);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (InHotStandby)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/ipc/standby.c.html#L511" title="storage/ipc/standby.c:511">ResolveRecoveryConflictWithSnapshotFullXid</a>(xlrec-&gt;snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;locator);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1014">&#x200c;</a></span><span class="linkable">btree_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldCtx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldCtx = MemoryContextSwitchTo(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (info)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_INSERT_LEAF:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/nbtree/nbtxlog.c:160">btree_xlog_insert</a>(<span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_INSERT_UPPER:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/nbtree/nbtxlog.c:160">btree_xlog_insert</a>(<span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_INSERT_META:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/nbtree/nbtxlog.c:160">btree_xlog_insert</a>(<span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_SPLIT_L:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L251" title="access/nbtree/nbtxlog.c:251">btree_xlog_split</a>(<span class="Constant">true</span>, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_SPLIT_R:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L251" title="access/nbtree/nbtxlog.c:251">btree_xlog_split</a>(<span class="Constant">false</span>, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_INSERT_POST:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="access/nbtree/nbtxlog.c:160">btree_xlog_insert</a>(<span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">true</span>, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_DEDUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L464" title="access/nbtree/nbtxlog.c:464">btree_xlog_dedup</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_VACUUM:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L598" title="access/nbtree/nbtxlog.c:598">btree_xlog_vacuum</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L651" title="access/nbtree/nbtxlog.c:651">btree_xlog_delete</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_MARK_PAGE_HALFDEAD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L713" title="access/nbtree/nbtxlog.c:713">btree_xlog_mark_page_halfdead</a>(info, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_UNLINK_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_UNLINK_PAGE_META:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L798" title="access/nbtree/nbtxlog.c:798">btree_xlog_unlink_page</a>(info, record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_NEWROOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L937" title="access/nbtree/nbtxlog.c:937">btree_xlog_newroot</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_REUSE_PAGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1003" title="access/nbtree/nbtxlog.c:1003">btree_xlog_reuse_page</a>(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> XLOG_BTREE_META_CLEANUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L82" title="access/nbtree/nbtxlog.c:82">_bt_restore_meta</a>(record, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L1014" title="access/nbtree/nbtxlog.c:1014">btree_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldCtx);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1073">&#x200c;</a></span><span class="linkable">btree_xlog_startup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a> = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Btree recovery temporary context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L1081">&#x200c;</a></span><span class="linkable">btree_xlog_cleanup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../spgist/spgxlog.c.html#L25" title="access/spgist/spgxlog.c:25">opCtx</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Mask a btree page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> performing consistency checks on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1091">&#x200c;</a></span><span class="linkable">btree_mask</span>(<span class="Type">char</span> *pagedata, BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = (Page) pagedata;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque maskopaq;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L31" title="access/common/bufmask.c:31">mask_page_lsn_and_checksum</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L46" title="access/common/bufmask.c:46">mask_page_hint_bits</a>(page);<br/></li>
<li>&nbsp; &nbsp; <a href="../common/bufmask.c.html#L71" title="access/common/bufmask.c:71">mask_unused_space</a>(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; maskopaq = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (P_ISLEAF(maskopaq))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In btree leaf pages, it is possible to modify the LP_FLAGS without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitting <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL record. Hence, mask the line pointer flags. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>(), <a href="nbtinsert.c.html#L408" title="access/nbtree/nbtinsert.c:408">_bt_check_unique</a>() for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/bufmask.c.html#L95" title="access/common/bufmask.c:95">mask_lp_flags</a>(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BTP_HAS_GARBAGE is just an un-logged hint <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>. So, mask it. See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtinsert.c.html#L2683" title="access/nbtree/nbtinsert.c:2683">_bt_delete_or_dedup_one_page</a>(), <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>(), and <a href="nbtinsert.c.html#L408" title="access/nbtree/nbtinsert.c:408">_bt_check_unique</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maskopaq-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During replay of a btree page split, we don't set the BTP_SPLIT_END<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * flag of the right sibling and <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the cycle_id to 0 for the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page. See <a href="#L251" title="access/nbtree/nbtxlog.c:251">btree_xlog_split</a>() for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; maskopaq-&gt;btpo_flags &amp;= ~BTP_SPLIT_END;<br/></li>
<li>&nbsp; &nbsp; maskopaq-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
