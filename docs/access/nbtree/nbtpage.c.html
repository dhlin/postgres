<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtpage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtpage.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L869">_bt_allocbuf</a></li>
<li><a href="#L797">_bt_checkpage</a></li>
<li><a href="#L1093">_bt_conditionallockbuf</a></li>
<li><a href="#L1464">_bt_delitems_cmp</a></li>
<li><a href="#L1284">_bt_delitems_delete</a></li>
<li><a href="#L1513">_bt_delitems_delete_check</a></li>
<li><a href="#L1405">_bt_delitems_update</a></li>
<li><a href="#L1154">_bt_delitems_vacuum</a></li>
<li><a href="#L845">_bt_getbuf</a></li>
<li><a href="#L142">_bt_getmeta</a></li>
<li><a href="#L344">_bt_getroot</a></li>
<li><a href="#L675">_bt_getrootheight</a></li>
<li><a href="#L580">_bt_gettrueroot</a></li>
<li><a href="#L67">_bt_initmetapage</a></li>
<li><a href="#L1695">_bt_leftsib_splitflag</a></li>
<li><a href="#L2813">_bt_lock_subtree_parent</a></li>
<li><a href="#L1039">_bt_lockbuf</a></li>
<li><a href="#L2088">_bt_mark_page_halfdead</a></li>
<li><a href="#L739">_bt_metaversion</a></li>
<li><a href="#L1802">_bt_pagedel</a></li>
<li><a href="#L1129">_bt_pageinit</a></li>
<li><a href="#L3062">_bt_pendingfsm_add</a></li>
<li><a href="#L2995">_bt_pendingfsm_finalize</a></li>
<li><a href="#L2954">_bt_pendingfsm_init</a></li>
<li><a href="#L1003">_bt_relandgetbuf</a></li>
<li><a href="#L1023">_bt_relbuf</a></li>
<li><a href="#L1752">_bt_rightsib_halfdeadflag</a></li>
<li><a href="#L232">_bt_set_cleanup_info</a></li>
<li><a href="#L2314">_bt_unlink_halfdead_page</a></li>
<li><a href="#L1070">_bt_unlockbuf</a></li>
<li><a href="#L1109">_bt_upgradelockbufcleanup</a></li>
<li><a href="#L107">_bt_upgrademetapage</a></li>
<li><a href="#L179">_bt_vacuum_needs_cleanup</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtpage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; BTree-specific page management code for the Postgres btree access<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; method.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtpage.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Postgres btree pages look like ordinary relation pages.&nbsp; The opaque<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; data at high addresses includes pointers to left and right siblings<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; and flag data describing page state.&nbsp; The first page in a btree, page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; zero, is special -- it stores meta-information describing the tree.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Pages one and higher store the actual tree data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procarray.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memdebug.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> BTMetaPageData *<a href="#L142" title="access/nbtree/nbtpage.c:142">_bt_getmeta</a>(Relation rel, Buffer metabuf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1284" title="access/nbtree/nbtpage.c:1284">_bt_delitems_delete</a>(Relation rel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId snapshotConflictHorizon,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *deletable, <span class="Type">int</span> ndeletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting *updatable, <span class="Type">int</span> nupdatable);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1405" title="access/nbtree/nbtpage.c:1405">_bt_delitems_update</a>(BTVacuumPosting *updatable, <span class="Type">int</span> nupdatable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber *updatedoffsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size *updatedbuflen, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> needswal);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2088" title="access/nbtree/nbtpage.c:2088">_bt_mark_page_halfdead</a>(Relation rel, Relation heaprel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Buffer leafbuf, BTStack stack);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2314" title="access/nbtree/nbtpage.c:2314">_bt_unlink_halfdead_page</a>(Relation rel, Buffer leafbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber scanblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *rightsib_empty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTVacState *vstate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a>(Relation rel, Relation heaprel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber child, BTStack stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer *subtreeparent, OffsetNumber *poffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber *topparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber *topparentrightsib);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3062" title="access/nbtree/nbtpage.c:3062">_bt_pendingfsm_add</a>(BTVacState *vstate, BlockNumber target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FullTransactionId safexid);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L67" title="access/nbtree/nbtpage.c:67">_bt_initmetapage</a>() -- Fill a page buffer with a correct metapage image<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="linkable">_bt_initmetapage</span>(Page page, BlockNumber rootbknum, uint32 level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allequalimage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque metaopaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metad = BTPageGetMeta(page);<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_magic = BTREE_MAGIC;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_version = BTREE_VERSION;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_root = rootbknum;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_level = level;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_fastroot = rootbknum;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_fastlevel = level;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_delpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_heap_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_allequalimage = allequalimage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metaopaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; metaopaque-&gt;btpo_flags = BTP_META;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set pd_lower just past the end of the metadata.&nbsp; This is essential,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because without doing so, metadata will be lost if xlog.c compresses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metad + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData)) - (<span class="Type">char</span> *) page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L107" title="access/nbtree/nbtpage.c:107">_bt_upgrademetapage</a>() -- Upgrade a meta-page from an old format to version<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 3, the last version that can be updated without broadly affecting<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on-disk compatibility.&nbsp; (A REINDEX is required to upgrade to v4.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine does purely in-memory image upgrade.&nbsp; Caller is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; responsible for locking, WAL-logging etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="linkable">_bt_upgrademetapage</span>(Page page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque metaopaque <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metad = BTPageGetMeta(page);<br/></li>
<li>&nbsp; &nbsp; metaopaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It must be really a meta page of upgradable version */<br/></li>
<li></span>&nbsp; &nbsp; Assert(metaopaque-&gt;btpo_flags &amp; BTP_META);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_version &lt; BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_MIN_VERSION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set version number and fill extra fields added into version 3 */<br/></li>
<li></span>&nbsp; &nbsp; metad-&gt;btm_version = BTREE_NOVAC_VERSION;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_delpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_heap_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only a REINDEX can set this field */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!metad-&gt;btm_allequalimage);<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_allequalimage = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust pd_lower (see <a href="#L67" title="access/nbtree/nbtpage.c:67">_bt_initmetapage</a>() for details) */<br/></li>
<li></span>&nbsp; &nbsp; ((PageHeader) page)-&gt;pd_lower =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">char</span> *) metad + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData)) - (<span class="Type">char</span> *) page;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get metadata from share-locked buffer containing metapage, while performing<br/></li>
<li></span><span class="Comment"> * standard sanity checks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers that cache data returned here in local cache should note that an<br/></li>
<li></span><span class="Comment"> * on-the-fly upgrade using <a href="#L107" title="access/nbtree/nbtpage.c:107">_bt_upgrademetapage</a>() can change the version field<br/></li>
<li></span><span class="Comment"> * and BTREE_NOVAC_VERSION specific fields without invalidating local cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BTMetaPageData *<br/></li>
<li><a id="L142">&#x200c;</a><span class="linkable">_bt_getmeta</span>(Relation rel, Buffer metabuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque metaopaque;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li>&nbsp; &nbsp; metaopaque = BTPageGetOpaque(metapg);<br/></li>
<li>&nbsp; &nbsp; metad = BTPageGetMeta(metapg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity-check the metapage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!P_ISMETA(metaopaque) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_magic != BTREE_MAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a btree&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_version &lt; BTREE_MIN_VERSION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_version &gt; BTREE_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;version mismatch in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: file version </span><span class="Special">%d</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;current version </span><span class="Special">%d</span><span class="Constant">, minimal supported version </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_version, BTREE_VERSION, BTREE_MIN_VERSION)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> metad;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a>() -- Checks if index needs <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called by <a href="nbtree.c.html#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a> when <a href="nbtree.c.html#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> was never called because no<br/></li>
<li></span><span class="Comment"> * index tuples needed to be deleted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L179">&#x200c;</a></span><span class="linkable">_bt_vacuum_needs_cleanup</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; btm_version;<br/></li>
<li>&nbsp; &nbsp; BlockNumber prev_num_delpages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy details from metapage to local variables quickly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we deliberately avoid using cached version of metapage here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_READ);<br/></li>
<li>&nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li>&nbsp; &nbsp; metad = BTPageGetMeta(metapg);<br/></li>
<li>&nbsp; &nbsp; btm_version = metad-&gt;btm_version;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btm_version &lt; BTREE_NOVAC_VERSION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Metapage needs to be dynamically upgraded to store fields that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only present when btm_version &gt;= BTREE_NOVAC_VERSION<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev_num_delpages = metad-&gt;btm_last_cleanup_num_delpages;<br/></li>
<li>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Trigger <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> in rare cases where prev_num_delpages exceeds 5% of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * total size of the index.&nbsp; We can reasonably expect (though are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guaranteed) to be able to recycle this many pages if we decide to do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a> call during the ongoing <a href="nbtree.c.html#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a>.&nbsp; For further<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * details see the nbtree/README section on placing deleted pages in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FSM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (prev_num_delpages &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prev_num_delpages &gt; RelationGetNumberOfBlocks(rel) / <span class="Constant">20</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L232" title="access/nbtree/nbtpage.c:232">_bt_set_cleanup_info</a>() -- Update metapage for <a href="nbtree.c.html#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called at the end of <a href="nbtree.c.html#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a>, when num_delpages value has been<br/></li>
<li></span><span class="Comment"> * finalized.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L232">&#x200c;</a></span><span class="linkable">_bt_set_cleanup_info</span>(Relation rel, BlockNumber num_delpages)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On-disk compatibility note: The btm_last_cleanup_num_delpages metapage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field started out as a TransactionId field called btm_oldest_btpo_xact.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Both &quot;versions&quot; are just uint32 fields.&nbsp; It was convenient to repurpose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the field when we began to use 64-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> XIDs in deleted pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that a pg_upgrade'd database will contain an XID value in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> recognized as the metapage's btm_last_cleanup_num_delpages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * field.&nbsp; <a href="#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a>() may even believe that this value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicates that there are lots of pages that it needs to recycle, when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in reality there are only one or two.&nbsp; The worst that can happen is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that there will be a call to <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a> a little earlier, which will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set btm_last_cleanup_num_delpages to a sane value when we're called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note also that the metapage's btm_last_cleanup_num_heap_tuples field is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no longer used as of PostgreSQL 14.&nbsp; We set it to -1.0 on rewrite, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be consistent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_READ);<br/></li>
<li>&nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li>&nbsp; &nbsp; metad = BTPageGetMeta(metapg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't <a href="../../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> chance to upgrade index/metapage when BTREE_MIN_VERSION */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_version &gt;= BTREE_NOVAC_VERSION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_delpages == num_delpages)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Usually means index continues to have num_delpages of 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* trade in our read lock for a write lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, metabuf, BT_WRITE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* upgrade meta-page if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_version &lt; BTREE_NOVAC_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="access/nbtree/nbtpage.c:107">_bt_upgrademetapage</a>(metapg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-related information */<br/></li>
<li></span>&nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_delpages = num_delpages;<br/></li>
<li>&nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_heap_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* write wal record if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_metadata md;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, metabuf, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.version = metad-&gt;btm_version;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.root = metad-&gt;btm_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.level = metad-&gt;btm_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.fastroot = metad-&gt;btm_fastroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.fastlevel = metad-&gt;btm_fastlevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.last_cleanup_num_delpages = num_delpages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; md.allequalimage = metad-&gt;btm_allequalimage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) &amp;md, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_btree_metadata));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_META_CLEANUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapg, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>() -- Get the root page of the btree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Since the root page can move around the btree file, we have to read<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; its location from the metadata page, and then read the root page<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; itself.&nbsp; If no root page exists yet, we have to create one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The access type parameter (BT_READ or BT_WRITE) controls whether<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a new root page will be created or not.&nbsp; If access = BT_READ,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; and no root page exists, we just return InvalidBuffer.&nbsp; For<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; BT_WRITE, we try to create the root page if it doesn't exist.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> that the returned root page will have only a read lock set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on it even if access = BT_WRITE!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; If access = BT_WRITE, heaprel must be set; otherwise caller can just<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pass NULL.&nbsp; See <a href="#L869" title="access/nbtree/nbtpage.c:869">_bt_allocbuf</a> for an explanation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The returned page is not necessarily the true root --- it could be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a &quot;fast root&quot; (a page that is alone in its level due to deletions).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also, if the root page is split while we are &quot;in flight&quot; to it,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; what we will return is the old root, which is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> just the leftmost<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; page on a probably-not-very-wide level.&nbsp; For most purposes this is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as good as or better than the true root, so we do not bother to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; insist on finding the true root.&nbsp; We do, however, guarantee to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; return a live (not deleted or half-dead) page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On successful return, the root page is pinned and read-locked.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The metadata page is not locked or pinned on exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L344">&#x200c;</a><span class="linkable">_bt_getroot</span>(Relation rel, Relation heaprel, <span class="Type">int</span> access)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rootbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; rootpage;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque rootopaque;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rootblkno;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; rootlevel;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(access == BT_READ || heaprel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to use previously-cached metapage data to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the root.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normally saves one buffer access per index search, which is a very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * helpful savings in bufmgr traffic and hence contention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad = (BTMetaPageData *) rel-&gt;rd_amcache;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't have cached it if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these fail */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_magic == BTREE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_MIN_VERSION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_version &lt;= BTREE_VERSION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!metad-&gt;btm_allequalimage ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; metad-&gt;btm_version &gt; BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_root != P_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootblkno = metad-&gt;btm_fastroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rootblkno != P_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootlevel = metad-&gt;btm_fastlevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootbuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, rootblkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootpage = BufferGetPage(rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque = BTPageGetOpaque(rootpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since the cache might be stale, we check the page more carefully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here than normal.&nbsp; We *must* check that it's not deleted. If it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not alone on its level, then we reject too --- this may be overly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * paranoid but better safe than sorry.&nbsp; Note we don't check P_ISROOT,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because that's not set in a &quot;fast root&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_IGNORE(rootopaque) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootopaque-&gt;btpo_level == rootlevel &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P_LEFTMOST(rootopaque) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P_RIGHTMOST(rootopaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> cached page as the root */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rootbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cache is stale, throw it away */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rel-&gt;rd_amcache);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_amcache = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_READ);<br/></li>
<li>&nbsp; &nbsp; metad = <a href="#L142" title="access/nbtree/nbtpage.c:142">_bt_getmeta</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if no root page initialized yet, do it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_root == P_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If access = BT_READ, caller doesn't want us to create root yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (access == BT_READ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trade in our read lock for a write lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, metabuf, BT_WRITE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Race condition:&nbsp; &nbsp; if someone else initialized the metadata between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the time we released the read lock and acquired the write lock, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must avoid doing it again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_root != P_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Metadata initialized by someone else.&nbsp; In order to guarantee no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deadlocks, we have to release the metadata page and start all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * over again.&nbsp; (Is that really true? But it's hardly worth trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>(rel, heaprel, access);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get, <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>, write, and leave a lock of the appropriate type on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the new root page.&nbsp; Since this is the first page in the tree, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a leaf as well as the root.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rootbuf = <a href="#L869" title="access/nbtree/nbtpage.c:869">_bt_allocbuf</a>(rel, heaprel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootpage = BufferGetPage(rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque = BTPageGetOpaque(rootpage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque-&gt;btpo_prev = rootopaque-&gt;btpo_next = P_NONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque-&gt;btpo_flags = (BTP_LEAF | BTP_ROOT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque-&gt;btpo_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get raw page pointer for metapage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NO ELOG(ERROR) till meta is updated */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* upgrade metapage if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_version &lt; BTREE_NOVAC_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="access/nbtree/nbtpage.c:107">_bt_upgrademetapage</a>(metapg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_root = rootblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_fastroot = rootblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_fastlevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_delpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_last_cleanup_num_heap_tuples = -<span class="Constant">1.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_btree_newroot xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_btree_metadata md;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, rootbuf, REGBUF_WILL_INIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">2</span>, metabuf, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.version = metad-&gt;btm_version;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.root = rootblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.fastroot = rootblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.fastlevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.last_cleanup_num_delpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; md.allequalimage = metad-&gt;btm_allequalimage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">2</span>, (<span class="Type">char</span> *) &amp;md, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_btree_metadata));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.rootblk = rootblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.level = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfBtreeNewroot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_NEWROOT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(rootpage, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapg, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * swap root write lock for read lock.&nbsp; There is no danger of anyone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else accessing the new root page while it's unlocked, since no one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else knows where it is yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, rootbuf, BT_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* okay, metadata is correct, release lock on it without caching */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootblkno = metad-&gt;btm_fastroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rootblkno != P_NONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootlevel = metad-&gt;btm_fastlevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cache the metapage data for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_amcache = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rel-&gt;rd_indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(rel-&gt;rd_amcache, metad, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are done with the metapage; arrange to release it via first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a> call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rootbuf = metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootbuf = <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, rootbuf, rootblkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootpage = BufferGetPage(rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootopaque = BTPageGetOpaque(rootpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_IGNORE(rootopaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's dead, Jim.&nbsp; step right one page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(rootopaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no live root page found in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rootblkno = rootopaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rootopaque-&gt;btpo_level != rootlevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;root page </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has level </span><span class="Special">%u</span><span class="Constant">, expected </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rootblkno, RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rootopaque-&gt;btpo_level, rootlevel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here, we have a pin and read lock on the root page, and no lock set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the metadata page.&nbsp; Return the root page's buffer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> rootbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L580" title="access/nbtree/nbtpage.c:580">_bt_gettrueroot</a>() -- Get the true root page of the btree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is the same as the BT_READ case of <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>(), except<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; we follow the true-root link not the fast-root link.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * By the time we acquire lock on the root page, it might have been split and<br/></li>
<li></span><span class="Comment"> * not be the true root anymore.&nbsp; This is okay for the present uses of this<br/></li>
<li></span><span class="Comment"> * routine; we only really need to be able to move up at least one tree level<br/></li>
<li></span><span class="Comment"> * from whatever non-root page we were at.&nbsp; If we ever do need to lock the<br/></li>
<li></span><span class="Comment"> * one true root page, we could loop here, re-reading the metapage on each<br/></li>
<li></span><span class="Comment"> * failure.&nbsp; (Note that it wouldn't do to hold the lock on the metapage while<br/></li>
<li></span><span class="Comment"> * moving to the root --- that'd deadlock against <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent root split.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L580">&#x200c;</a><span class="linkable">_bt_gettrueroot</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque metaopaque;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rootbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; rootpage;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque rootopaque;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rootblkno;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; rootlevel;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't try to use cached metapage data here, since (a) this path is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not performance-critical, and (b) if we are here it suggests our cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is out-of-date anyway.&nbsp; In light of point (b), it's probably safest to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actively flush <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cached metapage info.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rel-&gt;rd_amcache);<br/></li>
<li>&nbsp; &nbsp; rel-&gt;rd_amcache = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_READ);<br/></li>
<li>&nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li>&nbsp; &nbsp; metaopaque = BTPageGetOpaque(metapg);<br/></li>
<li>&nbsp; &nbsp; metad = BTPageGetMeta(metapg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!P_ISMETA(metaopaque) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_magic != BTREE_MAGIC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a btree&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_version &lt; BTREE_MIN_VERSION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_version &gt; BTREE_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;version mismatch in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: file version </span><span class="Special">%d</span><span class="Constant">, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;current version </span><span class="Special">%d</span><span class="Constant">, minimal supported version </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_version, BTREE_VERSION, BTREE_MIN_VERSION)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if no root page initialized yet, fail */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_root == P_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rootblkno = metad-&gt;btm_root;<br/></li>
<li>&nbsp; &nbsp; rootlevel = metad-&gt;btm_level;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are done with the metapage; arrange to release it via first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a> call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rootbuf = metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootbuf = <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, rootbuf, rootblkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootpage = BufferGetPage(rootbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootopaque = BTPageGetOpaque(rootpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_IGNORE(rootopaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it's dead, Jim.&nbsp; step right one page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(rootopaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;no live root page found in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rootblkno = rootopaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rootopaque-&gt;btpo_level != rootlevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;root page </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has level </span><span class="Special">%u</span><span class="Constant">, expected </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rootblkno, RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rootopaque-&gt;btpo_level, rootlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rootbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L675" title="access/nbtree/nbtpage.c:675">_bt_getrootheight</a>() -- Get the height of the btree search tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We return the level (counting from zero) of the current fast root.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This represents the number of tree levels we'd have to descend through<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to start <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> btree index search.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is used by the <a href="../../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> for cost-estimation purposes.&nbsp; Since it's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; only an estimate, slightly-stale data is fine, hence we don't worry<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; about updating previously cached data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L675">&#x200c;</a></span><span class="linkable">_bt_getrootheight</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad = <a href="#L142" title="access/nbtree/nbtpage.c:142">_bt_getmeta</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's no root page yet, <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>() doesn't expect a cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be made, so just stop here and report the index height is zero.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (</span><span class="Todo">XXX</span><span class="Comment"> perhaps <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>() should be changed to allow this case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_root == P_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cache the metapage data for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_amcache = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rel-&gt;rd_indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(rel-&gt;rd_amcache, metad, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get cached page */<br/></li>
<li></span>&nbsp; &nbsp; metad = (BTMetaPageData *) rel-&gt;rd_amcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We shouldn't have cached it if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these fail */<br/></li>
<li></span>&nbsp; &nbsp; Assert(metad-&gt;btm_magic == BTREE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_MIN_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_version &lt;= BTREE_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(!metad-&gt;btm_allequalimage ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; metad-&gt;btm_version &gt; BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_fastroot != P_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> metad-&gt;btm_fastlevel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L739" title="access/nbtree/nbtpage.c:739">_bt_metaversion</a>() -- Get version/status info from metapage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Sets caller's *heapkeyspace and *allequalimage arguments using data<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; from the B-Tree metapage (could be locally-cached version).&nbsp; This<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; information needs to be stashed in insertion scankey, so we provide a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; single function that fetches both at once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is used to determine the rules that must be used to descend a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; btree.&nbsp; Version 4 indexes treat heap TID as a tiebreaker attribute.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_upgrade'd version 3 indexes need extra steps to preserve reasonable<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; performance when inserting a new BTScanInsert-wise duplicate tuple<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; among many leaf pages already full of such duplicates.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also sets allequalimage field, which indicates whether or not it is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; safe to apply deduplication.&nbsp; We rely on the assumption that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; btm_allequalimage will be zero'ed on heapkeyspace indexes that were<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pg_upgrade'd from Postgres 12.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L739">&#x200c;</a></span><span class="linkable">_bt_metaversion</span>(Relation rel, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *heapkeyspace, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *allequalimage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_amcache == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad = <a href="#L142" title="access/nbtree/nbtpage.c:142">_bt_getmeta</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there's no root page yet, <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>() doesn't expect a cache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be made, so just stop here.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> perhaps <a href="#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>() should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be changed to allow this case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_root == P_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *heapkeyspace = metad-&gt;btm_version &gt; BTREE_NOVAC_VERSION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *allequalimage = metad-&gt;btm_allequalimage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cache the metapage data for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An on-the-fly version upgrade performed by <a href="#L107" title="access/nbtree/nbtpage.c:107">_bt_upgrademetapage</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can change the nbtree version for an index without invalidating <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * local cache.&nbsp; This is okay because it can only happen when moving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from version 2 to version 3, both of which are !heapkeyspace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * versions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_amcache = <a href="../../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(rel-&gt;rd_indexcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(rel-&gt;rd_amcache, metad, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTMetaPageData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get cached page */<br/></li>
<li></span>&nbsp; &nbsp; metad = (BTMetaPageData *) rel-&gt;rd_amcache;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We shouldn't have cached it if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these fail */<br/></li>
<li></span>&nbsp; &nbsp; Assert(metad-&gt;btm_magic == BTREE_MAGIC);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_MIN_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_version &lt;= BTREE_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(!metad-&gt;btm_allequalimage ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; metad-&gt;btm_version &gt; BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; Assert(metad-&gt;btm_fastroot != P_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *heapkeyspace = metad-&gt;btm_version &gt; BTREE_NOVAC_VERSION;<br/></li>
<li>&nbsp; &nbsp; *allequalimage = metad-&gt;btm_allequalimage;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>() -- Verify that a freshly-read page looks sane.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L797">&#x200c;</a></span><span class="linkable">_bt_checkpage</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a> verifies that every newly-read page passes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PageHeaderIsValid, which means it either contains a reasonably sane<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page header or is all-zero.&nbsp; We have to defend against the all-zero<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, however.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains unexpected zero page at block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Additionally check that the special area looks sane.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PageGetSpecialSize(page) != MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPageOpaqueData)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains corrupted page at block </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Please REINDEX it.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>() -- Get an existing block in a buffer, for read or write.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The general rule in nbtree is that it's never okay to access a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; page without holding both a buffer pin and a buffer lock on<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the page's buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; When this routine returns, the appropriate lock is set on the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; requested buffer and its reference count has been incremented<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (ie, the buffer is &quot;locked and pinned&quot;).&nbsp; Also, we apply<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a> to sanity-check the page, and perform Valgrind<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; client requests that <a href="../../main/main.c.html#L320" title="main/main.c:320">help</a> Valgrind detect unsafe page accesses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Note: raw <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>() calls are disallowed in nbtree; all<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; buffer lock requests need to go through wrapper <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> such<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; as <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L845">&#x200c;</a><span class="linkable">_bt_getbuf</span>(Relation rel, BlockNumber blkno, <span class="Type">int</span> access)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(blkno));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Read an existing block of the relation */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(rel, blkno);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, buf, access);<br/></li>
<li>&nbsp; &nbsp; <a href="#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L869" title="access/nbtree/nbtpage.c:869">_bt_allocbuf</a>() -- Allocate a new block/page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a write-locked buffer containing an unallocated nbtree page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers are required to pass a valid heaprel.&nbsp; We need heaprel so that we<br/></li>
<li></span><span class="Comment"> * can handle generating a snapshotConflictHorizon that makes reusing a page<br/></li>
<li></span><span class="Comment"> * from the FSM safe for queries that may be running on standbys.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L869">&#x200c;</a><span class="linkable">_bt_allocbuf</span>(Relation rel, Relation heaprel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(heaprel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First see if the FSM knows of <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> free pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't trust the FSM's report unreservedly; we have to check that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page is still free.&nbsp; (For example, an already-free page could have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-used between the time the last VACUUM scanned it and the time the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM made its FSM updates.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In fact, it's worse than that: we can't even assume that it's safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take a lock on the reported page.&nbsp; If somebody else has a lock on it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or even worse our own caller does, we could deadlock.&nbsp; (The own-caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scenario is actually not improbable. Consider an index on a serial or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timestamp column.&nbsp; Nearly all splits will be at the rightmost page, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's entirely likely that <a href="nbtinsert.c.html#L1467" title="access/nbtree/nbtinsert.c:1467">_bt_split</a> will call us while holding a lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on the page most recently acquired from FSM. A VACUUM running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrently with the previous split could well have placed that page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back in FSM.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To get around that, we ask for only a conditional lock on the reported<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.&nbsp; If we fail, then someone else is using the page, and we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reasonably assume it's not free.&nbsp; (If we happen to be wrong, the worst<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consequence is the page will be lost to use till the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> VACUUM, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is no big problem.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = <a href="../../storage/freespace/indexfsm.c.html#L38" title="storage/freespace/indexfsm.c:38">GetFreeIndexPage</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L745" title="storage/buffer/bufmgr.c:745">ReadBuffer</a>(rel, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1093" title="access/nbtree/nbtpage.c:1093">_bt_conditionallockbuf</a>(rel, buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an all-zeroes page in an index.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * example, a backend might successfully extend the relation one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page and then crash <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is able to make a WAL entry for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * adding the page.&nbsp; If we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a zeroed page then reclaim it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay to use page.&nbsp; Initialize and return it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTPageIsRecyclable(page, heaprel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are generating WAL for Hot Standby then create a WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record that will allow us to conflict with queries running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on standby, in case they have snapshots older than safexid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel) &amp;&amp; XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_btree_reuse_page xlrec_reuse;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't register the buffer with the record,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because this operation doesn't modify the page (that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already happened, back when VACUUM deleted the page).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This record only exists to provide a conflict point for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hot Standby.&nbsp; See record REDO routine comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec_reuse.locator = rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec_reuse.block = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec_reuse.snapshotConflictHorizon = BTPageGetDeleteXid(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec_reuse.isCatalogRel =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationIsAccessibleInLogicalDecoding(heaprel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec_reuse, SizeOfBtreeReusePage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_REUSE_PAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay to use page.&nbsp; Re-<a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> and return it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;FSM returned nonrecyclable page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;FSM returned nonlockable page&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* couldn't get lock, so just drop pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extend the relation by one page. Need to use RBM_ZERO_AND_LOCK or we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risk a race condition against <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a> --- see comments therein.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This forces us to <a href="../../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the valgrind request that <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise would make, as we can't use <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>() without introducing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a race.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L845" title="storage/buffer/bufmgr.c:845">ExtendBufferedRel</a>(BMR_REL(rel), MAIN_FORKNUM, <span class="Constant">NULL</span>, EB_LOCK_FIRST);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationUsesLocalBuffers(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(BufferGetPage(buf), BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the new page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning it */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; Assert(PageIsNew(page));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>(page, BufferGetPageSize(buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>() -- release a locked buffer and get another one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is equivalent to <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a> followed by <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>.&nbsp; Also, if obuf is<br/></li>
<li></span><span class="Comment"> * InvalidBuffer then it reduces to just <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>; allowing this case<br/></li>
<li></span><span class="Comment"> * simplifies some callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The original motivation for using this was to avoid two entries to the<br/></li>
<li></span><span class="Comment"> * bufmgr when one would do.&nbsp; However, <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's mainly just a notational<br/></li>
<li></span><span class="Comment"> * convenience.&nbsp; The only case where it saves work over <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>/<a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a><br/></li>
<li></span><span class="Comment"> * is when the target page is the same one already in the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L1003">&#x200c;</a><span class="linkable">_bt_relandgetbuf</span>(Relation rel, Buffer obuf, BlockNumber blkno, <span class="Type">int</span> access)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BlockNumberIsValid(blkno));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(obuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, obuf);<br/></li>
<li>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L2537" title="storage/buffer/bufmgr.c:2537">ReleaseAndReadBuffer</a>(obuf, rel, blkno);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, buf, access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>() -- release a locked buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock and pin (refcount) are both dropped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1023">&#x200c;</a></span><span class="linkable">_bt_relbuf</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>() -- lock a pinned buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Lock is acquired without acquiring another pin.&nbsp; This is like a raw<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>() call, but performs extra steps needed by Valgrind.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Caller may need to call <a href="#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>() with buf when pin on buf<br/></li>
<li></span><span class="Comment"> * wasn't originally acquired in <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>() or <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1039">&#x200c;</a></span><span class="linkable">_bt_lockbuf</span>(Relation rel, Buffer buf, <span class="Type">int</span> access)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>() asserts that pin is held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It doesn't matter that <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>() won't get called in the event of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an nbtree error (e.g. a unique violation error).&nbsp; That won't cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Valgrind false positives.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The nbtree client requests are superimposed on top of the bufmgr.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer pin client requests.&nbsp; In the event of an nbtree error the buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will certainly get marked as defined when the backend once again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * acquires its first pin on the buffer. (Of course, if the backend never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * touches the buffer again then it doesn't matter that it remains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-accessible to Valgrind.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: When an IndexTuple C pointer gets computed using an ItemId read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from a page while a lock was held, the C pointer becomes unsafe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dereference forever as soon as the lock is released.&nbsp; Valgrind can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * detect cases where the pointer gets dereferenced with no _current_<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock/pin held, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationUsesLocalBuffers(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(BufferGetPage(buf), BLCKSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>() -- unlock a pinned buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1070">&#x200c;</a></span><span class="linkable">_bt_unlockbuf</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Buffer is pinned and locked, which means that it is expected to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defined and addressable.&nbsp; Check that proactively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_CHECK_MEM_IS_DEFINED(BufferGetPage(buf), BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>() asserts that pin is held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationUsesLocalBuffers(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_NOACCESS(BufferGetPage(buf), BLCKSZ);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1093" title="access/nbtree/nbtpage.c:1093">_bt_conditionallockbuf</a>() -- conditionally BT_WRITE lock pinned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Caller may need to call <a href="#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>() with buf when pin on buf<br/></li>
<li></span><span class="Comment"> * wasn't originally acquired in <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>() or <a href="#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1093">&#x200c;</a></span><span class="linkable">_bt_conditionallockbuf</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>() asserts that pin is held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/buffer/bufmgr.c.html#L5111" title="storage/buffer/bufmgr.c:5111">ConditionalLockBuffer</a>(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RelationUsesLocalBuffers(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_MAKE_MEM_DEFINED(BufferGetPage(buf), BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1109" title="access/nbtree/nbtpage.c:1109">_bt_upgradelockbufcleanup</a>() -- upgrade lock to a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1109">&#x200c;</a></span><span class="linkable">_bt_upgradelockbufcleanup</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Buffer is pinned and locked, which means that it is expected to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defined and addressable.&nbsp; Check that proactively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; VALGRIND_CHECK_MEM_IS_DEFINED(BufferGetPage(buf), BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>() asserts that pin is held by this backend */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5085" title="storage/buffer/bufmgr.c:5085">LockBuffer</a>(buf, BUFFER_LOCK_UNLOCK);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L5165" title="storage/buffer/bufmgr.c:5165">LockBufferForCleanup</a>(buf);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1129" title="access/nbtree/nbtpage.c:1129">_bt_pageinit</a>() -- Initialize a new page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, the page header is initialized; data space is empty;<br/></li>
<li></span><span class="Comment"> * special space is zeroed out.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1129">&#x200c;</a></span><span class="linkable">_bt_pageinit</span>(Page page, Size size)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L42" title="storage/page/bufpage.c:42">PageInit</a>(page, size, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPageOpaqueData));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> item(s) from a btree leaf page during VACUUM.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine assumes that the caller already has a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on<br/></li>
<li></span><span class="Comment"> * the buffer.&nbsp; Also, the given deletable and updatable arrays *must* be<br/></li>
<li></span><span class="Comment"> * sorted in ascending order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Routine deals with deleting TIDs when some (but not all) of the heap TIDs<br/></li>
<li></span><span class="Comment"> * in an existing posting list item are to be removed.&nbsp; This works by<br/></li>
<li></span><span class="Comment"> * updating/overwriting an existing item with caller's new version of the item<br/></li>
<li></span><span class="Comment"> * (a version that lacks the TIDs that are to be deleted).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We record VACUUMs and b-tree deletes differently in WAL.&nbsp; Deletes must<br/></li>
<li></span><span class="Comment"> * generate their own snapshotConflictHorizon directly from the tableam,<br/></li>
<li></span><span class="Comment"> * whereas VACUUMs rely on the initial VACUUM table scan performing<br/></li>
<li></span><span class="Comment"> * WAL-logging that takes care of the issue for the table's indexes<br/></li>
<li></span><span class="Comment"> * indirectly.&nbsp; Also, we remove the VACUUM cycle ID from pages, which b-tree<br/></li>
<li></span><span class="Comment"> * deletes don't do.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1154">&#x200c;</a></span><span class="linkable">_bt_delitems_vacuum</span>(Relation rel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *deletable, <span class="Type">int</span> ndeletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting *updatable, <span class="Type">int</span> nupdatable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needswal = RelationNeedsWAL(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *updatedbuf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; updatedbuflen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber updatedoffsets[MaxIndexTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be called unless there's something to do */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ndeletable &gt; <span class="Constant">0</span> || nupdatable &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate new version of posting lists without deleted TIDs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nupdatable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; updatedbuf = <a href="#L1405" title="access/nbtree/nbtpage.c:1405">_bt_delitems_update</a>(updatable, nupdatable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updatedoffsets, &amp;updatedbuflen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; needswal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No ereport(ERROR) until changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle posting tuple updates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deliberately do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> handling simple deletes.&nbsp; If we did it the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other way around (i.e. WAL record order -- simple deletes <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updates) then we'd have to make compensating changes to the 'updatable'<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array of offset numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>() won't unset each item's LP_DEAD <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> when it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happens to already be set.&nbsp; It's important that we not interfere with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future simple index tuple deletion operations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber updatedoffset = updatedoffsets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = updatable[i]-&gt;itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = MAXALIGN(IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(page, updatedoffset, (Item) itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemsz))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to update partially dead item in block </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf), RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now handle simple deletes of entire tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, deletable, ndeletable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can clear the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle ID since this page has certainly been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processed by the current <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the BTP_HAS_GARBAGE page flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This flag indicates the presence of LP_DEAD items on the page (though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not reliably).&nbsp; Note that we only rely on it with pg_upgrade'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * !heapkeyspace indexes.&nbsp; That's why clearing it here won't usually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interfere with simple index tuple deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needswal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_vacuum xlrec_vacuum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_vacuum.ndeleted = ndeletable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_vacuum.nupdated = nupdatable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec_vacuum, SizeOfBtreeVacuum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) deletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nupdatable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) updatedoffsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupdatable * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, updatedbuf, updatedbuflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_VACUUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updatedbuf != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(updatedbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free tuples allocated within <a href="#L1405" title="access/nbtree/nbtpage.c:1405">_bt_delitems_update</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(updatable[i]-&gt;itup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> item(s) from a btree leaf page during single-page <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine assumes that the caller has pinned and write locked the<br/></li>
<li></span><span class="Comment"> * buffer.&nbsp; Also, the given deletable and updatable arrays *must* be sorted in<br/></li>
<li></span><span class="Comment"> * ascending order.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Routine deals with deleting TIDs when some (but not all) of the heap TIDs<br/></li>
<li></span><span class="Comment"> * in an existing posting list item are to be removed.&nbsp; This works by<br/></li>
<li></span><span class="Comment"> * updating/overwriting an existing item with caller's new version of the item<br/></li>
<li></span><span class="Comment"> * (a version that lacks the TIDs that are to be deleted).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is nearly the same as <a href="#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a> as far as what it does to<br/></li>
<li></span><span class="Comment"> * the page, but it needs its own snapshotConflictHorizon and isCatalogRel<br/></li>
<li></span><span class="Comment"> * (from the tableam).&nbsp; This is used by the REDO routine to generate recovery<br/></li>
<li></span><span class="Comment"> * conflicts.&nbsp; The other difference is that only <a href="#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a> will<br/></li>
<li></span><span class="Comment"> * clear page's VACUUM cycle ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1284">&#x200c;</a></span><span class="linkable">_bt_delitems_delete</span>(Relation rel, Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionId snapshotConflictHorizon, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *deletable, <span class="Type">int</span> ndeletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting *updatable, <span class="Type">int</span> nupdatable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needswal = RelationNeedsWAL(rel);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *updatedbuf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; updatedbuflen = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber updatedoffsets[MaxIndexTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be called unless there's something to do */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ndeletable &gt; <span class="Constant">0</span> || nupdatable &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate new versions of posting lists without deleted TIDs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nupdatable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; updatedbuf = <a href="#L1405" title="access/nbtree/nbtpage.c:1405">_bt_delitems_update</a>(updatable, nupdatable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; updatedoffsets, &amp;updatedbuflen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; needswal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No ereport(ERROR) until changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle updates and deletes just like <a href="#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber updatedoffset = updatedoffsets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = updatable[i]-&gt;itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = MAXALIGN(IndexTupleSize(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(page, updatedoffset, (Item) itup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itemsz))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;failed to update partially dead item in block </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf), RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1161" title="storage/page/bufpage.c:1161">PageIndexMultiDelete</a>(page, deletable, ndeletable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike <a href="#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a>, we *must not* clear the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle ID at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this point.&nbsp; The VACUUM command alone controls <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle IDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the BTP_HAS_GARBAGE page flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This flag indicates the presence of LP_DEAD items on the page (though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not reliably).&nbsp; Note that we only rely on it with pg_upgrade'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * !heapkeyspace indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opaque-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needswal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_delete xlrec_delete;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_delete.snapshotConflictHorizon = snapshotConflictHorizon;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_delete.ndeleted = ndeletable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_delete.nupdated = nupdatable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_delete.isCatalogRel = isCatalogRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec_delete, SizeOfBtreeDelete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) deletable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nupdatable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) updatedoffsets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupdatable * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(OffsetNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, updatedbuf, updatedbuflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_DELETE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* can't leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (updatedbuf != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(updatedbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* free tuples allocated within <a href="#L1405" title="access/nbtree/nbtpage.c:1405">_bt_delitems_update</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(updatable[i]-&gt;itup);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set up state needed to delete TIDs from posting list tuples via &quot;updating&quot;<br/></li>
<li></span><span class="Comment"> * the tuple.&nbsp; Performs steps common to both <a href="#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L1284" title="access/nbtree/nbtpage.c:1284">_bt_delitems_delete</a>.&nbsp; These steps must take place <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each function's<br/></li>
<li></span><span class="Comment"> * critical section begins.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * updatable and nupdatable are inputs, though note that we will use<br/></li>
<li></span><span class="Comment"> * <a href="nbtdedup.c.html#L924" title="access/nbtree/nbtdedup.c:924">_bt_update_posting</a>() to replace the original itup with a pointer to a final<br/></li>
<li></span><span class="Comment"> * version in <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d memory.&nbsp; Caller should free the tuples when its done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The first nupdatable entries from updatedoffsets are set to the page offset<br/></li>
<li></span><span class="Comment"> * number for posting list tuples that caller updates.&nbsp; This is mostly useful<br/></li>
<li></span><span class="Comment"> * because caller may need to WAL-log the page offsets (though we always do<br/></li>
<li></span><span class="Comment"> * this for caller out of convenience).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns buffer consisting of an array of xl_btree_update structs that<br/></li>
<li></span><span class="Comment"> * describe the steps we perform here for caller (though only when needswal is<br/></li>
<li></span><span class="Comment"> * true).&nbsp; Also sets *updatedbuflen to the final size of the buffer.&nbsp; This<br/></li>
<li></span><span class="Comment"> * buffer is used by caller when WAL logging is required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1405">&#x200c;</a><span class="linkable">_bt_delitems_update</span>(BTVacuumPosting *updatable, <span class="Type">int</span> nupdatable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *updatedoffsets, Size *updatedbuflen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> needswal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *updatedbuf = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; buflen = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Shouldn't be called unless there's something to do */<br/></li>
<li></span>&nbsp; &nbsp; Assert(nupdatable &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting vacposting = updatable[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Replace work area IndexTuple with updated version */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtdedup.c.html#L924" title="access/nbtree/nbtdedup.c:924">_bt_update_posting</a>(vacposting);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep track of size of xl_btree_update for updatedbuf in passing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = SizeOfBtreeUpdate + vacposting-&gt;ndeletedtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buflen += itemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build updatedoffsets buffer in passing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; updatedoffsets[i] = vacposting-&gt;updatedoffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (needswal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate, set final size for caller */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; updatedbuf = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(buflen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *updatedbuflen = buflen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting vacposting = updatable[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xl_btree_update update;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update.ndeletedtids = vacposting-&gt;ndeletedtids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(updatedbuf + offset, &amp;update.ndeletedtids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; SizeOfBtreeUpdate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset += SizeOfBtreeUpdate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemsz = update.ndeletedtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(updatedbuf + offset, vacposting-&gt;deletetids, itemsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset += itemsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> updatedbuf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Comparator used by <a href="#L1513" title="access/nbtree/nbtpage.c:1513">_bt_delitems_delete_check</a>() to restore deltids array<br/></li>
<li></span><span class="Comment"> * back to its original leaf-page-wise sort order<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1464">&#x200c;</a></span><span class="linkable">_bt_delitems_cmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TM_IndexDelete *indexdelete1 = (TM_IndexDelete *) a;<br/></li>
<li>&nbsp; &nbsp; TM_IndexDelete *indexdelete2 = (TM_IndexDelete *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(indexdelete1-&gt;id != indexdelete2-&gt;id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_s16(indexdelete1-&gt;id, indexdelete2-&gt;id);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to delete item(s) from a btree leaf page during single-page <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtree interface to table_index_delete_tuples().&nbsp; Deletes a <a href="../../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of index<br/></li>
<li></span><span class="Comment"> * tuples from caller's deltids array: those whose TIDs are found safe to<br/></li>
<li></span><span class="Comment"> * delete by the tableam (or already marked LP_DEAD in index, and so already<br/></li>
<li></span><span class="Comment"> * known to be deletable by our simple index deletion caller).&nbsp; We physically<br/></li>
<li></span><span class="Comment"> * delete index tuples from buf leaf page last of all (for index tuples where<br/></li>
<li></span><span class="Comment"> * that is known to be safe following our table_index_delete_tuples() call).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simple index deletion caller only includes TIDs from index tuples marked<br/></li>
<li></span><span class="Comment"> * LP_DEAD, as well as extra TIDs it found on the same leaf page that can be<br/></li>
<li></span><span class="Comment"> * included without increasing the total number of distinct table blocks for<br/></li>
<li></span><span class="Comment"> * the deletion operation as a whole.&nbsp; This approach often allows us to delete<br/></li>
<li></span><span class="Comment"> * some extra index tuples that were practically free for tableam to check in<br/></li>
<li></span><span class="Comment"> * passing (when they actually turn out to be safe to delete).&nbsp; It probably<br/></li>
<li></span><span class="Comment"> * only makes sense for the tableam to go ahead with these extra checks when<br/></li>
<li></span><span class="Comment"> * it is block-oriented (otherwise the checks probably won't be practically<br/></li>
<li></span><span class="Comment"> * free, which we rely on).&nbsp; The tableam interface requires the tableam side<br/></li>
<li></span><span class="Comment"> * to handle the problem, though, so this is okay (we as an index AM are free<br/></li>
<li></span><span class="Comment"> * to make the simplifying assumption that all tableams must be block-based).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bottom-up index deletion caller provides all the TIDs from the leaf page,<br/></li>
<li></span><span class="Comment"> * without expecting that tableam will check most of them.&nbsp; The tableam has<br/></li>
<li></span><span class="Comment"> * considerable discretion around which entries/blocks it checks.&nbsp; Our role in<br/></li>
<li></span><span class="Comment"> * costing the bottom-up deletion operation is strictly advisory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Caller must have added deltids entries (i.e. entries that go in<br/></li>
<li></span><span class="Comment"> * delstate's <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> array) in leaf-page-wise order: page offset number order,<br/></li>
<li></span><span class="Comment"> * TID order among entries taken from the same posting list tuple (tiebreak on<br/></li>
<li></span><span class="Comment"> * TID).&nbsp; This order is convenient to work with here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: We also rely on the id field of each deltids <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> &quot;capturing&quot; this<br/></li>
<li></span><span class="Comment"> * original leaf-page-wise order.&nbsp; That is, we expect to be able to get back<br/></li>
<li></span><span class="Comment"> * to the original leaf-page-wise order just by sorting deltids on the id<br/></li>
<li></span><span class="Comment"> * field (tableam will sort deltids for its own reasons, so we'll need to put<br/></li>
<li></span><span class="Comment"> * it back in leaf-page-wise order afterwards).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1513">&#x200c;</a></span><span class="linkable">_bt_delitems_delete_check</span>(Relation rel, Buffer buf, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDeleteOp *delstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; TransactionId snapshotConflictHorizon;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isCatalogRel;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber postingidxoffnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupdatable = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber deletable[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; BTVacuumPosting updatable[MaxIndexTuplesPerPage];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use tableam interface to determine which tuples to delete first */<br/></li>
<li></span>&nbsp; &nbsp; snapshotConflictHorizon = table_index_delete_tuples(heapRel, delstate);<br/></li>
<li>&nbsp; &nbsp; isCatalogRel = RelationIsAccessibleInLogicalDecoding(heapRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should not WAL-log snapshotConflictHorizon unless it's required */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!XLogStandbyInfoActive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshotConflictHorizon = InvalidTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a leaf-page-wise description of what <a href="#L1284" title="access/nbtree/nbtpage.c:1284">_bt_delitems_delete</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs to do to physically delete index tuples from the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must sort deltids array to restore leaf-page-wise order (original order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> call to tableam).&nbsp; This is the order that the loop expects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that deltids array might be a lot smaller <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; It might even have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no entries at all (with bottom-up deletion caller), in which case there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is nothing left to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort(delstate-&gt;deltids, delstate-&gt;ndeltids, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexDelete),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1464" title="access/nbtree/nbtpage.c:1464">_bt_delitems_cmp</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (delstate-&gt;ndeltids == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(delstate-&gt;bottomup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We definitely have to delete at least one index tuple (or one TID) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; delstate-&gt;ndeltids; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexStatus *dstatus = delstate-&gt;status + delstate-&gt;deltids[i].id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber idxoffnum = dstatus-&gt;idxoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, idxoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestedi,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting vacposting;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(OffsetNumberIsValid(idxoffnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idxoffnum == postingidxoffnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This deltid entry is a TID from a posting list tuple that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already been completely processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(BTreeTupleIsPosting(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(BTreeTupleGetHeapTID(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;delstate-&gt;deltids[i].tid) &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(BTreeTupleGetMaxHeapTID(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;delstate-&gt;deltids[i].tid) &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Plain non-pivot tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L35" title="storage/page/itemptr.c:35">ItemPointerEquals</a>(&amp;itup-&gt;t_tid, &amp;delstate-&gt;deltids[i].tid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dstatus-&gt;knowndeletable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[ndeletable++] = idxoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * itup is a posting list tuple whose lowest deltids entry (which may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or may not be for the first TID from itup) is considered here <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We should process all of the deltids entries for the posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * together <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, though (not just the lowest).&nbsp; Remember to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later itup-related entries during later iterations of outermost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; postingidxoffnum = idxoffnum;&nbsp; &nbsp; <span class="Comment">/* Remember work in outermost loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nestedi = i;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize for first itup deltids entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; vacposting = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Describes final action for itup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nitem = BTreeTupleGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> p = <span class="Constant">0</span>; p &lt; nitem; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer ptid = BTreeTupleGetPostingN(itup, p);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptidcmp = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This nested loop reuses work across ptid TIDs taken from itup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We take advantage of the fact that both itup's TIDs and deltids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries (within a single itup/posting list grouping) must both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be in ascending TID order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; nestedi &lt; delstate-&gt;ndeltids; nestedi++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *tcdeltid = &amp;delstate-&gt;deltids[nestedi];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TM_IndexStatus *tdstatus = (delstate-&gt;status + tcdeltid-&gt;id);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Stop once we get past all itup related deltids entries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(tdstatus-&gt;idxoffnum &gt;= idxoffnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tdstatus-&gt;idxoffnum != idxoffnum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Skip past non-deletable itup related entries up front */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tdstatus-&gt;knowndeletable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Entry is first partial ptid match (or an exact match)? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptidcmp = <a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(&amp;tcdeltid-&gt;tid, ptid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptidcmp &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Greater than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> (partial or exact) match... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ...exact ptid match to a deletable deltids entry? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptidcmp != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Exact match for deletable deltids entry -- ptid gets deleted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacposting == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(BTVacuumPostingData, deletetids) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;itup = itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;updatedoffset = idxoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;ndeletedtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;deletetids[vacposting-&gt;ndeletedtids++] = p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Final decision on itup, a posting list tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacposting == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No TIDs to delete from itup -- do nothing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vacposting-&gt;ndeletedtids == nitem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Straight delete of itup (to delete all TIDs) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[ndeletable++] = idxoffnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Turns out we won't need granular information */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacposting);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> some (but not all) TIDs from itup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(vacposting-&gt;ndeletedtids &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vacposting-&gt;ndeletedtids &lt; nitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatable[nupdatable++] = vacposting;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Physically delete tuples (or TIDs) using deletable (or updatable) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1284" title="access/nbtree/nbtpage.c:1284">_bt_delitems_delete</a>(rel, buf, snapshotConflictHorizon, isCatalogRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable, ndeletable, updatable, nupdatable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(updatable[i]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that leftsib page (the btpo_prev of target page) is not marked with<br/></li>
<li></span><span class="Comment"> * INCOMPLETE_SPLIT flag.&nbsp; Used during page deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returning true indicates that page flag is set in leftsib (which is<br/></li>
<li></span><span class="Comment"> * definitely still the left sibling of target).&nbsp; When that happens, the<br/></li>
<li></span><span class="Comment"> * target doesn't have a downlink in parent, and the page deletion algorithm<br/></li>
<li></span><span class="Comment"> * isn't prepared to handle that.&nbsp; Deletion of the target page (or the whole<br/></li>
<li></span><span class="Comment"> * subtree that contains the target page) cannot take place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should not have a lock on the target page itself, since pages on the<br/></li>
<li></span><span class="Comment"> * same level must always be locked left to right to avoid deadlocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1695">&#x200c;</a></span><span class="linkable">_bt_leftsib_splitflag</span>(Relation rel, BlockNumber leftsib, BlockNumber target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Easy case: No left sibling */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leftsib == P_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, leftsib, BT_READ);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the left sibling was concurrently split, so that its <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-pointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't point to the current page anymore, the split that created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target must be completed.&nbsp; Caller can reasonably expect that there will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be a downlink to the target page that it can relocate using its stack.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (We don't allow splitting an incompletely split page again until the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous split has been completed.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = (opaque-&gt;btpo_next == target &amp;&amp; P_INCOMPLETE_SPLIT(opaque));<br/></li>
<li>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that leafrightsib page (the btpo_next of target leaf page) is not<br/></li>
<li></span><span class="Comment"> * marked with ISHALFDEAD flag.&nbsp; Used during page deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returning true indicates that page flag is set in leafrightsib, so page<br/></li>
<li></span><span class="Comment"> * deletion cannot go ahead.&nbsp; Our caller is not prepared to deal with the case<br/></li>
<li></span><span class="Comment"> * where the parent page does not have a pivot tuples whose downlink points to<br/></li>
<li></span><span class="Comment"> * leafrightsib (due to an earlier interrupted VACUUM operation).&nbsp; It doesn't<br/></li>
<li></span><span class="Comment"> * seem worth going to the trouble of teaching our caller to deal with it.<br/></li>
<li></span><span class="Comment"> * The situation will be resolved after VACUUM finishes the deletion of the<br/></li>
<li></span><span class="Comment"> * half-dead page (when a future VACUUM operation reaches the target page<br/></li>
<li></span><span class="Comment"> * again).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L1695" title="access/nbtree/nbtpage.c:1695">_bt_leftsib_splitflag</a>() is called for both leaf pages and <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages.<br/></li>
<li></span><span class="Comment"> * <a href="#L1752" title="access/nbtree/nbtpage.c:1752">_bt_rightsib_halfdeadflag</a>() is only called for leaf pages, though.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * okay because of the restriction on deleting pages that are the rightmost<br/></li>
<li></span><span class="Comment"> * page of their parent (i.e. that such deletions can only take place when the<br/></li>
<li></span><span class="Comment"> * entire subtree must be deleted).&nbsp; The leaf level check made here will apply<br/></li>
<li></span><span class="Comment"> * to a right &quot;cousin&quot; leaf page rather than a simple right sibling leaf page<br/></li>
<li></span><span class="Comment"> * in cases where caller actually goes on to attempt deleting pages that are<br/></li>
<li></span><span class="Comment"> * above the leaf page.&nbsp; The right cousin leaf page is representative of the<br/></li>
<li></span><span class="Comment"> * left edge of the subtree to the right of the to-be-deleted subtree as a<br/></li>
<li></span><span class="Comment"> * whole, which is exactly the condition that our caller cares about.<br/></li>
<li></span><span class="Comment"> * (Besides, <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages are never marked half-dead, so it isn't even<br/></li>
<li></span><span class="Comment"> * possible to _directly_ assess if an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page is part of some other<br/></li>
<li></span><span class="Comment"> * to-be-deleted subtree.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1752">&#x200c;</a></span><span class="linkable">_bt_rightsib_halfdeadflag</span>(Relation rel, BlockNumber leafrightsib)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(leafrightsib != P_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; buf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, leafrightsib, BT_READ);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(P_ISLEAF(opaque) &amp;&amp; !P_ISDELETED(opaque));<br/></li>
<li>&nbsp; &nbsp; result = P_ISHALFDEAD(opaque);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() -- <a href="../../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a leaf page from the b-tree, if legal to do so.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This action unlinks the leaf page from the b-tree structure, removing all<br/></li>
<li></span><span class="Comment"> * pointers leading to it --- but not touching its own left and right links.<br/></li>
<li></span><span class="Comment"> * The page cannot be physically reclaimed right away, since other processes<br/></li>
<li></span><span class="Comment"> * may currently be trying to follow links leading to the page; they have to<br/></li>
<li></span><span class="Comment"> * be allowed to use its right-link to recover.&nbsp; See nbtree/README.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, the target buffer must be pinned and locked (either read or write<br/></li>
<li></span><span class="Comment"> * lock is OK).&nbsp; The page must be an empty leaf page, which may be half-dead<br/></li>
<li></span><span class="Comment"> * already (a half-dead page should only be passed to us when an earlier<br/></li>
<li></span><span class="Comment"> * VACUUM operation was interrupted, though).&nbsp; Note in particular that caller<br/></li>
<li></span><span class="Comment"> * should never pass a buffer containing an existing deleted page here.&nbsp; The<br/></li>
<li></span><span class="Comment"> * lock and pin on caller's buffer will be dropped <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we return.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Maintains bulk delete stats for caller, which are taken from vstate.&nbsp; We<br/></li>
<li></span><span class="Comment"> * need to cooperate closely with caller here so that whole VACUUM operation<br/></li>
<li></span><span class="Comment"> * reliably avoids <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> double counting of subsidiary-to-leafbuf pages that we<br/></li>
<li></span><span class="Comment"> * delete in passing.&nbsp; If such pages happen to be from a block number that is<br/></li>
<li></span><span class="Comment"> * ahead of the current scanblkno position, then caller is expected to count<br/></li>
<li></span><span class="Comment"> * them directly later on.&nbsp; It's simpler for us to understand caller's<br/></li>
<li></span><span class="Comment"> * requirements than it would be for caller to understand when or how a<br/></li>
<li></span><span class="Comment"> * deleted page became deleted after the fact.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this leaks memory.&nbsp; Rather than trying to clean up everything<br/></li>
<li></span><span class="Comment"> * carefully, it's better to run it in a temp context that can be reset<br/></li>
<li></span><span class="Comment"> * frequently.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1802">&#x200c;</a></span><span class="linkable">_bt_pagedel</span>(Relation rel, Buffer leafbuf, BTVacState *vstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber rightsib;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rightsib_empty;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save original leafbuf block number from caller.&nbsp; Only deleted blocks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that are &lt;= scanblkno are added to bulk delete stat's pages_deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; BlockNumber scanblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;stack&quot; is a search stack leading (approximately) to the target page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is initially NULL, but when iterating, we keep it to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicated search effort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, when &quot;stack&quot; is not NULL, we have already checked that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current page is not the right half of an incomplete split, i.e. the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left sibling does not have its INCOMPLETE_SPLIT flag set, including<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the current target page is to the right of caller's initial page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (the scanblkno page).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; BTStack&nbsp; &nbsp; &nbsp; &nbsp; stack = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Internal pages are never deleted directly, only as part of deleting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the whole subtree all the way down to leaf level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also check for deleted pages here.&nbsp; Caller never passes us a fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted page.&nbsp; Only VACUUM can delete pages, so there can't have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been a concurrent deletion.&nbsp; Assume that we reached <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page encountered here by following a sibling link, and that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index is corrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!P_ISDELETED(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_ISLEAF(opaque) || P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pre-9.4 page deletion only marked <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages as half-dead,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we only use that flag on leaf pages. The old algorithm<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was never supposed to leave half-dead pages in the tree, it was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just a transient state, but it was nevertheless possible in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error scenarios. We don't know how to deal with them here. They<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are harmless as far as searches are considered, but inserts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the deleted keyspace could add out-of-order downlinks in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels. Log a notice, hopefully the admin will notice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and reindex.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_ISHALFDEAD(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a half-dead <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This can be caused by an interrupted VACUUM in version 9.3 or older, <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> upgrade. Please REINDEX it.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;found deleted block </span><span class="Special">%u</span><span class="Constant"> while following right link from block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(leafbuf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can never delete rightmost pages nor root pages.&nbsp; While at it,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check that page is empty, since it's possible that the leafbuf page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was empty a moment ago, but has since had some inserts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To keep the algorithm simple, we also never delete an incompletely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split page (they should be rare enough that this doesn't make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * meaningful difference to disk usage):<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The INCOMPLETE_SPLIT flag on the page tells us if the page is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left half of an incomplete split, but ensuring that it's not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right half is more complicated.&nbsp; For that, we have to check that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the left sibling doesn't have its INCOMPLETE_SPLIT flag set using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1695" title="access/nbtree/nbtpage.c:1695">_bt_leftsib_splitflag</a>().&nbsp; On the first iteration, we temporarily<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the lock on scanblkno/leafbuf, check the left sibling, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * construct a search stack to scanblkno.&nbsp; On subsequent iterations,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we know we stepped right from a page that passed these tests, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's OK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque) || P_ISROOT(opaque) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P_FIRSTDATAKEY(opaque) &lt;= PageGetMaxOffsetNumber(page) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P_INCOMPLETE_SPLIT(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Should never fail to delete a half-dead page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!P_ISHALFDEAD(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First, remove downlink pointing to the page (or a parent of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page, if we are going to delete a taller subtree), and mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leafbuf page half-dead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_ISHALFDEAD(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need an approximate pointer to the page's parent page.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use a variant of the standard search mechanism to search for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the page's high key; this will give us a link to either the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current parent or someplace to its left (if there are multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> high keys, which is possible with !heapkeyspace indexes).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also check if this is the right-half of an incomplete split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (see comment above).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!stack)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanInsert itup_key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; targetkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber leftsib,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; sleafbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetkey = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>((IndexTuple) PageGetItem(page, itemid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftsib = opaque-&gt;btpo_prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leafblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid deadlocks, we'd better drop the leaf page lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> going further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the left sibling of leafbuf (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * marked with INCOMPLETE_SPLIT flag <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> proceeding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(leafblkno == scanblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1695" title="access/nbtree/nbtpage.c:1695">_bt_leftsib_splitflag</a>(rel, leftsib, leafblkno))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need an insertion scan key, so build one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtsearch.c.html#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a> searches for the leaf page that contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matching non-pivot tuples, but we need it to &quot;search&quot; for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the high key pivot from the page that we're set to delete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compensate for the mismatch by having <a href="nbtsearch.c.html#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a> locate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last position &lt; <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>-to-untruncated-prefix non-pivots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup_key = <a href="nbtutils.c.html#L129" title="access/nbtree/nbtutils.c:129">_bt_mkscankey</a>(rel, targetkey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up a BTLessStrategyNumber-like insertion scan key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup_key-&gt;nextkey = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup_key-&gt;backward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack = <a href="nbtsearch.c.html#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>(rel, <span class="Constant">NULL</span>, itup_key, &amp;sleafbuf, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* won't need a second lock or pin on leafbuf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, sleafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-lock the leaf page, and start over to use our stack<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within <a href="#L2088" title="access/nbtree/nbtpage.c:2088">_bt_mark_page_halfdead</a>.&nbsp; We must do it that way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's possible that leafbuf can no longer be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted.&nbsp; We need to recheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: We can't simply hold on to the sleafbuf lock instead,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it's barely possible that sleafbuf is not the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page as leafbuf.&nbsp; This happens when leafbuf split after our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original lock was dropped, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="nbtsearch.c.html#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a> finished<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * its descent.&nbsp; We rely on the assumption that we'll <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leafbuf isn't safe to delete anymore in this scenario.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Page deletion can cope with the stack being to the left of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leafbuf, but not to the right of leafbuf.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, leafbuf, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * See if it's safe to delete the leaf page, and determine how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * many parent/<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages above the leaf level will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted.&nbsp; If it's safe then <a href="#L2088" title="access/nbtree/nbtpage.c:2088">_bt_mark_page_halfdead</a> will also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform the first phase of deletion, which includes marking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leafbuf page half-dead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(P_ISLEAF(opaque) &amp;&amp; !P_IGNORE(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2088" title="access/nbtree/nbtpage.c:2088">_bt_mark_page_halfdead</a>(rel, vstate-&gt;info-&gt;heaprel, leafbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Then unlink it from its siblings.&nbsp; Each call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2314" title="access/nbtree/nbtpage.c:2314">_bt_unlink_halfdead_page</a> unlinks the topmost page from the subtree,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * making it shallower.&nbsp; Iterate until the leafbuf page is deleted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rightsib_empty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(P_ISLEAF(opaque) &amp;&amp; P_ISHALFDEAD(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (P_ISHALFDEAD(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for interrupts in <a href="#L2314" title="access/nbtree/nbtpage.c:2314">_bt_unlink_halfdead_page</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2314" title="access/nbtree/nbtpage.c:2314">_bt_unlink_halfdead_page</a>(rel, leafbuf, scanblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;rightsib_empty, vstate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2314" title="access/nbtree/nbtpage.c:2314">_bt_unlink_halfdead_page</a> should never fail, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * established that deletion is generally safe in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L2088" title="access/nbtree/nbtpage.c:2088">_bt_mark_page_halfdead</a> -- index must be corrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that <a href="#L2314" title="access/nbtree/nbtpage.c:2314">_bt_unlink_halfdead_page</a> already released the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lock and pin on leafbuf for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(P_ISLEAF(opaque) &amp;&amp; P_ISDELETED(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightsib = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check here, as calling loops will have locks held, preventing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupts from being processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page has <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> been deleted. If its right sibling is completely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty, it's possible that the reason we haven't deleted it earlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is that it was the rightmost child of the parent. Now that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * removed the downlink for this page, the right sibling might <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the only child of the parent, and could be removed. It would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * picked up by the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> anyway, but might as well try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, so loop back to process the right sibling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: This relies on the assumption that <a href="nbtinsert.c.html#L2319" title="access/nbtree/nbtinsert.c:2319">_bt_getstackbuf</a>() will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to reuse our original descent stack with a different child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block (provided that the child block is to the right of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original leaf page reached by <a href="nbtsearch.c.html#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>()). It will even update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the descent stack each time we loop around, avoiding repeated work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rightsib_empty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leafbuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, rightsib, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * First stage of page deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Establish the height of the to-be-deleted subtree with leafbuf at its<br/></li>
<li></span><span class="Comment"> * lowest level, remove the downlink to the subtree, and mark leafbuf<br/></li>
<li></span><span class="Comment"> * half-dead.&nbsp; The final to-be-deleted subtree is usually just leafbuf itself,<br/></li>
<li></span><span class="Comment"> * but may include additional <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages (at most one per level of the<br/></li>
<li></span><span class="Comment"> * tree below the root).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must pass a valid heaprel, since it's just about possible that our<br/></li>
<li></span><span class="Comment"> * call to <a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a> will need to allocate a new index page to<br/></li>
<li></span><span class="Comment"> * complete a page split.&nbsp; Every call to <a href="#L869" title="access/nbtree/nbtpage.c:869">_bt_allocbuf</a> needs to pass a heaprel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 'false' if leafbuf is unsafe to delete, usually because leafbuf is<br/></li>
<li></span><span class="Comment"> * the rightmost child of its parent (and parent has more than one downlink).<br/></li>
<li></span><span class="Comment"> * Returns 'true' when the first stage of page deletion completed<br/></li>
<li></span><span class="Comment"> * successfully.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2088">&#x200c;</a></span><span class="linkable">_bt_mark_page_halfdead</span>(Relation rel, Relation heaprel, Buffer leafbuf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTStack stack)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber leafblkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber leafrightsib;<br/></li>
<li>&nbsp; &nbsp; BlockNumber topparent;<br/></li>
<li>&nbsp; &nbsp; BlockNumber topparentrightsib;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; subtreeparent;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber poffset;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber nextoffset;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; IndexTupleData trunctuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!P_RIGHTMOST(opaque) &amp;&amp; !P_ISROOT(opaque) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P_ISLEAF(opaque) &amp;&amp; !P_IGNORE(opaque) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; P_FIRSTDATAKEY(opaque) &gt; PageGetMaxOffsetNumber(page));<br/></li>
<li>&nbsp; &nbsp; Assert(heaprel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save info about the leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leafblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(leafbuf);<br/></li>
<li>&nbsp; &nbsp; leafrightsib = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before attempting to lock the parent page, check that the right sibling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not in half-dead state.&nbsp; A half-dead right sibling would have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * downlink in the parent, which would be highly confusing later when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete the downlink.&nbsp; It would fail the &quot;right sibling of target page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is also the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> child in parent page&quot; cross-check below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1752" title="access/nbtree/nbtpage.c:1752">_bt_rightsib_halfdeadflag</a>(rel, leafrightsib))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;could not delete page </span><span class="Special">%u</span><span class="Constant"> because its right sibling </span><span class="Special">%u</span><span class="Constant"> is half-dead&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leafblkno, leafrightsib);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot delete a page that is the rightmost child of its immediate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent, unless it is the only child --- in which case the parent has to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be deleted too, and the same condition applies recursively to it. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have to check this condition all the way up <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to delete,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and lock the parent of the root of the to-be-deleted subtree (the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;subtree parent&quot;).&nbsp; <a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a>() locks the subtree parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for us.&nbsp; We remove the downlink to the &quot;top parent&quot; page (subtree root<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page) from the subtree parent page below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize topparent to be leafbuf page <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; The final to-be-deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtree is often a degenerate one page subtree consisting only of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leafbuf page.&nbsp; When that happens, the leafbuf page is the final subtree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * root page/top parent page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; topparent = leafblkno;<br/></li>
<li>&nbsp; &nbsp; topparentrightsib = leafrightsib;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a>(rel, heaprel, leafblkno, stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;subtreeparent, &amp;poffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;topparent, &amp;topparentrightsib))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(subtreeparent);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is just an assertion because <a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a> should have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guaranteed tuple has the expected contents<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itemid = PageGetItemId(page, poffset);<br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; Assert(BTreeTupleGetDownLink(itup) == topparent);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; nextoffset = OffsetNumberNext(poffset);<br/></li>
<li>&nbsp; &nbsp; itemid = PageGetItemId(page, nextoffset);<br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that the parent-page index items we're about to delete/overwrite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in subtree parent page contain what we expect.&nbsp; This can fail if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index has become corrupt for some reason.&nbsp; When that happens we back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out of deletion of the leafbuf subtree.&nbsp; (This is just like the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where <a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a>() cannot &quot;re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>&quot; leafbuf's downlink.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleGetDownLink(itup) != topparentrightsib)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;right sibling </span><span class="Special">%u</span><span class="Constant"> of block </span><span class="Special">%u</span><span class="Constant"> is not <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> child </span><span class="Special">%u</span><span class="Constant"> of block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; topparentrightsib, topparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTreeTupleGetDownLink(itup),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(subtreeparent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, subtreeparent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any insert which would have gone on the leaf block will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> go to its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right sibling.&nbsp; In other words, the key space moves right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L3214" title="storage/lmgr/predicate.c:3214">PredicateLockPageCombine</a>(rel, leafblkno, leafrightsib);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No ereport(ERROR) until changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update parent of subtree.&nbsp; We want to delete the downlink to the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent page/root of the subtree, and the *following* key.&nbsp; Easiest way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is to copy the right sibling's downlink over the downlink that points<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to top parent page, and then delete the right sibling's original pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Lanin and Shasha make the key space move left when deleting a page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whereas the key space moves right here.&nbsp; That's why we cannot simply<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete the pivot tuple with the downlink to the top parent page.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nbtree/README.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(subtreeparent);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemid = PageGetItemId(page, poffset);<br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; BTreeTupleSetDownLink(itup, topparentrightsib);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nextoffset = OffsetNumberNext(poffset);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L1052" title="storage/page/bufpage.c:1052">PageIndexTupleDelete</a>(page, nextoffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the leaf page as half-dead, and stamp it with a link to the top<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent page.&nbsp; When the leaf page is also the top parent page, the link<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is set to InvalidBlockNumber.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_flags |= BTP_HALF_DEAD;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PageGetMaxOffsetNumber(page) == P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; MemSet(&amp;trunctuple, <span class="Constant">0</span>, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData));<br/></li>
<li>&nbsp; &nbsp; trunctuple.t_info = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (topparent != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetTopParent(&amp;trunctuple, topparent);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetTopParent(&amp;trunctuple, InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/page/bufpage.c.html#L1405" title="storage/page/bufpage.c:1405">PageIndexTupleOverwrite</a>(page, P_HIKEY, (Item) &amp;trunctuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTupleSize(&amp;trunctuple)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not overwrite high key in half-dead page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must mark buffers dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(subtreeparent);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_mark_page_halfdead xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.poffset = poffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.leafblk = leafblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (topparent != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.topparent = topparent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlrec.topparent = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, leafbuf, REGBUF_WILL_INIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, subtreeparent, REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.leftblk = opaque-&gt;btpo_prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.rightblk = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfBtreeMarkPageHalfDead);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_MARK_PAGE_HALFDEAD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(subtreeparent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, subtreeparent);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Second stage of page deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlinks a single page (in the subtree undergoing deletion) from its<br/></li>
<li></span><span class="Comment"> * siblings.&nbsp; Also marks the page deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To get rid of the whole subtree, including the leaf page itself, call here<br/></li>
<li></span><span class="Comment"> * until the leaf page is deleted.&nbsp; The original &quot;top parent&quot; established in<br/></li>
<li></span><span class="Comment"> * the first stage of deletion is deleted in the first call here, while the<br/></li>
<li></span><span class="Comment"> * leaf page is deleted in the last call here.&nbsp; Note that the leaf page itself<br/></li>
<li></span><span class="Comment"> * is often the initial top parent page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns 'false' if the page could not be unlinked (shouldn't happen).&nbsp; If<br/></li>
<li></span><span class="Comment"> * the right sibling of the current target page is empty, *rightsib_empty is<br/></li>
<li></span><span class="Comment"> * set to true, allowing caller to delete the target's right sibling page in<br/></li>
<li></span><span class="Comment"> * passing.&nbsp; Note that *rightsib_empty is only actually used by caller when<br/></li>
<li></span><span class="Comment"> * target page is leafbuf, following last call here for leafbuf/the subtree<br/></li>
<li></span><span class="Comment"> * containing leafbuf.&nbsp; (We always set *rightsib_empty for caller, just to be<br/></li>
<li></span><span class="Comment"> * consistent.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must hold pin and lock on leafbuf at entry (read or write doesn't matter).<br/></li>
<li></span><span class="Comment"> * On success exit, we'll be holding pin and write lock.&nbsp; On failure exit,<br/></li>
<li></span><span class="Comment"> * we'll release both pin and lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning (we define it that way<br/></li>
<li></span><span class="Comment"> * to avoid having to reacquire a lock we already released).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2314">&#x200c;</a></span><span class="linkable">_bt_unlink_halfdead_page</span>(Relation rel, Buffer leafbuf, BlockNumber scanblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *rightsib_empty, BTVacState *vstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber leafblkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(leafbuf);<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult *stats = vstate-&gt;stats;<br/></li>
<li>&nbsp; &nbsp; BlockNumber leafleftsib;<br/></li>
<li>&nbsp; &nbsp; BlockNumber leafrightsib;<br/></li>
<li>&nbsp; &nbsp; BlockNumber target;<br/></li>
<li>&nbsp; &nbsp; BlockNumber leftsib;<br/></li>
<li>&nbsp; &nbsp; BlockNumber rightsib;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; lbuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; rbuf;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; metabuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; metapg = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; BTMetaPageData *metad = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; FullTransactionId safexid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; rightsib_is_rightmost;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; targetlevel;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; leafhikey;<br/></li>
<li>&nbsp; &nbsp; BlockNumber leaftopparent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(P_ISLEAF(opaque) &amp;&amp; !P_ISDELETED(opaque) &amp;&amp; P_ISHALFDEAD(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember some information about the leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itemid = PageGetItemId(page, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; leafhikey = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; target = BTreeTupleGetTopParent(leafhikey);<br/></li>
<li>&nbsp; &nbsp; leafleftsib = opaque-&gt;btpo_prev;<br/></li>
<li>&nbsp; &nbsp; leafrightsib = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check here, as calling loops will have locks held, preventing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts from being processed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unlink the current top parent of the subtree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(target))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Target is leaf page (or leaf page is top parent, if you prefer) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; target = leafblkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = leafbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftsib = leafleftsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetlevel = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Target is the <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page taken from leaf's top parent link */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(target != leafblkno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the block number of the target's left sibling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, target, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftsib = opaque-&gt;btpo_prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetlevel = opaque-&gt;btpo_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(targetlevel &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To avoid deadlocks, we'd better drop the target page lock <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to lock the pages we need to modify in the standard order:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * moving right, then up.&nbsp; Else we will deadlock against other writers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So, first lock the leaf page, if it's not the target.&nbsp; Then <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write-lock the current left sibling of the target page.&nbsp; The sibling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that was current a moment ago could have split, so we may have to move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, leafbuf, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (leftsib != P_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lbuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, leftsib, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(lbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (P_ISDELETED(opaque) || opaque-&gt;btpo_next != target)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; leftsibvalid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we follow the link from the page that was the left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sibling mere moments ago, validate its right link.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reduces the opportunities for loop to fail to ever make <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progress in the presence of index corruption.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we rely on the assumption that there can only be one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> process running at a time (against the same index).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque) || P_ISDELETED(opaque) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftsib == opaque-&gt;btpo_next)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftsibvalid = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftsib = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, lbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!leftsibvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is known to fail in the field; sibling link corruption<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is relatively common.&nbsp; Press on with vacuuming rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just throwing an ERROR.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;valid left sibling for deletion target could not be located: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;left sibling </span><span class="Special">%u</span><span class="Constant"> of target </span><span class="Special">%u</span><span class="Constant"> with leafblkno </span><span class="Special">%u</span><span class="Constant"> and scanblkno </span><span class="Special">%u</span><span class="Constant"> on level </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftsib, target, leafblkno, scanblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetlevel, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must release all pins and locks on failure exit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* step right one page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lbuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, leftsib, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(lbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lbuf = InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Next write-lock the target page itself */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, buf, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check page is still empty etc, else abandon deletion.&nbsp; This is just for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * paranoia's sake; a half-dead page cannot resurrect because there can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only one <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> process running at a time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque) || P_ISROOT(opaque) || P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;target page changed status unexpectedly in block </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_prev != leftsib)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;target page left link unexpectedly changed from </span><span class="Special">%u</span><span class="Constant"> to </span><span class="Special">%u</span><span class="Constant"> in block </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftsib, opaque-&gt;btpo_prev, target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (target == leafblkno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_FIRSTDATAKEY(opaque) &lt;= PageGetMaxOffsetNumber(page) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !P_ISLEAF(opaque) || !P_ISHALFDEAD(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;target leaf page changed status unexpectedly in block </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Leaf page is also target page: don't set leaftopparent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leaftopparent = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; finaldataitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_FIRSTDATAKEY(opaque) != PageGetMaxOffsetNumber(page) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P_ISLEAF(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;target <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page on level </span><span class="Special">%u</span><span class="Constant"> changed status unexpectedly in block </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetlevel, target, RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Target is <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>: set leaftopparent for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call here...&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, P_FIRSTDATAKEY(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; finaldataitem = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leaftopparent = BTreeTupleGetDownLink(finaldataitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ...except when it would be a redundant pointer-to-self */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leaftopparent == leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaftopparent = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No leaftopparent for level 0 (leaf page) or level 1 target */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!BlockNumberIsValid(leaftopparent) || targetlevel &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> write-lock the (current) right sibling.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rightsib = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; rbuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, rightsib, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(rbuf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validate target's right sibling page.&nbsp; Its left link must point back to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the target page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_prev != target)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is known to fail in the field; sibling link corruption is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relatively common.&nbsp; Press on with vacuuming rather than just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throwing an ERROR (same approach used for left-sibling's-right-link<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * validation check a moment ago).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;right sibling's left-link doesn't match: &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;right sibling </span><span class="Special">%u</span><span class="Constant"> of target </span><span class="Special">%u</span><span class="Constant"> with leafblkno </span><span class="Special">%u</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;and scanblkno </span><span class="Special">%u</span><span class="Constant"> spuriously links to non-target </span><span class="Special">%u</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;on level </span><span class="Special">%u</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightsib, target, leafblkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanblkno, opaque-&gt;btpo_prev,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetlevel, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must release all pins and locks on failure exit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, lbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, rbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rightsib_is_rightmost = P_RIGHTMOST(opaque);<br/></li>
<li>&nbsp; &nbsp; *rightsib_empty = (P_FIRSTDATAKEY(opaque) &gt; PageGetMaxOffsetNumber(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are deleting the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>-to-last page on the target's level, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rightsib is a candidate to become the new fast root. (In theory, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be possible to <a href="../../regex/regc_nfa.c.html#L1884" title="regex/regc_nfa.c:1884">push</a> the fast root even further down, but the odds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of doing so are slim, and the locking considerations daunting.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can safely acquire a lock on the metapage here --- see comments for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtinsert.c.html#L2444" title="access/nbtree/nbtinsert.c:2444">_bt_newlevel</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leftsib == P_NONE &amp;&amp; rightsib_is_rightmost)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(rbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rightsib will be the only one left on the level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metabuf = <a href="#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, BTREE_METAPAGE, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metapg = BufferGetPage(metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metad = BTPageGetMeta(metapg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The expected case here is btm_fastlevel == targetlevel+1; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the fastlevel is &lt;= targetlevel, something is wrong, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * choose to overwrite it to fix it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_fastlevel &gt; targetlevel + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no update wanted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; metabuf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Here we begin doing the deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No ereport(ERROR) until changes are logged */<br/></li>
<li></span>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update siblings' side-links.&nbsp; Note the target page's side-links will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continue to point to the siblings.&nbsp; Asserts here are just rechecking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things we already verified above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(lbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(opaque-&gt;btpo_next == target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_next = rightsib;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(rbuf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; Assert(opaque-&gt;btpo_prev == target);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_prev = leftsib;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we deleted a parent of the targeted leaf page, instead of the leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself, update the leaf to point to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> remaining child in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subtree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: We rely on the fact that a buffer pin on the leaf page has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * held since leafhikey was initialized.&nbsp; This is safe, though only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the page was already half-dead at that point.&nbsp; The leaf page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot have been modified by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other backend during the period when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no lock was held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetTopParent(leafhikey, leaftopparent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the page itself deleted.&nbsp; It can be recycled when all current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions are gone.&nbsp; Storing <a href="../transam/xact.c.html#L423" title="access/transam/xact.c:423">GetTopTransactionId</a>() would work, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're in VACUUM and would not otherwise have an XID.&nbsp; Having already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated links to the target, <a href="../transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>() suffices as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound.&nbsp; Any scan having retained a <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-stale link is advertising<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in its PGPROC an xmin less than or <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the value we read here.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will continue to do so, holding back the xmin horizon, for the duration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of that scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; Assert(P_ISHALFDEAD(opaque) || !P_ISLEAF(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> bound XID that's used to determine when deleted page is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer needed as a tombstone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; safexid = <a href="../transam/varsup.c.html#L288" title="access/transam/varsup.c:288">ReadNextFullTransactionId</a>();<br/></li>
<li>&nbsp; &nbsp; BTPageSetDeleted(page, safexid);<br/></li>
<li>&nbsp; &nbsp; opaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And update the metapage, if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(metabuf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* upgrade metapage if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (metad-&gt;btm_version &lt; BTREE_NOVAC_VERSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="access/nbtree/nbtpage.c:107">_bt_upgrademetapage</a>(metapg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_fastroot = rightsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; metad-&gt;btm_fastlevel = targetlevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(metabuf);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must mark buffers dirty <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(rbuf);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(lbuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(leafbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_unlink_page xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_metadata xlmeta;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; xlinfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_WILL_INIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">1</span>, lbuf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">2</span>, rbuf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">3</span>, leafbuf, REGBUF_WILL_INIT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* information stored on the target/to-be-unlinked block */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.leftsib = leftsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.rightsib = rightsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.level = targetlevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.safexid = safexid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* information needed to recreate the leaf block (if not the target) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.leafleftsib = leafleftsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.leafrightsib = leafrightsib;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.leaftopparent = leaftopparent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, SizeOfBtreeUnlinkPage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(metabuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">4</span>, metabuf, REGBUF_WILL_INIT | REGBUF_STANDARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(metad-&gt;btm_version &gt;= BTREE_NOVAC_VERSION);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.version = metad-&gt;btm_version;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.root = metad-&gt;btm_root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.level = metad-&gt;btm_level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.fastroot = metad-&gt;btm_fastroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.fastlevel = metad-&gt;btm_fastlevel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.last_cleanup_num_delpages = metad-&gt;btm_last_cleanup_num_delpages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlmeta.allequalimage = metad-&gt;btm_allequalimage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">4</span>, (<span class="Type">char</span> *) &amp;xlmeta, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xl_btree_metadata));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlinfo = XLOG_BTREE_UNLINK_PAGE_META;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlinfo = XLOG_BTREE_UNLINK_PAGE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, xlinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(metabuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(metapg, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(rbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(lbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(leafbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release metapage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(metabuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, metabuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* release siblings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BufferIsValid(lbuf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, lbuf);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, rbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If the target is not leafbuf, we're done with it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> -- release it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target != leafblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maintain pages_newly_deleted, which is simply the number of pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleted by the ongoing VACUUM operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maintain pages_deleted in a way that takes into account how<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtree.c.html#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a>() will count deleted pages that have yet to become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scanblkno -- only count page when it's not going to get that treatment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;pages_newly_deleted++;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (target &lt;= scanblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;pages_deleted++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember information about the target page (<a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> a newly deleted page)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in dedicated vstate space for later.&nbsp; The page will be considered as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * candidate to place in the FSM at the end of the current <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3062" title="access/nbtree/nbtpage.c:3062">_bt_pendingfsm_add</a>(vstate, target, safexid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Success - hold on to lock on leafbuf (might also have been target) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Establish how tall the to-be-deleted subtree will be during the first stage<br/></li>
<li></span><span class="Comment"> * of page deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller's child argument is the block number of the page caller wants to<br/></li>
<li></span><span class="Comment"> * delete (this is leafbuf's block number, except when we're called<br/></li>
<li></span><span class="Comment"> * recursively).&nbsp; stack is a search stack leading to it.&nbsp; Note that we will<br/></li>
<li></span><span class="Comment"> * update the stack entry(s) to reflect current downlink positions --- this is<br/></li>
<li></span><span class="Comment"> * similar to the corresponding point in page split handling.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If &quot;first stage&quot; caller cannot go ahead with deleting _any_ pages, returns<br/></li>
<li></span><span class="Comment"> * false.&nbsp; Returns true on success, in which case caller can use certain<br/></li>
<li></span><span class="Comment"> * details established here to perform the first stage of deletion.&nbsp; This<br/></li>
<li></span><span class="Comment"> * function is the last point at which page deletion may be deemed unsafe<br/></li>
<li></span><span class="Comment"> * (barring index corruption, or unexpected concurrent page deletions).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We write lock the parent of the root of the to-be-deleted subtree for<br/></li>
<li></span><span class="Comment"> * caller on success (i.e. we leave our lock on the *subtreeparent buffer for<br/></li>
<li></span><span class="Comment"> * caller).&nbsp; Caller will have to remove a downlink from *subtreeparent.&nbsp; We<br/></li>
<li></span><span class="Comment"> * also set a *subtreeparent offset number in *poffset, to indicate the<br/></li>
<li></span><span class="Comment"> * location of the pivot tuple that contains the relevant downlink.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The root of the to-be-deleted subtree is called the &quot;top parent&quot;.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that the leafbuf page is often the final &quot;top parent&quot; page (you can think<br/></li>
<li></span><span class="Comment"> * of the leafbuf page as a degenerate single page subtree when that happens).<br/></li>
<li></span><span class="Comment"> * Caller should <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> *topparent to the target leafbuf page block number<br/></li>
<li></span><span class="Comment"> * (while *topparentrightsib should be set to leafbuf's right sibling block<br/></li>
<li></span><span class="Comment"> * number).&nbsp; We will update *topparent (and *topparentrightsib) for caller<br/></li>
<li></span><span class="Comment"> * here, though only when it turns out that caller will delete at least one<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page (i.e. only when caller needs to store a valid link to the top<br/></li>
<li></span><span class="Comment"> * parent block in the leafbuf page using BTreeTupleSetTopParent()).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2813">&#x200c;</a></span><span class="linkable">_bt_lock_subtree_parent</span>(Relation rel, Relation heaprel, BlockNumber child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTStack stack, Buffer *subtreeparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber *poffset, BlockNumber *topparent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber *topparentrightsib)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftsibparent;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber parentoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; pbuf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Locate the pivot tuple whose downlink points to &quot;child&quot;.&nbsp; Write lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the parent page itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pbuf = <a href="nbtinsert.c.html#L2319" title="access/nbtree/nbtinsert.c:2319">_bt_getstackbuf</a>(rel, heaprel, stack, child);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pbuf == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failed to &quot;re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>&quot; a pivot tuple whose downlink matched our child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * block number on the parent level -- the index must be corrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't even try to delete the leafbuf subtree.&nbsp; Just report the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * issue and press on with vacuuming the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: <a href="nbtinsert.c.html#L2319" title="access/nbtree/nbtinsert.c:2319">_bt_getstackbuf</a>() recovers from concurrent page splits that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take place on the parent level.&nbsp; Its approach is a near-exhaustive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * linear search.&nbsp; This also gives it a surprisingly good chance of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recovering in the event of a buggy or inconsistent opclass.&nbsp; But we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't rely on that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;failed to re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> parent key in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for deletion target page </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel), child)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parent = stack-&gt;bts_blkno;<br/></li>
<li>&nbsp; &nbsp; parentoffset = stack-&gt;bts_offset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(pbuf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; leftsibparent = opaque-&gt;btpo_prev;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtinsert.c.html#L2319" title="access/nbtree/nbtinsert.c:2319">_bt_getstackbuf</a>() completes page splits on returned parent buffer when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In general it's a bad idea for VACUUM to use up more disk space, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is why page deletion does not finish incomplete page splits most of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time.&nbsp; We allow this limited exception because the risk is much <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and the potential downside of not proceeding is much higher:&nbsp; A single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page with the INCOMPLETE_SPLIT flag set might otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent us from deleting hundreds of empty leaf pages from one level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!P_INCOMPLETE_SPLIT(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parentoffset &lt; maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Child is not the rightmost child in parent, so it's safe to delete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the subtree whose root/topparent is child page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *subtreeparent = pbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *poffset = parentoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Child is the rightmost child of parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since it's the rightmost child of parent, deleting the child (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleting the subtree whose root/topparent is the child page) is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe when it's also possible to delete the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(parentoffset == maxoff);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parentoffset != P_FIRSTDATAKEY(opaque) || P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Child isn't parent's only child, or parent is rightmost on its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entire level.&nbsp; Definitely cannot delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, pbuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now make sure that the parent deletion is itself safe by examining the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child's grandparent page.&nbsp; Recurse, passing the parent page as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child page (child's grandparent is the parent on the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> level up). If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent deletion is unsafe, then child deletion must also be unsafe (in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which case caller cannot delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages at all).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *topparent = parent;<br/></li>
<li>&nbsp; &nbsp; *topparentrightsib = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release lock on parent <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> recursing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's OK to release page locks on parent <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> recursive call locks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * grandparent.&nbsp; An <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page can only acquire an entry if the child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is split, but that cannot happen as long as we still hold a lock on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leafbuf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, pbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before recursing, check that the left sibling of parent (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * marked with INCOMPLETE_SPLIT flag first (must do so after we drop the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent lock).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: We deliberately avoid completing incomplete splits here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1695" title="access/nbtree/nbtpage.c:1695">_bt_leftsib_splitflag</a>(rel, leftsibparent, parent))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Recurse to examine child page's grandparent page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L2813" title="access/nbtree/nbtpage.c:2813">_bt_lock_subtree_parent</a>(rel, heaprel, parent, stack-&gt;bts_parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; subtreeparent, poffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; topparent, topparentrightsib);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize local memory state used by VACUUM for <a href="#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a><br/></li>
<li></span><span class="Comment"> * optimization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called at the start of a <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>().&nbsp; Caller's cleanuponly argument<br/></li>
<li></span><span class="Comment"> * indicates if ongoing VACUUM has not (and will not) call <a href="nbtree.c.html#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect to allocate memory inside VACUUM's top-level memory context here.<br/></li>
<li></span><span class="Comment"> * The working buffer is subject to a limit based on <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>.&nbsp; Our strategy<br/></li>
<li></span><span class="Comment"> * when the array can no longer grow within the bounds of that limit is to<br/></li>
<li></span><span class="Comment"> * stop saving additional newly deleted pages, while proceeding as usual with<br/></li>
<li></span><span class="Comment"> * the pages that we can fit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2954">&#x200c;</a></span><span class="linkable">_bt_pendingfsm_init</span>(Relation rel, BTVacState *vstate, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> cleanuponly)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; maxbufsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't bother with optimization in <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-only case -- we don't expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly deleted pages.&nbsp; Besides, <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-only calls to <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can only take place because this optimization didn't work out during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the last VACUUM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cleanuponly)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cap maximum size of array so that we always respect <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>.&nbsp; Avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * int overflow here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; vstate-&gt;bufsize = <span class="Constant">256</span>;<br/></li>
<li>&nbsp; &nbsp; maxbufsize = (<a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> * <span class="Constant">1024L</span>) / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPendingFSM);<br/></li>
<li>&nbsp; &nbsp; maxbufsize = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(maxbufsize, <span class="Constant">INT_MAX</span>);<br/></li>
<li>&nbsp; &nbsp; maxbufsize = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(maxbufsize, MaxAllocSize / <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPendingFSM));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Stay sane with small <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> */<br/></li>
<li></span>&nbsp; &nbsp; maxbufsize = Max(maxbufsize, vstate-&gt;bufsize);<br/></li>
<li>&nbsp; &nbsp; vstate-&gt;maxbufsize = maxbufsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate buffer, indicate that there are currently 0 pending pages */<br/></li>
<li></span>&nbsp; &nbsp; vstate-&gt;pendingpages = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPendingFSM) * vstate-&gt;bufsize);<br/></li>
<li>&nbsp; &nbsp; vstate-&gt;npendingpages = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Place <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly deleted pages (i.e. pages that <a href="#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() deleted during<br/></li>
<li></span><span class="Comment"> * the ongoing VACUUM operation) into the free space map -- though only when<br/></li>
<li></span><span class="Comment"> * it is actually safe to do so by <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called at the end of a <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>(), just <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> free space map vacuuming<br/></li>
<li></span><span class="Comment"> * takes place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Frees memory allocated by <a href="#L2954" title="access/nbtree/nbtpage.c:2954">_bt_pendingfsm_init</a>(), if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2995">&#x200c;</a></span><span class="linkable">_bt_pendingfsm_finalize</span>(Relation rel, BTVacState *vstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult *stats = vstate-&gt;stats;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heaprel = vstate-&gt;info-&gt;heaprel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(stats-&gt;pages_newly_deleted &gt;= vstate-&gt;npendingpages);<br/></li>
<li>&nbsp; &nbsp; Assert(heaprel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;npendingpages == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just free memory when nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;pendingpages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vstate-&gt;pendingpages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef DEBUG_BTREE_PENDING_FSM<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Debugging aid: Sleep for 5 seconds to greatly increase the chances of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * placing pending pages in the FSM.&nbsp; Note that the optimization will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never be effective without some other backend concurrently consuming an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">5000000L</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recompute VACUUM XID boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't actually care about the oldest non-removable XID.&nbsp; Computing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the oldest such XID has a useful side-effect that we rely on: it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forcibly updates the XID horizon state for this backend.&nbsp; This step is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * essential; <a href="../../storage/ipc/procarray.c.html#L4270" title="storage/ipc/procarray.c:4270">GlobalVisCheckRemovableFullXid</a>() will not reliably recognize<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that it is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe to recycle newly deleted pages without this step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../storage/ipc/procarray.c.html#L1993" title="storage/ipc/procarray.c:1993">GetOldestNonRemovableTransactionId</a>(heaprel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; vstate-&gt;npendingpages; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber target = vstate-&gt;pendingpages[i].target;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId safexid = vstate-&gt;pendingpages[i].safexid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the equivalent of checking BTPageIsRecyclable(), but without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accessing the page again a second time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give up on finding the first non-recyclable page -- all later pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be non-recyclable too, since <a href="#L3062" title="access/nbtree/nbtpage.c:3062">_bt_pendingfsm_add</a>() adds pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the array in safexid order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../../storage/ipc/procarray.c.html#L4270" title="storage/ipc/procarray.c:4270">GlobalVisCheckRemovableFullXid</a>(heaprel, safexid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>(rel, target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;pages_free++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vstate-&gt;pendingpages);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maintain array of pages that were deleted during current <a href="nbtree.c.html#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>()<br/></li>
<li></span><span class="Comment"> * call, for use in <a href="#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3062">&#x200c;</a></span><span class="linkable">_bt_pendingfsm_add</span>(BTVacState *vstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockNumber target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FullTransactionId safexid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(vstate-&gt;npendingpages &lt;= vstate-&gt;bufsize);<br/></li>
<li>&nbsp; &nbsp; Assert(vstate-&gt;bufsize &lt;= vstate-&gt;maxbufsize);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify an assumption made by <a href="#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a>(): pages from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array will always be in safexid order (since that is the order that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * save them in here)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;npendingpages &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FullTransactionId lastsafexid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;pendingpages[vstate-&gt;npendingpages - <span class="Constant">1</span>].safexid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(FullTransactionIdFollowsOrEquals(safexid, lastsafexid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If temp buffer reaches maxbufsize/<a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> capacity then we discard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information about this page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this also covers the case where we opted to not use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization in <a href="#L2954" title="access/nbtree/nbtpage.c:2954">_bt_pendingfsm_init</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;npendingpages == vstate-&gt;maxbufsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider enlarging buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;npendingpages == vstate-&gt;bufsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbufsize = vstate-&gt;bufsize * <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Respect <a href="../../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (newbufsize &gt; vstate-&gt;maxbufsize)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newbufsize = vstate-&gt;maxbufsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;bufsize = newbufsize;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vstate-&gt;pendingpages =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(vstate-&gt;pendingpages,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPendingFSM) * vstate-&gt;bufsize);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Save metadata for newly deleted page */<br/></li>
<li></span>&nbsp; &nbsp; vstate-&gt;pendingpages[vstate-&gt;npendingpages].target = target;<br/></li>
<li>&nbsp; &nbsp; vstate-&gt;pendingpages[vstate-&gt;npendingpages].safexid = safexid;<br/></li>
<li>&nbsp; &nbsp; vstate-&gt;npendingpages++;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
