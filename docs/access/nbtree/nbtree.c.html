<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtree.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtree.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L61">BTPS_State</a></li>
<li><a href="#L83">BTParallelScanDesc</a></li>
<li><a href="#L67">BTParallelScanDescData</a></li>
<li><a href="#L81">BTParallelScanDescData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L732">_bt_parallel_done</a></li>
<li><a href="#L771">_bt_parallel_primscan_schedule</a></li>
<li><a href="#L709">_bt_parallel_release</a></li>
<li><a href="#L605">_bt_parallel_seize</a></li>
<li><a href="#L312">btbeginscan</a></li>
<li><a href="#L159">btbuildempty</a></li>
<li><a href="#L808">btbulkdelete</a></li>
<li><a href="#L1444">btcanreturn</a></li>
<li><a href="#L417">btendscan</a></li>
<li><a href="#L537">btestimateparallelscan</a></li>
<li><a href="#L266">btgetbitmap</a></li>
<li><a href="#L206">btgettuple</a></li>
<li><a href="#L101">bthandler</a></li>
<li><a href="#L547">btinitparallelscan</a></li>
<li><a href="#L182">btinsert</a></li>
<li><a href="#L453">btmarkpos</a></li>
<li><a href="#L561">btparallelrescan</a></li>
<li><a href="#L1395">btreevacuumposting</a></li>
<li><a href="#L359">btrescan</a></li>
<li><a href="#L479">btrestrpos</a></li>
<li><a href="#L838">btvacuumcleanup</a></li>
<li><a href="#L1060">btvacuumpage</a></li>
<li><a href="#L926">btvacuumscan</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtree.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Implementation of Lehman and Yao's btree management algorithm for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Postgres.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains only the public interface routines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtree.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/execnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bulk_write.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/indexfsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/index_selfuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BTPARALLEL_NOT_INITIALIZED indicates that the scan has not started.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BTPARALLEL_NEED_PRIMSCAN indicates that some process must <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> seize the<br/></li>
<li></span><span class="Comment"> * scan to advance it via another call to <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BTPARALLEL_ADVANCING indicates that some process is advancing the scan to<br/></li>
<li></span><span class="Comment"> * a new page; others must wait.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BTPARALLEL_IDLE indicates that no backend is currently advancing the scan<br/></li>
<li></span><span class="Comment"> * to a new page; some process can start doing that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BTPARALLEL_DONE indicates that the scan is complete (including error exit).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; BTPARALLEL_NOT_INITIALIZED,<br/></li>
<li>&nbsp; &nbsp; BTPARALLEL_NEED_PRIMSCAN,<br/></li>
<li>&nbsp; &nbsp; BTPARALLEL_ADVANCING,<br/></li>
<li>&nbsp; &nbsp; BTPARALLEL_IDLE,<br/></li>
<li>&nbsp; &nbsp; BTPARALLEL_DONE,<br/></li>
<li><a id="L61">&#x200c;</a>} <span class="linkable">BTPS_State</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L67" title="access/nbtree/nbtree.c:67">BTParallelScanDescData</a> contains btree specific shared information required<br/></li>
<li></span><span class="Comment"> * for parallel scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L67">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BTParallelScanDescData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber btps_scanPage;&nbsp; &nbsp; <span class="Comment">/* latest or <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page to be scanned */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L61" title="access/nbtree/nbtree.c:61">BTPS_State</a>&nbsp; &nbsp; btps_pageStatus;&nbsp; &nbsp; <span class="Comment">/* indicates whether <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available for scan. see above for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible states of parallel scan. */<br/></li>
<li></span>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; btps_mutex;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* protects above variables, btps_arrElems */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable btps_cv;&nbsp; &nbsp; <span class="Comment">/* used to synchronize parallel scan */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * btps_arrElems is used when scans need to schedule another primitive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index scan.&nbsp; Holds BTArrayKeyInfo.cur_elem offsets for scan keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btps_arrElems[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L81">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BTParallelScanDescData</span>;<br/></li>
<li><br/></li>
<li><a id="L83">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <a href="#L67" title="access/nbtree/nbtree.c:67">BTParallelScanDescData</a> *<span class="linkable">BTParallelScanDesc</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTCycleId cycleid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a>(BTVacState *vstate, BlockNumber scanblkno);<br/></li>
<li><span class="Type">static</span> BTVacuumPosting <a href="#L1395" title="access/nbtree/nbtree.c:1395">btreevacuumposting</a>(BTVacState *vstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple posting,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber updatedoffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> *nremaining);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Btree handler function: return IndexAmRoutine with access method parameters<br/></li>
<li></span><span class="Comment"> * and callbacks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L101">&#x200c;</a><span class="linkable">bthandler</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine = makeNode(IndexAmRoutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstrategies = BTMaxStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsupport = BTNProcs;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptsprocnum = BTOPTIONS_PROC;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorder = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanorderbyop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbackward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanunique = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanmulticol = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptionalkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearcharray = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsearchnulls = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amstorage = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amclusterable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ampredlocks = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanparallel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanbuildparallel = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcaninclude = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amusemaintenanceworkmem = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amsummarizing = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelvacuumoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VACUUM_OPTION_PARALLEL_BULKDEL | VACUUM_OPTION_PARALLEL_COND_CLEANUP;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amkeytype = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuild = <a href="nbtsort.c.html#L293" title="access/nbtree/nbtsort.c:293">btbuild</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildempty = <a href="#L159" title="access/nbtree/nbtree.c:159">btbuildempty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsert = <a href="#L182" title="access/nbtree/nbtree.c:182">btinsert</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminsertcleanup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambulkdelete = <a href="#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amvacuumcleanup = <a href="#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcanreturn = <a href="#L1444" title="access/nbtree/nbtree.c:1444">btcanreturn</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amcostestimate = <a href="../../utils/adt/selfuncs.c.html#L6788" title="utils/adt/selfuncs.c:6788">btcostestimate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amoptions = <a href="nbtutils.c.html#L4561" title="access/nbtree/nbtutils.c:4561">btoptions</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amproperty = <a href="nbtutils.c.html#L4584" title="access/nbtree/nbtutils.c:4584">btproperty</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambuildphasename = <a href="nbtutils.c.html#L4607" title="access/nbtree/nbtutils.c:4607">btbuildphasename</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;<a href="../index/amapi.c.html#L114" title="access/index/amapi.c:114">amvalidate</a> = <a href="nbtvalidate.c.html#L41" title="access/nbtree/nbtvalidate.c:41">btvalidate</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amadjustmembers = <a href="nbtvalidate.c.html#L293" title="access/nbtree/nbtvalidate.c:293">btadjustmembers</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ambeginscan = <a href="#L312" title="access/nbtree/nbtree.c:312">btbeginscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrescan = <a href="#L359" title="access/nbtree/nbtree.c:359">btrescan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgettuple = <a href="#L206" title="access/nbtree/nbtree.c:206">btgettuple</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amgetbitmap = <a href="#L266" title="access/nbtree/nbtree.c:266">btgetbitmap</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amendscan = <a href="#L417" title="access/nbtree/nbtree.c:417">btendscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;ammarkpos = <a href="#L453" title="access/nbtree/nbtree.c:453">btmarkpos</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amrestrpos = <a href="#L479" title="access/nbtree/nbtree.c:479">btrestrpos</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amestimateparallelscan = <a href="#L537" title="access/nbtree/nbtree.c:537">btestimateparallelscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;aminitparallelscan = <a href="#L547" title="access/nbtree/nbtree.c:547">btinitparallelscan</a>;<br/></li>
<li>&nbsp; &nbsp; amroutine-&gt;amparallelrescan = <a href="#L561" title="access/nbtree/nbtree.c:561">btparallelrescan</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_POINTER(amroutine);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L159" title="access/nbtree/nbtree.c:159">btbuildempty</a>() -- build an empty btree index in the initialization fork<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L159">&#x200c;</a></span><span class="linkable">btbuildempty</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; allequalimage = <a href="nbtutils.c.html#L5139" title="access/nbtree/nbtutils.c:5139">_bt_allequalimage</a>(index, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate;<br/></li>
<li>&nbsp; &nbsp; BulkWriteBuffer metabuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bulkstate = <a href="../../storage/smgr/bulk_write.c.html#L86" title="storage/smgr/bulk_write.c:86">smgr_bulk_start_rel</a>(index, INIT_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Construct metapage. */<br/></li>
<li></span>&nbsp; &nbsp; metabuf = <a href="../../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(bulkstate);<br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L67" title="access/nbtree/nbtpage.c:67">_bt_initmetapage</a>((Page) metabuf, P_NONE, <span class="Constant">0</span>, allequalimage);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(bulkstate, BTREE_METAPAGE, metabuf, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/smgr/bulk_write.c.html#L129" title="storage/smgr/bulk_write.c:129">smgr_bulk_finish</a>(bulkstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L182" title="access/nbtree/nbtree.c:182">btinsert</a>() -- insert an index tuple into a btree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Descend the tree recursively, <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the appropriate location for our<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; new tuple, and put it there.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">btinsert</span>(Relation rel, Datum *<a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer ht_ctid, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexUniqueCheck checkUnique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> indexUnchanged,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* generate an index tuple */<br/></li>
<li></span>&nbsp; &nbsp; itup = <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>(RelationGetDescr(rel), <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull);<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_tid = *ht_ctid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="nbtinsert.c.html#L102" title="access/nbtree/nbtinsert.c:102">_bt_doinsert</a>(rel, itup, checkUnique, indexUnchanged, heapRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L206" title="access/nbtree/nbtree.c:206">btgettuple</a>() -- Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple in the scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L206">&#x200c;</a></span><span class="linkable">btgettuple</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* btree indexes are never lossy */<br/></li>
<li></span>&nbsp; &nbsp; scan-&gt;xs_recheck = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Each loop iteration performs another primitive index scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've already initialized this scan, we can just advance it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the appropriate direction.&nbsp; If we haven't done so yet, we call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>() to get the first item in the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BTScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>(scan, dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check to see if we should kill the previously-fetched tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;kill_prior_tuple)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Yes, remember it for later. (We'll deal with all such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuples at once right <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> leaving the index page.)&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * test for numKilled overrun is not just paranoia: if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller reverses direction in the indexscan then the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item might get entered multiple times. It's not worth<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * trying to <a href="../../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> that, so we don't detect it, but instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just forget <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> excess entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;killedItems == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;killedItems = (<span class="Type">int</span> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MaxTIDsPerBTreePage * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &lt; MaxTIDsPerBTreePage)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;killedItems[so-&gt;numKilled++] = so-&gt;currPos.itemIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now continue the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res = <a href="nbtsearch.c.html#L1492" title="access/nbtree/nbtsearch.c:1492">_bt_next</a>(scan, dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have a tuple, return it ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... otherwise see if we need another primitive index scan */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (so-&gt;numArrayKeys &amp;&amp; <a href="nbtutils.c.html#L1668" title="access/nbtree/nbtutils.c:1668">_bt_start_prim_scan</a>(scan, dir));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> res;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L266" title="access/nbtree/nbtree.c:266">btgetbitmap</a>() -- gets all matching tuples, and adds them to a bitmap<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int64<br/></li>
<li><a id="L266">&#x200c;</a><span class="linkable">btgetbitmap</span>(IndexScanDesc scan, <a href="../../nodes/tidbitmap.c.html#L149" title="nodes/tidbitmap.c:149">TIDBitmap</a> *tbm)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; ntids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ItemPointer heapTid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Each loop iteration performs another primitive index scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the first page &amp; tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>(scan, ForwardScanDirection))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save tuple ID, and continue scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapTid = &amp;scan-&gt;xs_heaptid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a>(tbm, heapTid, <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntids++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple within page.&nbsp; This is the same as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * easy case in <a href="nbtsearch.c.html#L1492" title="access/nbtree/nbtsearch.c:1492">_bt_next</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++so-&gt;currPos.itemIndex &gt; so-&gt;currPos.lastItem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* let <a href="nbtsearch.c.html#L1492" title="access/nbtree/nbtsearch.c:1492">_bt_next</a> do the heavy lifting */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="nbtsearch.c.html#L1492" title="access/nbtree/nbtsearch.c:1492">_bt_next</a>(scan, ForwardScanDirection))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save tuple ID, and continue scanning */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapTid = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex].heapTid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../nodes/tidbitmap.c.html#L377" title="nodes/tidbitmap.c:377">tbm_add_tuples</a>(tbm, heapTid, <span class="Constant">1</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now see if we need another primitive index scan */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (so-&gt;numArrayKeys &amp;&amp; <a href="nbtutils.c.html#L1668" title="access/nbtree/nbtutils.c:1668">_bt_start_prim_scan</a>(scan, ForwardScanDirection));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ntids;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L312" title="access/nbtree/nbtree.c:312">btbeginscan</a>() -- start a scan on a btree index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexScanDesc<br/></li>
<li><a id="L312">&#x200c;</a><span class="linkable">btbeginscan</span>(Relation rel, <span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no order by operators allowed */<br/></li>
<li></span>&nbsp; &nbsp; Assert(norderbys == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the scan */<br/></li>
<li></span>&nbsp; &nbsp; scan = <a href="../index/genam.c.html#L78" title="access/index/genam.c:78">RelationGetIndexScan</a>(rel, nkeys, norderbys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate private workspace */<br/></li>
<li></span>&nbsp; &nbsp; so = (BTScanOpaque) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTScanOpaqueData));<br/></li>
<li>&nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; BTScanPosInvalidate(so-&gt;markPos);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;numberOfKeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;keyData = (ScanKey) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(scan-&gt;numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;keyData = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;arrayKeys = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;orderProcs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;arrayContext = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;killedItems = <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* until needed */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;numKilled = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't know yet whether the scan will be index-only, so we do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate the tuple workspace arrays until <a href="#L359" title="access/nbtree/nbtree.c:359">btrescan</a>.&nbsp; However, we set up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan-&gt;xs_itupdesc whether we'll need it or not, since that's so cheap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;currTuples = so-&gt;markTuples = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_itupdesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan-&gt;opaque = so;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> scan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L359" title="access/nbtree/nbtree.c:359">btrescan</a>() -- rescan an index relation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L359">&#x200c;</a></span><span class="linkable">btrescan</span>(IndexScanDesc scan, ScanKey scankey, <span class="Type">int</span> nscankeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanKey orderbys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we aren't holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> read locks, but gotta drop the pins */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Before leaving current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;markItemIndex = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;markPos);<br/></li>
<li>&nbsp; &nbsp; BTScanPosInvalidate(so-&gt;markPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate tuple workspace arrays, if needed for an index-only scan and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not already done in a previous rescan call.&nbsp; To save on <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead, both workspaces are allocated as one <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a> block; only this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function and <a href="#L417" title="access/nbtree/nbtree.c:417">btendscan</a> know that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this data structure also makes it safe to return data from a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;name&quot; column, even though btree name_ops uses an underlying storage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * datatype of cstring.&nbsp; The risk there is that &quot;name&quot; is supposed to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * padded to NAMEDATALEN, but the actual index tuple is probably shorter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, since we only return data out of tuples sitting in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * currTuples array, a fetch of NAMEDATALEN bytes can at worst <a href="../../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data out of the markTuples array --- running off the end of memory for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a SIGSEGV is not possible.&nbsp; Yeah, this is ugly as sin, but it beats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding special-case treatment for name_ops elsewhere.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_want_itup &amp;&amp; so-&gt;currTuples == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currTuples = (<span class="Type">char</span> *) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(BLCKSZ * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markTuples = so-&gt;currTuples + BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset the scan keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scankey &amp;&amp; scan-&gt;numberOfKeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(scan-&gt;keyData,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scankey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;numberOfKeys * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; so-&gt;numberOfKeys = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* until <a href="nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a> sets it */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;numArrayKeys = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ditto */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L417" title="access/nbtree/nbtree.c:417">btendscan</a>() -- close down a scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L417">&#x200c;</a></span><span class="linkable">btendscan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we aren't holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> read locks, but gotta drop the pins */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Before leaving current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; so-&gt;markItemIndex = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;markPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No need to invalidate positions, the RAM is about to be freed. */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release storage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;keyData != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(so-&gt;keyData);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* so-&gt;arrayKeys and so-&gt;orderProcs are in arrayContext */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;arrayContext != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(so-&gt;arrayContext);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;killedItems != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(so-&gt;killedItems);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currTuples != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(so-&gt;currTuples);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* so-&gt;markTuples should not be <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'d, see <a href="#L359" title="access/nbtree/nbtree.c:359">btrescan</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(so);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L453" title="access/nbtree/nbtree.c:453">btmarkpos</a>() -- save current scan position<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">btmarkpos</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There may be an old mark with a pin (but no lock). */<br/></li>
<li></span>&nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;markPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Just record the current itemIndex.&nbsp; If we later step to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the marked position, <a href="nbtsearch.c.html#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a> makes a full copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the currPos struct in markPos.&nbsp; If (as often happens) the mark is moved<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we leave the page, we don't have to do that work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markItemIndex = so-&gt;currPos.itemIndex;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;markPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markItemIndex = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L479" title="access/nbtree/nbtree.c:479">btrestrpos</a>() -- restore scan to last saved position<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L479">&#x200c;</a></span><span class="linkable">btrestrpos</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;markItemIndex &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The scan has never moved to a new page since the last mark.&nbsp; Just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restore the itemIndex.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * NB: In this case we can't count on anything in so-&gt;markPos to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accurate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.itemIndex = so-&gt;markItemIndex;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The scan moved to a new page after last mark or restore, and we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> restoring to the marked page.&nbsp; We aren't holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * locks, but if we're still holding the pin for the current position,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must drop it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsValid(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Before leaving current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsValid(so-&gt;markPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bump pin on mark buffer for assignment to current buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsPinned(so-&gt;markPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(so-&gt;markPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;so-&gt;currPos, &amp;so-&gt;markPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(BTScanPosData, items[<span class="Constant">1</span>]) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so-&gt;markPos.lastItem * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTScanPosItem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(so-&gt;currTuples, so-&gt;markTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so-&gt;markPos.nextTupleOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset the scan's array keys (see <a href="nbtsearch.c.html#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a> for why) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numArrayKeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L1343" title="access/nbtree/nbtutils.c:1343">_bt_start_array_keys</a>(scan, so-&gt;currPos.dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L537" title="access/nbtree/nbtree.c:537">btestimateparallelscan</a> -- estimate storage for <a href="#L67" title="access/nbtree/nbtree.c:67">BTParallelScanDescData</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L537">&#x200c;</a><span class="linkable">btestimateparallelscan</span>(<span class="Type">int</span> nkeys, <span class="Type">int</span> norderbys)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pessimistically assume all input scankeys will be output with arrays */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> offsetof(<a href="#L67" title="access/nbtree/nbtree.c:67">BTParallelScanDescData</a>, btps_arrElems) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">int</span>) * nkeys;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L547" title="access/nbtree/nbtree.c:547">btinitparallelscan</a> -- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> for parallel btree scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L547">&#x200c;</a></span><span class="linkable">btinitparallelscan</span>(<span class="Type">void</span> *target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> bt_target = (<a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a>) target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockInit(&amp;bt_target-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; bt_target-&gt;btps_scanPage = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; bt_target-&gt;btps_pageStatus = BTPARALLEL_NOT_INITIALIZED;<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;bt_target-&gt;btps_cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L561" title="access/nbtree/nbtree.c:561">btparallelrescan</a>() -- reset parallel scan<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L561">&#x200c;</a></span><span class="linkable">btparallelrescan</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> btscan;<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc parallel_scan = scan-&gt;parallel_scan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(parallel_scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btscan = (<a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a>) OffsetToPointer((<span class="Type">void</span> *) parallel_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_scan-&gt;ps_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In theory, we don't need to acquire the spinlock here, because there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other workers running at this point, but we do so for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistency.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; btscan-&gt;btps_scanPage = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; btscan-&gt;btps_pageStatus = BTPARALLEL_NOT_INITIALIZED;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a>() -- Begin the process of advancing the scan to a new<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; page.&nbsp; Other scans must wait until we call <a href="#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or <a href="#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is true if we successfully seized the scan and false<br/></li>
<li></span><span class="Comment"> * if we did not.&nbsp; The latter case occurs if no pages remain.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the return value is true, *pageno returns the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> or current page<br/></li>
<li></span><span class="Comment"> * of the scan (depending on the scan direction).&nbsp; An invalid block number<br/></li>
<li></span><span class="Comment"> * means the scan hasn't yet started, or that caller needs to start the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * primitive index scan (if it's the latter case we'll set so.needPrimScan).<br/></li>
<li></span><span class="Comment"> * The first time a participating process reaches the last page, it will return<br/></li>
<li></span><span class="Comment"> * true and set *pageno to P_NONE; after that, further attempts to seize the<br/></li>
<li></span><span class="Comment"> * scan will return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers should ignore the value of pageno if the return value is false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers that are in a position to start a new primitive index scan must<br/></li>
<li></span><span class="Comment"> * pass first=true (all other callers pass first=false).&nbsp; We just return false<br/></li>
<li></span><span class="Comment"> * for first=false callers that require another primitive index scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L605">&#x200c;</a></span><span class="linkable">_bt_parallel_seize</span>(IndexScanDesc scan, BlockNumber *pageno, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> first)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exit_loop = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; status = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc parallel_scan = scan-&gt;parallel_scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> btscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *pageno = P_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (first)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize array related state when called from <a href="nbtsearch.c.html#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>, assuming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that this will either be the first primitive index scan for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan, or a previous explicitly scheduled primitive scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: so-&gt;needPrimScan is only set when a scheduled primitive index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan is set to be performed in caller's worker process.&nbsp; It should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be set here by us for the first primitive scan, nor should we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ever set it for a parallel scan that has no array keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't attempt to seize the scan when backend requires another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * primitive index scan unless we're in a position to start it <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;needPrimScan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btscan = (<a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a>) OffsetToPointer((<span class="Type">void</span> *) parallel_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_scan-&gt;ps_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;btscan-&gt;btps_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (btscan-&gt;btps_pageStatus == BTPARALLEL_DONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're done with this parallel index scan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (btscan-&gt;btps_pageStatus == BTPARALLEL_NEED_PRIMSCAN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(so-&gt;numArrayKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we can start another primitive scan right away, do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise just wait.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_pageStatus = BTPARALLEL_ADVANCING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; so-&gt;numArrayKeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = &amp;so-&gt;arrayKeys[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; skey = &amp;so-&gt;keyData[array-&gt;scan_key];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; array-&gt;cur_elem = btscan-&gt;btps_arrElems[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skey-&gt;sk_argument = array-&gt;elem_values[array-&gt;cur_elem];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;scanBehind = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pageno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit_loop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (btscan-&gt;btps_pageStatus != BTPARALLEL_ADVANCING)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have successfully seized control of the scan for the purpose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of advancing it to a new page!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_pageStatus = BTPARALLEL_ADVANCING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pageno = btscan-&gt;btps_scanPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exit_loop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exit_loop || !status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;btscan-&gt;btps_cv, WAIT_EVENT_BTREE_PAGE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> status;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a>() -- Complete the process of advancing the scan to a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; new page.&nbsp; We <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have the new value btps_scanPage; some other backend<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; can <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> begin advancing the scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers whose scan uses array keys must save their scan_page argument so<br/></li>
<li></span><span class="Comment"> * that it can be passed to <a href="#L771" title="access/nbtree/nbtree.c:771">_bt_parallel_primscan_schedule</a>, should caller<br/></li>
<li></span><span class="Comment"> * determine that another primitive index scan is required.&nbsp; If that happens,<br/></li>
<li></span><span class="Comment"> * scan_page won't be scanned by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend (unless the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> primitive index<br/></li>
<li></span><span class="Comment"> * scan lands on scan_page).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">_bt_parallel_release</span>(IndexScanDesc scan, BlockNumber scan_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc parallel_scan = scan-&gt;parallel_scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> btscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btscan = (<a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a>) OffsetToPointer((<span class="Type">void</span> *) parallel_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_scan-&gt;ps_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; btscan-&gt;btps_scanPage = scan_page;<br/></li>
<li>&nbsp; &nbsp; btscan-&gt;btps_pageStatus = BTPARALLEL_IDLE;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L259" title="storage/lmgr/condition_variable.c:259">ConditionVariableSignal</a>(&amp;btscan-&gt;btps_cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>() -- Mark the parallel scan as complete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When there are no pages left to scan, this function should be called to<br/></li>
<li></span><span class="Comment"> * notify other workers.&nbsp; Otherwise, they might wait forever for the scan to<br/></li>
<li></span><span class="Comment"> * advance to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L732">&#x200c;</a></span><span class="linkable">_bt_parallel_done</span>(IndexScanDesc scan)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc parallel_scan = scan-&gt;parallel_scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> btscan;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; status_changed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing, for non-parallel scans */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parallel_scan == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btscan = (<a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a>) OffsetToPointer((<span class="Type">void</span> *) parallel_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_scan-&gt;ps_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the parallel scan as done, unless some other process did so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btscan-&gt;btps_pageStatus != BTPARALLEL_DONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_pageStatus = BTPARALLEL_DONE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status_changed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;btscan-&gt;btps_mutex);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* wake up all the workers associated with this parallel scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status_changed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;btscan-&gt;btps_cv);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L771" title="access/nbtree/nbtree.c:771">_bt_parallel_primscan_schedule</a>() -- Schedule another primitive index scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller passes the block number most recently passed to <a href="#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a><br/></li>
<li></span><span class="Comment"> * by its backend.&nbsp; Caller successfully schedules the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> primitive index scan<br/></li>
<li></span><span class="Comment"> * if the shared parallel state hasn't been seized since caller's backend last<br/></li>
<li></span><span class="Comment"> * advanced the scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L771">&#x200c;</a></span><span class="linkable">_bt_parallel_primscan_schedule</span>(IndexScanDesc scan, BlockNumber prev_scan_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; ParallelIndexScanDesc parallel_scan = scan-&gt;parallel_scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a> btscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(so-&gt;numArrayKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; btscan = (<a href="#L83" title="access/nbtree/nbtree.c:83">BTParallelScanDesc</a>) OffsetToPointer((<span class="Type">void</span> *) parallel_scan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parallel_scan-&gt;ps_offset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (btscan-&gt;btps_scanPage == prev_scan_page &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_pageStatus == BTPARALLEL_IDLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_scanPage = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_pageStatus = BTPARALLEL_NEED_PRIMSCAN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Serialize scan's current array keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; so-&gt;numArrayKeys; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTArrayKeyInfo *array = &amp;so-&gt;arrayKeys[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; btscan-&gt;btps_arrElems[i] = array-&gt;cur_elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;btscan-&gt;btps_mutex);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Bulk deletion of all index entries pointing to a set of heap tuples.<br/></li>
<li></span><span class="Comment"> * The set of target tuples is specified via a callback routine that tells<br/></li>
<li></span><span class="Comment"> * whether <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given heap tuple (identified by ItemPointer) is being deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct containing statistical info for VACUUM displays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L808">&#x200c;</a><span class="linkable">btbulkdelete</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; BTCycleId&nbsp; &nbsp; cycleid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allocate stats if first time through, else re-use existing struct */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Establish the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle ID to use for this scan */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* The ENSURE stuff ensures we clean up shared memory on failure */<br/></li>
<li></span>&nbsp; &nbsp; PG_ENSURE_ERROR_CLEANUP(<a href="nbtutils.c.html#L4511" title="access/nbtree/nbtutils.c:4511">_bt_end_vacuum_callback</a>, PointerGetDatum(rel));<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cycleid = <a href="nbtutils.c.html#L4426" title="access/nbtree/nbtutils.c:4426">_bt_start_vacuum</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>(info, stats, callback, callback_state, cycleid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_ENSURE_ERROR_CLEANUP(<a href="nbtutils.c.html#L4511" title="access/nbtree/nbtutils.c:4511">_bt_end_vacuum_callback</a>, PointerGetDatum(rel));<br/></li>
<li>&nbsp; &nbsp; <a href="nbtutils.c.html#L4483" title="access/nbtree/nbtutils.c:4483">_bt_end_vacuum</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Post-VACUUM <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result: a <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d struct containing statistical info for VACUUM displays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexBulkDeleteResult *<br/></li>
<li><a id="L838">&#x200c;</a><span class="linkable">btvacuumcleanup</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber num_delpages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op in ANALYZE ONLY mode */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;analyze_only)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> was called, we need not do anything (we just maintain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the information used within <a href="nbtpage.c.html#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a>() by calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtpage.c.html#L232" title="access/nbtree/nbtpage.c:232">_bt_set_cleanup_info</a>() below).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> was _not_ called, then we have a choice to make: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must decide whether or not a <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>() call is needed <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> (i.e.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether the ongoing VACUUM operation can entirely avoid a physical scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the index).&nbsp; A call to <a href="nbtpage.c.html#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a>() decides it for us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stats == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if VACUUM operation can entirely avoid <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>() call */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="nbtpage.c.html#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a>(info-&gt;index))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since we aren't going to actually delete <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaf items, there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to go through all the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>-cycle-ID pushups here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Posting list tuples are a source of inaccuracy for <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scans.&nbsp; <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>() will assume that the number of index tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from each page can be used as num_index_tuples, even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * num_index_tuples is supposed to represent the number of TIDs in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index.&nbsp; This naive approach can underestimate the number of tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the index significantly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We handle the problem by making num_index_tuples an estimate in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-only case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats = (IndexBulkDeleteResult *) <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexBulkDeleteResult));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>(info, stats, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;estimated_count = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Maintain num_delpages value in metapage for <a href="nbtpage.c.html#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * num_delpages is the number of deleted pages <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in the index that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not safe to place in the FSM to be recycled just yet.&nbsp; num_delpages is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * greater than 0 only when <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() actually deleted pages during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * our call to <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>().&nbsp; Even then, <a href="nbtpage.c.html#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a>() must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have failed to place <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> newly deleted pages in the FSM just moments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ago.&nbsp; (Actually, there are edge cases where recycling of the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM's newly deleted pages does not even become safe by the time the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> VACUUM comes around.&nbsp; See nbtree/README.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stats-&gt;pages_deleted &gt;= stats-&gt;pages_free);<br/></li>
<li>&nbsp; &nbsp; num_delpages = stats-&gt;pages_deleted - stats-&gt;pages_free;<br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L232" title="access/nbtree/nbtpage.c:232">_bt_set_cleanup_info</a>(info-&gt;index, num_delpages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's quite possible for us to be fooled by concurrent page splits into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * double-counting some index tuples, so disbelieve <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> total that exceeds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the underlying heap's count ... if we know that accurately.&nbsp; Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this might just make matters worse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!info-&gt;estimated_count)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stats-&gt;num_index_tuples &gt; info-&gt;num_heap_tuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;num_index_tuples = info-&gt;num_heap_tuples;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a> --- scan the index for VACUUMing purposes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This combines the <a href="../../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> of looking for leaf tuples that are deletable<br/></li>
<li></span><span class="Comment"> * according to the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> callback, looking for empty pages that can be<br/></li>
<li></span><span class="Comment"> * deleted, and looking for old deleted pages that can be recycled.&nbsp; Both<br/></li>
<li></span><span class="Comment"> * <a href="#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> and <a href="#L838" title="access/nbtree/nbtree.c:838">btvacuumcleanup</a> invoke this (the latter only if no<br/></li>
<li></span><span class="Comment"> * <a href="#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> call occurred and <a href="nbtpage.c.html#L179" title="access/nbtree/nbtpage.c:179">_bt_vacuum_needs_cleanup</a> returned true).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller is responsible for initially allocating/zeroing a stats struct<br/></li>
<li></span><span class="Comment"> * and for obtaining a <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle ID if necessary.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L926">&#x200c;</a></span><span class="linkable">btvacuumscan</span>(IndexVacuumInfo *info, IndexBulkDeleteResult *stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexBulkDeleteCallback callback, <span class="Type">void</span> *callback_state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTCycleId cycleid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; BTVacState&nbsp; &nbsp; vstate;<br/></li>
<li>&nbsp; &nbsp; BlockNumber num_pages;<br/></li>
<li>&nbsp; &nbsp; BlockNumber scanblkno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needLock;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset fields that track information about the entire index <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoids double-counting in the case where a single VACUUM command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * requires multiple scans of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid resetting the tuples_removed and pages_newly_deleted fields here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since they track information about the VACUUM command, and so must last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * across each call to <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that pages_free is treated as state about the whole index, not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current VACUUM.&nbsp; This is appropriate because <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls are idempotent, and get repeated for the same deleted pages in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some scenarios.&nbsp; The point for us is to track the number of recyclable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pages in the index at the end of the VACUUM command.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;num_pages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;num_index_tuples = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_deleted = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;pages_free = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up info to pass down to <a href="#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a> */<br/></li>
<li></span>&nbsp; &nbsp; vstate.info = info;<br/></li>
<li>&nbsp; &nbsp; vstate.stats = stats;<br/></li>
<li>&nbsp; &nbsp; vstate.callback = callback;<br/></li>
<li>&nbsp; &nbsp; vstate.callback_state = callback_state;<br/></li>
<li>&nbsp; &nbsp; vstate.cycleid = cycleid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a temporary memory context to run <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a> in */<br/></li>
<li></span>&nbsp; &nbsp; vstate.pagedelcontext = AllocSetContextCreate(<a href="../../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize vstate fields used by <a href="nbtpage.c.html#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a> */<br/></li>
<li></span>&nbsp; &nbsp; vstate.bufsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vstate.maxbufsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; vstate.pendingpages = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; vstate.npendingpages = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Consider applying <a href="nbtpage.c.html#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a> optimization */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtpage.c.html#L2954" title="access/nbtree/nbtpage.c:2954">_bt_pendingfsm_init</a>(rel, &amp;vstate, (callback == <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The outer loop iterates over all index pages except the metapage, in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical order (we hope the kernel will cooperate in providing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * read-ahead for speed).&nbsp; It is critical that we visit all leaf pages,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including ones added after we start the scan, else we might fail to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delete some deletable tuples.&nbsp; Hence, we must repeatedly check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation length.&nbsp; We must acquire the relation-extension lock while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing so to avoid a race condition: if someone else is extending the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, there is a window where bufmgr/smgr have created a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all-zero page but it hasn't yet been write-locked by <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(). If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we manage to scan such a page here, we'll improperly assume it can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycled.&nbsp; Taking the lock synchronizes things enough to prevent a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem: either num_pages won't include the new page, or <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already has write lock on the buffer and it will be fully initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can examine it.&nbsp; Also, we need not worry if a page is added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediately after we look; the page splitting code already has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write-lock on the left page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it adds a right page, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already have processed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples due to be moved into such a page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">: Now that new pages are locked with RBM_ZERO_AND_LOCK, I don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think the use of the extension lock is still required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> locking for new or temp relations, however, since no one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * else could be accessing them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; needLock = !RELATION_IS_LOCAL(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scanblkno = BTREE_METAPAGE + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the current relation length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L430" title="storage/lmgr/lmgr.c:430">LockRelationForExtension</a>(rel, ExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_pages = RelationGetNumberOfBlocks(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needLock)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/lmgr.c.html#L480" title="storage/lmgr/lmgr.c:480">UnlockRelationForExtension</a>(rel, ExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;report_progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_SCAN_BLOCKS_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; num_pages);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Quit if we've scanned the whole relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scanblkno &gt;= num_pages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Iterate over pages, then loop back to recheck length */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (; scanblkno &lt; num_pages; scanblkno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a>(&amp;vstate, scanblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info-&gt;report_progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_SCAN_BLOCKS_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scanblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set statistics num_pages field to final size of index */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;num_pages = num_pages;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(vstate.pagedelcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there were <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> calls to <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() during scan of the index then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the resulting pages can be placed in the FSM <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's not safe we'll have to leave it up to a future VACUUM operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, if we placed <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pages in the FSM (either just <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> or during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the scan), forcibly update the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level FSM pages to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * searchers can <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtpage.c.html#L2995" title="access/nbtree/nbtpage.c:2995">_bt_pendingfsm_finalize</a>(rel, &amp;vstate);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stats-&gt;pages_free &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L71" title="storage/freespace/indexfsm.c:71">IndexFreeSpaceMapVacuum</a>(rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a> --- VACUUM one page<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This processes a single page for <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a>().&nbsp; In some cases we must<br/></li>
<li></span><span class="Comment"> * backtrack to re-examine and VACUUM pages that were the scanblkno during<br/></li>
<li></span><span class="Comment"> * a previous call here.&nbsp; This is how we handle page splits (that happened<br/></li>
<li></span><span class="Comment"> * after our cycleid was acquired) whose right half page happened to reuse<br/></li>
<li></span><span class="Comment"> * a block that we might have processed at some point <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it was<br/></li>
<li></span><span class="Comment"> * recycled (i.e. <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the page split).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1060">&#x200c;</a></span><span class="linkable">btvacuumpage</span>(BTVacState *vstate, BlockNumber scanblkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexVacuumInfo *info = vstate-&gt;info;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteResult *stats = vstate-&gt;stats;<br/></li>
<li>&nbsp; &nbsp; IndexBulkDeleteCallback callback = vstate-&gt;callback;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *callback_state = vstate-&gt;callback_state;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = info-&gt;index;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heaprel = info-&gt;heaprel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; attempt_pagedel;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backtrack_to;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; blkno = scanblkno;<br/></li>
<li><br/></li>
<li><span class="Statement">backtrack</span><span class="cUserCont">:<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; attempt_pagedel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; backtrack_to = P_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a> while not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../commands/vacuum.c.html#L2336" title="commands/vacuum.c:2336">vacuum_delay_point</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't use <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>() here because it always applies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtpage.c.html#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>(), which will barf on an all-zero page. We want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycle all-zero pages, not fail.&nbsp; Also, we want to use a nondefault<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer access strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="../../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>(rel, MAIN_FORKNUM, blkno, RBM_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; info-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, buf, BT_READ);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PageIsNew(page))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L797" title="access/nbtree/nbtpage.c:797">_bt_checkpage</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(blkno &lt;= scanblkno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (blkno != scanblkno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're backtracking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We followed a right link to a sibling leaf page (a page that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happens to be from a block located <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> scanblkno).&nbsp; The only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case we want to do anything with is a live leaf page having the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle ID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The page had better be in a state that's consistent with what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expect.&nbsp; Check for conditions that imply corruption in passing.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't be half-dead because only an interrupted VACUUM process can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave pages in that state, so we'd definitely have dealt with it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back when the page was the scanblkno page (half-dead pages are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always marked fully deleted by <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>(), barring corruption).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!opaque || !P_ISLEAF(opaque) || P_ISHALFDEAD(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;right sibling </span><span class="Special">%u</span><span class="Constant"> of scanblkno </span><span class="Special">%u</span><span class="Constant"> unexpectedly in an inconsistent state in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blkno, scanblkno, RelationGetRelationName(rel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We may have already processed the page in an earlier call, when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page was scanblkno.&nbsp; This happens when the leaf page split occurred<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after the scan began, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the right sibling page became the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanblkno.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Page may also have been deleted by current <a href="#L1060" title="access/nbtree/nbtree.c:1060">btvacuumpage</a>() call,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() sometimes deletes the right sibling page of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanblkno in passing (it does so after we decided where to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backtrack to).&nbsp; We don't need to process this page as a deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page a second time <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> (in fact, it would be wrong to count it as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted page in the bulk delete statistics a second time).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_cycleid != vstate-&gt;cycleid || P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done with current scanblkno (and all <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> split pages) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!opaque || BTPageIsRecyclable(page, heaprel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay to recycle this page (which could be leaf or <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/freespace/indexfsm.c.html#L52" title="storage/freespace/indexfsm.c:52">RecordFreeIndexPage</a>(rel, blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;pages_deleted++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;pages_free++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Already deleted page (which could be leaf or <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>).&nbsp; Can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recycle yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;pages_deleted++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (P_ISHALFDEAD(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Half-dead leaf page (from interrupted VACUUM) -- finish deleting */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; attempt_pagedel = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() will increment both pages_newly_deleted and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages_deleted stats in all cases (barring corruption)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (P_ISLEAF(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber deletable[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ndeletable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting updatable[MaxIndexTuplesPerPage];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupdatable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidsdead,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidslive;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Trade in the initial read lock for a full <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> lock on this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page.&nbsp; We must get such a lock on every leaf page over the course<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> scan, whether or not it actually contains <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deletable tuples --- see nbtree/README.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1109" title="access/nbtree/nbtpage.c:1109">_bt_upgradelockbufcleanup</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether we need to backtrack to earlier pages.&nbsp; What we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concerned about is a page split that happened since we started the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> scan.&nbsp; If the split moved tuples on the right half of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split (i.e. the tuples that sort high) to a block that we already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * passed over, then we might have missed the tuples.&nbsp; We need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backtrack <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; (Must do this <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> possibly clearing btpo_cycleid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or deleting scanblkno page below!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;cycleid != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_cycleid == vstate-&gt;cycleid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(opaque-&gt;btpo_flags &amp; BTP_SPLIT_END) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !P_RIGHTMOST(opaque) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_next &lt; scanblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backtrack_to = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ndeletable = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nupdatable = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; minoff = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nhtidsdead = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nhtidslive = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callback)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L808" title="access/nbtree/nbtree.c:808">btbulkdelete</a> callback tells us what to delete (or update) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (offnum = minoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PageGetItemId(page, offnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!BTreeTupleIsPivot(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Regular tuple, standard table TID representation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (callback(&amp;itup-&gt;t_tid, callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[ndeletable++] = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidsdead++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidslive++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTVacuumPosting vacposting;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nremaining;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Posting list tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting = <a href="#L1395" title="access/nbtree/nbtree.c:1395">btreevacuumposting</a>(vstate, itup, offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;nremaining);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vacposting == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All table TIDs from the posting tuple remain, so no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * delete or update required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nremaining == BTreeTupleGetNPosting(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nremaining &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store metadata about posting list tuple in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updatable array for entire page.&nbsp; Existing tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be updated during the later call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtpage.c.html#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nremaining &lt; BTreeTupleGetNPosting(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; updatable[nupdatable++] = vacposting;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidsdead += BTreeTupleGetNPosting(itup) - nremaining;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All table TIDs from the posting list must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deleted.&nbsp; We'll delete the index tuple completely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (no update required).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nremaining == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deletable[ndeletable++] = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidsdead += BTreeTupleGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(vacposting);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtidslive += nremaining;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Apply <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> needed deletes or updates.&nbsp; We issue just one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtpage.c.html#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a>() call per page, so as to minimize WAL traffic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ndeletable &gt; <span class="Constant">0</span> || nupdatable &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nhtidsdead &gt;= ndeletable + nupdatable);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a>(rel, buf, deletable, ndeletable, updatable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nupdatable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;tuples_removed += nhtidsdead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must recompute maxoff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nupdatable; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(updatable[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the leaf page has been split during this <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cycle, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems worth expending a write to clear btpo_cycleid even if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't have <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> deletions to do.&nbsp; (If we do, <a href="nbtpage.c.html#L1154" title="access/nbtree/nbtpage.c:1154">_bt_delitems_vacuum</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * takes care of this.)&nbsp; This ensures we won't process the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We treat this like a hint-<a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> update because there's no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-log it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(nhtidsdead == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vstate-&gt;cycleid != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_cycleid == vstate-&gt;cycleid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque-&gt;btpo_cycleid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4914" title="storage/buffer/bufmgr.c:4914">MarkBufferDirtyHint</a>(buf, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the leaf page is <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty, try to delete it; else count the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * live tuples (live table TIDs in posting lists are counted as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate live tuples).&nbsp; We don't delete when backtracking, though,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since that would require teaching <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>() about backtracking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (doesn't seem worth adding more complexity to deal with that).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't count the number of live TIDs during <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-only calls to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L926" title="access/nbtree/nbtree.c:926">btvacuumscan</a> (i.e. when callback is not set).&nbsp; We count the number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of index tuples directly instead.&nbsp; This avoids the expense of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directly examining all of the tuples on each page.&nbsp; VACUUM will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * treat num_index_tuples as an estimate in <a href="../../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>-only case, so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't matter that this underestimates num_index_tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * significantly in some cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (minoff &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attempt_pagedel = (blkno == scanblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (callback)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;num_index_tuples += nhtidslive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats-&gt;num_index_tuples += maxoff - minoff + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!attempt_pagedel || nhtidslive == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attempt_pagedel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Run pagedel in a temp context to avoid memory leakage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(vstate-&gt;pagedelcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(vstate-&gt;pagedelcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a> maintains the bulk delete stats on our behalf;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pages_newly_deleted and pages_deleted are likely to be incremented<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(blkno == scanblkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1802" title="access/nbtree/nbtpage.c:1802">_bt_pagedel</a>(rel, buf, vstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pagedel released buffer, so we shouldn't */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (backtrack_to != P_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = backtrack_to;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> backtrack;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1395" title="access/nbtree/nbtree.c:1395">btreevacuumposting</a> --- determine TIDs still needed in posting list<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns metadata describing how to build replacement tuple without the TIDs<br/></li>
<li></span><span class="Comment"> * that VACUUM needs to delete.&nbsp; Returned value is NULL in the common case<br/></li>
<li></span><span class="Comment"> * where no changes are needed to caller's posting list tuple (we avoid<br/></li>
<li></span><span class="Comment"> * allocating memory here as an optimization).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The number of TIDs that should remain in the posting list tuple is set for<br/></li>
<li></span><span class="Comment"> * caller in *nremaining.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> BTVacuumPosting<br/></li>
<li><a id="L1395">&#x200c;</a><span class="linkable">btreevacuumposting</span>(BTVacState *vstate, IndexTuple posting,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber updatedoffset, <span class="Type">int</span> *nremaining)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; live = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem = BTreeTupleGetNPosting(posting);<br/></li>
<li>&nbsp; &nbsp; ItemPointer items = BTreeTupleGetPosting(posting);<br/></li>
<li>&nbsp; &nbsp; BTVacuumPosting vacposting = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nitem; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!vstate-&gt;callback(items + i, vstate-&gt;callback_state))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Live table TID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; live++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (vacposting == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First dead table TID encountered.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> clear that we need to delete one or more dead table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TIDs, so start maintaining metadata describing how to update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * existing posting list tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(offsetof(BTVacuumPostingData, deletetids) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;itup = posting;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;updatedoffset = updatedoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;ndeletedtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;deletetids[vacposting-&gt;ndeletedtids++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Second or subsequent dead table TID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacposting-&gt;deletetids[vacposting-&gt;ndeletedtids++] = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *nremaining = live;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> vacposting;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1444" title="access/nbtree/nbtree.c:1444">btcanreturn</a>() -- Check whether btree indexes support index-only scans.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * btrees always do, so this is trivial.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1444">&#x200c;</a></span><span class="linkable">btcanreturn</span>(Relation index, <span class="Type">int</span> attno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
