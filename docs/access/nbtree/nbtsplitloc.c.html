<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtsplitloc.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtsplitloc.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L60">FindSplitData</a></li>
<li><a href="#L26">FindSplitStrat</a></li>
<li><a href="#L38">SplitPoint</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L749">_bt_adjacenthtid</a></li>
<li><a href="#L630">_bt_afternewitemoff</a></li>
<li><a href="#L788">_bt_bestsplitloc</a></li>
<li><a href="#L876">_bt_defaultinterval</a></li>
<li><a href="#L566">_bt_deltasortsplits</a></li>
<li><a href="#L129">_bt_findsplitloc</a></li>
<li><a href="#L1052">_bt_interval_edges</a></li>
<li><a href="#L449">_bt_recsplitloc</a></li>
<li><a href="#L1175">_bt_split_firstright</a></li>
<li><a href="#L1159">_bt_split_lastleft</a></li>
<li><a href="#L1131">_bt_split_penalty</a></li>
<li><a href="#L594">_bt_splitcmp</a></li>
<li><a href="#L934">_bt_strategy</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L850">INTERNAL_SPLIT_DISTANCE</a></li>
<li><a href="#L849">LEAF_SPLIT_DISTANCE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtsplitloc.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Choose split point code for Postgres btree implementation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtsplitloc.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* strategy for searching through materialized list of split points */<br/></li>
<li></span>&nbsp; &nbsp; SPLIT_DEFAULT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* give some weight to truncation */<br/></li>
<li></span>&nbsp; &nbsp; SPLIT_MANY_DUPLICATES,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> minimally distinguishing point */<br/></li>
<li></span>&nbsp; &nbsp; SPLIT_SINGLE_VALUE,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* leave left page almost full */<br/></li>
<li><a id="L26">&#x200c;</a></span>} <span class="linkable">FindSplitStrat</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* details of free space left by split */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; curdelta;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current leftfree/rightfree delta */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; leftfree;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space left on left page post-split */<br/></li>
<li></span>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; rightfree;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space left on right page post-split */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* split point identifying fields (returned by <a href="#L129" title="access/nbtree/nbtsplitloc.c:129">_bt_findsplitloc</a>) */<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber firstrightoff; <span class="Comment">/* first origpage item on rightpage */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newitemonleft;&nbsp; &nbsp; <span class="Comment">/* new item goes on left, or right? */<br/></li>
<li><a id="L38">&#x200c;</a></span>} <span class="linkable">SplitPoint</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* context data for <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a> */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index relation */<br/></li>
<li></span>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; origpage;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* page undergoing split */<br/></li>
<li></span>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; newitem;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* new item (cause of page split) */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; newitemsz;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* size of newitem (includes line pointer) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_leaf;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* T if splitting a leaf page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_rightmost;&nbsp; &nbsp; <span class="Comment">/* T if splitting rightmost page on level */<br/></li>
<li></span>&nbsp; &nbsp; OffsetNumber newitemoff;&nbsp; &nbsp; <span class="Comment">/* where the new item is to be inserted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftspace;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space available for items on left page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightspace;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* space available for items on right page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olddataitemstotal;&nbsp; &nbsp; <span class="Comment">/* space taken by old items */<br/></li>
<li></span>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; minfirstrightsz;&nbsp; &nbsp; <span class="Comment">/* smallest firstright size */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* candidate split point data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxsplits;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* maximum number of splits */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nsplits;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current number of splits */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *splits;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all candidate split points for page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; interval;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of acceptable split points */<br/></li>
<li><a id="L60">&#x200c;</a></span>} <span class="linkable">FindSplitData</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber firstrightoff, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newitemonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> olddataitemstoleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size firstrightofforigpagetuplesz);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L566" title="access/nbtree/nbtsplitloc.c:566">_bt_deltasortsplits</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <span class="Type">double</span> fillfactormult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> usemult);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L594" title="access/nbtree/nbtsplitloc.c:594">_bt_splitcmp</a>(<span class="Type">const</span> <span class="Type">void</span> *arg1, <span class="Type">const</span> <span class="Type">void</span> *arg2);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L630" title="access/nbtree/nbtsplitloc.c:630">_bt_afternewitemoff</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> leaffillfactor, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *usemult);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L749" title="access/nbtree/nbtsplitloc.c:749">_bt_adjacenthtid</a>(ItemPointer lowhtid, ItemPointer highhtid);<br/></li>
<li><span class="Type">static</span> OffsetNumber <a href="#L788" title="access/nbtree/nbtsplitloc.c:788">_bt_bestsplitloc</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <span class="Type">int</span> perfectpenalty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *newitemonleft, <a href="#L26" title="access/nbtree/nbtsplitloc.c:26">FindSplitStrat</a> strategy);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L876" title="access/nbtree/nbtsplitloc.c:876">_bt_defaultinterval</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L934" title="access/nbtree/nbtsplitloc.c:934">_bt_strategy</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *leftpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *rightpage, <a href="#L26" title="access/nbtree/nbtsplitloc.c:26">FindSplitStrat</a> *strategy);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1052" title="access/nbtree/nbtsplitloc.c:1052">_bt_interval_edges</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> **leftinterval, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> **rightinterval);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int</span> <a href="#L1131" title="access/nbtree/nbtsplitloc.c:1131">_bt_split_penalty</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> IndexTuple <a href="#L1159" title="access/nbtree/nbtsplitloc.c:1159">_bt_split_lastleft</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> IndexTuple <a href="#L1175" title="access/nbtree/nbtsplitloc.c:1175">_bt_split_firstright</a>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L129" title="access/nbtree/nbtsplitloc.c:129">_bt_findsplitloc</a>() -- <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an appropriate place to split a page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> goal here is to equalize the free space that will be on each<br/></li>
<li></span><span class="Comment"> * split page, *after accounting for the inserted tuple*.&nbsp; (If we fail to<br/></li>
<li></span><span class="Comment"> * account for it, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves with too little room on the page<br/></li>
<li></span><span class="Comment"> * that it needs to go into!)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the page is the rightmost page on its level, we instead try to arrange<br/></li>
<li></span><span class="Comment"> * to leave the left split page fillfactor% full.&nbsp; In this way, when we are<br/></li>
<li></span><span class="Comment"> * inserting successively increasing keys (consider sequences, timestamps,<br/></li>
<li></span><span class="Comment"> * etc) we will end up with a tree whose pages are about fillfactor% full,<br/></li>
<li></span><span class="Comment"> * instead of the 50% full result that we'd get without this special case.<br/></li>
<li></span><span class="Comment"> * This is the same as nbtsort.c produces for a newly-created tree.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that leaf and nonleaf pages use different fillfactors.&nbsp; Note also that<br/></li>
<li></span><span class="Comment"> * there are a number of further special cases where fillfactor is not<br/></li>
<li></span><span class="Comment"> * applied in the standard way.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We are passed the intended insert position of the new tuple, expressed as<br/></li>
<li></span><span class="Comment"> * the offsetnumber of the tuple it must go in front of (this could be<br/></li>
<li></span><span class="Comment"> * maxoff+1 if the tuple is to go at the end).&nbsp; The new tuple itself is also<br/></li>
<li></span><span class="Comment"> * passed, since it's needed to give some weight to how effective suffix<br/></li>
<li></span><span class="Comment"> * truncation will be.&nbsp; The implementation picks the split point that<br/></li>
<li></span><span class="Comment"> * maximizes the effectiveness of suffix truncation from a small list of<br/></li>
<li></span><span class="Comment"> * alternative candidate split points that leave each side of the split with<br/></li>
<li></span><span class="Comment"> * about the same share of free space.&nbsp; Suffix truncation is secondary to<br/></li>
<li></span><span class="Comment"> * equalizing free space, except in cases with large numbers of duplicates.<br/></li>
<li></span><span class="Comment"> * Note that it is always assumed that caller goes on to perform truncation,<br/></li>
<li></span><span class="Comment"> * even with pg_upgrade'd indexes where that isn't actually the case<br/></li>
<li></span><span class="Comment"> * (!heapkeyspace indexes).&nbsp; See nbtree/README for more information about<br/></li>
<li></span><span class="Comment"> * suffix truncation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return the index of the first existing tuple that should go on the<br/></li>
<li></span><span class="Comment"> * righthand page (which is called firstrightoff), plus a boolean<br/></li>
<li></span><span class="Comment"> * indicating whether the new tuple goes on the left or right page.&nbsp; You<br/></li>
<li></span><span class="Comment"> * can think of the returned state as a point _between_ two adjacent data<br/></li>
<li></span><span class="Comment"> * items (lastleft and firstright data items) on an imaginary version of<br/></li>
<li></span><span class="Comment"> * origpage that already includes newitem.&nbsp; The <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> is necessary to<br/></li>
<li></span><span class="Comment"> * disambiguate the case where firstrightoff == newitemoff (i.e. it is<br/></li>
<li></span><span class="Comment"> * sometimes needed to determine if the firstright tuple for the split is<br/></li>
<li></span><span class="Comment"> * newitem rather than the tuple from origpage at offset firstrightoff).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L129">&#x200c;</a><span class="linkable">_bt_findsplitloc</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Page origpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber newitemoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size newitemsz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexTuple newitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *newitemonleft)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightspace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olddataitemstotal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; olddataitemstoleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfectpenalty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaffillfactor;<br/></li>
<li>&nbsp; &nbsp; <a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> state;<br/></li>
<li>&nbsp; &nbsp; <a href="#L26" title="access/nbtree/nbtsplitloc.c:26">FindSplitStrat</a> strategy;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstrightoff;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; fillfactormult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; usemult;<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a>&nbsp; &nbsp; leftpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightpage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(origpage);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(origpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Total free space available on a btree page, after fixed overhead */<br/></li>
<li></span>&nbsp; &nbsp; leftspace = rightspace =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageGetPageSize(origpage) - SizeOfPageHeaderData -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPageOpaqueData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The right page will have the same high key as the old page */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(origpage, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightspace -= (<span class="Type">int</span>) (MAXALIGN(ItemIdGetLength(itemid)) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Count up total space in data items <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually scanning 'em */<br/></li>
<li></span>&nbsp; &nbsp; olddataitemstotal = rightspace - (<span class="Type">int</span>) <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(origpage);<br/></li>
<li>&nbsp; &nbsp; leaffillfactor = BTGetFillFactor(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Passed-in newitemsz is MAXALIGNED but does not include line pointer */<br/></li>
<li></span>&nbsp; &nbsp; newitemsz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; state.rel = rel;<br/></li>
<li>&nbsp; &nbsp; state.origpage = origpage;<br/></li>
<li>&nbsp; &nbsp; state.newitem = newitem;<br/></li>
<li>&nbsp; &nbsp; state.newitemsz = newitemsz;<br/></li>
<li>&nbsp; &nbsp; state.is_leaf = P_ISLEAF(opaque);<br/></li>
<li>&nbsp; &nbsp; state.is_rightmost = P_RIGHTMOST(opaque);<br/></li>
<li>&nbsp; &nbsp; state.leftspace = leftspace;<br/></li>
<li>&nbsp; &nbsp; state.rightspace = rightspace;<br/></li>
<li>&nbsp; &nbsp; state.olddataitemstotal = olddataitemstotal;<br/></li>
<li>&nbsp; &nbsp; state.minfirstrightsz = <span class="Constant">SIZE_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; state.newitemoff = newitemoff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* newitem cannot be a posting list item */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!BTreeTupleIsPosting(newitem));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nsplits should never exceed maxoff because there will be at most as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * many candidate split points as there are points _between_ tuples, once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you imagine that the new item is already on the original page (the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * final number of splits may be slightly <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> because not all points<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * between tuples will be legal).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state.maxsplits = maxoff;<br/></li>
<li>&nbsp; &nbsp; state.splits = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a>) * state.maxsplits);<br/></li>
<li>&nbsp; &nbsp; state.nsplits = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan through the data items and calculate space usage for a split at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each possible position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; olddataitemstoleft = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(origpage, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemsz = MAXALIGN(ItemIdGetLength(itemid)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When item offset number is not newitemoff, neither side of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split can be newitem.&nbsp; Record a split after the previous data item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from original page, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the current data item from original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page. (<a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>() will reject the split when there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous items, which we rely on.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &lt; newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>(&amp;state, offnum, <span class="Constant">false</span>, olddataitemstoleft, itemsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (offnum &gt; newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>(&amp;state, offnum, <span class="Constant">true</span>, olddataitemstoleft, itemsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Record a split after all &quot;offnum &lt; newitemoff&quot; original page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * data items, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> newitem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>(&amp;state, offnum, <span class="Constant">false</span>, olddataitemstoleft, itemsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Record a split after newitem, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> data item from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original page at offset newitemoff/current offset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>(&amp;state, offnum, <span class="Constant">true</span>, olddataitemstoleft, itemsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; olddataitemstoleft += itemsz;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record a split after all original page data items, but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> newitem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Though only when it's possible that newitem will end up alone on new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right page.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(olddataitemstoleft == olddataitemstotal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newitemoff &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L449" title="access/nbtree/nbtsplitloc.c:449">_bt_recsplitloc</a>(&amp;state, newitemoff, <span class="Constant">false</span>, olddataitemstotal, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * I believe it is not possible to fail to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a feasible split, but just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state.nsplits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a feasible split point for index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start search for a split point among list of legal split points.&nbsp; Give<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * primary consideration to equalizing available free space in each half<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the split initially (start with default strategy), while applying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rightmost and split-after-new-item optimizations where appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Either of the two other fallback strategies may be required for cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with a large number of duplicates around the original/space-optimal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Default strategy gives some weight to suffix truncation in deciding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split point on leaf pages.&nbsp; It attempts to <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a split point where a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distinguishing attribute appears earlier in the new high key for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * left side of the split, in order to maximize the number of trailing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attributes that can be truncated away.&nbsp; Only candidate split points<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that imply an acceptable balance of free space on each side are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered.&nbsp; See <a href="#L876" title="access/nbtree/nbtsplitloc.c:876">_bt_defaultinterval</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state.is_leaf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fillfactormult only used on rightmost page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; usemult = state.is_rightmost;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fillfactormult = BTREE_NONLEAF_FILLFACTOR / <span class="Constant">100.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state.is_rightmost)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rightmost leaf page --&nbsp; fillfactormult always used */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; usemult = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fillfactormult = leaffillfactor / <span class="Constant">100.0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L630" title="access/nbtree/nbtsplitloc.c:630">_bt_afternewitemoff</a>(&amp;state, maxoff, leaffillfactor, &amp;usemult))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * New item inserted at rightmost point among a localized grouping on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a leaf page -- apply &quot;split after new item&quot; optimization, either by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * applying leaf fillfactor multiplier, or by choosing the exact split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point that leaves newitem as lastleft. (usemult is set for us.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usemult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fillfactormult should be set based on leaf fillfactor */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fillfactormult = leaffillfactor / <span class="Constant">100.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> precise split point after newitemoff */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; state.nsplits; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split = state.splits + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (split-&gt;newitemonleft &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newitemoff == split-&gt;firstrightoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state.splits);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *newitemonleft = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> newitemoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Cannot legally split after newitemoff; proceed with split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * without using fillfactor multiplier.&nbsp; This is defensive, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never be needed in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fillfactormult = <span class="Constant">0.50</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Other leaf page.&nbsp; 50:50 page split. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; usemult = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fillfactormult not used, but be tidy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fillfactormult = <span class="Constant">0.50</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save leftmost and rightmost splits for page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> original ordinal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sort order is lost by delta/fillfactormult sort<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leftpage = state.splits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; rightpage = state.splits[state.nsplits - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Give split points a fillfactormult-wise delta, and sort on deltas */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L566" title="access/nbtree/nbtsplitloc.c:566">_bt_deltasortsplits</a>(&amp;state, fillfactormult, usemult);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine split interval for default strategy */<br/></li>
<li></span>&nbsp; &nbsp; state.interval = <a href="#L876" title="access/nbtree/nbtsplitloc.c:876">_bt_defaultinterval</a>(&amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine if default strategy/split interval will produce a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficiently distinguishing split, or if we should change strategies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Alternative strategies change the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of split points that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered acceptable (split interval), and possibly change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fillfactormult, in order to deal with pages with a large number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates gracefully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Pass low and high splits for the entire page (actually, they're for an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * imaginary version of the page that includes newitem).&nbsp; These are used<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the initial split interval encloses split points that are full of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates, and we need to consider if it's even possible to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appending a heap TID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perfectpenalty = <a href="#L934" title="access/nbtree/nbtsplitloc.c:934">_bt_strategy</a>(&amp;state, &amp;leftpage, &amp;rightpage, &amp;strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == SPLIT_DEFAULT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Default strategy worked out (always works out with <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Original split interval still stands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Many duplicates strategy is used when a heap TID would otherwise be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appended, but the page isn't completely full of logical duplicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The split interval is widened to include all legal candidate split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * points.&nbsp; There might be a few as two distinct <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the whole-page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split interval, though it's also possible that most of the <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the page are unique.&nbsp; The final split point will either be to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * immediate left or to the immediate right of the group of duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuples that enclose the first/delta-optimal split point (perfect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * penalty was set so that the lowest delta split point that avoids<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appending a heap TID will be chosen).&nbsp; Maximizing the number of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attributes that can be truncated away is not a goal of the many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates strategy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Single value strategy is used when it is impossible to avoid appending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a heap TID.&nbsp; It arranges to leave the left page very full.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maximizes space utilization in cases where tuples with the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> span many pages.&nbsp; Newly inserted duplicates will tend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to have higher heap TID <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, so we'll end up splitting to the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consistently.&nbsp; (Single value strategy is harmless though not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particularly useful with !heapkeyspace indexes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == SPLIT_MANY_DUPLICATES)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state.is_leaf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't try to truncate away extra user attributes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(perfectpenalty ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexRelationGetNumberOfKeyAttributes(state.rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No need to resort splits -- no change in fillfactormult/deltas */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state.interval = state.nsplits;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == SPLIT_SINGLE_VALUE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state.is_leaf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Split near the end of the page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; usemult = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fillfactormult = BTREE_SINGLEVAL_FILLFACTOR / <span class="Constant">100.0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Resort split points with new delta */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L566" title="access/nbtree/nbtsplitloc.c:566">_bt_deltasortsplits</a>(&amp;state, fillfactormult, usemult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Appending a heap TID is unavoidable, so interval of 1 is fine */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state.interval = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Search among acceptable split points (using final split interval) for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the entry that has the lowest penalty, and is therefore expected to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maximize fan-out.&nbsp; Sets *newitemonleft for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; firstrightoff = <a href="#L788" title="access/nbtree/nbtsplitloc.c:788">_bt_bestsplitloc</a>(&amp;state, perfectpenalty, newitemonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strategy);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state.splits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> firstrightoff;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to record a particular point between two tuples (possibly the<br/></li>
<li></span><span class="Comment"> * new item) on page (ie, combination of firstrightoff and newitemonleft<br/></li>
<li></span><span class="Comment"> * settings) in *state for later analysis.&nbsp; This is also a convenient point to<br/></li>
<li></span><span class="Comment"> * check if the split is legal (if it isn't, it won't be recorded).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * firstrightoff is the offset of the first item on the original page that<br/></li>
<li></span><span class="Comment"> * goes to the right page, and firstrightofforigpagetuplesz is the size of<br/></li>
<li></span><span class="Comment"> * that tuple.&nbsp; firstrightoff can be &gt; max offset, which means that all the<br/></li>
<li></span><span class="Comment"> * old items go to the left page and only the new item goes to the right page.<br/></li>
<li></span><span class="Comment"> * We don't actually use firstrightofforigpagetuplesz in that case (actually,<br/></li>
<li></span><span class="Comment"> * we don't use it for _any_ split where the firstright tuple happens to be<br/></li>
<li></span><span class="Comment"> * newitem).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * olddataitemstoleft is the total size of all old items to the left of the<br/></li>
<li></span><span class="Comment"> * split point that is recorded here when legal.&nbsp; Should not include<br/></li>
<li></span><span class="Comment"> * newitemsz, since that is handled here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L449">&#x200c;</a></span><span class="linkable">_bt_recsplitloc</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber firstrightoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> newitemonleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> olddataitemstoleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Size firstrightofforigpagetuplesz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; leftfree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightfree;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; firstrightsz;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; postingsz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; newitemisfirstright;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is the new item going to be split point's firstright tuple? */<br/></li>
<li></span>&nbsp; &nbsp; newitemisfirstright = (firstrightoff == state-&gt;newitemoff &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !newitemonleft);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (newitemisfirstright)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstrightsz = state-&gt;newitemsz;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; firstrightsz = firstrightofforigpagetuplesz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate suffix truncation space saving when firstright tuple is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * posting list tuple, though only when the tuple is over 64 bytes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * including line pointer overhead (arbitrary).&nbsp; This avoids accessing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuple in cases where its posting list must be very small (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple has one at all).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: We don't do this in the case where firstright tuple is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * newitem, since newitem cannot have a posting list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;is_leaf &amp;&amp; firstrightsz &gt; <span class="Constant">64</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; newhighkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage, firstrightoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newhighkey = (IndexTuple) PageGetItem(state-&gt;origpage, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(newhighkey))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postingsz = IndexTupleSize(newhighkey) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetPostingOffset(newhighkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Account for all the old tuples */<br/></li>
<li></span>&nbsp; &nbsp; leftfree = state-&gt;leftspace - olddataitemstoleft;<br/></li>
<li>&nbsp; &nbsp; rightfree = state-&gt;rightspace -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (state-&gt;olddataitemstotal - olddataitemstoleft);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The first item on the right page becomes the high key of the left page;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * therefore it counts against left space as well as right space (we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot assume that suffix truncation will make it <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> smaller).&nbsp; When<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index has included attributes, then those attributes of left page high<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key will be truncated leaving that page with slightly more free space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, that shouldn't affect our ability to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> valid split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * location, since we err in the direction of being pessimistic about free<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * space on the left half.&nbsp; Besides, even when suffix truncation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-TID attributes occurs, the new high key often won't even be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single MAXALIGN() quantum smaller than the firstright tuple it's based<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are on the leaf level, assume that suffix truncation cannot avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding a heap TID to the left half's new high key when splitting at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leaf level.&nbsp; In practice the new high key will often be smaller and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will rarely be larger, but conservatively assume the worst case.&nbsp; We do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * go to the trouble of subtracting away posting list overhead, though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only when it looks like it will make an appreciable difference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Posting lists are the only case where truncation will typically make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the final high key far smaller than firstright, so being a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * precise there noticeably improves the balance of free space.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;is_leaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftfree -= (int16) (firstrightsz +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData)) -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; postingsz);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leftfree -= (int16) firstrightsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* account for the new item */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (newitemonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftfree -= (int16) state-&gt;newitemsz;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rightfree -= (int16) state-&gt;newitemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are not on the leaf level, we will be able to discard the key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data from the first item that winds up on the right page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;is_leaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightfree += (int16) firstrightsz -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (int16) (MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Record split if legal */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leftfree &gt;= <span class="Constant">0</span> &amp;&amp; rightfree &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(state-&gt;nsplits &lt; state-&gt;maxsplits);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine smallest firstright tuple size among legal splits */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;minfirstrightsz = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(state-&gt;minfirstrightsz, firstrightsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;splits[state-&gt;nsplits].curdelta = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;splits[state-&gt;nsplits].leftfree = leftfree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;splits[state-&gt;nsplits].rightfree = rightfree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;splits[state-&gt;nsplits].firstrightoff = firstrightoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;splits[state-&gt;nsplits].newitemonleft = newitemonleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nsplits++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to assign space deltas to materialized array of candidate split<br/></li>
<li></span><span class="Comment"> * points based on current fillfactor, and to sort array using that fillfactor<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L566">&#x200c;</a></span><span class="linkable">_bt_deltasortsplits</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <span class="Type">double</span> fillfactormult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> usemult)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; state-&gt;nsplits; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split = state-&gt;splits + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (usemult)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta = fillfactormult * split-&gt;leftfree -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Constant">1.0</span> - fillfactormult) * split-&gt;rightfree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta = split-&gt;leftfree - split-&gt;rightfree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delta &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delta = -delta;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save delta */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; split-&gt;curdelta = delta;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qsort(state-&gt;splits, state-&gt;nsplits, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a>), <a href="#L594" title="access/nbtree/nbtsplitloc.c:594">_bt_splitcmp</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * qsort-style comparator used by <a href="#L566" title="access/nbtree/nbtsplitloc.c:566">_bt_deltasortsplits</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L594">&#x200c;</a></span><span class="linkable">_bt_splitcmp</span>(<span class="Type">const</span> <span class="Type">void</span> *arg1, <span class="Type">const</span> <span class="Type">void</span> *arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split1 = (<a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *) arg1;<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split2 = (<a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *) arg2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_s16(split1-&gt;curdelta, split2-&gt;curdelta);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to determine whether or not a non-rightmost leaf page should be<br/></li>
<li></span><span class="Comment"> * split immediately after the would-be original page offset for the<br/></li>
<li></span><span class="Comment"> * new/incoming tuple (or should have leaf fillfactor applied when new item is<br/></li>
<li></span><span class="Comment"> * to the right on original page).&nbsp; This is appropriate when there is a<br/></li>
<li></span><span class="Comment"> * pattern of localized monotonically increasing insertions into a composite<br/></li>
<li></span><span class="Comment"> * index, where leading attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> form local groupings, and we<br/></li>
<li></span><span class="Comment"> * anticipate further insertions of the same/current grouping (new item's<br/></li>
<li></span><span class="Comment"> * grouping) in the near future.&nbsp; This can be thought of as a variation on<br/></li>
<li></span><span class="Comment"> * applying leaf fillfactor during rightmost leaf page splits, since cases<br/></li>
<li></span><span class="Comment"> * that benefit will converge on packing leaf pages leaffillfactor% full over<br/></li>
<li></span><span class="Comment"> * time.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We may leave extra free space remaining on the rightmost page of a &quot;most<br/></li>
<li></span><span class="Comment"> * significant column&quot; grouping of tuples if that grouping never ends up<br/></li>
<li></span><span class="Comment"> * having future insertions that use the free space.&nbsp; That effect is<br/></li>
<li></span><span class="Comment"> * self-limiting; a future grouping that becomes the &quot;nearest on the right&quot;<br/></li>
<li></span><span class="Comment"> * grouping of the affected grouping usually puts the extra free space to good<br/></li>
<li></span><span class="Comment"> * use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller uses optimization when routine returns true, though the exact action<br/></li>
<li></span><span class="Comment"> * taken by caller varies.&nbsp; Caller uses original leaf page fillfactor in<br/></li>
<li></span><span class="Comment"> * standard way rather than using the new item offset directly when *usemult<br/></li>
<li></span><span class="Comment"> * was also set to true here.&nbsp; Otherwise, caller applies optimization by<br/></li>
<li></span><span class="Comment"> * locating the legal split point that makes the new tuple the lastleft tuple<br/></li>
<li></span><span class="Comment"> * for the split.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L630">&#x200c;</a></span><span class="linkable">_bt_afternewitemoff</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, OffsetNumber maxoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> leaffillfactor, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *usemult)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; nkeyatts;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keepnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;is_leaf &amp;&amp; !state-&gt;is_rightmost);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(state-&gt;rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Single key indexes not considered here */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nkeyatts == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ascending insertion pattern never inferred when new item is first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;newitemoff == P_FIRSTKEY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Only apply optimization on pages with equisized tuples, since ordinal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys are likely to be fixed-width.&nbsp; Testing if the new tuple is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable width directly might also work, but that fails to apply the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization to indexes with a numeric_ops attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Conclude that page has equisized tuples when the new item is the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * width as the smallest item observed during pass over page, and other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-pivot tuples must be the same width as well.&nbsp; (Note that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly-truncated existing high key isn't counted in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * olddataitemstotal, and must be subtracted from maxoff.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;newitemsz != state-&gt;minfirstrightsz)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;newitemsz * (maxoff - <span class="Constant">1</span>) != state-&gt;olddataitemstotal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid applying optimization when tuples are wider than a tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consisting of two non-NULL int8/int64 attributes (or four non-NULL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * int4/int32 attributes)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;newitemsz &gt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(IndexTupleData) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64) * <span class="Constant">2</span>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At least the first attribute's value must be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the corresponding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value in previous tuple to apply optimization.&nbsp; New item cannot be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Handle case where new item is to the right of all items on the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page.&nbsp; This is suggestive of monotonically increasing insertions in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself, so the &quot;heap TID adjacency&quot; test is not applied here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;newitemoff &gt; maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage, maxoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = (IndexTuple) PageGetItem(state-&gt;origpage, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keepnatts = <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(state-&gt;rel, tup, state-&gt;newitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keepnatts &gt; <span class="Constant">1</span> &amp;&amp; keepnatts &lt;= nkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *usemult = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;Low cardinality leading column, high cardinality suffix column&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes with a random insertion pattern (e.g., an index with a boolean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column, such as an index on '(book_is_in_print, book_isbn)') present us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with a risk of consistently misapplying the optimization.&nbsp; We're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * willing to <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> very occasional misapplication of the optimization,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * provided the cases where we get it wrong are rare and self-limiting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Heap TID adjacency strongly suggests that the item just to the left was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inserted very recently, which limits overapplication of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization.&nbsp; Besides, all inappropriate cases triggered here will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still split in the middle of the page on average.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage, OffsetNumberPrev(state-&gt;newitemoff));<br/></li>
<li>&nbsp; &nbsp; tup = (IndexTuple) PageGetItem(state-&gt;origpage, itemid);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do cheaper test first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(tup) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L749" title="access/nbtree/nbtsplitloc.c:749">_bt_adjacenthtid</a>(&amp;tup-&gt;t_tid, &amp;state-&gt;newitem-&gt;t_tid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check same conditions as rightmost item case, too */<br/></li>
<li></span>&nbsp; &nbsp; keepnatts = <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(state-&gt;rel, tup, state-&gt;newitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (keepnatts &gt; <span class="Constant">1</span> &amp;&amp; keepnatts &lt;= nkeyatts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; interp = (<span class="Type">double</span>) state-&gt;newitemoff / ((<span class="Type">double</span>) maxoff + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; leaffillfactormult = (<span class="Type">double</span>) leaffillfactor / <span class="Constant">100.0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't allow caller to split after a new item when it will result in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a split point to the right of the point that a leaf fillfactor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * split would use -- have caller apply leaf fillfactor instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *usemult = interp &gt; leaffillfactormult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine for determining if two heap TIDS are &quot;adjacent&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Adjacent means that the high TID is very likely to have been inserted into<br/></li>
<li></span><span class="Comment"> * heap relation immediately after the low TID, probably during the current<br/></li>
<li></span><span class="Comment"> * transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L749">&#x200c;</a></span><span class="linkable">_bt_adjacenthtid</span>(ItemPointer lowhtid, ItemPointer highhtid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber lowblk,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highblk;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lowblk = ItemPointerGetBlockNumber(lowhtid);<br/></li>
<li>&nbsp; &nbsp; highblk = ItemPointerGetBlockNumber(highhtid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make optimistic assumption of adjacency when heap blocks match */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lowblk == highblk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When heap block one up, second offset should be FirstOffsetNumber */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lowblk + <span class="Constant">1</span> == highblk &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerGetOffsetNumber(highhtid) == FirstOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the &quot;best&quot; split point among candidate split points.<br/></li>
<li></span><span class="Comment"> * The best split point is the split point with the lowest penalty among split<br/></li>
<li></span><span class="Comment"> * points that fall within current/final split interval.&nbsp; Penalty is an<br/></li>
<li></span><span class="Comment"> * abstract score, with a definition that varies depending on whether we're<br/></li>
<li></span><span class="Comment"> * splitting a leaf page or an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page.&nbsp; See <a href="#L1131" title="access/nbtree/nbtsplitloc.c:1131">_bt_split_penalty</a>() for<br/></li>
<li></span><span class="Comment"> * details.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;perfectpenalty&quot; is assumed to be the lowest possible penalty among<br/></li>
<li></span><span class="Comment"> * candidate split points.&nbsp; This allows us to return early without wasting<br/></li>
<li></span><span class="Comment"> * cycles on calculating the first differing attribute for all candidate<br/></li>
<li></span><span class="Comment"> * splits when that clearly cannot improve our choice (or when we only want a<br/></li>
<li></span><span class="Comment"> * minimally distinguishing split point, and don't want to make the split <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * more unbalanced than is necessary).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We return the index of the first existing tuple that should go on the right<br/></li>
<li></span><span class="Comment"> * page, plus a boolean indicating if new item is on left of split point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> OffsetNumber<br/></li>
<li><a id="L788">&#x200c;</a><span class="linkable">_bt_bestsplitloc</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <span class="Type">int</span> perfectpenalty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *newitemonleft, <a href="#L26" title="access/nbtree/nbtsplitloc.c:26">FindSplitStrat</a> strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestpenalty,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowsplit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highsplit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(state-&gt;interval, state-&gt;nsplits);<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *final;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bestpenalty = <span class="Constant">INT_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; lowsplit = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = lowsplit; i &lt; highsplit; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; penalty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; penalty = <a href="#L1131" title="access/nbtree/nbtsplitloc.c:1131">_bt_split_penalty</a>(state, state-&gt;splits + i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (penalty &lt; bestpenalty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestpenalty = penalty;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowsplit = i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (penalty &lt;= perfectpenalty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; final = &amp;state-&gt;splits[lowsplit];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is a risk that the &quot;many duplicates&quot; strategy will repeatedly do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the wrong thing when there are monotonically decreasing insertions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the right of a large group of duplicates.&nbsp;&nbsp; Repeated splits could leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a succession of right half pages with free space that can never be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used.&nbsp; This must be avoided.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider the example of the leftmost page in a single integer attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULLS FIRST index which is almost filled with NULLs.&nbsp; Monotonically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decreasing integer insertions might cause the same leftmost page to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * split repeatedly at the same point.&nbsp; Each split derives its new high<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key from the lowest current value to the immediate right of the large<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * group of NULLs, which will always be higher than all future integer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insertions, directing all future integer insertions to the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leftmost page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == SPLIT_MANY_DUPLICATES &amp;&amp; !state-&gt;is_rightmost &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !final-&gt;newitemonleft &amp;&amp; final-&gt;firstrightoff &gt;= state-&gt;newitemoff &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; final-&gt;firstrightoff &lt; state-&gt;newitemoff + <span class="Constant">9</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid the problem by performing a 50:50 split when the new item is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just to the right of the would-be &quot;many duplicates&quot; split point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Note that the test used for an insert that is &quot;just to the right&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the split point is conservative.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; final = &amp;state-&gt;splits[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *newitemonleft = final-&gt;newitemonleft;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> final-&gt;firstrightoff;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><a id="L849">&#x200c;</a><span class="PreProc">#define <span class="linkable">LEAF_SPLIT_DISTANCE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0.050<br/></li>
<li><a id="L850">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">INTERNAL_SPLIT_DISTANCE</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0.075<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a split interval to use for the default strategy.&nbsp; This is a limit<br/></li>
<li></span><span class="Comment"> * on the number of candidate split points to give further consideration to.<br/></li>
<li></span><span class="Comment"> * Only a fraction of all candidate splits points (those located at the start<br/></li>
<li></span><span class="Comment"> * of the <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-sorted splits array) fall within the split interval.&nbsp; Split<br/></li>
<li></span><span class="Comment"> * interval is applied within <a href="#L788" title="access/nbtree/nbtsplitloc.c:788">_bt_bestsplitloc</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Split interval represents an acceptable <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of split points -- those that<br/></li>
<li></span><span class="Comment"> * have leftfree and rightfree <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are acceptably balanced.&nbsp; The final<br/></li>
<li></span><span class="Comment"> * split point chosen is the split point with the lowest &quot;penalty&quot; among split<br/></li>
<li></span><span class="Comment"> * points in this split interval (unless we change our entire strategy, in<br/></li>
<li></span><span class="Comment"> * which case the interval also changes -- see <a href="#L934" title="access/nbtree/nbtsplitloc.c:934">_bt_strategy</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;Prefix B-Trees&quot; paper calls split interval sigma l for leaf splits,<br/></li>
<li></span><span class="Comment"> * and sigma b for <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> (&quot;branch&quot;) splits.&nbsp; It's hard to provide a<br/></li>
<li></span><span class="Comment"> * theoretical justification for the size of the split interval, though it's<br/></li>
<li></span><span class="Comment"> * clear that a small split interval can make tuples on level L+1 much smaller<br/></li>
<li></span><span class="Comment"> * on average, without noticeably affecting space utilization on level L.<br/></li>
<li></span><span class="Comment"> * (Note that the way that we calculate split interval might need to change if<br/></li>
<li></span><span class="Comment"> * suffix truncation is taught to truncate tuples &quot;within&quot; the last<br/></li>
<li></span><span class="Comment"> * attribute/datum for data types like text, which is more or less how it is<br/></li>
<li></span><span class="Comment"> * assumed to work in the paper.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L876">&#x200c;</a></span><span class="linkable">_bt_defaultinterval</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *spaceoptimal;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; tolerance,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowleftfree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lowrightfree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highleftfree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highrightfree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine leftfree and rightfree <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that are higher and <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're willing to tolerate.&nbsp; Note that the final split interval will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about 10% of nsplits in the common case where all non-pivot tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (data items) from a leaf page are uniformly sized.&nbsp; We're a <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aggressive when splitting <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;is_leaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tolerance = state-&gt;olddataitemstotal * <a href="#L849" title="access/nbtree/nbtsplitloc.c:849">LEAF_SPLIT_DISTANCE</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tolerance = state-&gt;olddataitemstotal * <a href="#L850" title="access/nbtree/nbtsplitloc.c:850">INTERNAL_SPLIT_DISTANCE</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First candidate split point is the most evenly balanced */<br/></li>
<li></span>&nbsp; &nbsp; spaceoptimal = state-&gt;splits;<br/></li>
<li>&nbsp; &nbsp; lowleftfree = spaceoptimal-&gt;leftfree - tolerance;<br/></li>
<li>&nbsp; &nbsp; lowrightfree = spaceoptimal-&gt;rightfree - tolerance;<br/></li>
<li>&nbsp; &nbsp; highleftfree = spaceoptimal-&gt;leftfree + tolerance;<br/></li>
<li>&nbsp; &nbsp; highrightfree = spaceoptimal-&gt;rightfree + tolerance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through split points, starting from the split immediately after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'spaceoptimal'.&nbsp; Find the first split point that divides free space so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unevenly that including it in the split interval would be unacceptable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; state-&gt;nsplits; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split = state-&gt;splits + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Cannot use curdelta here, since its value is often weighted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (split-&gt;leftfree &lt; lowleftfree || split-&gt;rightfree &lt; lowrightfree ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split-&gt;leftfree &gt; highleftfree || split-&gt;rightfree &gt; highrightfree)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> i;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> state-&gt;nsplits;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to decide whether split should use default strategy/initial<br/></li>
<li></span><span class="Comment"> * split interval, or whether it should finish splitting the page using<br/></li>
<li></span><span class="Comment"> * alternative strategies (this is only possible with leaf pages).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller uses alternative strategy (or sticks with default strategy) based<br/></li>
<li></span><span class="Comment"> * on how *strategy is set here.&nbsp; Return value is &quot;perfect penalty&quot;, which is<br/></li>
<li></span><span class="Comment"> * passed to <a href="#L788" title="access/nbtree/nbtsplitloc.c:788">_bt_bestsplitloc</a>() as a final constraint on how far caller is<br/></li>
<li></span><span class="Comment"> * willing to go to avoid appending a heap TID when using the many duplicates<br/></li>
<li></span><span class="Comment"> * strategy (it also saves <a href="#L788" title="access/nbtree/nbtsplitloc.c:788">_bt_bestsplitloc</a>() useless cycles).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">_bt_strategy</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *leftpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *rightpage, <a href="#L26" title="access/nbtree/nbtsplitloc.c:26">FindSplitStrat</a> *strategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; leftmost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightmost;<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *leftinterval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rightinterval;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perfectpenalty;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnkeyatts = IndexRelationGetNumberOfKeyAttributes(state-&gt;rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Assume that alternative strategy won't be used for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; *strategy = SPLIT_DEFAULT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use smallest observed firstright item size for entire page (actually,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entire imaginary version of page that includes newitem) as perfect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * penalty on <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages.&nbsp; This can save cycles in the common case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where most or all splits (not just splits within interval) have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * firstright tuples that are the same size.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;is_leaf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;minfirstrightsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use leftmost and rightmost tuples from leftmost and rightmost splits in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current split interval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1052" title="access/nbtree/nbtsplitloc.c:1052">_bt_interval_edges</a>(state, &amp;leftinterval, &amp;rightinterval);<br/></li>
<li>&nbsp; &nbsp; leftmost = <a href="#L1159" title="access/nbtree/nbtsplitloc.c:1159">_bt_split_lastleft</a>(state, leftinterval);<br/></li>
<li>&nbsp; &nbsp; rightmost = <a href="#L1175" title="access/nbtree/nbtsplitloc.c:1175">_bt_split_firstright</a>(state, rightinterval);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If initial split interval can produce a split point that will at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid appending a heap TID in new high key, we're done.&nbsp; Finish split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with default strategy and initial split interval.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perfectpenalty = <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(state-&gt;rel, leftmost, rightmost);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (perfectpenalty &lt;= indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> perfectpenalty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Work out how caller should finish split when even their &quot;perfect&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * penalty for initial/default split interval indicates that the interval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does not contain even a single split that avoids appending a heap TID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the leftmost split's lastleft tuple and the rightmost split's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * firstright tuple to assess every possible split.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leftmost = <a href="#L1159" title="access/nbtree/nbtsplitloc.c:1159">_bt_split_lastleft</a>(state, leftpage);<br/></li>
<li>&nbsp; &nbsp; rightmost = <a href="#L1175" title="access/nbtree/nbtsplitloc.c:1175">_bt_split_firstright</a>(state, rightpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If page (including new item) has many duplicates but is not entirely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * full of duplicates, a many duplicates strategy split will be performed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If page is entirely full of duplicates, a single value strategy split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be performed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perfectpenalty = <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(state-&gt;rel, leftmost, rightmost);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (perfectpenalty &lt;= indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *strategy = SPLIT_MANY_DUPLICATES;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Many duplicates strategy should split at either side the group of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicates that enclose the delta-optimal split point.&nbsp; Return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indnkeyatts rather than the true perfect penalty to make that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen.&nbsp; (If perfectpenalty was returned here then low cardinality<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * composite indexes could have continual unbalanced splits.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that caller won't go through with a many duplicates split in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rare cases where it looks like there are ever-decreasing insertions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the immediate right of the split point.&nbsp; This must happen just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> a final decision is made, within <a href="#L788" title="access/nbtree/nbtsplitloc.c:788">_bt_bestsplitloc</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> indnkeyatts;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Single value strategy is only appropriate with ever-increasing heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TIDs; otherwise, original default strategy split should proceed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid pathological performance.&nbsp; Use page high key to infer if this is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rightmost page among pages that store the same duplicate value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This should not prevent insertions of heap TIDs that are slightly out<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of order from using single value strategy, since that's expected with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent inserters of the same duplicate value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;is_rightmost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *strategy = SPLIT_SINGLE_VALUE;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; hikey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hikey = (IndexTuple) PageGetItem(state-&gt;origpage, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perfectpenalty = <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(state-&gt;rel, hikey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state-&gt;newitem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (perfectpenalty &lt;= indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *strategy = SPLIT_SINGLE_VALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have caller finish split using default strategy, since page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not appear to be the rightmost page for duplicates of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * value the page is filled with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> perfectpenalty;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to locate leftmost and rightmost splits for current/default<br/></li>
<li></span><span class="Comment"> * split interval.&nbsp; Note that it will be the same split iff there is only one<br/></li>
<li></span><span class="Comment"> * split in interval.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1052">&#x200c;</a></span><span class="linkable">_bt_interval_edges</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> **leftinterval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> **rightinterval)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; highsplit = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(state-&gt;interval, state-&gt;nsplits);<br/></li>
<li>&nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *deltaoptimal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; deltaoptimal = state-&gt;splits;<br/></li>
<li>&nbsp; &nbsp; *leftinterval = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; *rightinterval = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Delta is an absolute distance to optimal split point, so both the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leftmost and rightmost split point will usually be at the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = highsplit - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *distant = state-&gt;splits + i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (distant-&gt;firstrightoff &lt; deltaoptimal-&gt;firstrightoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*leftinterval == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *leftinterval = distant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (distant-&gt;firstrightoff &gt; deltaoptimal-&gt;firstrightoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*rightinterval == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rightinterval = distant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!distant-&gt;newitemonleft &amp;&amp; deltaoptimal-&gt;newitemonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;incoming tuple will become firstright&quot; (distant) is to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left of &quot;incoming tuple will become lastleft&quot; (delta-optimal)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(distant-&gt;firstrightoff == state-&gt;newitemoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*leftinterval == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *leftinterval = distant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (distant-&gt;newitemonleft &amp;&amp; !deltaoptimal-&gt;newitemonleft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;incoming tuple will become lastleft&quot; (distant) is to the right<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of &quot;incoming tuple will become firstright&quot; (delta-optimal)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(distant-&gt;firstrightoff == state-&gt;newitemoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*rightinterval == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rightinterval = distant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There was only one or two splits in initial split interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(distant == deltaoptimal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*leftinterval == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *leftinterval = distant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*rightinterval == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rightinterval = distant;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*leftinterval &amp;&amp; *rightinterval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> penalty for caller's candidate split point.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On leaf pages, penalty is the attribute number that distinguishes each side<br/></li>
<li></span><span class="Comment"> * of a split.&nbsp; It's the last attribute that needs to be included in new high<br/></li>
<li></span><span class="Comment"> * key for left page.&nbsp; It can be greater than the number of key attributes in<br/></li>
<li></span><span class="Comment"> * cases where a heap TID will need to be appended during truncation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages, penalty is simply the size of the firstright tuple for<br/></li>
<li></span><span class="Comment"> * the split (including line pointer overhead).&nbsp; This tuple will become the<br/></li>
<li></span><span class="Comment"> * new high key for the left page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">int<br/></li>
<li><a id="L1131">&#x200c;</a></span><span class="linkable">_bt_split_penalty</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; lastleft;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; firstright;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!state-&gt;is_leaf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!split-&gt;newitemonleft &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; split-&gt;firstrightoff == state-&gt;newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;newitemsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage, split-&gt;firstrightoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> MAXALIGN(ItemIdGetLength(itemid)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lastleft = <a href="#L1159" title="access/nbtree/nbtsplitloc.c:1159">_bt_split_lastleft</a>(state, split);<br/></li>
<li>&nbsp; &nbsp; firstright = <a href="#L1175" title="access/nbtree/nbtsplitloc.c:1175">_bt_split_firstright</a>(state, split);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(state-&gt;rel, lastleft, firstright);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to get a lastleft IndexTuple for a split point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> IndexTuple<br/></li>
<li><a id="L1159">&#x200c;</a><span class="linkable">_bt_split_lastleft</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (split-&gt;newitemonleft &amp;&amp; split-&gt;firstrightoff == state-&gt;newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;newitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumberPrev(split-&gt;firstrightoff));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (IndexTuple) PageGetItem(state-&gt;origpage, itemid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to get a firstright IndexTuple for a split point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> IndexTuple<br/></li>
<li><a id="L1175">&#x200c;</a><span class="linkable">_bt_split_firstright</span>(<a href="#L60" title="access/nbtree/nbtsplitloc.c:60">FindSplitData</a> *state, <a href="#L38" title="access/nbtree/nbtsplitloc.c:38">SplitPoint</a> *split)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!split-&gt;newitemonleft &amp;&amp; split-&gt;firstrightoff == state-&gt;newitemoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> state-&gt;newitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemid = PageGetItemId(state-&gt;origpage, split-&gt;firstrightoff);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (IndexTuple) PageGetItem(state-&gt;origpage, itemid);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
