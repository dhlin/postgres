<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtsearch.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtsearch.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L337">_bt_binsrch</a></li>
<li><a href="#L468">_bt_binsrch_insert</a></li>
<li><a href="#L596">_bt_binsrch_posting</a></li>
<li><a href="#L682">_bt_compare</a></li>
<li><a href="#L61">_bt_drop_lock_and_maybe_pin</a></li>
<li><a href="#L2560">_bt_endpoint</a></li>
<li><a href="#L876">_bt_first</a></li>
<li><a href="#L2479">_bt_get_endpoint</a></li>
<li><a href="#L2650">_bt_initialize_more_data</a></li>
<li><a href="#L235">_bt_moveright</a></li>
<li><a href="#L1492">_bt_next</a></li>
<li><a href="#L2334">_bt_parallel_readpage</a></li>
<li><a href="#L2168">_bt_readnextpage</a></li>
<li><a href="#L1556">_bt_readpage</a></li>
<li><a href="#L1940">_bt_saveitem</a></li>
<li><a href="#L2008">_bt_savepostingitem</a></li>
<li><a href="#L96">_bt_search</a></li>
<li><a href="#L1970">_bt_setuppostingitems</a></li>
<li><a href="#L2036">_bt_steppage</a></li>
<li><a href="#L2365">_bt_walk_left</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtsearch.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Search code for postgres btrees.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtsearch.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L61" title="access/nbtree/nbtsearch.c:61">_bt_drop_lock_and_maybe_pin</a>(IndexScanDesc scan, BTScanPos sp);<br/></li>
<li><span class="Type">static</span> OffsetNumber <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>(Relation rel, BTScanInsert key, Buffer buf);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L596" title="access/nbtree/nbtsearch.c:596">_bt_binsrch_posting</a>(BTScanInsert key, Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>(IndexScanDesc scan, ScanDirection dir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> firstPage);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1940" title="access/nbtree/nbtsearch.c:1940">_bt_saveitem</a>(BTScanOpaque so, <span class="Type">int</span> itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, IndexTuple itup);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1970" title="access/nbtree/nbtsearch.c:1970">_bt_setuppostingitems</a>(BTScanOpaque so, <span class="Type">int</span> itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum, ItemPointer heapTid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple itup);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L2008" title="access/nbtree/nbtsearch.c:2008">_bt_savepostingitem</a>(BTScanOpaque so, <span class="Type">int</span> itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointer heapTid, <span class="Type">int</span> tupleOffset);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a>(IndexScanDesc scan, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2168" title="access/nbtree/nbtsearch.c:2168">_bt_readnextpage</a>(IndexScanDesc scan, BlockNumber blkno, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2334" title="access/nbtree/nbtsearch.c:2334">_bt_parallel_readpage</a>(IndexScanDesc scan, BlockNumber blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanDirection dir);<br/></li>
<li><span class="Type">static</span> Buffer <a href="#L2365" title="access/nbtree/nbtsearch.c:2365">_bt_walk_left</a>(Relation rel, Buffer buf);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2560" title="access/nbtree/nbtsearch.c:2560">_bt_endpoint</a>(IndexScanDesc scan, ScanDirection dir);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L2650" title="access/nbtree/nbtsearch.c:2650">_bt_initialize_more_data</a>(BTScanOpaque so, ScanDirection dir);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L61" title="access/nbtree/nbtsearch.c:61">_bt_drop_lock_and_maybe_pin</a>()<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlock the buffer; and if it is safe to release the pin, do that, too.<br/></li>
<li></span><span class="Comment"> * This will prevent <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> from stalling in a blocked state trying to read a<br/></li>
<li></span><span class="Comment"> * page when a cursor is sitting on it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See nbtree/README section on making concurrent TID recycling safe.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="linkable">_bt_drop_lock_and_maybe_pin</span>(IndexScanDesc scan, BTScanPos sp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="nbtpage.c.html#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(scan-&gt;indexRelation, sp-&gt;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsMVCCSnapshot(scan-&gt;xs_snapshot) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelationNeedsWAL(scan-&gt;indexRelation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !scan-&gt;xs_want_itup)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4850" title="storage/buffer/bufmgr.c:4850">ReleaseBuffer</a>(sp-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sp-&gt;buf = InvalidBuffer;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>() -- Search the tree for a particular scankey,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or more precisely for the first leaf page it could be on.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed scankey is an insertion-type scankey (see nbtree/README),<br/></li>
<li></span><span class="Comment"> * but it can omit the rightmost column(s) of the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is a stack of parent-page pointers (i.e. there is no entry for<br/></li>
<li></span><span class="Comment"> * the leaf level/page).&nbsp; *bufP is set to the address of the leaf-page buffer,<br/></li>
<li></span><span class="Comment"> * which is locked and pinned.&nbsp; No locks are held on the parent pages,<br/></li>
<li></span><span class="Comment"> * however!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned buffer is locked according to access parameter.&nbsp; Additionally,<br/></li>
<li></span><span class="Comment"> * access = BT_WRITE will allow an empty root page to be created and returned.<br/></li>
<li></span><span class="Comment"> * When access = BT_READ, an empty index will result in *bufP being set to<br/></li>
<li></span><span class="Comment"> * InvalidBuffer.&nbsp; Also, in BT_WRITE mode, <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incomplete splits encountered<br/></li>
<li></span><span class="Comment"> * during the search will be finished.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heaprel must be provided by callers that pass access = BT_WRITE, since we<br/></li>
<li></span><span class="Comment"> * might need to allocate a new root page for caller -- see <a href="nbtpage.c.html#L869" title="access/nbtree/nbtpage.c:869">_bt_allocbuf</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BTStack<br/></li>
<li><a id="L96">&#x200c;</a><span class="linkable">_bt_search</span>(Relation rel, Relation heaprel, BTScanInsert key, Buffer *bufP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> access)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTStack&nbsp; &nbsp; &nbsp; &nbsp; stack_in = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_access = BT_READ;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* heaprel must be set whenever <a href="nbtpage.c.html#L869" title="access/nbtree/nbtpage.c:869">_bt_allocbuf</a> is reachable */<br/></li>
<li></span>&nbsp; &nbsp; Assert(access == BT_READ || access == BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; Assert(access == BT_READ || heaprel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the root page to start with */<br/></li>
<li></span>&nbsp; &nbsp; *bufP = <a href="nbtpage.c.html#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>(rel, heaprel, access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If index is empty and access = BT_READ, no root page is created. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(*bufP))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (BTStack) <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop iterates once per level descended in the tree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTStack&nbsp; &nbsp; &nbsp; &nbsp; new_stack;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Race -- the page we just grabbed may have split since we read its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlink in its parent page (or the metapage).&nbsp; If it has, we may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to move right to its new sibling.&nbsp; Do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In write-mode, allow <a href="#L235" title="access/nbtree/nbtsearch.c:235">_bt_moveright</a> to finish <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incomplete splits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * along the way.&nbsp; Strictly speaking, we'd only need to finish an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * incomplete split on the leaf page we're about to insert to, not on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the <a href="../../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels (<a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages with incomplete splits are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also taken care of in <a href="nbtinsert.c.html#L2319" title="access/nbtree/nbtinsert.c:2319">_bt_getstackbuf</a>).&nbsp; But this is a good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opportunity to finish splits of <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> pages too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bufP = <a href="#L235" title="access/nbtree/nbtsearch.c:235">_bt_moveright</a>(rel, heaprel, key, *bufP, (access == BT_WRITE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack_in, page_access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if this is a leaf page, we're done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(*bufP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_ISLEAF(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the appropriate pivot tuple on this page.&nbsp; Its downlink points<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the child page that we're about to descend to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; offnum = <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>(rel, key, *bufP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(BTreeTupleIsPivot(itup) || !key-&gt;heapkeyspace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; child = BTreeTupleGetDownLink(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to save the location of the pivot tuple we chose in a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stack entry for this page/level.&nbsp; If caller ends up splitting a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page one level down, it usually ends up inserting a new pivot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple/downlink immediately after the location recorded here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; new_stack = (BTStack) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTStackData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_stack-&gt;bts_blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(*bufP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_stack-&gt;bts_offset = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_stack-&gt;bts_parent = stack_in;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Page level 1 is lowest non-leaf page level prior to leaves.&nbsp; So, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're on the level 1 and asked to lock leaf page in write mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then lock <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page in write mode, because it must be a leaf.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_level == <span class="Constant">1</span> &amp;&amp; access == BT_WRITE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page_access = BT_WRITE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* drop the read lock on the page, then acquire one on its child */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bufP = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, *bufP, child, page_access);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* okay, all set to move down a level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stack_in = new_stack;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're asked to lock leaf in write mode, but didn't manage to, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relock.&nbsp; This should only happen when the root page is a leaf page (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the only page in the index other than the metapage).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (access == BT_WRITE &amp;&amp; page_access == BT_READ)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* trade in our read lock for a write lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, *bufP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, *bufP, BT_WRITE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Race -- the leaf page may have split after we dropped the read lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we acquired a write lock.&nbsp; If it has, we may need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * move right to its new sibling.&nbsp; Do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *bufP = <a href="#L235" title="access/nbtree/nbtsearch.c:235">_bt_moveright</a>(rel, heaprel, key, *bufP, <span class="Constant">true</span>, stack_in, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stack_in;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L235" title="access/nbtree/nbtsearch.c:235">_bt_moveright</a>() -- move right in the btree if necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we follow a pointer to reach a page, it is possible that<br/></li>
<li></span><span class="Comment"> * the page has changed in the meanwhile.&nbsp; If this happens, we're<br/></li>
<li></span><span class="Comment"> * guaranteed that the page has &quot;split right&quot; -- that is, that <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * data that appeared on the page originally is either on the page<br/></li>
<li></span><span class="Comment"> * or strictly to the right of it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine decides whether or not we need to move right in the<br/></li>
<li></span><span class="Comment"> * tree by examining the high key entry on the page.&nbsp; If that entry is<br/></li>
<li></span><span class="Comment"> * strictly less than the scankey, or &lt;= the scankey in the<br/></li>
<li></span><span class="Comment"> * key.nextkey=true case, then we followed the wrong link and we need<br/></li>
<li></span><span class="Comment"> * to move right.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The passed insertion-type scankey can omit the rightmost column(s) of the<br/></li>
<li></span><span class="Comment"> * index. (see nbtree/README)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When key.nextkey is false (the usual case), we are looking for the first<br/></li>
<li></span><span class="Comment"> * item &gt;= key.&nbsp; When key.nextkey is true, we are looking for the first item<br/></li>
<li></span><span class="Comment"> * strictly greater than key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If forupdate is true, we will attempt to finish <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incomplete splits<br/></li>
<li></span><span class="Comment"> * that we encounter.&nbsp; This is required when locking a target page for an<br/></li>
<li></span><span class="Comment"> * insertion, because we don't allow inserting on a page <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the split is<br/></li>
<li></span><span class="Comment"> * completed.&nbsp; 'heaprel' and 'stack' are only used if forupdate is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, we have the buffer pinned and a lock of the type specified by<br/></li>
<li></span><span class="Comment"> * 'access'.&nbsp; If we move right, we release the buffer and lock and acquire<br/></li>
<li></span><span class="Comment"> * the same on the right sibling.&nbsp; Return value is the buffer we stop at.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L235">&#x200c;</a><span class="linkable">_bt_moveright</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation heaprel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanInsert key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forupdate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTStack stack,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> access)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cmpval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!forupdate || heaprel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When nextkey = false (normal case): if the scan key that brought us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this page is &gt; the high key stored on the page, then the page has split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we need to move right.&nbsp; (pg_upgrade'd !heapkeyspace indexes could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have some duplicates to the right as well as the left, but that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something that's only ever dealt with on the leaf level, after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a> has found an initial leaf page.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When nextkey = true: move right if the scan key is &gt;= page's high key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note that key.scantid cannot be set in this case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The page could even have split more than once, so scan as far as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also have to move right if we followed a link that brought us to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dead page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cmpval = key-&gt;nextkey ? <span class="Constant">0</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Finish <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incomplete splits we encounter along the way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forupdate &amp;&amp; P_INCOMPLETE_SPLIT(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* upgrade our lock if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (access == BT_READ)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, buf, BT_WRITE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_INCOMPLETE_SPLIT(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtinsert.c.html#L2241" title="access/nbtree/nbtinsert.c:2241">_bt_finish_split</a>(rel, heaprel, buf, stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-acquire the lock in the right mode, and re-check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, blkno, access);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_IGNORE(opaque) || <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>(rel, key, page, P_HIKEY) &gt;= cmpval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* step right one page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, buf, opaque-&gt;btpo_next, access);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (P_IGNORE(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;fell off the end of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>() -- Do a binary search for a key on a particular page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> (non-leaf) page, <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>() returns the OffsetNumber<br/></li>
<li></span><span class="Comment"> * of the last key &lt; given scankey, or last key &lt;= given scankey if nextkey<br/></li>
<li></span><span class="Comment"> * is true.&nbsp; (Since <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a> treats the first data key of such a page as<br/></li>
<li></span><span class="Comment"> * minus infinity, there will be at least one key &lt; scankey, so the result<br/></li>
<li></span><span class="Comment"> * always points at one of the keys on the page.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On a leaf page, <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>() returns the final result of the initial<br/></li>
<li></span><span class="Comment"> * positioning process that started with <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>'s call to <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>.<br/></li>
<li></span><span class="Comment"> * We're returning a non-pivot tuple offset, so things are a little different.<br/></li>
<li></span><span class="Comment"> * It is possible that we'll return an offset that's either past the last<br/></li>
<li></span><span class="Comment"> * non-pivot slot, or (in the case of a backward scan) <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first slot.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This procedure is not responsible for walking right, it just examines<br/></li>
<li></span><span class="Comment"> * the given page.&nbsp; <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>() has no lock or refcount side effects<br/></li>
<li></span><span class="Comment"> * on the buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> OffsetNumber<br/></li>
<li><a id="L337">&#x200c;</a><span class="linkable">_bt_binsrch</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanInsert key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Requesting nextkey semantics while using scantid seems nonsensical */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!key-&gt;nextkey || key-&gt;scantid == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* scantid-set callers must use <a href="#L468" title="access/nbtree/nbtsearch.c:468">_bt_binsrch_insert</a>() on leaf pages */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!P_ISLEAF(opaque) || key-&gt;scantid == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; low = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; high = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are no keys on the page, return the first available slot. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this covers two cases: the page is really empty (no keys), or it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contains only a high key.&nbsp; The latter case is possible after vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This can never happen on an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page, however, since they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never empty (an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page must have at least one child).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(high &lt; low))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Binary search to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first key on the page &gt;= scan key, or first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key &gt; scankey when nextkey is true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For nextkey=false (cmpval=1), the loop invariant is: all slots <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'low' are &lt; scan key, all slots at or after 'high' are &gt;= scan key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For nextkey=true (cmpval=0), the loop invariant is: all slots <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'low' are &lt;= scan key, all slots at or after 'high' are &gt; scan key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can fall out when high == low.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; high++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establish the loop invariant for high */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cmpval = key-&gt;nextkey ? <span class="Constant">0</span> : <span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> comparison value */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber mid = low + ((high - low) / <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have low &lt;= mid &lt; high, so mid points at a real slot */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>(rel, key, page, mid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= cmpval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point we have high == low.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On a leaf page we always return the first non-pivot tuple &gt;= scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (resp. &gt; scan key) for forward scan callers.&nbsp; For backward scans, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always the _last_ non-pivot tuple &lt; scan key (resp. &lt;= scan key).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (P_ISLEAF(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the backward scan case we're supposed to locate the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matching tuple on the leaf level -- not the first matching tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (the last tuple will be the first one returned by the scan).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we've located the first non-pivot tuple immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after the last matching tuple (which might just be maxoff + 1).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compensate by stepping back.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;backward)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> OffsetNumberPrev(low);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On a non-leaf page, return the last key &lt; scan key (resp. &lt;= scan key).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There must be one if <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>() is playing by the rules.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>() will seldom see <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exactly-matching pivot tuples, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a truncated -inf heap TID is usually enough to prevent it altogether.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even omitted scan key entries are treated as &gt; truncated attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, during backward scans <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>() interprets omitted scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key attributes as == corresponding truncated -inf attributes instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This works just like &lt; would work here.&nbsp; Under this scheme, &lt; strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backward scans will always directly descend to the correct leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In particular, they will never incur an &quot;extra&quot; leaf page access with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan key that happens to contain the same prefix of <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pivot tuple's untruncated prefix.&nbsp; VACUUM relies on this guarantee when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it uses a leaf page high key to &quot;re-<a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a>&quot; a page undergoing deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(low &gt; P_FIRSTDATAKEY(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> OffsetNumberPrev(low);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L468" title="access/nbtree/nbtsearch.c:468">_bt_binsrch_insert</a>() -- Cacheable, incremental leaf page binary search.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Like <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>(), but with support for caching the binary search<br/></li>
<li></span><span class="Comment"> * bounds.&nbsp; Only used during insertion, and only on the leaf page that it<br/></li>
<li></span><span class="Comment"> * looks like caller will insert tuple on.&nbsp; Exclusive-locked and pinned<br/></li>
<li></span><span class="Comment"> * leaf page is contained within insertstate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caches the bounds fields in insertstate so that a subsequent call can<br/></li>
<li></span><span class="Comment"> * reuse the low and strict high bounds of original binary search.&nbsp; Callers<br/></li>
<li></span><span class="Comment"> * that use these fields directly must be prepared for the case where low<br/></li>
<li></span><span class="Comment"> * and/or stricthigh are not on the same page (one or both exceed maxoff<br/></li>
<li></span><span class="Comment"> * for the page).&nbsp; The case where there are no items on the page (high &lt;<br/></li>
<li></span><span class="Comment"> * low) makes bounds invalid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for invalidating bounds when it modifies the page<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling here a second time, and for dealing with posting list<br/></li>
<li></span><span class="Comment"> * tuple matches (callers can use insertstate's postingoff field to<br/></li>
<li></span><span class="Comment"> * determine which existing heap TID will need to be replaced by a posting<br/></li>
<li></span><span class="Comment"> * list split).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>OffsetNumber<br/></li>
<li><a id="L468">&#x200c;</a><span class="linkable">_bt_binsrch_insert</span>(Relation rel, BTInsertState insertstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanInsert key = insertstate-&gt;itup_key;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stricthigh;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmpval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(insertstate-&gt;buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(P_ISLEAF(opaque));<br/></li>
<li>&nbsp; &nbsp; Assert(!key-&gt;nextkey);<br/></li>
<li>&nbsp; &nbsp; Assert(insertstate-&gt;postingoff == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!insertstate-&gt;bounds_valid)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start new binary search */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; low = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; high = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore result of previous binary search against same page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; low = insertstate-&gt;low;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; high = insertstate-&gt;stricthigh;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If there are no keys on the page, return the first available slot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(high &lt; low))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller can't reuse bounds */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; insertstate-&gt;low = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; insertstate-&gt;stricthigh = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; insertstate-&gt;bounds_valid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Binary search to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first key on the page &gt;= scan key. (nextkey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is always false when inserting).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The loop invariant is: all slots <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> 'low' are &lt; scan key, all slots<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at or after 'high' are &gt;= scan key.&nbsp; 'stricthigh' is &gt; scan key, and is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maintained to save additional search effort for caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can fall out when high == low.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!insertstate-&gt;bounds_valid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; high++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establish the loop invariant for high */<br/></li>
<li></span>&nbsp; &nbsp; stricthigh = high;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* high initially strictly higher */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; cmpval = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !nextkey comparison value */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber mid = low + ((high - low) / <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have low &lt;= mid &lt; high, so mid points at a real slot */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>(rel, key, page, mid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt;= cmpval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stricthigh = high;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If tuple at offset located by binary search is a posting list whose<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> overlaps with caller's scantid, perform posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary search to set postingoff for caller.&nbsp; Caller must split the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * posting list when postingoff is set.&nbsp; This should happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * infrequently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlikely(result == <span class="Constant">0</span> &amp;&amp; key-&gt;scantid != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postingoff should never be set more than once per leaf page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * binary search.&nbsp; That would mean that there are duplicate table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TIDs in the index, which is never okay.&nbsp; Check for that here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (insertstate-&gt;postingoff != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;table tid from new index tuple (</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) cannot <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> insert offset between offsets </span><span class="Special">%u</span><span class="Constant"> and </span><span class="Special">%u</span><span class="Constant"> of block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetBlockNumber(key-&gt;scantid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ItemPointerGetOffsetNumber(key-&gt;scantid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; low, stricthigh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(insertstate-&gt;buf),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; insertstate-&gt;postingoff = <a href="#L596" title="access/nbtree/nbtsearch.c:596">_bt_binsrch_posting</a>(key, page, mid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On a leaf page, a binary search always returns the first key &gt;= scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key (at least in !nextkey case), which could be the last slot + 1. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is also the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> bound of cached search.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stricthigh may also be the last slot + 1, which prevents caller from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using bounds directly, but is still useful to us if we're called a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second time with cached bounds (cached low will be &lt; stricthigh when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that happens).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; insertstate-&gt;low = low;<br/></li>
<li>&nbsp; &nbsp; insertstate-&gt;stricthigh = stricthigh;<br/></li>
<li>&nbsp; &nbsp; insertstate-&gt;bounds_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L596" title="access/nbtree/nbtsearch.c:596">_bt_binsrch_posting</a>() -- posting list binary search.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Helper routine for <a href="#L468" title="access/nbtree/nbtsearch.c:468">_bt_binsrch_insert</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns offset into posting list where caller's scantid belongs.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L596">&#x200c;</a></span><span class="linkable">_bt_binsrch_posting</span>(BTScanInsert key, Page page, OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this isn't a posting tuple, then the index must be corrupt (if it is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an ordinary non-pivot tuple then there must be an existing tuple with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap TID that equals inserter's new heap TID/scantid).&nbsp; Defensively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check that tuple is a posting list tuple whose posting list <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * includes caller's scantid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This is also needed because contrib/amcheck's rootdescend option needs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be able to relocate a non-pivot tuple using <a href="#L468" title="access/nbtree/nbtsearch.c:468">_bt_binsrch_insert</a>().)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(key-&gt;heapkeyspace &amp;&amp; key-&gt;allequalimage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the event that posting list tuple has LP_DEAD <a href="../../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> set, indicate this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="#L468" title="access/nbtree/nbtsearch.c:468">_bt_binsrch_insert</a>() caller by returning -1, a <a href="../../lib/rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> value.&nbsp; A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second call to <a href="#L468" title="access/nbtree/nbtsearch.c:468">_bt_binsrch_insert</a>() can take place when its caller has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed the dead item.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ItemIdIsDead(itemid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* &quot;high&quot; is past end of posting list for loop invariant */<br/></li>
<li></span>&nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; high = BTreeTupleGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; Assert(high &gt;= <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid = low + ((high - low) / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res = <a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(key-&gt;scantid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTreeTupleGetPostingN(itup, mid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (res &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (res &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> mid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Exact match not found */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a>() -- Compare insertion-type scankey to tuple on a page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; page/offnum: location of btree item to be compared to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This routine returns:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;0 if scankey &lt; tuple at offnum;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 0 if scankey == tuple at offnum;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;0 if scankey &gt; tuple at offnum.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NULLs in the keys are treated as sortable <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.&nbsp; Therefore<br/></li>
<li></span><span class="Comment"> * &quot;equality&quot; does not necessarily mean that the item should be returned<br/></li>
<li></span><span class="Comment"> * to the caller as a matching key.&nbsp; Similarly, an insertion scankey<br/></li>
<li></span><span class="Comment"> * with its scantid set is treated as <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to a posting tuple whose TID<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> overlaps with their scantid.&nbsp; There generally won't be a<br/></li>
<li></span><span class="Comment"> * matching TID in the posting tuple, which caller must handle<br/></li>
<li></span><span class="Comment"> * themselves (e.g., by splitting the posting list tuple).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * CRUCIAL <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: on a non-leaf page, the first data key is assumed to be<br/></li>
<li></span><span class="Comment"> * &quot;minus infinity&quot;: this routine will always claim it is less than the<br/></li>
<li></span><span class="Comment"> * scankey.&nbsp; The actual key value stored is explicitly truncated to 0<br/></li>
<li></span><span class="Comment"> * attributes (explicitly minus infinity) with version 3+ indexes, but<br/></li>
<li></span><span class="Comment"> * that isn't relied upon.&nbsp; This allows us to implement the Lehman and<br/></li>
<li></span><span class="Comment"> * Yao convention that the first down-link pointer is <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first<br/></li>
<li></span><span class="Comment"> * key.&nbsp; See backend/access/nbtree/README for details.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>int32<br/></li>
<li><a id="L682">&#x200c;</a><span class="linkable">_bt_compare</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanInsert key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Page page,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; itupdesc = RelationGetDescr(rel);<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; ItemPointer heapTid;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; scankey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncmpkey;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntupatts;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="nbtutils.c.html#L4921" title="access/nbtree/nbtutils.c:4921">_bt_check_natts</a>(rel, key-&gt;heapkeyspace, page, offnum));<br/></li>
<li>&nbsp; &nbsp; Assert(key-&gt;keysz &lt;= IndexRelationGetNumberOfKeyAttributes(rel));<br/></li>
<li>&nbsp; &nbsp; Assert(key-&gt;heapkeyspace || key-&gt;scantid == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force result &quot;&gt;&quot; if target item is first data item on an <a href="../../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * --- see <a href="../../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!P_ISLEAF(opaque) &amp;&amp; offnum == P_FIRSTDATAKEY(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));<br/></li>
<li>&nbsp; &nbsp; ntupatts = BTreeTupleGetNAtts(itup, rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The scan key is set up with the attribute number associated with each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * term in the key.&nbsp; It is important that, if the index is multi-key, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan contain the first k key attributes, and that they be in order.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * you think about how multi-key ordering works, you'll understand why<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't test for violation of this condition here, however.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial setup for the index scan had better have gotten it right (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ncmpkey = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(ntupatts, key-&gt;keysz);<br/></li>
<li>&nbsp; &nbsp; Assert(key-&gt;heapkeyspace || ncmpkey == key-&gt;keysz);<br/></li>
<li>&nbsp; &nbsp; Assert(!BTreeTupleIsPosting(itup) || key-&gt;allequalimage);<br/></li>
<li>&nbsp; &nbsp; scankey = key-&gt;scankeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt;= ncmpkey; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; datum = index_getattr(itup, scankey-&gt;sk_attno, itupdesc, &amp;isNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scankey-&gt;sk_flags &amp; SK_ISNULL)&nbsp; &nbsp; <span class="Comment">/* key is NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;=&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (scankey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* NULL &quot;&lt;&quot; NOT_NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NULL &quot;&gt;&quot; NOT_NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isNull)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* key is NOT_NULL and item is NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scankey-&gt;sk_flags &amp; SK_BT_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* NOT_NULL &quot;&gt;&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* NOT_NULL &quot;&lt;&quot; NULL */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The sk_func needs to be passed the index value as left arg and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the sk_argument as right arg (they might be of different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types).&nbsp; Since it is convenient for callers to think of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L682" title="access/nbtree/nbtsearch.c:682">_bt_compare</a> as comparing the scankey to the index item, we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to flip the sign of the comparison result.&nbsp; (Unless it's a DESC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column, in which case we *don't* flip the sign.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = DatumGetInt32(<a href="../../utils/fmgr/fmgr.c.html#L1149" title="utils/fmgr/fmgr.c:1149">FunctionCall2Coll</a>(&amp;scankey-&gt;sk_func,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scankey-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; datum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; scankey-&gt;sk_argument));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(scankey-&gt;sk_flags &amp; SK_BT_DESC))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INVERT_COMPARE_RESULT(result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the keys are unequal, return the difference */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scankey++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All non-truncated attributes (other than heap TID) were found to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.&nbsp; Treat truncated attributes as minus infinity when scankey has a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key attribute value that would otherwise be compared directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: it doesn't matter if ntupatts includes non-key attributes;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scankey won't, so explicitly excluding non-key attributes isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;keysz &gt; ntupatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the heap TID attribute and scantid to try to break the tie.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rules are the same as <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other key attribute -- only the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * representation differs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heapTid = BTreeTupleGetHeapTID(itup);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;scantid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forward scans have a scankey that is considered greater than a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncated pivot tuple if and when the scankey has <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes up to and including the least significant untruncated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attribute in tuple.&nbsp; Even attributes that were omitted from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scan key are considered greater than -inf truncated attributes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (See <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a> for an explanation of our backward scan behavior.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For example, if an index has the minimum two attributes (single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user key attribute, plus heap TID attribute), and a page's high key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is ('foo', -inf), and scankey is ('foo', &lt;omitted&gt;), the search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will not descend to the page to the left.&nbsp; The search will descend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right instead.&nbsp; The truncated attribute in pivot tuple means that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all non-pivot tuples on the page to the left are strictly &lt; 'foo',<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so it isn't necessary to descend left.&nbsp; In other words, search<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't have to descend left because it isn't interested in a match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that has a heap TID value of -inf.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the heap TID part of the test ensures that scankey is being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compared to a pivot tuple with one or more truncated -inf key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attributes.&nbsp; The heap TID attribute is the last key attribute in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every index, of course, but other than that it isn't special.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!key-&gt;backward &amp;&amp; key-&gt;keysz == ntupatts &amp;&amp; heapTid == <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;heapkeyspace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* All provided scankey arguments found to be <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Treat truncated heap TID as minus infinity, since scankey has a key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attribute value (scantid) that would otherwise be compared directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(key-&gt;keysz == IndexRelationGetNumberOfKeyAttributes(rel));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (heapTid == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scankey must be treated as <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to a posting list tuple if its scantid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value falls within the <a href="../../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of the posting list.&nbsp; In all other cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there can only be a single heap TID value, which is compared directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with scantid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ntupatts &gt;= IndexRelationGetNumberOfKeyAttributes(rel));<br/></li>
<li>&nbsp; &nbsp; result = <a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(key-&gt;scantid, heapTid);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt;= <span class="Constant">0</span> || !BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(key-&gt;scantid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetMaxHeapTID(itup));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>() -- Find the first item in a scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We need to be clever about the direction of scan, the search<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; conditions, and the tree ordering.&nbsp; We <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the first item (or,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; if backwards scan, the last item) in the tree that satisfies the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; qualifications in the scan key.&nbsp; On success exit, the page containing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the current index tuple is pinned but not locked, and data about<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; the matching tuple(s) on the page has been loaded into so-&gt;currPos.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_heaptid is set to the heap TID of the current tuple, and if<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; requested, scan-&gt;xs_itup points to a copy of the index tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are no matching items in the index, we return false, with no<br/></li>
<li></span><span class="Comment"> * pins or locks held.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that scan-&gt;keyData[], and the so-&gt;keyData[] scankey built from it,<br/></li>
<li></span><span class="Comment"> * are both search-type scankeys (see nbtree/README for more about this).<br/></li>
<li></span><span class="Comment"> * Within this routine, we build a temporary insertion-type scankey to use<br/></li>
<li></span><span class="Comment"> * in locating the scan start position.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L876">&#x200c;</a></span><span class="linkable">_bt_first</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; BTStack&nbsp; &nbsp; &nbsp; &nbsp; stack;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strat;<br/></li>
<li>&nbsp; &nbsp; BTScanInsertData inskey;<br/></li>
<li>&nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; startKeys[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; ScanKeyData notnullkeys[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keysz = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; StrategyNumber strat_total;<br/></li>
<li>&nbsp; &nbsp; BTScanPosItem *currItem;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BTScanPosIsValid(so-&gt;currPos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pgstat_count_index_scan(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine the scan keys and eliminate <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> redundant keys; also mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keys that must be matched to continue the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Quit <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> if <a href="nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a>() discovered that the scan keys can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * never be satisfied (eg, x == 1 AND x &gt; 2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!so-&gt;qual_ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For parallel scans, get the starting page from shared state. If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scan has not started, proceed to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out first leaf page in the usual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * way while keeping other participating processes <a href="../../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>.&nbsp; If the scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has already begun, use the page number from the shared structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When a parallel scan has another primitive index scan scheduled, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel worker will seize the scan for that purpose <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * similar to the case where the top-level scan hasn't started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a>(scan, &amp;blkno, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize arrays (when <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a> didn't already set up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> primitive index scan)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numArrayKeys &amp;&amp; !so-&gt;needPrimScan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L1343" title="access/nbtree/nbtutils.c:1343">_bt_start_array_keys</a>(scan, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (blkno == P_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (blkno != InvalidBlockNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2334" title="access/nbtree/nbtsearch.c:2334">_bt_parallel_readpage</a>(scan, blkno, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> readcomplete;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (so-&gt;numArrayKeys &amp;&amp; !so-&gt;needPrimScan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> call (for current <a href="nbtree.c.html#L359" title="access/nbtree/nbtree.c:359">btrescan</a>) without parallelism.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize arrays, and the corresponding scan keys that were just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output by <a href="nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L1343" title="access/nbtree/nbtutils.c:1343">_bt_start_array_keys</a>(scan, dir);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine the scan keys to discover where we need to start the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to identify the keys that can be used as starting boundaries;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * these are =, &gt;, or &gt;= keys for a forward scan or =, &lt;, &lt;= keys for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a backwards scan.&nbsp; We can use keys for multiple attributes so long as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the prior attributes had only =, &gt;= (resp. =, &lt;=) keys.&nbsp; Once we <a href="../../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a &gt; or &lt; boundary or <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an attribute with no boundary (which can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * thought of as the same as &quot;&gt; -infinity&quot;), we can't use keys for <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attributes to its right, because it would break our simplistic notion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of what initial positioning strategy to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the scan keys include cross-type operators, <a href="nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * may not be able to eliminate redundant keys; in such cases we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arbitrarily pick a usable one for each attribute.&nbsp; This is correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but possibly not optimal behavior.&nbsp; (For example, with keys like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;x &gt;= 4 AND x &gt;= 5&quot; we would elect to scan starting at x=4 when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * x=5 would be more efficient.)&nbsp; Since the situation only arises given<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a poorly-worded query plus an incomplete opfamily, live with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When both equality and inequality keys appear for a single attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (again, only possible when cross-type operators appear), we *must*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> one of the equality keys for the starting point, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>() will stop the scan as soon as an equality qual fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For example, if we have keys like &quot;x &gt;= 4 AND x = 10&quot; and we elect to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start at x=4, we will fail and stop <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching x=10.&nbsp; If multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality quals survive preprocessing, however, it doesn't matter which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one we use --- by definition, they are either redundant or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contradictory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any regular (not SK_SEARCHNULL) key implies a NOT NULL qualifier.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index stores nulls at the end of the index we'll be starting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from, and we have no boundary key for the column (which means the key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we deduced NOT NULL from is an inequality key that constrains the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end of the index), then we cons up an explicit SK_SEARCHNOTNULL key to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use as a boundary key.&nbsp; If we didn't do this, we might <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * traversing a lot of null entries at the start of the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In this loop, row-comparison keys are treated the same as keys on their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first (leftmost) columns.&nbsp; We'll add on <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order columns of the row<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison below, if possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The selected scan keys (at most one per index column) are remembered by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storing their addresses into the local startKeys[] array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>/<a href="nbtutils.c.html#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> decide whether and when to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> primitive index scan (for scans with array keys) based in part<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on an understanding of how it'll enable us to reposition the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They're directly aware of how we'll sometimes cons up an explicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SK_SEARCHNOTNULL key.&nbsp; They'll even end primitive scans by applying a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * symmetric &quot;deduce NOT NULL&quot; rule of their own.&nbsp; This allows top-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scans to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> large groups of NULLs through repeated deductions about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key strictness (for a required inequality key) and whether NULLs in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key's index column are stored last or first (relative to non-NULLs).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you update anything here, <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>/<a href="nbtutils.c.html#L1789" title="access/nbtree/nbtutils.c:1789">_bt_advance_array_keys</a> might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to be kept in sync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; strat_total = BTEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numberOfKeys &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; curattr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; chosen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; impliesNN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * chosen is the so-far-chosen key for the current attribute, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't cast the decision in stone until we reach keys for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> attribute.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; curattr = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; chosen = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also remember <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> scankey that implies a NOT NULL constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; impliesNN = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Loop iterates from 0 to numberOfKeys inclusive; we use the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pass to handle after-last-key processing.&nbsp; Actual exit from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop is at one of the &quot;break&quot; statements below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (cur = so-&gt;keyData, i = <span class="Constant">0</span>;; cur++, i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= so-&gt;numberOfKeys || cur-&gt;sk_attno != curattr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done looking at keys for curattr.&nbsp; If we didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * usable boundary key, see if we can deduce a NOT NULL key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chosen == <span class="Constant">NULL</span> &amp;&amp; impliesNN != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((impliesNN-&gt;sk_flags &amp; SK_BT_NULLS_FIRST) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirectionIsForward(dir) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ScanDirectionIsBackward(dir)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Yes, so build the key in notnullkeys[keysz] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chosen = &amp;notnullkeys[keysz];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L32" title="access/common/scankey.c:32">ScanKeyEntryInitialize</a>(chosen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (SK_SEARCHNOTNULL | SK_ISNULL |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (impliesNN-&gt;sk_flags &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (SK_BT_DESC | SK_BT_NULLS_FIRST))),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; curattr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((impliesNN-&gt;sk_flags &amp; SK_BT_NULLS_FIRST) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTGreaterStrategyNumber :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTLessStrategyNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we still didn't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a usable boundary key, quit; else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * save the boundary key pointer in startKeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chosen == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startKeys[keysz++] = chosen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Adjust strat_total, and quit if we have stored a &gt; or &lt;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * key.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat = chosen-&gt;sk_strategy;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strat != BTEqualStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat_total = strat;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strat == BTGreaterStrategyNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat == BTLessStrategyNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done if that was the last attribute, or if <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> key is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in sequence (implying no boundary key is available for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> attribute).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= so-&gt;numberOfKeys ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_attno != curattr + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> attr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curattr = cur-&gt;sk_attno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chosen = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; impliesNN = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can we use this key as a starting boundary for this attr?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If not, does it imply a NOT NULL constraint?&nbsp; (Because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SK_SEARCHNULL keys are always assigned BTEqualStrategyNumber,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * *<a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>* inequality key works for that; we need not test.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cur-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chosen == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chosen = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; impliesNN = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* override <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> non-equality choice */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chosen = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chosen == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chosen = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; impliesNN = cur;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found no usable boundary keys, we have to start from one end of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the tree.&nbsp; Walk down that edge to the first or last key, and scan from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (keysz == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; match;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; match = <a href="#L2560" title="access/nbtree/nbtsearch.c:2560">_bt_endpoint</a>(scan, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!match)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No match, so mark (parallel) scan finished */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> match;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to start the scan somewhere within the index.&nbsp; Set up an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insertion scankey we can use to search for the boundary point we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identified above.&nbsp; The insertion scankey is built using the keys<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * identified by startKeys[].&nbsp; (Remaining insertion scankey fields are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized after initial-positioning strategy is finalized.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(keysz &lt;= INDEX_MAX_KEYS);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; keysz; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; cur = startKeys[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(cur-&gt;sk_attno == i + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_flags &amp; SK_ROW_HEADER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Row comparison header: look to the first row member instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The member scankeys are already in insertion format (ie, they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have sk_func = 3-way-comparison function), but we have to watch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out for nulls, which <a href="nbtutils.c.html#L2556" title="access/nbtree/nbtutils.c:2556">_bt_preprocess_keys</a> didn't check. A null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the first row member makes the condition unmatchable, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like qual_ok = false.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ScanKey&nbsp; &nbsp; &nbsp; &nbsp; subkey = (ScanKey) DatumGetPointer(cur-&gt;sk_argument);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_flags &amp; SK_ROW_MEMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(inskey.scankeys + i, subkey, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the row comparison is the last positioning key we accepted,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * try to add additional keys from the <a href="../../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-order row members.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (If we accepted independent conditions on additional index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns, we use those instead --- doesn't seem worth trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determine which is more restrictive.)&nbsp; Note that this is OK<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * even if the row comparison is of &quot;&gt;&quot; or &quot;&lt;&quot; type, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * condition applied to all but the last row member is effectively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;&gt;=&quot; or &quot;&lt;=&quot;, and so the extra keys don't break the positioning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scheme.&nbsp; But, by the same token, if we aren't able to use all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the row members, then the part of the row comparison that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * did use has to be treated as just a &quot;&gt;=&quot; or &quot;&lt;=&quot; condition, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we'd better adjust strat_total accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == keysz - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; used_all_subkeys = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(subkey-&gt;sk_flags &amp; SK_ROW_END));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subkey++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(subkey-&gt;sk_flags &amp; SK_ROW_MEMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_attno != keysz + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* out-of-sequence, can't use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_strategy != cur-&gt;sk_strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* wrong direction, can't use it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ISNULL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; <span class="Comment">/* can't use null keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(keysz &lt; INDEX_MAX_KEYS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(inskey.scankeys + keysz, subkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ScanKeyData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keysz++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (subkey-&gt;sk_flags &amp; SK_ROW_END)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; used_all_subkeys = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!used_all_subkeys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (strat_total)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat_total = BTLessEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strat_total = BTGreaterEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done with outer loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ordinary comparison key.&nbsp; Transform the search-style scan key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to an insertion scan key by replacing the sk_func with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate btree comparison function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If scankey operator is not a cross-type comparison, we can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the cached comparison function; otherwise gotta look it up in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the catalogs.&nbsp; (That can't lead to infinite recursion, since no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexscan initiated by syscache lookup will use cross-data-type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operators.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We support the convention that sk_subtype == InvalidOid means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the opclass input type; this is a hack to simplify life for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cur-&gt;sk_subtype == rel-&gt;rd_opcintype[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur-&gt;sk_subtype == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FmgrInfo&nbsp;&nbsp; *procinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procinfo = <a href="../index/indexam.c.html#L860" title="access/index/indexam.c:860">index_getprocinfo</a>(rel, cur-&gt;sk_attno, BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L101" title="access/common/scankey.c:101">ScanKeyEntryInitializeWithInfo</a>(inskey.scankeys + i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidStrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; procinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_argument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegProcedure cmp_proc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmp_proc = <a href="../../utils/cache/lsyscache.c.html#L796" title="utils/cache/lsyscache.c:796">get_opfamily_proc</a>(rel-&gt;rd_opfamily[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel-&gt;rd_opcintype[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(cmp_proc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing support function </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) for attribute </span><span class="Special">%d</span><span class="Constant"> of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BTORDER_PROC, rel-&gt;rd_opcintype[i], cur-&gt;sk_subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_attno, RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../common/scankey.c.html#L32" title="access/common/scankey.c:32">ScanKeyEntryInitialize</a>(inskey.scankeys + i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidStrategy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_subtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_collation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cmp_proc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur-&gt;sk_argument);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Examine the selected initial-positioning strategy to determine exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we need to start the scan, and set flag variables to control the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initial descent by <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a> (and our <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a> call for the leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a> returns).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtpage.c.html#L739" title="access/nbtree/nbtpage.c:739">_bt_metaversion</a>(rel, &amp;inskey.heapkeyspace, &amp;inskey.allequalimage);<br/></li>
<li>&nbsp; &nbsp; inskey.anynullkeys = <span class="Constant">false</span>; <span class="Comment">/* unused */<br/></li>
<li></span>&nbsp; &nbsp; inskey.scantid = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; inskey.keysz = keysz;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strat_total)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.nextkey = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.backward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTLessEqualStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.nextkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.backward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTEqualStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a backward scan was specified, need to start with last <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item not first one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the same as the &lt;= strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.nextkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.backward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the same as the &gt;= strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.nextkey = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.backward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterEqualStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find first item &gt;= scankey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.nextkey = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.backward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> BTGreaterStrategyNumber:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find first item &gt; scankey<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.nextkey = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inskey.backward = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't get here, but keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized strat_total: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) strat_total);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the manufactured insertion scan key to descend the tree and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position ourselves on the target leaf page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ScanDirectionIsBackward(dir) == inskey.backward);<br/></li>
<li>&nbsp; &nbsp; stack = <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>(rel, <span class="Constant">NULL</span>, &amp;inskey, &amp;buf, BT_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* don't need to keep the stack around... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtutils.c.html#L221" title="access/nbtree/nbtutils.c:221">_bt_freestack</a>(stack);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only get here if the index is completely empty. Lock relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because nothing finer to lock exists.&nbsp; Without a buffer lock, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible for another transaction to insert data between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>() and <a href="../../storage/lmgr/predicate.c.html#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a>().&nbsp; We have to try again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after taking the relation-level predicate lock, to close a narrow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * window where we wouldn't scan concurrently inserted tuples, but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writer wouldn't see our predicate lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsolationIsSerializable())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a>(rel, scan-&gt;xs_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stack = <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>(rel, <span class="Constant">NULL</span>, &amp;inskey, &amp;buf, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L221" title="access/nbtree/nbtutils.c:221">_bt_freestack</a>(stack);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark parallel scan as done, so that all the workers can finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * their scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(rel, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf), scan-&gt;xs_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2650" title="access/nbtree/nbtsearch.c:2650">_bt_initialize_more_data</a>(so, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* position to the precise item on the page */<br/></li>
<li></span>&nbsp; &nbsp; offnum = <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>(rel, &amp;inskey, buf);<br/></li>
<li>&nbsp; &nbsp; Assert(!BTScanPosIsValid(so-&gt;currPos));<br/></li>
<li>&nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now load data from the first page of the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If inskey.nextkey = false and inskey.backward = false, offnum is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positioned at the first non-pivot tuple &gt;= inskey.scankeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If inskey.nextkey = false and inskey.backward = true, offnum is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positioned at the last non-pivot tuple &lt; inskey.scankeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If inskey.nextkey = true and inskey.backward = false, offnum is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positioned at the first non-pivot tuple &gt; inskey.scankeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If inskey.nextkey = true and inskey.backward = true, offnum is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positioned at the last non-pivot tuple &lt;= inskey.scankeys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a> returned an offnum that is out of bounds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the page.&nbsp; For example, when inskey is both &lt; the leaf page's high<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * key and &gt; all of its non-pivot tuples, offnum will be &quot;maxoff + 1&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>(scan, dir, offnum, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no actually-matching data on this page.&nbsp; Try to advance to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.&nbsp; Return false if there's no matching data at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(scan-&gt;indexRelation, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a>(scan, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have at least one item to return as scan's first item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="access/nbtree/nbtsearch.c:61">_bt_drop_lock_and_maybe_pin</a>(scan, &amp;so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="Statement">readcomplete</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* OK, itemIndex says what to return */<br/></li>
<li></span>&nbsp; &nbsp; currItem = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex];<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_heaptid = currItem-&gt;heapTid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_want_itup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_itup = (IndexTuple) (so-&gt;currTuples + currItem-&gt;tupleOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1492" title="access/nbtree/nbtsearch.c:1492">_bt_next</a>() -- Get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item in a scan.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On entry, so-&gt;currPos describes the current page, which may be pinned<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; but is not locked, and so-&gt;currPos.itemIndex identifies which item was<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; previously returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On successful exit, scan-&gt;xs_heaptid is set to the TID of the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; heap tuple, and if requested, scan-&gt;xs_itup points to a copy of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; index tuple.&nbsp; so-&gt;currPos is updated as needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; On failure exit (no more tuples), we release pin and set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf to InvalidBuffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1492">&#x200c;</a></span><span class="linkable">_bt_next</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; BTScanPosItem *currItem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple on current page; or if there's no more, try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * step to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page with data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++so-&gt;currPos.itemIndex &gt; so-&gt;currPos.lastItem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a>(scan, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (--so-&gt;currPos.itemIndex &lt; so-&gt;currPos.firstItem)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a>(scan, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, itemIndex says what to return */<br/></li>
<li></span>&nbsp; &nbsp; currItem = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex];<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_heaptid = currItem-&gt;heapTid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_want_itup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_itup = (IndexTuple) (so-&gt;currTuples + currItem-&gt;tupleOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>() -- Load data from current index page into so-&gt;currPos<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have pinned and read-locked so-&gt;currPos.buf; the buffer's state<br/></li>
<li></span><span class="Comment"> * is not changed here.&nbsp; Also, currPos.moreLeft and moreRight must be valid;<br/></li>
<li></span><span class="Comment"> * they are updated as appropriate.&nbsp; All other fields of so-&gt;currPos are<br/></li>
<li></span><span class="Comment"> * initialized from scratch here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We scan the current page starting at offnum and moving in the indicated<br/></li>
<li></span><span class="Comment"> * direction.&nbsp; All items matching the scan keys are loaded into currPos.items.<br/></li>
<li></span><span class="Comment"> * moreLeft or moreRight (as appropriate) is cleared if <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> reports<br/></li>
<li></span><span class="Comment"> * that there can be no more matching tuples in the current scan direction<br/></li>
<li></span><span class="Comment"> * (could just be for the current primitive index scan when scan has arrays).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> caller passes us an offnum returned by <a href="#L337" title="access/nbtree/nbtsearch.c:337">_bt_binsrch</a>, which might<br/></li>
<li></span><span class="Comment"> * be an out of bounds offnum such as &quot;maxoff + 1&quot; in certain corner cases.<br/></li>
<li></span><span class="Comment"> * <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> will stop the scan as soon as an equality qual fails (when<br/></li>
<li></span><span class="Comment"> * its scan key was marked required), so <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a> _must_ pass us an offnum<br/></li>
<li></span><span class="Comment"> * exactly at the beginning of where <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> tuples are to be found.&nbsp; When we're<br/></li>
<li></span><span class="Comment"> * passed an offnum past the end of the page, we might still manage to stop<br/></li>
<li></span><span class="Comment"> * the scan on this page by calling <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> against the high key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the case of a parallel scan, caller must have called <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a><br/></li>
<li></span><span class="Comment"> * prior to calling this function; this function will invoke<br/></li>
<li></span><span class="Comment"> * <a href="nbtree.c.html#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a> <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matching items found on the page, false if <a href="../../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1556">&#x200c;</a></span><span class="linkable">_bt_readpage</span>(IndexScanDesc scan, ScanDirection dir, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> firstPage)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber minoff;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber maxoff;<br/></li>
<li>&nbsp; &nbsp; BTReadPageState pstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; arrayKeys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must have the buffer pinned and locked, but the usual macro can't be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used here; this function is what makes it good for currPos.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(BufferIsValid(so-&gt;currPos.buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* allow <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page be processed by parallel worker */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.prev_scan_page = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.prev_scan_page = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(so-&gt;currPos.buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a>(scan, pstate.prev_scan_page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indnatts = IndexRelationGetNumberOfAttributes(scan-&gt;indexRelation);<br/></li>
<li>&nbsp; &nbsp; arrayKeys = so-&gt;numArrayKeys != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; minoff = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> page-level state that we'll pass to <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a> */<br/></li>
<li></span>&nbsp; &nbsp; pstate.dir = dir;<br/></li>
<li>&nbsp; &nbsp; pstate.minoff = minoff;<br/></li>
<li>&nbsp; &nbsp; pstate.maxoff = maxoff;<br/></li>
<li>&nbsp; &nbsp; pstate.finaltup = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; pstate.page = page;<br/></li>
<li>&nbsp; &nbsp; pstate.offnum = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; pstate.continuescan = <span class="Constant">true</span>; <span class="Comment">/* default assumption */<br/></li>
<li></span>&nbsp; &nbsp; pstate.prechecked = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstate.firstmatch = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; pstate.rechecks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; pstate.targetdistance = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We note the buffer's block number so that we can release the pin later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This allows us to re-read the buffer if it is needed again for hinting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;currPos.currPage = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(so-&gt;currPos.buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We save the LSN of the page as we read it, so that we know whether it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * safe to apply LP_DEAD hints to the page later.&nbsp; This allows us to drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the pin for MVCC scans, which allows <a href="../../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> to avoid blocking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;currPos.lsn = <a href="../../storage/buffer/bufmgr.c.html#L3928" title="storage/buffer/bufmgr.c:3928">BufferGetLSNAtomic</a>(so-&gt;currPos.buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must save the page's right-link while scanning it; this tells us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where to step right to after we're done with these items.&nbsp; There is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding need for the left-link, since splits always go right.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;currPos.nextPage = opaque-&gt;btpo_next;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> tuple workspace to empty */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;currPos.nextTupleOffset = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that the current page has been made consistent, the macro should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * good.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(BTScanPosIsPinned(so-&gt;currPos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prechecking the value of the continuescan flag for the last item on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * page (for backwards scan it will be the first item on a page).&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * observe it to be true, then it should be true for all other items. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows us to do significant optimizations in the <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function for all the items on the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * With the forward scan, we do this check for the last item on the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instead of the high key.&nbsp; It's relatively likely that the most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * significant column in the high key will be different from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding value from the last item on the page.&nbsp; So checking with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the last item on the page would give a more precise answer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this for the first page read by each (primitive) scan, to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slowing down point queries.&nbsp; They typically don't stand to gain much<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the optimization can be applied, and are more likely to notice the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead of the precheck.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The optimization is unsafe and must be avoided whenever <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just set a low-order required array's key to the best available match<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a truncated -inf attribute value from the prior page's high key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> 0 is always the best available match in this scenario).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's quite likely that matches for array <a href="../../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> 0 begin on this page,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the start of matches won't necessarily align with page boundaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When the start of matches is somewhere in the middle of this page, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be wrong to treat page's final non-pivot tuple as representative.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Doing so might lead us to treat some of the page's earlier tuples as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being part of a group of tuples thought to satisfy the required keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: Conversely, in the case where the scan's arrays just advanced<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using the prior page's HIKEY _without_ advancement setting scanBehind,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the start of matches must be aligned with page boundaries, which makes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it safe to attempt the optimization here <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; It's also safe when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prior page's HIKEY simply didn't need to advance <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required array. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both cases we can safely assume that the _first_ tuple from this page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be &gt;= the current set of array keys/equality constraints. And so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the final tuple is == those same keys (and also satisfies <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * required &lt; or &lt;= strategy scan keys) during the precheck, we can safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that this must also be true of all earlier tuples from the page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!firstPage &amp;&amp; !so-&gt;scanBehind &amp;&amp; minoff &lt; maxoff)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, ScanDirectionIsForward(dir) ? maxoff : minoff);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Call with arrayKeys=false to avoid undesirable side-effects */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>(scan, &amp;pstate, <span class="Constant">false</span>, itup, indnatts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate.prechecked = pstate.continuescan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate.continuescan = <span class="Constant">true</span>; <span class="Comment">/* reset */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SK_SEARCHARRAY forward scans must provide high key up front */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeys &amp;&amp; !P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, P_HIKEY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.finaltup = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* load items[] in ascending order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemIndex = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = Max(offnum, minoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offnum &lt;= maxoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; passes_quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the scan specifies not to return killed tuples, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * treat a killed tuple as not passing the qual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;ignore_killed_tuples &amp;&amp; ItemIdIsDead(iid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberNext(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!BTreeTupleIsPivot(itup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.offnum = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; passes_quals = <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>(scan, &amp;pstate, arrayKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itup, indnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead to a later tuple (only possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the scan uses array keys)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeys &amp;&amp; OffsetNumberIsValid(pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!passes_quals &amp;&amp; pstate.continuescan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offnum &lt; pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (passes_quals)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple passes all scan key conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.firstmatch = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1940" title="access/nbtree/nbtsearch.c:1940">_bt_saveitem</a>(so, itemIndex, offnum, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up state to return posting list, and remember first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleOffset =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="access/nbtree/nbtsearch.c:1970">_bt_setuppostingitems</a>(so, itemIndex, offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetPostingN(itup, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember additional TIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; BTreeTupleGetNPosting(itup); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2008" title="access/nbtree/nbtsearch.c:2008">_bt_savepostingitem</a>(so, itemIndex, offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetPostingN(itup, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* When !continuescan, there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more matches, so stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pstate.continuescan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberNext(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't need to visit page to the right when the high key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicates that no more matches will be found there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Checking the high key like this works out more often than you might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * think.&nbsp; Leaf page splits pick a split point between the two most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dissimilar tuples (this is weighed against the need to evenly share<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free space).&nbsp; Leaf pages with high key attribute <a href="../../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only appear on non-pivot tuples on the right sibling page are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * common.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate.continuescan &amp;&amp; !P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncatt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; truncatt = BTreeTupleGetNAtts(itup, scan-&gt;indexRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.prechecked = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* precheck didn't cover HIKEY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>(scan, &amp;pstate, arrayKeys, itup, truncatt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pstate.continuescan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreRight = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(itemIndex &lt;= MaxTIDsPerBTreePage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.firstItem = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.lastItem = itemIndex - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.itemIndex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SK_SEARCHARRAY backward scans must provide final tuple up front */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeys &amp;&amp; minoff &lt;= maxoff &amp;&amp; !P_LEFTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, minoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.finaltup = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* load items[] in descending order */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itemIndex = MaxTIDsPerBTreePage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; offnum = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(offnum, maxoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offnum &gt;= minoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; iid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple_alive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; passes_quals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the scan specifies not to return killed tuples, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * treat a killed tuple as not passing the qual.&nbsp; Most of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time, it's a win to not bother examining the tuple's index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * keys, but just <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> tuple (previous, actually,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we're scanning backwards).&nbsp; However, if this is the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple on the page, we do check the index keys, to prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uselessly advancing to the page to the left.&nbsp; This is similar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the high key optimization used by forward scans.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;ignore_killed_tuples &amp;&amp; ItemIdIsDead(iid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offnum &gt;= P_FIRSTDATAKEY(opaque));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum &gt; P_FIRSTDATAKEY(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberPrev(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_alive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple_alive = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, iid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!BTreeTupleIsPivot(itup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.offnum = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; passes_quals = <a href="nbtutils.c.html#L3512" title="access/nbtree/nbtutils.c:3512">_bt_checkkeys</a>(scan, &amp;pstate, arrayKeys,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; itup, indnatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we need to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> ahead to a later tuple (only possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the scan uses array keys)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (arrayKeys &amp;&amp; OffsetNumberIsValid(pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!passes_quals &amp;&amp; pstate.continuescan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(offnum &gt; pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.<a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (passes_quals &amp;&amp; tuple_alive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tuple passes all scan key conditions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstate.firstmatch = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1940" title="access/nbtree/nbtsearch.c:1940">_bt_saveitem</a>(so, itemIndex, offnum, itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleOffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up state to return posting list, and remember first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we deliberately save/return items from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * posting lists in ascending heap TID order for backwards<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scans.&nbsp; This allows <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>() to make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistent assumption about the order of items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * associated with the same posting list tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleOffset =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1970" title="access/nbtree/nbtsearch.c:1970">_bt_setuppostingitems</a>(so, itemIndex, offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetPostingN(itup, <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember additional TIDs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; BTreeTupleGetNPosting(itup); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemIndex--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2008" title="access/nbtree/nbtsearch.c:2008">_bt_savepostingitem</a>(so, itemIndex, offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetPostingN(itup, i),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tupleOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pstate.continuescan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* there can't be <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more matches, so stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreLeft = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = OffsetNumberPrev(offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(itemIndex &gt;= <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.firstItem = itemIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.lastItem = MaxTIDsPerBTreePage - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.itemIndex = MaxTIDsPerBTreePage - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (so-&gt;currPos.firstItem &lt;= so-&gt;currPos.lastItem);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Save an index item into so-&gt;currPos.items[itemIndex] */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1940">&#x200c;</a></span><span class="linkable">_bt_saveitem</span>(BTScanOpaque so, <span class="Type">int</span> itemIndex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber offnum, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanPosItem *currItem = &amp;so-&gt;currPos.items[itemIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BTreeTupleIsPivot(itup) &amp;&amp; !BTreeTupleIsPosting(itup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currItem-&gt;heapTid = itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; currItem-&gt;indexOffset = offnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currTuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupsz = IndexTupleSize(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currItem-&gt;tupleOffset = so-&gt;currPos.nextTupleOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(so-&gt;currTuples + so-&gt;currPos.nextTupleOffset, itup, itupsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.nextTupleOffset += MAXALIGN(itupsz);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Setup state to save TIDs/items from a single posting list tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Saves an index item into so-&gt;currPos.items[itemIndex] for TID that is<br/></li>
<li></span><span class="Comment"> * returned to scan first.&nbsp; Second or subsequent TIDs for posting list should<br/></li>
<li></span><span class="Comment"> * be saved by calling <a href="#L2008" title="access/nbtree/nbtsearch.c:2008">_bt_savepostingitem</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns an offset into tuple storage space that <a href="../../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> tuple is stored at if<br/></li>
<li></span><span class="Comment"> * needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1970">&#x200c;</a></span><span class="linkable">_bt_setuppostingitems</span>(BTScanOpaque so, <span class="Type">int</span> itemIndex, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer heapTid, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanPosItem *currItem = &amp;so-&gt;currPos.items[itemIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BTreeTupleIsPosting(itup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currItem-&gt;heapTid = *heapTid;<br/></li>
<li>&nbsp; &nbsp; currItem-&gt;indexOffset = offnum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currTuples)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save base IndexTuple (truncate posting list) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; base;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; itupsz = BTreeTupleGetPostingOffset(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itupsz = MAXALIGN(itupsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currItem-&gt;tupleOffset = so-&gt;currPos.nextTupleOffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base = (IndexTuple) (so-&gt;currTuples + so-&gt;currPos.nextTupleOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(base, itup, itupsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Defensively reduce work area index tuple header size */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; base-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; base-&gt;t_info |= itupsz;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.nextTupleOffset += itupsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> currItem-&gt;tupleOffset;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Save an index item into so-&gt;currPos.items[itemIndex] for current posting<br/></li>
<li></span><span class="Comment"> * tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assumes that <a href="#L1970" title="access/nbtree/nbtsearch.c:1970">_bt_setuppostingitems</a>() has already been called for current<br/></li>
<li></span><span class="Comment"> * posting list tuple.&nbsp; Caller passes its return value as tupleOffset.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L2008">&#x200c;</a></span><span class="linkable">_bt_savepostingitem</span>(BTScanOpaque so, <span class="Type">int</span> itemIndex, OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer heapTid, <span class="Type">int</span> tupleOffset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanPosItem *currItem = &amp;so-&gt;currPos.items[itemIndex];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; currItem-&gt;heapTid = *heapTid;<br/></li>
<li>&nbsp; &nbsp; currItem-&gt;indexOffset = offnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Have index-only scans return the same base IndexTuple for every TID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that originates from the same posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; currItem-&gt;tupleOffset = tupleOffset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a>() -- Step to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page containing valid data for scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, if so-&gt;currPos.buf is valid the buffer is pinned but not locked;<br/></li>
<li></span><span class="Comment"> * if pinned, we'll drop the pin <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> moving to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.&nbsp; The buffer is<br/></li>
<li></span><span class="Comment"> * not locked on entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For success on a scan using a non-MVCC snapshot we hold a pin, but not a<br/></li>
<li></span><span class="Comment"> * read lock, on that page.&nbsp; If we do not hold the pin, we set so-&gt;currPos.buf<br/></li>
<li></span><span class="Comment"> * to InvalidBuffer.&nbsp; We return true to indicate success.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2036">&#x200c;</a></span><span class="linkable">_bt_steppage</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(BTScanPosIsValid(so-&gt;currPos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Before leaving current page, deal with <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> killed items */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;numKilled &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtutils.c.html#L4175" title="access/nbtree/nbtutils.c:4175">_bt_killitems</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Before we modify currPos, make a copy of the page data if there was a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark position that needs it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;markItemIndex &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bump pin on current buffer for assignment to mark buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsPinned(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L4882" title="storage/buffer/bufmgr.c:4882">IncrBufferRefCount</a>(so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;so-&gt;markPos, &amp;so-&gt;currPos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offsetof(BTScanPosData, items[<span class="Constant">1</span>]) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so-&gt;currPos.lastItem * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTScanPosItem));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;markTuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(so-&gt;markTuples, so-&gt;currTuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; so-&gt;currPos.nextTupleOffset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markPos.itemIndex = so-&gt;markItemIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markItemIndex = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're just about to start the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> primitive index scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (possible with a scan that has arrays keys, and needs to <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * continue in the current scan direction), moreLeft/moreRight only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indicate the end of the current primitive index scan.&nbsp; They must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * never be taken to indicate that the top-level index scan has ended<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (that would be wrong).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could handle this case by treating the current array keys as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * markPos state.&nbsp; But depending on the current array state like this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would add complexity.&nbsp; Instead, we just unset markPos's copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * moreRight or moreLeft (whichever might be affected), while making<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * btrestpos reset the scan's arrays to their initial scan positions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In effect, btrestpos leaves advancing the arrays up to the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a> call (that takes place after it has restored markPos).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(so-&gt;markPos.dir == dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;needPrimScan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markPos.moreRight = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;markPos.moreLeft = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Walk right to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page with data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Seize the scan to get the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> block number; if the scan has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ended already, bail out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a>(scan, &amp;blkno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* release the previous buffer, if pinned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not parallel, so use the previously-saved nextPage link. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = so-&gt;currPos.nextPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember we left a page with data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreLeft = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* release the previous buffer, if pinned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember we left a page with data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreRight = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Seize the scan to get the current block number; if the scan has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ended already, bail out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a>(scan, &amp;blkno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not parallel, so just use our own notion of the current page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = so-&gt;currPos.currPage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2168" title="access/nbtree/nbtsearch.c:2168">_bt_readnextpage</a>(scan, blkno, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have at least one item to return as scan's <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L61" title="access/nbtree/nbtsearch.c:61">_bt_drop_lock_and_maybe_pin</a>(scan, &amp;so-&gt;currPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2168" title="access/nbtree/nbtsearch.c:2168">_bt_readnextpage</a>() -- Read <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page containing valid data for scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success exit, so-&gt;currPos is updated to contain data from the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * interesting page, and we return true.&nbsp; Caller must release the lock (and<br/></li>
<li></span><span class="Comment"> * maybe the pin) on the buffer on success exit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there are no more matching <a href="../transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> in the given direction, we drop all<br/></li>
<li></span><span class="Comment"> * locks and pins, set so-&gt;currPos.buf to InvalidBuffer, and return false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2168">&#x200c;</a></span><span class="linkable">_bt_readnextpage</span>(IndexScanDesc scan, BlockNumber blkno, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; status;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we're at end of scan, give up and mark parallel scan as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done, so that all the workers can finish their scan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NONE || !so-&gt;currPos.moreRight)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for interrupts while we're not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* step right one page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for deleted page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_IGNORE(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(rel, blkno, scan-&gt;xs_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matches on this page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note that this will clear moreRight if we can stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>(scan, dir, P_FIRSTDATAKEY(opaque), <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page be processed by parallel worker */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a>(scan, opaque-&gt;btpo_next);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nope, keep going */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a>(scan, &amp;blkno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Should only happen in parallel cases, when some other backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * advanced the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currPos.currPage != blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosUnpinIfPinned(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.currPage = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk left to the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page with data.&nbsp; This is much more complex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * than the walk-right case because of the possibility that the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to our left splits while we are in flight to it, plus the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possibility that the page we were on gets deleted after we leave<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.&nbsp; See nbtree/README for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It might be possible to rearrange this code to have less overhead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in pinning and locking, but that would require capturing the left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sibling block number when the page is initially read, and then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * optimistically starting there (rather than pinning the page twice).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is not clear that this would be worth the complexity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BTScanPosIsPinned(so-&gt;currPos))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1039" title="access/nbtree/nbtpage.c:1039">_bt_lockbuf</a>(rel, so-&gt;currPos.buf, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, so-&gt;currPos.currPage, BT_READ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done if we know there are no matching keys to the left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!so-&gt;currPos.moreLeft)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Step to <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> physical page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = <a href="#L2365" title="access/nbtree/nbtsearch.c:2365">_bt_walk_left</a>(rel, so-&gt;currPos.buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we're physically at end of index, return failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;currPos.buf == InvalidBuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L732" title="access/nbtree/nbtree.c:732">_bt_parallel_done</a>(scan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Okay, we managed to move left to a non-deleted page. Done if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not half-dead and contains matching tuples. Else loop back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and do it all again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_IGNORE(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(rel, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(so-&gt;currPos.buf), scan-&gt;xs_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see if there are <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> matches on this page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note that this will clear moreLeft if we can stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>(scan, dir, PageGetMaxOffsetNumber(page), <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page be processed by parallel worker */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtree.c.html#L709" title="access/nbtree/nbtree.c:709">_bt_parallel_release</a>(scan, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(so-&gt;currPos.buf));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For parallel scans, get the last page scanned as it is quite<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible that by the time we try to seize the scan, some other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker has already advanced the scan to a different page.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must continue based on the latest page scanned by <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;parallel_scan != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="nbtree.c.html#L605" title="access/nbtree/nbtree.c:605">_bt_parallel_seize</a>(scan, &amp;blkno, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!status)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.buf = <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2334" title="access/nbtree/nbtsearch.c:2334">_bt_parallel_readpage</a>() -- Read current page containing valid data for scan<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On success, release lock and maybe pin on buffer.&nbsp; We return true to<br/></li>
<li></span><span class="Comment"> * indicate success.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2334">&#x200c;</a></span><span class="linkable">_bt_parallel_readpage</span>(IndexScanDesc scan, BlockNumber blkno, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!so-&gt;needPrimScan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2650" title="access/nbtree/nbtsearch.c:2650">_bt_initialize_more_data</a>(so, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2168" title="access/nbtree/nbtsearch.c:2168">_bt_readnextpage</a>(scan, blkno, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We have at least one item to return as scan's <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L61" title="access/nbtree/nbtsearch.c:61">_bt_drop_lock_and_maybe_pin</a>(scan, &amp;so-&gt;currPos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2365" title="access/nbtree/nbtsearch.c:2365">_bt_walk_left</a>() -- step left one page, if possible<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The given buffer must be pinned and read-locked.&nbsp; This will be dropped<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> stepping left.&nbsp; On return, we have pin and read lock on the<br/></li>
<li></span><span class="Comment"> * returned page, instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidBuffer if there is no page to the left (no lock is held<br/></li>
<li></span><span class="Comment"> * in that case).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is possible for the returned leaf page to be half-dead; caller must<br/></li>
<li></span><span class="Comment"> * check that condition and step left again when required.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Buffer<br/></li>
<li><a id="L2365">&#x200c;</a><span class="linkable">_bt_walk_left</span>(Relation rel, Buffer buf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber obknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber lblkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we're at end of tree, release buf and return failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_LEFTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remember original page we are stepping left from */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; obknum = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* step left */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blkno = lblkno = opaque-&gt;btpo_prev;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1023" title="access/nbtree/nbtpage.c:1023">_bt_relbuf</a>(rel, buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check for interrupts while we're not holding <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffer lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L845" title="access/nbtree/nbtpage.c:845">_bt_getbuf</a>(rel, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this isn't the page we want, walk right till we <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> what we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want --- but go no more than four hops (an arbitrary limit). If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the correct page by then, the most likely bet is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original page got deleted and isn't in the sibling chain at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore, not that its left sibling got split more than four times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that it is correct to test P_ISDELETED not P_IGNORE here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because half-dead pages are still in the sibling chain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_ISDELETED(opaque) &amp;&amp; opaque-&gt;btpo_next == obknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found desired page, return it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque) || ++tries &gt; <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, buf, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return to the original page to see what's up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, buf, obknum, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It was deleted.&nbsp; Move right to first nondeleted page (there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * must be one); that is the page that has acquired the deleted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one's keyspace, so stepping left from it will take us where we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;fell off the end of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, buf, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!P_ISDELETED(opaque))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now return to top of loop, resetting obknum to point to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nondeleted page, and try again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It wasn't deleted; the explanation had better be that the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the left got split or deleted. Without this check, we'd go<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into an infinite loop if there's anything wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_prev == lblkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> left sibling of block </span><span class="Special">%u</span><span class="Constant"> in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; obknum, RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Okay to try again with new lblkno value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2479" title="access/nbtree/nbtsearch.c:2479">_bt_get_endpoint</a>() -- Find the first or last page on a given tree level<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the index is empty, we will return InvalidBuffer; <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other failure<br/></li>
<li></span><span class="Comment"> * condition causes ereport().&nbsp; We will not return a dead page.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The returned buffer is pinned and read-locked.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Buffer<br/></li>
<li><a id="L2479">&#x200c;</a><span class="linkable">_bt_get_endpoint</span>(Relation rel, uint32 level, <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> rightmost)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are looking for a leaf page, okay to descend from fast root;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise better descend from true root.&nbsp; (There is no point in being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smarter about intermediate levels.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L344" title="access/nbtree/nbtpage.c:344">_bt_getroot</a>(rel, <span class="Constant">NULL</span>, BT_READ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L580" title="access/nbtree/nbtpage.c:580">_bt_gettrueroot</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidBuffer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we landed on a deleted page, step right to <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a live page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (there must be one).&nbsp; Also, if we want the rightmost page, step<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * right if needed to get to it (this could happen if the page split<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since we obtained a pointer to it).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (P_IGNORE(opaque) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (rightmost &amp;&amp; !P_RIGHTMOST(opaque)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno = opaque-&gt;btpo_next;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blkno == P_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;fell off the end of index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, buf, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_level == level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opaque-&gt;btpo_level &lt; level)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDEX_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;btree level </span><span class="Special">%u</span><span class="Constant"> not found in index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; level, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Descend to leftmost or rightmost child page */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rightmost)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offnum = P_FIRSTDATAKEY(opaque);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, PageGetItemId(page, offnum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blkno = BTreeTupleGetDownLink(itup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="nbtpage.c.html#L1003" title="access/nbtree/nbtpage.c:1003">_bt_relandgetbuf</a>(rel, buf, blkno, BT_READ);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L2560" title="access/nbtree/nbtsearch.c:2560">_bt_endpoint</a>() -- Find the first or last page in the index, and scan<br/></li>
<li></span><span class="Comment"> * from there to the first key satisfying all the quals.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used by <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>() to set up a scan when we've determined<br/></li>
<li></span><span class="Comment"> * that the scan must start at the beginning or end of the index (for<br/></li>
<li></span><span class="Comment"> * a forward or backward scan respectively).&nbsp; Exit conditions are the<br/></li>
<li></span><span class="Comment"> * same as for <a href="#L876" title="access/nbtree/nbtsearch.c:876">_bt_first</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2560">&#x200c;</a></span><span class="linkable">_bt_endpoint</span>(IndexScanDesc scan, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel = scan-&gt;indexRelation;<br/></li>
<li>&nbsp; &nbsp; BTScanOpaque so = (BTScanOpaque) scan-&gt;opaque;<br/></li>
<li>&nbsp; &nbsp; Buffer&nbsp; &nbsp; &nbsp; &nbsp; buf;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page;<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque;<br/></li>
<li>&nbsp; &nbsp; OffsetNumber start;<br/></li>
<li>&nbsp; &nbsp; BTScanPosItem *currItem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan down to the leftmost or rightmost leaf page.&nbsp; This is a simplified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * version of <a href="#L96" title="access/nbtree/nbtsearch.c:96">_bt_search</a>().&nbsp; We don't maintain a stack since we know we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't need it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="#L2479" title="access/nbtree/nbtsearch.c:2479">_bt_get_endpoint</a>(rel, <span class="Constant">0</span>, ScanDirectionIsBackward(dir));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BufferIsValid(buf))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Empty index. Lock the whole relation, as nothing finer to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2561" title="storage/lmgr/predicate.c:2561">PredicateLockRelation</a>(rel, scan-&gt;xs_snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTScanPosInvalidate(so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/lmgr/predicate.c.html#L2584" title="storage/lmgr/predicate.c:2584">PredicateLockPage</a>(rel, <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf), scan-&gt;xs_snapshot);<br/></li>
<li>&nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; Assert(P_ISLEAF(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There could be dead pages to the left, so not this: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assert(P_LEFTMOST(opaque)); */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ScanDirectionIsBackward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(P_RIGHTMOST(opaque));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid scan direction: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) dir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; start = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember which buffer we have pinned */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;currPos.buf = buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2650" title="access/nbtree/nbtsearch.c:2650">_bt_initialize_more_data</a>(so, dir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now load data from the first page of the scan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1556" title="access/nbtree/nbtsearch.c:1556">_bt_readpage</a>(scan, dir, start, <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no actually-matching data on this page.&nbsp; Try to advance to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> page.&nbsp; Return false if there's no matching data at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="nbtpage.c.html#L1070" title="access/nbtree/nbtpage.c:1070">_bt_unlockbuf</a>(scan-&gt;indexRelation, so-&gt;currPos.buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L2036" title="access/nbtree/nbtsearch.c:2036">_bt_steppage</a>(scan, dir))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have at least one item to return as scan's first item */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="access/nbtree/nbtsearch.c:61">_bt_drop_lock_and_maybe_pin</a>(scan, &amp;so-&gt;currPos);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, itemIndex says what to return */<br/></li>
<li></span>&nbsp; &nbsp; currItem = &amp;so-&gt;currPos.items[so-&gt;currPos.itemIndex];<br/></li>
<li>&nbsp; &nbsp; scan-&gt;xs_heaptid = currItem-&gt;heapTid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (scan-&gt;xs_want_itup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan-&gt;xs_itup = (IndexTuple) (so-&gt;currTuples + currItem-&gt;tupleOffset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2650" title="access/nbtree/nbtsearch.c:2650">_bt_initialize_more_data</a>() -- <a href="../../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> moreLeft, moreRight and scan dir<br/></li>
<li></span><span class="Comment"> * from currPos<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L2650">&#x200c;</a></span><span class="linkable">_bt_initialize_more_data</span>(BTScanOpaque so, ScanDirection dir)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; so-&gt;currPos.dir = dir;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (so-&gt;needPrimScan)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(so-&gt;numArrayKeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreLeft = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreRight = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;needPrimScan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ScanDirectionIsForward(dir))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreLeft = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreRight = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreLeft = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; so-&gt;currPos.moreRight = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; so-&gt;numKilled = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just paranoia */<br/></li>
<li></span>&nbsp; &nbsp; so-&gt;markItemIndex = -<span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ditto */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
