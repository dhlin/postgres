<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>access/nbtree/nbtdedup.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

  <h1>access/nbtree/nbtdedup.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L648">_bt_bottomupdel_finish_pending</a></li>
<li><a href="#L307">_bt_bottomupdel_pass</a></li>
<li><a href="#L555">_bt_dedup_finish_pending</a></li>
<li><a href="#L58">_bt_dedup_pass</a></li>
<li><a href="#L484">_bt_dedup_save_htid</a></li>
<li><a href="#L433">_bt_dedup_start_pending</a></li>
<li><a href="#L782">_bt_do_singleval</a></li>
<li><a href="#L864">_bt_form_posting</a></li>
<li><a href="#L1078">_bt_posting_valid</a></li>
<li><a href="#L822">_bt_singleval_fillfactor</a></li>
<li><a href="#L1022">_bt_swap_posting</a></li>
<li><a href="#L924">_bt_update_posting</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * nbtdedup.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Deduplicate or bottom-up delete items in Postgres btrees.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/access/nbtree/nbtdedup.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/nbtxlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L648" title="access/nbtree/nbtdedup.c:648">_bt_bottomupdel_finish_pending</a>(Page page, BTDedupState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TM_IndexDeleteOp *delstate);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L782" title="access/nbtree/nbtdedup.c:782">_bt_do_singleval</a>(Relation rel, Page page, BTDedupState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber minoff, IndexTuple newitem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L822" title="access/nbtree/nbtdedup.c:822">_bt_singleval_fillfactor</a>(Page page, BTDedupState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size newitemsz);<br/></li>
<li><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(IndexTuple posting);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a deduplication pass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The general approach taken here is to perform as much deduplication as<br/></li>
<li></span><span class="Comment"> * possible to free as much space as possible.&nbsp; Note, however, that &quot;single<br/></li>
<li></span><span class="Comment"> * value&quot; strategy is used for !bottomupdedup callers when the page is full of<br/></li>
<li></span><span class="Comment"> * tuples of a single value.&nbsp; Deduplication passes that apply the strategy<br/></li>
<li></span><span class="Comment"> * will leave behind a few untouched tuples at the end of the page, preparing<br/></li>
<li></span><span class="Comment"> * the page for an anticipated page split that uses nbtsplitloc.c's own single<br/></li>
<li></span><span class="Comment"> * value strategy.&nbsp; Our high level goal is to delay merging the untouched<br/></li>
<li></span><span class="Comment"> * tuples until after the page splits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When a call to <a href="#L307" title="access/nbtree/nbtdedup.c:307">_bt_bottomupdel_pass</a>() just took place (and failed), our<br/></li>
<li></span><span class="Comment"> * high level goal is to prevent a page split entirely by buying more time.<br/></li>
<li></span><span class="Comment"> * We still hope that a page split can be avoided altogether.&nbsp; That's why<br/></li>
<li></span><span class="Comment"> * single value strategy is not even considered for bottomupdedup callers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The page will have to be split if we cannot successfully free at least<br/></li>
<li></span><span class="Comment"> * newitemsz (we also need space for newitem's line pointer, which isn't<br/></li>
<li></span><span class="Comment"> * included in caller's newitemsz).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Caller should have already deleted all existing items with their<br/></li>
<li></span><span class="Comment"> * LP_DEAD bits set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L58">&#x200c;</a></span><span class="linkable">_bt_dedup_pass</span>(Relation rel, Buffer buf, IndexTuple newitem, Size newitemsz,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> bottomupdedup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; newpage;<br/></li>
<li>&nbsp; &nbsp; BTDedupState state;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; pagesaving <a href="../../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; singlevalstrat = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Passed-in newitemsz is MAXALIGNED but does not include line pointer */<br/></li>
<li></span>&nbsp; &nbsp; newitemsz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize deduplication state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It would be possible for maxpostingsize (limit on posting list tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size) to be set to one third of the page.&nbsp; However, it seems like a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * good idea to limit the size of posting lists to one sixth of a page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * That ought to leave us with a good split point when pages full of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicates can be split several times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state = (BTDedupState) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTDedupStateData));<br/></li>
<li>&nbsp; &nbsp; state-&gt;deduplicate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nmaxitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;maxpostingsize = <a href="../../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(BTMaxItemSize(page) / <span class="Constant">2</span>, INDEX_SIZE_MASK);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Metadata about base tuple of current pending posting list */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;base = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;baseoff = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; state-&gt;basetupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Metadata about current pending posting list TIDs */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;htids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;maxpostingsize);<br/></li>
<li>&nbsp; &nbsp; state-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Size of all physical tuples to be replaced by pending posting list */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;phystupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nintervals should be initialized to zero */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nintervals = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; minoff = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Consider applying &quot;single value&quot; strategy, though only if the page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems likely to be split in the near future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bottomupdedup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; singlevalstrat = <a href="#L782" title="access/nbtree/nbtdedup.c:782">_bt_do_singleval</a>(rel, page, state, minoff, newitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Deduplicate items from page, and write them to newpage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the original page's LSN into newpage copy.&nbsp; This will become the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * updated version of the page.&nbsp; We need this because <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examine the LSN and possibly <a href="../../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> it in a page image.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newpage = <a href="../../storage/page/bufpage.c.html#L402" title="storage/page/bufpage.c:402">PageGetTempPageCopySpecial</a>(page);<br/></li>
<li>&nbsp; &nbsp; PageSetLSN(newpage, PageGetLSN(page));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy high key, if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!P_RIGHTMOST(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; hitemid = PageGetItemId(page, P_HIKEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; hitemsz = ItemIdGetLength(hitemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; hitem = (IndexTuple) PageGetItem(page, hitemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(newpage, (Item) hitem, hitemsz, P_HIKEY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;deduplication failed to add highkey&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = minoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!ItemIdIsDead(itemid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum == minoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No previous/base tuple for the data item -- use the data item<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as base tuple of pending posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(state, itup, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;deduplicate &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(rel, state-&gt;base, itup) &gt; nkeyatts &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L484" title="access/nbtree/nbtdedup.c:484">_bt_dedup_save_htid</a>(state, itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to base tuple of pending posting list.&nbsp; Heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TID(s) for itup have been saved in state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tuple is not <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to pending posting list tuple, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L484" title="access/nbtree/nbtdedup.c:484">_bt_dedup_save_htid</a>() opted to not <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> current item into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pending posting list for some other reason (e.g., adding more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * TIDs would have caused posting list to exceed current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maxpostingsize).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If state contains pending posting list with more than one item,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * form new posting tuple and add it to our temp page (newpage).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else add pending interval's base tuple to the temp page as-is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pagesaving += <a href="#L555" title="access/nbtree/nbtdedup.c:555">_bt_dedup_finish_pending</a>(newpage, state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (singlevalstrat)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Single value strategy's extra steps.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lower maxpostingsize for sixth and final large posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple at the point where 5 maxpostingsize-capped tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have either been formed or observed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When a sixth maxpostingsize-capped item is formed/observed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stop merging together tuples altogether.&nbsp; The few tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that remain at the end of the page won't be merged together<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at all (at least not until after a future page split takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * place, when this page's newly allocated right sibling page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gets its first deduplication pass).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nmaxitems == <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L822" title="access/nbtree/nbtdedup.c:822">_bt_singleval_fillfactor</a>(page, state, newitemsz);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (state-&gt;nmaxitems == <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;deduplicate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; singlevalstrat = <span class="Constant">false</span>; <span class="Comment">/* won't be back here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* itup starts new pending posting list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(state, itup, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle the last item */<br/></li>
<li></span>&nbsp; &nbsp; pagesaving += <a href="#L555" title="access/nbtree/nbtdedup.c:555">_bt_dedup_finish_pending</a>(newpage, state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no items suitable for deduplication were found, newpage must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly the same as the original page, so just return from function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could determine whether or not to proceed on the basis the space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * savings being sufficient to avoid an immediate page split instead.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't do that because there is some small value in nbtsplitloc.c always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operating against a page that is fully deduplicated (apart from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * newitem).&nbsp; Besides, most of the cost has already been paid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nintervals == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(newpage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;htids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By here, it's clear that deduplication will definitely go ahead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clear the BTP_HAS_GARBAGE page flag.&nbsp; The index must be a heapkeyspace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index, and as such we'll never pay attention to BTP_HAS_GARBAGE anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But keep things tidy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (P_HAS_GARBAGE(opaque))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BTPageOpaque nopaque = BTPageGetOpaque(newpage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nopaque-&gt;btpo_flags &amp;= ~BTP_HAS_GARBAGE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/page/bufpage.c.html#L424" title="storage/page/bufpage.c:424">PageRestoreTempPage</a>(newpage, page);<br/></li>
<li>&nbsp; &nbsp; <a href="../../storage/buffer/bufmgr.c.html#L2474" title="storage/buffer/bufmgr.c:2474">MarkBufferDirty</a>(buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* XLOG stuff */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_btree_dedup xlrec_dedup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec_dedup.nintervals = state-&gt;nintervals;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L242" title="access/transam/xloginsert.c:242">XLogRegisterBuffer</a>(<span class="Constant">0</span>, buf, REGBUF_STANDARD);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec_dedup, SizeOfBtreeDedup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The intervals array is not in the buffer, but pretend that it is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> stores the whole buffer, the array need not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stored too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../transam/xloginsert.c.html#L405" title="access/transam/xloginsert.c:405">XLogRegisterBufData</a>(<span class="Constant">0</span>, (<span class="Type">char</span> *) state-&gt;intervals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nintervals * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTDedupInterval));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_BTREE_ID, XLOG_BTREE_DEDUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PageSetLSN(page, recptr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Local space accounting should agree with page accounting */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pagesaving &lt; newitemsz || <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page) &gt;= newitemsz);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cannot leak memory here */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;htids);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform bottom-up index deletion pass.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See if duplicate index tuples (plus certain nearby tuples) are eligible to<br/></li>
<li></span><span class="Comment"> * be deleted via bottom-up index deletion.&nbsp; The high level goal here is to<br/></li>
<li></span><span class="Comment"> * entirely prevent &quot;unnecessary&quot; page splits caused by MVCC version churn<br/></li>
<li></span><span class="Comment"> * from UPDATEs (when the UPDATEs don't logically modify <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the columns<br/></li>
<li></span><span class="Comment"> * covered by the 'rel' index).&nbsp; This is qualitative, not quantitative -- we<br/></li>
<li></span><span class="Comment"> * do not particularly care about once-off opportunities to delete many index<br/></li>
<li></span><span class="Comment"> * tuples together.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See nbtree/README for details on the design of nbtree bottom-up deletion.<br/></li>
<li></span><span class="Comment"> * See access/tableam.h for a description of how we're expected to cooperate<br/></li>
<li></span><span class="Comment"> * with the tableam.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, in which case caller can assume page split will be<br/></li>
<li></span><span class="Comment"> * avoided for a reasonable amount of time.&nbsp; Returns false when caller should<br/></li>
<li></span><span class="Comment"> * deduplicate the page (if possible at all).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Occasionally we return true despite failing to delete enough items to<br/></li>
<li></span><span class="Comment"> * avoid a split.&nbsp; This makes caller <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> deduplication and go split the page<br/></li>
<li></span><span class="Comment"> * right away.&nbsp; Our return value is always just advisory information.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Caller should have already deleted all existing items with their<br/></li>
<li></span><span class="Comment"> * LP_DEAD bits set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L307">&#x200c;</a></span><span class="linkable">_bt_bottomupdel_pass</span>(Relation rel, Buffer buf, Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Size newitemsz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber offnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxoff;<br/></li>
<li>&nbsp; &nbsp; Page&nbsp; &nbsp; &nbsp; &nbsp; page = BufferGetPage(buf);<br/></li>
<li>&nbsp; &nbsp; BTPageOpaque opaque = BTPageGetOpaque(page);<br/></li>
<li>&nbsp; &nbsp; BTDedupState state;<br/></li>
<li>&nbsp; &nbsp; TM_IndexDeleteOp delstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; neverdedup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Passed-in newitemsz is MAXALIGNED but does not include line pointer */<br/></li>
<li></span>&nbsp; &nbsp; newitemsz += <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize deduplication state */<br/></li>
<li></span>&nbsp; &nbsp; state = (BTDedupState) <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTDedupStateData));<br/></li>
<li>&nbsp; &nbsp; state-&gt;deduplicate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nmaxitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;maxpostingsize = BLCKSZ; <span class="Comment">/* We're not really deduplicating */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;base = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;baseoff = InvalidOffsetNumber;<br/></li>
<li>&nbsp; &nbsp; state-&gt;basetupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;htids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(state-&gt;maxpostingsize);<br/></li>
<li>&nbsp; &nbsp; state-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;phystupsize = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nintervals = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize tableam state that describes bottom-up index deletion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We'll go on to ask the tableam to search for TIDs whose index tuples we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can safely delete.&nbsp; The tableam will search until our leaf page space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target is satisfied, or until the cost of continuing with the tableam<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation seems too high.&nbsp; It focuses its efforts on TIDs associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with duplicate index tuples that we mark &quot;promising&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This space target is a little arbitrary.&nbsp; The tableam must be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep the costs and benefits in balance.&nbsp; We provide the tableam with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exhaustive information about what might work, without directly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concerning ourselves with avoiding work during the tableam call.&nbsp; Our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * role in costing the bottom-up deletion process is strictly advisory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; delstate.irel = rel;<br/></li>
<li>&nbsp; &nbsp; delstate.iblknum = <a href="../../storage/buffer/bufmgr.c.html#L3667" title="storage/buffer/bufmgr.c:3667">BufferGetBlockNumber</a>(buf);<br/></li>
<li>&nbsp; &nbsp; delstate.bottomup = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; delstate.bottomupfreespace = Max(BLCKSZ / <span class="Constant">16</span>, newitemsz);<br/></li>
<li>&nbsp; &nbsp; delstate.ndeltids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; delstate.deltids = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MaxTIDsPerBTreePage * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexDelete));<br/></li>
<li>&nbsp; &nbsp; delstate.status = <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MaxTIDsPerBTreePage * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TM_IndexStatus));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; minoff = P_FIRSTDATAKEY(opaque);<br/></li>
<li>&nbsp; &nbsp; maxoff = PageGetMaxOffsetNumber(page);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (offnum = minoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum &lt;= maxoff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; offnum = OffsetNumberNext(offnum))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!ItemIdIsDead(itemid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offnum == minoff)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* itup starts first pending interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(state, itup, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(rel, state-&gt;base, itup) &gt; nkeyatts &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L484" title="access/nbtree/nbtdedup.c:484">_bt_dedup_save_htid</a>(state, itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tuple is <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>; just added its TIDs to pending interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finalize interval -- move its TIDs to delete state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L648" title="access/nbtree/nbtdedup.c:648">_bt_bottomupdel_finish_pending</a>(page, state, &amp;delstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* itup starts new pending interval */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L433" title="access/nbtree/nbtdedup.c:433">_bt_dedup_start_pending</a>(state, itup, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finalize final interval -- move its TIDs to delete state */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L648" title="access/nbtree/nbtdedup.c:648">_bt_bottomupdel_finish_pending</a>(page, state, &amp;delstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't give up <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in the event of having few (or even zero)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * promising tuples for the tableam because it's not up to us as the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AM to manage costs (note that the tableam might have heuristics of its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * own that work out what to do).&nbsp; We should at least avoid having our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller do a useless deduplication pass after we return in the event of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero promising tuples, though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; neverdedup = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nintervals == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; neverdedup = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state-&gt;htids);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Ask tableam which TIDs are deletable, then physically delete them */<br/></li>
<li></span>&nbsp; &nbsp; <a href="nbtpage.c.html#L1513" title="access/nbtree/nbtpage.c:1513">_bt_delitems_delete_check</a>(rel, buf, heapRel, &amp;delstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(delstate.deltids);<br/></li>
<li>&nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(delstate.status);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report &quot;success&quot; to caller unconditionally to avoid deduplication */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (neverdedup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't dedup when we won't end up back here <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time soon anyway */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../../storage/page/bufpage.c.html#L958" title="storage/page/bufpage.c:958">PageGetExactFreeSpace</a>(page) &gt;= Max(BLCKSZ / <span class="Constant">24</span>, newitemsz);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new pending posting list tuple based on caller's base tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Every tuple processed by deduplication either becomes the base tuple for a<br/></li>
<li></span><span class="Comment"> * posting list, or gets its heap TID(s) accepted into a pending posting list.<br/></li>
<li></span><span class="Comment"> * A tuple that starts out as the base tuple for a posting list will only<br/></li>
<li></span><span class="Comment"> * actually be rewritten within <a href="#L555" title="access/nbtree/nbtdedup.c:555">_bt_dedup_finish_pending</a>() when it turns out<br/></li>
<li></span><span class="Comment"> * that there are duplicates that can be merged into the base tuple.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L433">&#x200c;</a></span><span class="linkable">_bt_dedup_start_pending</span>(BTDedupState state, IndexTuple base,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber baseoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nhtids == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nitems == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(!BTreeTupleIsPivot(base));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy heap TID(s) from new base tuple for new candidate posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into working state's array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(base))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;htids, &amp;base-&gt;t_tid, <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nhtids = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;basetupsize = IndexTupleSize(base);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nposting;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nposting = BTreeTupleGetNPosting(base);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(state-&gt;htids, BTreeTupleGetPosting(base),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * nposting);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nhtids = nposting;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* basetupsize should not include existing posting list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;basetupsize = BTreeTupleGetPostingOffset(base);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save new base tuple itself -- it'll be needed if we actually create a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * new posting list from new pending posting list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must maintain physical size of all existing tuples (including line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pointer overhead) so that we can calculate space savings on page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nitems = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;base = base;<br/></li>
<li>&nbsp; &nbsp; state-&gt;baseoff = baseoff;<br/></li>
<li>&nbsp; &nbsp; state-&gt;phystupsize = MAXALIGN(IndexTupleSize(base)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also save baseoff in pending state for interval */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;intervals[state-&gt;nintervals].baseoff = state-&gt;baseoff;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Save itup heap TID(s) into pending posting list where possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns <a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a> indicating if the pending posting list managed by state <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * includes itup's heap TID(s).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L484">&#x200c;</a></span><span class="linkable">_bt_dedup_save_htid</span>(BTDedupState state, IndexTuple itup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtids;<br/></li>
<li>&nbsp; &nbsp; ItemPointer htids;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; mergedtupsz;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BTreeTupleIsPivot(itup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nhtids = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htids = &amp;itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nhtids = BTreeTupleGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htids = BTreeTupleGetPosting(itup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't append (have caller finish pending posting list as-is) if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appending heap TID(s) from itup would put us over maxpostingsize limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This calculation needs to match the code used within <a href="#L864" title="access/nbtree/nbtdedup.c:864">_bt_form_posting</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for new posting list tuples.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; mergedtupsz = MAXALIGN(state-&gt;basetupsize +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (state-&gt;nhtids + nhtids) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (mergedtupsz &gt; state-&gt;maxpostingsize)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Count this as an oversized item for single value strategy, though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only when there are 50 TIDs in the final posting list tuple.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limit (which is fairly arbitrary) avoids confusion about how many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1/6 of a page tuples have been encountered/created by the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deduplication pass.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: We deliberately don't consider which deduplication pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * merged together tuples to create this item (could be a previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deduplication pass, or current pass).&nbsp; See <a href="#L782" title="access/nbtree/nbtdedup.c:782">_bt_do_singleval</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * comments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nhtids &gt; <span class="Constant">50</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nmaxitems++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save heap TIDs to pending posting list tuple -- itup can be merged into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending posting list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nitems++;<br/></li>
<li>&nbsp; &nbsp; memcpy(state-&gt;htids + state-&gt;nhtids, htids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * nhtids);<br/></li>
<li>&nbsp; &nbsp; state-&gt;nhtids += nhtids;<br/></li>
<li>&nbsp; &nbsp; state-&gt;phystupsize += MAXALIGN(IndexTupleSize(itup)) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finalize pending posting list tuple, and add it to the page.&nbsp; Final tuple<br/></li>
<li></span><span class="Comment"> * is based on saved base tuple, and saved list of heap TIDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns space saving from deduplicating to make a new posting list tuple.<br/></li>
<li></span><span class="Comment"> * Note that this includes line pointer overhead.&nbsp; This is zero in the case<br/></li>
<li></span><span class="Comment"> * where no deduplication was possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L555">&#x200c;</a><span class="linkable">_bt_dedup_finish_pending</span>(Page newpage, BTDedupState state)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; OffsetNumber tupoff;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; tuplesz;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; spacesaving;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nitems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nitems &lt;= state-&gt;nhtids);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;intervals[state-&gt;nintervals].baseoff == state-&gt;baseoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupoff = OffsetNumberNext(PageGetMaxOffsetNumber(newpage));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;nitems == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use original, unchanged base tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuplesz = IndexTupleSize(state-&gt;base);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplesz == MAXALIGN(IndexTupleSize(state-&gt;base)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplesz &lt;= BTMaxItemSize(newpage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(newpage, (Item) state-&gt;base, tuplesz, tupoff,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;deduplication failed to add tuple to page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spacesaving = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; final;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form a tuple with a posting list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; final = <a href="#L864" title="access/nbtree/nbtdedup.c:864">_bt_form_posting</a>(state-&gt;base, state-&gt;htids, state-&gt;nhtids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuplesz = IndexTupleSize(final);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplesz &lt;= state-&gt;maxpostingsize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Save final number of items for posting list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;intervals[state-&gt;nintervals].nitems = state-&gt;nitems;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplesz == MAXALIGN(IndexTupleSize(final)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(tuplesz &lt;= BTMaxItemSize(newpage));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PageAddItem(newpage, (Item) final, tuplesz, tupoff, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>) == InvalidOffsetNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;deduplication failed to add tuple to page&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(final);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; spacesaving = state-&gt;phystupsize - (tuplesz + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Increment nintervals, since we wrote a new posting list tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nintervals++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(spacesaving &gt; <span class="Constant">0</span> &amp;&amp; spacesaving &lt; BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset state for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> pending posting list */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;phystupsize = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> spacesaving;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finalize interval during bottom-up index deletion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * During a bottom-up pass we expect that TIDs will be recorded in dedup state<br/></li>
<li></span><span class="Comment"> * first, and then get moved over to delstate (in variable-sized batches) by<br/></li>
<li></span><span class="Comment"> * calling here.&nbsp; Call here happens when the number of TIDs in a dedup<br/></li>
<li></span><span class="Comment"> * interval is known, and interval gets finalized (i.e. when caller sees <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * tuple on the page is not a duplicate, or when caller runs out of tuples to<br/></li>
<li></span><span class="Comment"> * process from leaf page).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is where bottom-up deletion determines and remembers which entries are<br/></li>
<li></span><span class="Comment"> * duplicates.&nbsp; This will be important information to the tableam delete<br/></li>
<li></span><span class="Comment"> * infrastructure later on.&nbsp; Plain index tuple duplicates are marked<br/></li>
<li></span><span class="Comment"> * &quot;promising&quot; here, per tableam contract.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Our approach to marking entries whose TIDs come from posting lists is more<br/></li>
<li></span><span class="Comment"> * complicated.&nbsp; Posting lists can only be formed by a deduplication pass (or<br/></li>
<li></span><span class="Comment"> * during an index build), so recent version churn affecting the pointed-to<br/></li>
<li></span><span class="Comment"> * logical rows is not particularly likely.&nbsp; We may still give a weak signal<br/></li>
<li></span><span class="Comment"> * about posting list tuples' entries (by marking just one of its TIDs/entries<br/></li>
<li></span><span class="Comment"> * promising), though this is only a possibility in the event of further<br/></li>
<li></span><span class="Comment"> * duplicate index tuples in final interval that covers posting list tuple (as<br/></li>
<li></span><span class="Comment"> * in the plain tuple case).&nbsp; A weak signal/hint will be useful to the tableam<br/></li>
<li></span><span class="Comment"> * when it has no stronger signal to go with for the deletion operation as a<br/></li>
<li></span><span class="Comment"> * whole.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The heuristics we use work well in practice because we only need to give<br/></li>
<li></span><span class="Comment"> * the tableam the right _general_ idea about where to look.&nbsp; Garbage tends to<br/></li>
<li></span><span class="Comment"> * naturally get concentrated in relatively few table blocks with workloads<br/></li>
<li></span><span class="Comment"> * that bottom-up deletion targets.&nbsp; The tableam cannot possibly rank all<br/></li>
<li></span><span class="Comment"> * available table blocks sensibly based on the hints we provide, but that's<br/></li>
<li></span><span class="Comment"> * okay -- only the extremes matter.&nbsp; The tableam just needs to be able to<br/></li>
<li></span><span class="Comment"> * predict which few table blocks will have the most tuples that are safe to<br/></li>
<li></span><span class="Comment"> * delete for each deletion operation, with low variance across related<br/></li>
<li></span><span class="Comment"> * deletion operations.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L648">&#x200c;</a></span><span class="linkable">_bt_bottomupdel_finish_pending</span>(Page page, BTDedupState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TM_IndexDeleteOp *delstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dupinterval = (state-&gt;nitems &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nitems &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;nitems &lt;= state-&gt;nhtids);<br/></li>
<li>&nbsp; &nbsp; Assert(state-&gt;intervals[state-&gt;nintervals].baseoff == state-&gt;baseoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; state-&gt;nitems; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; OffsetNumber offnum = state-&gt;baseoff + i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, offnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexDelete *ideltid = &amp;delstate-&gt;deltids[delstate-&gt;ndeltids];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TM_IndexStatus *istatus = &amp;delstate-&gt;status[delstate-&gt;ndeltids];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(itup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple case: A plain non-pivot tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ideltid-&gt;tid = itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ideltid-&gt;id = delstate-&gt;ndeltids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;idxoffnum = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;knowndeletable = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;promising = dupinterval;&nbsp; &nbsp; <span class="Comment">/* simple rule */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;freespace = ItemIdGetLength(itemid) + <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemIdData);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delstate-&gt;ndeltids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complicated case: A posting list tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We make the conservative assumption that there can only be at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * most one affected logical row per posting list tuple.&nbsp; There<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be at most one promising entry in deltids to represent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this presumed lone logical row.&nbsp; Note that this isn't even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * considered unless the posting list tuple is also in an interval<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of duplicates -- this complicated rule is just a variant of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simple rule used to decide if plain index tuples are promising.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nitem = BTreeTupleGetNPosting(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; firstpromising = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lastpromising = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(itup));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dupinterval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complicated rule: either the first or last TID in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * posting list gets marked promising (if <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> at all)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber minblocklist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; midblocklist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxblocklist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer mintid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; midtid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxtid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mintid = BTreeTupleGetHeapTID(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; midtid = BTreeTupleGetPostingN(itup, nitem / <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxtid = BTreeTupleGetMaxHeapTID(itup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minblocklist = ItemPointerGetBlockNumber(mintid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; midblocklist = ItemPointerGetBlockNumber(midtid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxblocklist = ItemPointerGetBlockNumber(maxtid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only entry with predominant table block can be promising */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstpromising = (minblocklist == midblocklist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastpromising = (!firstpromising &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; midblocklist == maxblocklist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> p = <span class="Constant">0</span>; p &lt; nitem; p++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ItemPointer htid = BTreeTupleGetPostingN(itup, p);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ideltid-&gt;tid = *htid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ideltid-&gt;id = delstate-&gt;ndeltids;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;idxoffnum = offnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;knowndeletable = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* for <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;promising = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((firstpromising &amp;&amp; p == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (lastpromising &amp;&amp; p == nitem - <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;promising = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus-&gt;freespace = <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);&nbsp; &nbsp; <span class="Comment">/* at worst */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ideltid++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; istatus++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delstate-&gt;ndeltids++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dupinterval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;intervals[state-&gt;nintervals].nitems = state-&gt;nitems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;nintervals++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset state for <a href="../../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> interval */<br/></li>
<li></span>&nbsp; &nbsp; state-&gt;nhtids = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;nitems = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; state-&gt;phystupsize = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine if page non-pivot tuples (data items) are all duplicates of the<br/></li>
<li></span><span class="Comment"> * same value -- if they are, deduplication's &quot;single value&quot; strategy should<br/></li>
<li></span><span class="Comment"> * be applied.&nbsp; The general goal of this strategy is to ensure that<br/></li>
<li></span><span class="Comment"> * nbtsplitloc.c (which uses its own single value strategy) will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a useful<br/></li>
<li></span><span class="Comment"> * split point as further duplicates are inserted, and successive rightmost<br/></li>
<li></span><span class="Comment"> * page splits occur among pages that store the same duplicate value.&nbsp; When<br/></li>
<li></span><span class="Comment"> * the page finally splits, it should end up BTREE_SINGLEVAL_FILLFACTOR% full,<br/></li>
<li></span><span class="Comment"> * just like it would if deduplication were disabled.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect that affected workloads will require _several_ single value<br/></li>
<li></span><span class="Comment"> * strategy deduplication passes (over a page that only stores duplicates)<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the page is finally split.&nbsp; The first deduplication pass should only<br/></li>
<li></span><span class="Comment"> * <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> regular non-pivot tuples.&nbsp; Later deduplication passes will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment"> * existing maxpostingsize-capped posting list tuples, which must be skipped<br/></li>
<li></span><span class="Comment"> * over.&nbsp; The penultimate pass is generally the first pass that actually<br/></li>
<li></span><span class="Comment"> * reaches <a href="#L822" title="access/nbtree/nbtdedup.c:822">_bt_singleval_fillfactor</a>(), and so will deliberately leave behind a<br/></li>
<li></span><span class="Comment"> * few untouched non-pivot tuples.&nbsp; The final deduplication pass won't free<br/></li>
<li></span><span class="Comment"> * <a href="../../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> space -- it will <a href="../../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over everything without merging anything (it<br/></li>
<li></span><span class="Comment"> * retraces the steps of the penultimate pass).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fortunately, having several passes isn't too expensive.&nbsp; Each pass (after<br/></li>
<li></span><span class="Comment"> * the first pass) won't spend many cycles on the large posting list tuples<br/></li>
<li></span><span class="Comment"> * left by previous passes.&nbsp; Each pass will <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a large contiguous group of<br/></li>
<li></span><span class="Comment"> * smaller duplicate tuples to <a href="../../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> together at the end of the page.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L782">&#x200c;</a></span><span class="linkable">_bt_do_singleval</span>(Relation rel, Page page, BTDedupState state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OffsetNumber minoff, IndexTuple newitem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nkeyatts = IndexRelationGetNumberOfKeyAttributes(rel);<br/></li>
<li>&nbsp; &nbsp; ItemId&nbsp; &nbsp; &nbsp; &nbsp; itemid;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; itemid = PageGetItemId(page, minoff);<br/></li>
<li>&nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(rel, newitem, itup) &gt; nkeyatts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemid = PageGetItemId(page, PageGetMaxOffsetNumber(page));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itup = (IndexTuple) PageGetItem(page, itemid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="nbtutils.c.html#L4874" title="access/nbtree/nbtutils.c:4874">_bt_keep_natts_fast</a>(rel, newitem, itup) &gt; nkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lower maxpostingsize when using &quot;single value&quot; strategy, to avoid a sixth<br/></li>
<li></span><span class="Comment"> * and final maxpostingsize-capped tuple.&nbsp; The sixth and final posting list<br/></li>
<li></span><span class="Comment"> * tuple will end up somewhat smaller than the first five.&nbsp; (Note: The first<br/></li>
<li></span><span class="Comment"> * five tuples could actually just be very large duplicate tuples that<br/></li>
<li></span><span class="Comment"> * couldn't be merged together at all.&nbsp; Deduplication will simply not modify<br/></li>
<li></span><span class="Comment"> * the page when that happens.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When there are six posting lists on the page (after current deduplication<br/></li>
<li></span><span class="Comment"> * pass goes on to create/observe a sixth very large tuple), caller should end<br/></li>
<li></span><span class="Comment"> * its deduplication pass.&nbsp; It isn't useful to try to deduplicate items that<br/></li>
<li></span><span class="Comment"> * are supposed to end up on the new right sibling page following the<br/></li>
<li></span><span class="Comment"> * anticipated page split.&nbsp; A future deduplication pass of future right<br/></li>
<li></span><span class="Comment"> * sibling page might take care of it.&nbsp; (This is why the first single value<br/></li>
<li></span><span class="Comment"> * strategy deduplication pass for a given leaf page will generally <a href="../../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> only<br/></li>
<li></span><span class="Comment"> * plain non-pivot tuples -- see <a href="#L782" title="access/nbtree/nbtdedup.c:782">_bt_do_singleval</a>() comments.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L822">&#x200c;</a></span><span class="linkable">_bt_singleval_fillfactor</span>(Page page, BTDedupState state, Size newitemsz)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; leftfree;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reduction;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This calculation needs to match nbtsplitloc.c */<br/></li>
<li></span>&nbsp; &nbsp; leftfree = PageGetPageSize(page) - SizeOfPageHeaderData -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BTPageOpaqueData));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Subtract size of new high key (includes pivot heap TID space) */<br/></li>
<li></span>&nbsp; &nbsp; leftfree -= newitemsz + MAXALIGN(<span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reduce maxpostingsize by an amount <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to target free space on left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * half of page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; reduction = leftfree * ((<span class="Constant">100</span> - BTREE_SINGLEVAL_FILLFACTOR) / <span class="Constant">100.0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (state-&gt;maxpostingsize &gt; reduction)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxpostingsize -= reduction;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;maxpostingsize = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build a posting list tuple based on caller's &quot;base&quot; index tuple and list of<br/></li>
<li></span><span class="Comment"> * heap TIDs.&nbsp; When nhtids == 1, builds a standard non-pivot tuple without a<br/></li>
<li></span><span class="Comment"> * posting list. (Posting list tuples can never have a single heap TID, partly<br/></li>
<li></span><span class="Comment"> * because that ensures that deduplication always reduces final MAXALIGN()'d<br/></li>
<li></span><span class="Comment"> * size of entire tuple.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Convention is that posting list starts at a MAXALIGN()'d offset (rather<br/></li>
<li></span><span class="Comment"> * than a SHORTALIGN()'d offset), in line with the approach taken when<br/></li>
<li></span><span class="Comment"> * appending a heap TID to new pivot tuple/high key during suffix truncation.<br/></li>
<li></span><span class="Comment"> * This sometimes wastes a little space that was only needed as alignment<br/></li>
<li></span><span class="Comment"> * padding in the original tuple.&nbsp; Following this convention simplifies the<br/></li>
<li></span><span class="Comment"> * space accounting used when deduplicating a page (the same convention<br/></li>
<li></span><span class="Comment"> * simplifies the accounting for choosing a point to split a page at).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Caller's &quot;htids&quot; array must be unique and already in ascending TID<br/></li>
<li></span><span class="Comment"> * order.&nbsp; Any existing heap TIDs from &quot;base&quot; won't automatically appear in<br/></li>
<li></span><span class="Comment"> * returned posting list tuple (they must be included in htids array.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexTuple<br/></li>
<li><a id="L864">&#x200c;</a><span class="linkable">_bt_form_posting</span>(IndexTuple base, ItemPointer htids, <span class="Type">int</span> nhtids)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; keysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsize;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BTreeTupleIsPosting(base))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; keysize = BTreeTupleGetPostingOffset(base);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; keysize = IndexTupleSize(base);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!BTreeTupleIsPivot(base));<br/></li>
<li>&nbsp; &nbsp; Assert(nhtids &gt; <span class="Constant">0</span> &amp;&amp; nhtids &lt;= PG_UINT16_MAX);<br/></li>
<li>&nbsp; &nbsp; Assert(keysize == MAXALIGN(keysize));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine final size of new tuple */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nhtids &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsize = MAXALIGN(keysize +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nhtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newsize = keysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(newsize &lt;= INDEX_SIZE_MASK);<br/></li>
<li>&nbsp; &nbsp; Assert(newsize == MAXALIGN(newsize));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate memory using <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>() (matches <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>()) */<br/></li>
<li></span>&nbsp; &nbsp; itup = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(newsize);<br/></li>
<li>&nbsp; &nbsp; memcpy(itup, base, keysize);<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_info |= newsize;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nhtids &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form posting list tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetPosting(itup, nhtids, keysize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(BTreeTupleGetPosting(itup), htids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData) * nhtids);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(itup));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form standard non-pivot tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itup-&gt;t_info &amp;= ~INDEX_ALT_TID_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(htids, &amp;itup-&gt;t_tid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(ItemPointerIsValid(&amp;itup-&gt;t_tid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> itup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a replacement tuple by &quot;updating&quot; a posting list tuple so that it<br/></li>
<li></span><span class="Comment"> * no longer has TIDs that need to be deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Used by both VACUUM and index deletion.&nbsp; Caller's vacposting argument<br/></li>
<li></span><span class="Comment"> * points to the existing posting list tuple to be updated.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, caller's vacposting argument will point to final &quot;updated&quot;<br/></li>
<li></span><span class="Comment"> * tuple, which will be <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d in caller's memory context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L924">&#x200c;</a></span><span class="linkable">_bt_update_posting</span>(BTVacuumPosting vacposting)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; origtuple = vacposting-&gt;itup;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; keysize,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newsize;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; itup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ui,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d;<br/></li>
<li>&nbsp; &nbsp; ItemPointer htids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nhtids = BTreeTupleGetNPosting(origtuple) - vacposting-&gt;ndeletedtids;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(origtuple));<br/></li>
<li>&nbsp; &nbsp; Assert(nhtids &gt; <span class="Constant">0</span> &amp;&amp; nhtids &lt; BTreeTupleGetNPosting(origtuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine final size of new tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This calculation needs to match the code used within <a href="#L864" title="access/nbtree/nbtdedup.c:864">_bt_form_posting</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for new posting list tuples.&nbsp; We avoid calling <a href="#L864" title="access/nbtree/nbtdedup.c:864">_bt_form_posting</a>() here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to save ourselves a second memory allocation for a htids workspace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; keysize = BTreeTupleGetPostingOffset(origtuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nhtids &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newsize = MAXALIGN(keysize +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nhtids * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; newsize = keysize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(newsize &lt;= INDEX_SIZE_MASK);<br/></li>
<li>&nbsp; &nbsp; Assert(newsize == MAXALIGN(newsize));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate memory using <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>() (matches <a href="../common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>()) */<br/></li>
<li></span>&nbsp; &nbsp; itup = <a href="../../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(newsize);<br/></li>
<li>&nbsp; &nbsp; memcpy(itup, origtuple, keysize);<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_info &amp;= ~INDEX_SIZE_MASK;<br/></li>
<li>&nbsp; &nbsp; itup-&gt;t_info |= newsize;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nhtids &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form posting list tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleSetPosting(itup, nhtids, keysize);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htids = BTreeTupleGetPosting(itup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Form standard non-pivot tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; itup-&gt;t_info &amp;= ~INDEX_ALT_TID_MASK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htids = &amp;itup-&gt;t_tid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ui = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; d = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; BTreeTupleGetNPosting(origtuple); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (d &lt; vacposting-&gt;ndeletedtids &amp;&amp; vacposting-&gt;deletetids[d] == i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htids[ui++] = *BTreeTupleGetPostingN(origtuple, i);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(ui == nhtids);<br/></li>
<li>&nbsp; &nbsp; Assert(d == vacposting-&gt;ndeletedtids);<br/></li>
<li>&nbsp; &nbsp; Assert(nhtids == <span class="Constant">1</span> || <a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(itup));<br/></li>
<li>&nbsp; &nbsp; Assert(nhtids &gt; <span class="Constant">1</span> || ItemPointerIsValid(&amp;itup-&gt;t_tid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* vacposting arg's itup will <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> point to updated version */<br/></li>
<li></span>&nbsp; &nbsp; vacposting-&gt;itup = itup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare for a posting list split by swapping heap TID in newitem with heap<br/></li>
<li></span><span class="Comment"> * TID from original posting list (the 'oposting' heap TID located at offset<br/></li>
<li></span><span class="Comment"> * 'postingoff').&nbsp; Modifies newitem, so caller should pass their own private<br/></li>
<li></span><span class="Comment"> * copy that can safely be modified.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns new posting list tuple, which is <a href="../../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()'d in caller's context.<br/></li>
<li></span><span class="Comment"> * This is guaranteed to be the same size as 'oposting'.&nbsp; Modified newitem is<br/></li>
<li></span><span class="Comment"> * what caller actually inserts. (This happens inside the same critical<br/></li>
<li></span><span class="Comment"> * section that performs an in-place update of old posting list using new<br/></li>
<li></span><span class="Comment"> * posting list returned here.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While the keys from newitem and oposting must be opclass <a href="../../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>, and must<br/></li>
<li></span><span class="Comment"> * generate identical output when run through the underlying type's output<br/></li>
<li></span><span class="Comment"> * function, it doesn't follow that their representations match exactly.<br/></li>
<li></span><span class="Comment"> * Caller must avoid assuming that there can't be representational differences<br/></li>
<li></span><span class="Comment"> * that make datums from oposting bigger or smaller than the corresponding<br/></li>
<li></span><span class="Comment"> * datums from newitem.&nbsp; For example, differences in TOAST input state might<br/></li>
<li></span><span class="Comment"> * break a faulty assumption about tuple size (the executor is entitled to<br/></li>
<li></span><span class="Comment"> * apply TOAST compression based on its own criteria).&nbsp; It also seems possible<br/></li>
<li></span><span class="Comment"> * that further representational variation will be introduced in the future,<br/></li>
<li></span><span class="Comment"> * in order to support nbtree features like page-level prefix compression.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See nbtree/README for details on the design of posting list splits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexTuple<br/></li>
<li><a id="L1022">&#x200c;</a><span class="linkable">_bt_swap_posting</span>(IndexTuple newitem, IndexTuple oposting, <span class="Type">int</span> postingoff)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nhtids;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *replacepos;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *replaceposright;<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; nmovebytes;<br/></li>
<li>&nbsp; &nbsp; IndexTuple&nbsp; &nbsp; nposting;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nhtids = BTreeTupleGetNPosting(oposting);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(oposting));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The postingoff argument originated as a <a href="nbtsearch.c.html#L596" title="access/nbtree/nbtsearch.c:596">_bt_binsrch_posting</a>() return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value.&nbsp; It will be 0 in the event of corruption that makes a leaf page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain a non-pivot tuple that's somehow identical to newitem (no two<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-pivot tuples should ever have the same TID).&nbsp; This has been known<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to happen in the field from time to time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform a basic sanity check to catch this case <a href="../../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(postingoff &gt; <span class="Constant">0</span> &amp;&amp; postingoff &lt; nhtids))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;posting list tuple with </span><span class="Special">%d</span><span class="Constant"> items cannot be split at offset </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nhtids, postingoff);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move item pointers in posting list to make a gap for the new item's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * heap TID.&nbsp; We shift TIDs one place to the right, losing original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rightmost TID. (nmovebytes must not include TIDs to the left of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postingoff, nor the existing rightmost/max TID that gets overwritten.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nposting = <a href="../common/indextuple.c.html#L547" title="access/common/indextuple.c:547">CopyIndexTuple</a>(oposting);<br/></li>
<li>&nbsp; &nbsp; replacepos = (<span class="Type">char</span> *) BTreeTupleGetPostingN(nposting, postingoff);<br/></li>
<li>&nbsp; &nbsp; replaceposright = (<span class="Type">char</span> *) BTreeTupleGetPostingN(nposting, postingoff + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; nmovebytes = (nhtids - postingoff - <span class="Constant">1</span>) * <span class="Statement"><a href="../../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ItemPointerData);<br/></li>
<li>&nbsp; &nbsp; memmove(replaceposright, replacepos, nmovebytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill the gap at postingoff with TID of new item (original new TID) */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!BTreeTupleIsPivot(newitem) &amp;&amp; !BTreeTupleIsPosting(newitem));<br/></li>
<li>&nbsp; &nbsp; ItemPointerCopy(&amp;newitem-&gt;t_tid, (ItemPointer) replacepos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now copy oposting's rightmost/max TID into new item (final new TID) */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerCopy(BTreeTupleGetMaxHeapTID(oposting), &amp;newitem-&gt;t_tid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(BTreeTupleGetMaxHeapTID(nposting),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTreeTupleGetHeapTID(newitem)) &lt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L1078" title="access/nbtree/nbtdedup.c:1078">_bt_posting_valid</a>(nposting));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nposting;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Verify posting list invariants for &quot;posting&quot;, which must be a posting list<br/></li>
<li></span><span class="Comment"> * tuple.&nbsp; Used within assertions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1078">&#x200c;</a></span><span class="linkable">_bt_posting_valid</span>(IndexTuple posting)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ItemPointerData last;<br/></li>
<li>&nbsp; &nbsp; ItemPointer htid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!BTreeTupleIsPosting(posting) || BTreeTupleGetNPosting(posting) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remember first heap TID for loop */<br/></li>
<li></span>&nbsp; &nbsp; ItemPointerCopy(BTreeTupleGetHeapTID(posting), &amp;last);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!ItemPointerIsValid(&amp;last))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Iterate, starting from second TID */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">1</span>; i &lt; BTreeTupleGetNPosting(posting); i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; htid = BTreeTupleGetPostingN(posting, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ItemPointerIsValid(htid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../../storage/page/itemptr.c.html#L51" title="storage/page/itemptr.c:51">ItemPointerCompare</a>(htid, &amp;last) &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ItemPointerCopy(htid, &amp;last);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../../index.html">Top Level</a></span>
 </p>

 </body>
</html>
