<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>backup/basebackup_incremental.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>backup/basebackup_incremental.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L76">IncrementalBackupInfo</a></li>
<li><a href="#L62">backup_file_entry</a></li>
<li><a href="#L52">backup_wal_range</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L196">AppendIncrementalManifestData</a></li>
<li><a href="#L154">CreateIncrementalBackupInfo</a></li>
<li><a href="#L229">FinalizeIncrementalManifest</a></li>
<li><a href="#L744">GetFileBackupMethod</a></li>
<li><a href="#L704">GetIncrementalFilePath</a></li>
<li><a href="#L976">GetIncrementalFileSize</a></li>
<li><a href="#L948">GetIncrementalHeaderSize</a></li>
<li><a href="#L265">PrepareForIncrementalBackup</a></li>
<li><a href="#L1117">compare_block_numbers</a></li>
<li><a href="#L998">hash_string_pointer</a></li>
<li><a href="#L1045">manifest_process_file</a></li>
<li><a href="#L1023">manifest_process_system_identifier</a></li>
<li><a href="#L1009">manifest_process_version</a></li>
<li><a href="#L1072">manifest_process_wal_range</a></li>
<li><a href="#L1090">manifest_report_error</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L34">BLOCKS_PER_READ</a></li>
<li><a href="#L42">MAX_CHUNK</a></li>
<li><a href="#L41">MIN_CHUNK</a></li>
<li><a href="#L72">SH_DECLARE</a></li>
<li><a href="#L73">SH_DEFINE</a></li>
<li><a href="#L66">SH_ELEMENT_TYPE</a></li>
<li><a href="#L70">SH_EQUAL</a></li>
<li><a href="#L69">SH_HASH_KEY</a></li>
<li><a href="#L68">SH_KEY</a></li>
<li><a href="#L67">SH_KEY_TYPE</a></li>
<li><a href="#L65">SH_PREFIX</a></li>
<li><a href="#L71">SH_SCOPE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * basebackup_incremental.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; code for incremental backup support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code isn't actually in <a href="../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> of taking an incremental backup;<br/></li>
<li></span><span class="Comment"> * the actual construction of the incremental backup happens in<br/></li>
<li></span><span class="Comment"> * basebackup.c. Here, we're concerned with providing the necessary<br/></li>
<li></span><span class="Comment"> * supports for that operation. In particular, we need to <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> the<br/></li>
<li></span><span class="Comment"> * backup manifest supplied by the user taking the incremental backup<br/></li>
<li></span><span class="Comment"> * and extract the required information from it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2010-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/backup/basebackup_incremental.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/basebackup_incremental.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/walsummary.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/blkreftable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/parse_manifest.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;datatype/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/walsummarizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L34">&#x200c;</a><span class="PreProc">#define&nbsp; &nbsp; <span class="linkable">BLOCKS_PER_READ</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">512<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We expect to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the last lines of the manifest, including the checksum,<br/></li>
<li></span><span class="Comment"> * in the last <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a> bytes of the manifest. We <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> an incremental<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> step if we are about to overflow <a href="#L42" title="backup/basebackup_incremental.c:42">MAX_CHUNK</a> bytes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MIN_CHUNK</span>&nbsp; </span><span class="Constant">1024<br/></li>
<li><a id="L42">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_CHUNK</span> (</span><span class="Constant">128</span><span class="PreProc"> *&nbsp; </span><span class="Constant">1024</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Details extracted from the WAL ranges present in the supplied backup manifest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; start_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; end_lsn;<br/></li>
<li><a id="L52">&#x200c;</a>} <span class="linkable">backup_wal_range</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Details extracted from the file list present in the supplied backup manifest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><a id="L62">&#x200c;</a>} <span class="linkable">backup_file_entry</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint32 <a href="#L998" title="backup/basebackup_incremental.c:998">hash_string_pointer</a>(<span class="Type">const</span> <span class="Type">char</span> *s);<br/></li>
<li><a id="L65">&#x200c;</a><span class="PreProc">#define <span class="linkable">SH_PREFIX</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; backup_file<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_ELEMENT_TYPE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L62" title="backup/basebackup_incremental.c:62">backup_file_entry</a><br/></li>
<li><a id="L67">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY_TYPE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Type">const</span><span class="PreProc"> </span><span class="Type">char</span><span class="PreProc"> *<br/></li>
<li><a id="L68">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_KEY</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; path<br/></li>
<li><a id="L69">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_HASH_KEY</span>(tb, key)&nbsp; &nbsp; <a href="#L998" title="backup/basebackup_incremental.c:998">hash_string_pointer</a>(key)<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_EQUAL</span>(tb, a, b)&nbsp; &nbsp; &nbsp; &nbsp; (strcmp(a, b) == </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L71">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_SCOPE</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">static</span><span class="PreProc"> </span><span class="Type">inline<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DECLARE</span><br/></li>
<li><a id="L73">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SH_DEFINE</span><br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/simplehash.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L76">&#x200c;</a><span class="Type">struct</span> <span class="linkable">IncrementalBackupInfo</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Memory context for this object and its subsidiary objects. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext mcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Temporary buffer for storing the manifest while parsing it. */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* WAL ranges extracted from the backup manifest. */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *manifest_wal_ranges;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Files extracted from the backup manifest.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't really need this information, because we use WAL summaries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * figure out what's changed. It would be unsafe to just rely on the list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of files that existed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>, because it's possible for a file to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed and a new one created with the same name and different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents. In such cases, the whole file must still be sent. We can tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from the WAL summaries whether that happened, but not from the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nonetheless, this data is useful for sanity checking. If a file that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think we shouldn't need to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> is not present in the manifest for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prior backup, something has gone terribly wrong. We retain the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * names and sizes, but not the checksums or last modified times, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which we have no use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One significant downside of storing this data is that it consumes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory. If that turns out to be a problem, we might have to decide not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to retain this information, or to make it optional.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; backup_file_hash *manifest_files;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Block-reference table for the incremental backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's possible that storing the entire block-reference table in memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be a problem for some users. The in-memory format that we're using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here is pretty efficient, converging to little more than 1 <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> per<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block for relation forks with large numbers of modified blocks. It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible, however, that if you try to perform an incremental backup of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a database with a sufficiently large number of relations on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sufficiently small machine, you could run out of memory here. If that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * turns out to be a problem in practice, we'll need to be more clever.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; BlockRefTable *brtab;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * State object for incremental JSON parsing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; JsonManifestParseIncrementalState *inc_state;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1009" title="backup/basebackup_incremental.c:1009">manifest_process_version</a>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> manifest_version);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1023" title="backup/basebackup_incremental.c:1023">manifest_process_system_identifier</a>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint64 manifest_system_identifier);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1045" title="backup/basebackup_incremental.c:1045">manifest_process_file</a>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *pathname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_checksum_type checksum_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> checksum_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 *checksum_payload);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1072" title="backup/basebackup_incremental.c:1072">manifest_process_wal_range</a>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr end_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1090" title="backup/basebackup_incremental.c:1090">manifest_report_error</a>(JsonManifestParseContext *ib,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_attribute_printf(<span class="Constant">2</span>, <span class="Constant">3</span>) pg_attribute_noreturn();<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1117" title="backup/basebackup_incremental.c:1117">compare_block_numbers</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new object for storing information extracted from the manifest<br/></li>
<li></span><span class="Comment"> * supplied when creating an incremental backup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *<br/></li>
<li><a id="L154">&#x200c;</a><span class="linkable">CreateIncrementalBackupInfo</span>(MemoryContext mcxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; JsonManifestParseContext *context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ib = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a>));<br/></li>
<li>&nbsp; &nbsp; ib-&gt;mcxt = mcxt;<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;ib-&gt;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's hard to guess how many files a &quot;typical&quot; installation will have in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the data directory, but a fresh initdb creates almost 1000 files as of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this writing, so it seems to make sense for our estimate to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * substantially higher.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ib-&gt;manifest_files = backup_file_create(mcxt, <span class="Constant">10000</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; context = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(JsonManifestParseContext));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse the manifest. */<br/></li>
<li></span>&nbsp; &nbsp; context-&gt;private_data = ib;<br/></li>
<li>&nbsp; &nbsp; context-&gt;version_cb = <a href="#L1009" title="backup/basebackup_incremental.c:1009">manifest_process_version</a>;<br/></li>
<li>&nbsp; &nbsp; context-&gt;system_identifier_cb = <a href="#L1023" title="backup/basebackup_incremental.c:1023">manifest_process_system_identifier</a>;<br/></li>
<li>&nbsp; &nbsp; context-&gt;per_file_cb = <a href="#L1045" title="backup/basebackup_incremental.c:1045">manifest_process_file</a>;<br/></li>
<li>&nbsp; &nbsp; context-&gt;per_wal_range_cb = <a href="#L1072" title="backup/basebackup_incremental.c:1072">manifest_process_wal_range</a>;<br/></li>
<li>&nbsp; &nbsp; context-&gt;error_cb = <a href="#L1090" title="backup/basebackup_incremental.c:1090">manifest_report_error</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ib-&gt;inc_state = json_parse_manifest_incremental_init(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ib;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Before taking an incremental backup, the caller must supply the backup<br/></li>
<li></span><span class="Comment"> * manifest from a prior backup. Each chunk of manifest data received<br/></li>
<li></span><span class="Comment"> * from the client should be passed to this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="linkable">AppendIncrementalManifestData</span>(<a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib, <span class="Type">const</span> <span class="Type">char</span> *data,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ib-&gt;mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ib-&gt;buf.len &gt; <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a> &amp;&amp; ib-&gt;buf.len + len &gt; <a href="#L42" title="backup/basebackup_incremental.c:42">MAX_CHUNK</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time for an incremental <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>. We'll do all but the last <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so that we have enough left for the final piece.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; json_parse_manifest_incremental_chunk(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ib-&gt;inc_state, ib-&gt;buf.data, ib-&gt;buf.len - <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> remove what we just parsed&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memmove(ib-&gt;buf.data, ib-&gt;buf.data + (ib-&gt;buf.len - <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a> + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ib-&gt;buf.len = <a href="#L41" title="backup/basebackup_incremental.c:41">MIN_CHUNK</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendBinaryStringInfo(&amp;ib-&gt;buf, data, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch back to previous memory context. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Finalize an <a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> object after all manifest data has<br/></li>
<li></span><span class="Comment"> * been supplied via calls to <a href="#L196" title="backup/basebackup_incremental.c:196">AppendIncrementalManifestData</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L229">&#x200c;</a></span><span class="linkable">FinalizeIncrementalManifest</span>(<a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ib-&gt;mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parse the last chunk of the manifest */<br/></li>
<li></span>&nbsp; &nbsp; json_parse_manifest_incremental_chunk(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ib-&gt;inc_state, ib-&gt;buf.data, ib-&gt;buf.len, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with the buffer, so release memory. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ib-&gt;buf.data);<br/></li>
<li>&nbsp; &nbsp; ib-&gt;buf.data = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with inc_state, so release that memory too */<br/></li>
<li></span>&nbsp; &nbsp; json_parse_manifest_incremental_shutdown(ib-&gt;inc_state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch back to previous memory context. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare to take an incremental backup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Before this function is called, <a href="#L196" title="backup/basebackup_incremental.c:196">AppendIncrementalManifestData</a> and<br/></li>
<li></span><span class="Comment"> * <a href="#L229" title="backup/basebackup_incremental.c:229">FinalizeIncrementalManifest</a> should have already been called to pass all<br/></li>
<li></span><span class="Comment"> * the manifest data to this object.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function performs sanity checks on the data extracted from the<br/></li>
<li></span><span class="Comment"> * manifest and figures out for which WAL ranges we need summaries, and<br/></li>
<li></span><span class="Comment"> * whether those summaries are available. Then, it reads and combines the<br/></li>
<li></span><span class="Comment"> * data from those summary files. It also updates the <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a> with the<br/></li>
<li></span><span class="Comment"> * reference TLI and LSN for the prior backup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L265">&#x200c;</a></span><span class="linkable">PrepareForIncrementalBackup</span>(<a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BackupState *<a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../access/transam/xlogrecovery.c.html#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *all_wslist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *required_wslist = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; TimeLineHistoryEntry **tlep;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_wal_ranges;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_backup_start_tli = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; earliest_wal_range_tli = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; earliest_wal_range_start_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; latest_wal_range_tli = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; pending_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; prior_pending_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deadcycles = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz initial_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ib-&gt;buf.data == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch to our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(ib-&gt;mcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A valid backup manifest must always contain at least one WAL <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (usually exactly one, unless the backup spanned a timeline switch).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; num_wal_ranges = list_length(ib-&gt;manifest_wal_ranges);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (num_wal_ranges == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;manifest contains no required WAL ranges&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Match up the TLIs that appear in the WAL ranges of the backup manifest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with those that appear in this server's timeline history. We expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * every <a href="#L52" title="backup/basebackup_incremental.c:52">backup_wal_range</a> to match to a TimeLineHistoryEntry; if it does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not, that's an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This loop also decides which of the WAL ranges is the manifest is most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ancient and which one is the newest, according to the timeline history<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of this server, and stores TLIs of those WAL ranges into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earliest_wal_range_tli and latest_wal_range_tli. It also updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earliest_wal_range_start_lsn to the start LSN of the WAL <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earliest_wal_range_tli.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the return value of <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a> puts the latest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline at the beginning of the list, not the end. Hence, the earliest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TLI is the one that occurs nearest the end of the list returned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>, and the latest TLI is the one that occurs closest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the beginning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a> = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(<a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;starttli);<br/></li>
<li>&nbsp; &nbsp; tlep = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(num_wal_ranges * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(TimeLineHistoryEntry *));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_wal_ranges; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L52" title="backup/basebackup_incremental.c:52">backup_wal_range</a> *<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = list_nth(ib-&gt;manifest_wal_ranges, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_earliest_wal_range_tli = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_latest_wal_range_tli = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search this server's history for this WAL <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>'s TLI. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="../access/transam/xlogrecovery.c.html#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineHistoryEntry *tle = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;tli == <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlep[i] = tle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;tli == earliest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_earliest_wal_range_tli = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;tli == latest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_latest_wal_range_tli = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * An incremental backup can only be taken relative to a backup that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * represents a previous state of this server. If the backup requires<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL from a timeline that's not in our history, that definitely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't the case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tlep[i] == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timeline </span><span class="Special">%u</span><span class="Constant"> found in manifest, but not in this server's history&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we found this TLI in the server's history <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> encountering<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the latest TLI seen so far in the server's history, then this TLI<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is the latest one seen so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If on the other hand we saw the earliest TLI seen so far <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finding this TLI, this TLI is earlier than the earliest one seen so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * far. And if this is the first TLI for which we've searched, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also the earliest one seen so far.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On the first loop iteration, both things should necessarily be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!saw_latest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest_wal_range_tli = <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (earliest_wal_range_tli == <span class="Constant">0</span> || saw_earliest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; earliest_wal_range_tli = <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; earliest_wal_range_start_lsn = <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;start_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Propagate information about the prior backup into the backup_label that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be generated for this backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;istartpoint = earliest_wal_range_start_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;istarttli = earliest_wal_range_tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity check start and end LSNs for the WAL ranges in the manifest.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Commonly, there won't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeline switches during the prior backup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at all, but if there are, they should happen at the same LSNs that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * server switched timelines.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Whether there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeline switches during the prior backup or not,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the prior backup shouldn't require <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL from a timeline prior to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start of that timeline. It also shouldn't require <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL from later<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than the start of this backup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these sanity checks fail, one possible explanation is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the user has generated WAL on the same timeline with the same LSNs more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than once. For instance, if two standbys running on timeline 1 were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * both promoted and (due to a broken archiving setup) both selected new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * timeline ID 2, then it's possible that one of these checks might trip.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that there are lots of ways for the user to do something very bad<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without tripping <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these checks, and they are not intended to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comprehensive. It's pretty hard to see how we could be certain of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything here. However, if there's a problem staring us right in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * face, it's best to report it, so we do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; num_wal_ranges; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L52" title="backup/basebackup_incremental.c:52">backup_wal_range</a> *<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = list_nth(ib-&gt;manifest_wal_ranges, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli == earliest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;start_lsn &lt; tlep[i]-&gt;begin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;manifest requires WAL from initial timeline </span><span class="Special">%u</span><span class="Constant"> starting at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but that timeline begins at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tlep[i]-&gt;begin))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;start_lsn != tlep[i]-&gt;begin)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;manifest requires WAL from continuation timeline </span><span class="Special">%u</span><span class="Constant"> starting at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but that timeline begins at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tlep[i]-&gt;begin))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli == latest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;end_lsn &gt; <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;manifest requires WAL from final timeline </span><span class="Special">%u</span><span class="Constant"> ending at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but this backup starts at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;end_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;end_lsn != tlep[i]-&gt;end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;manifest requires WAL from non-final timeline </span><span class="Special">%u</span><span class="Constant"> ending at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but this server switched timelines at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;end_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tlep[i]-&gt;end))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Wait for WAL summarization to catch up to the backup start LSN (but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time out if it doesn't do so quickly enough).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initial_time = current_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; timeout_in_ms = <span class="Constant">10000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; elapsed_seconds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Align the wait time to prevent drift. This doesn't really matter,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but we'd like the warnings about how long we've been <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to say<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 10 seconds, 20 seconds, 30 seconds, 40 seconds ... without ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * drifting to something that is not a multiple of ten.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; timeout_in_ms -=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(initial_time, current_time) %<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; timeout_in_ms;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for up to 10 seconds. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; summarized_lsn = <a href="../postmaster/walsummarizer.c.html#L646" title="postmaster/walsummarizer.c:646">WaitForWalSummarization</a>(<a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; timeout_in_ms, &amp;pending_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If WAL summarization has progressed sufficiently, stop <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarized_lsn &gt;= <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Keep track of the number of cycles during which there has been no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progression of pending_lsn. If pending_lsn is not advancing, that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means that not only are no new files appearing on disk, but we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not even incorporating new <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> into the in-memory state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending_lsn &gt; prior_pending_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prior_pending_lsn = pending_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; deadcycles = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++deadcycles;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've managed to wait for an entire minute without the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * summarizer absorbing a single WAL record, error out; probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something is wrong.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could consider also erroring out if the summarizer is taking too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * long to catch up, but it's not clear what rate of progress would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acceptable and what would be too slow. So instead, we just try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error out in the case where there's no progress at all. That seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * likely to catch a reasonable number of the things that can go wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in practice (e.g. the summarizer process is completely hung, say<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because somebody hooked up a debugger to it or something) without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * giving up too quickly when the system is just slow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (deadcycles &gt;= <span class="Constant">6</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL summarization is not progressing&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Summarization is needed through </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but is stuck at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on disk and </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> in memory.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(<a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(summarized_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(pending_lsn))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, just let the user know what's happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; current_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elapsed_seconds =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(initial_time, current_time) / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;still <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for WAL summarization through </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> after </span><span class="Special">%ld</span><span class="Constant"> seconds&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_seconds),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Summarization has reached </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> on disk and </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> in memory.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(summarized_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(pending_lsn))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Retrieve a list of all WAL summaries on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> timeline that overlap with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the LSN <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of interest. We could instead call <a href="walsummary.c.html#L43" title="backup/walsummary.c:43">GetWalSummaries</a>() once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per timeline in the loop that follows, but that would involve reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the directory multiple times. It should be mildly faster - and perhaps<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> safer - to do it just once.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; all_wslist = <a href="walsummary.c.html#L43" title="backup/walsummary.c:43">GetWalSummaries</a>(<span class="Constant">0</span>, earliest_wal_range_start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need WAL summaries for everything that happened during the prior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup and everything that happened afterward up until the point where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current backup started.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, <a href="../access/transam/xlogrecovery.c.html#L123" title="access/transam/xlogrecovery.c:123">expectedTLEs</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineHistoryEntry *tle = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; tli_start_lsn = tle-&gt;begin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; tli_end_lsn = tle-&gt;end;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; tli_missing_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tli_wslist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Working through the history of this server from the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline backwards, we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> everything until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the timeline<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where this backup started. Most of the time, this means we won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> anything at all, as it's unlikely that the timeline has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * changed since the beginning of the backup moments ago.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;tli == <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;starttli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_backup_start_tli = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli_end_lsn = <a href="../access/transam/xlogfuncs.c.html#L40" title="access/transam/xlogfuncs.c:40">backup_state</a>-&gt;startpoint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!found_backup_start_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find the summaries that overlap the LSN <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of interest for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline. If this is the earliest timeline involved, the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interest begins with the start LSN of the prior backup; otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it begins at the LSN at which this timeline came into existence. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this is the latest TLI involved, the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of interest ends at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start LSN of the current backup; otherwise, it ends at the point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where we switched from this timeline to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;tli == earliest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli_start_lsn = earliest_wal_range_start_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tli_wslist = <a href="walsummary.c.html#L100" title="backup/walsummary.c:100">FilterWalSummaries</a>(all_wslist, tle-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli_start_lsn, tli_end_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There is no guarantee that the WAL summaries we found cover the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entire <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of LSNs for which summaries are required, or indeed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we found <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL summaries at all. Check whether we have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * problem of that sort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="walsummary.c.html#L138" title="backup/walsummary.c:138">WalSummariesAreComplete</a>(tli_wslist, tli_start_lsn, tli_end_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;tli_missing_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(tli_missing_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL summaries are required on timeline </span><span class="Special">%u</span><span class="Constant"> from </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but no summaries for that timeline and LSN <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tli_start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tli_end_lsn))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL summaries are required on timeline </span><span class="Special">%u</span><span class="Constant"> from </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">, but the summaries for that timeline and LSN <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> are incomplete&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tli_start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(tli_end_lsn)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The first unsummarized LSN in this <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> is </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(tli_missing_lsn))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember that we need to read these summaries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Technically, it's possible that this could read more files than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * required, since tli_wslist in theory could contain redundant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * summaries. For instance, if we have a summary from 0/10000000 to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 0/20000000 and also one from 0/00000000 to 0/30000000, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * latter subsumes the former and the former could be ignored.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We ignore this possibility because the WAL summarizer only tries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate summaries that do not overlap. If somehow they exist,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll do a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of extra work but the results should still be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correct.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; required_wslist = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(required_wslist, tli_wslist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Timelines earlier than the one in which the prior backup began are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not relevant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;tli == earliest_wal_range_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read all of the required block reference table files and <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> all of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the data into a single in-memory block reference table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See the comments for struct <a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> for some thoughts on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory usage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ib-&gt;brtab = CreateEmptyBlockRefTable();<br/></li>
<li>&nbsp; &nbsp; foreach(lc, required_wslist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSummaryFile *ws = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSummaryIO wsio;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableReader *reader;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber limit_block;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocks[<a href="#L34" title="backup/basebackup_incremental.c:34">BLOCKS_PER_READ</a>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wsio.file = <a href="walsummary.c.html#L205" title="backup/walsummary.c:205">OpenWalSummaryFile</a>(ws, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; wsio.filepos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;reading WAL summary file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(wsio.file))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reader = CreateBlockRefTableReader(<a href="walsummary.c.html#L273" title="backup/walsummary.c:273">ReadWalSummary</a>, &amp;wsio,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/file/fd.c.html#L2461" title="storage/file/fd.c:2461">FilePathName</a>(wsio.file),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="walsummary.c.html#L322" title="backup/walsummary.c:322">ReportWalSummaryError</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (BlockRefTableReaderNextRelation(reader, &amp;rlocator, &amp;forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;limit_block))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(ib-&gt;brtab, &amp;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum, limit_block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; nblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks = BlockRefTableReaderGetBlocks(reader, blocks,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L34" title="backup/basebackup_incremental.c:34">BLOCKS_PER_READ</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nblocks == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nblocks; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableMarkBlockModified(ib-&gt;brtab, &amp;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum, blocks[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DestroyBlockRefTableReader(reader);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(wsio.file);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch back to previous memory context. */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the pathname that should be used when a file is sent incrementally.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">char</span> *<br/></li>
<li><a id="L704">&#x200c;</a><span class="linkable">GetIncrementalFilePath</span>(Oid dboid, Oid spcoid, RelFileNumber relfilenumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ForkNumber forknum, <span class="Type">unsigned</span> segno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *path;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *lastslash;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ipath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; path = GetRelationPath(dboid, spcoid, relfilenumber, INVALID_PROC_NUMBER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; lastslash = strrchr(path, <span class="Constant">'/'</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(lastslash != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; *lastslash = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (segno &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipath = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/INCREMENTAL.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>, path, lastslash + <span class="Constant">1</span>, segno);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ipath = psprintf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/INCREMENTAL.</span><span class="Special">%s</span><span class="Constant">&quot;</span>, path, lastslash + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(path);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ipath;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * How should we back up a particular file as part of an incremental backup?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the return value is BACK_UP_FILE_FULLY, caller should back up the whole<br/></li>
<li></span><span class="Comment"> * file just as if this were not an incremental backup.&nbsp; The contents of the<br/></li>
<li></span><span class="Comment"> * relative_block_numbers array are unspecified in this case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the return value is BACK_UP_FILE_INCREMENTALLY, caller should include<br/></li>
<li></span><span class="Comment"> * an incremental file in the backup instead of the entire file. On return,<br/></li>
<li></span><span class="Comment"> * *num_blocks_required will be set to the number of blocks that need to be<br/></li>
<li></span><span class="Comment"> * sent, and the actual block numbers will have been stored in<br/></li>
<li></span><span class="Comment"> * relative_block_numbers, which should be an array of at least RELSEG_SIZE.<br/></li>
<li></span><span class="Comment"> * In addition, *truncation_block_length will be set to the value that should<br/></li>
<li></span><span class="Comment"> * be included in the incremental file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>FileBackupMethod<br/></li>
<li><a id="L744">&#x200c;</a><span class="linkable">GetFileBackupMethod</span>(<a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib, <span class="Type">const</span> <span class="Type">char</span> *path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid dboid, Oid spcoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileNumber relfilenumber, ForkNumber forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> segno, <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> *num_blocks_required,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber *relative_block_numbers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span> *truncation_block_length)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber limit_block;<br/></li>
<li>&nbsp; &nbsp; BlockNumber start_blkno;<br/></li>
<li>&nbsp; &nbsp; BlockNumber stop_blkno;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; BlockRefTableEntry *brtentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should only be called after <a href="#L265" title="backup/basebackup_incremental.c:265">PrepareForIncrementalBackup</a>. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ib-&gt;buf.data == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dboid could be InvalidOid if shared rel, but spcoid and relfilenumber<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should have legal <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(OidIsValid(spcoid));<br/></li>
<li>&nbsp; &nbsp; Assert(RelFileNumberIsValid(relfilenumber));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the file size is too large or not a multiple of BLCKSZ, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something weird is happening, so give up and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the whole file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((size % BLCKSZ) != <span class="Constant">0</span> || size / BLCKSZ &gt; RELSEG_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The free-space map fork is not properly WAL-logged, so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup the entire file every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (forknum == FSM_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this file was not part of the prior backup, back it up fully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this file was created after the prior backup and <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the current backup, then the WAL summary information will tell us to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back up the whole file. However, if this file was created after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start of the current backup, then the WAL summary won't know anything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about it. Without this logic, we would erroneously conclude that it was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OK to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> it incrementally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the file could have existed at the time of the prior backup,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gotten deleted, and then a new file with the same name could have been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created.&nbsp; In that case, this logic won't prevent the file from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backed up incrementally. But, if the deletion happened <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the current backup, the limit block will be 0, inducing a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backup. If the deletion happened after the start of the current backup,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reconstruction will erroneously <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> blocks from the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lifespan of the file with blocks from the previous lifespan -- but in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this type of case, WAL replay to reach backup consistency should remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and recreate the file anyway, so the initial bogus contents should not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (backup_file_lookup(ib-&gt;manifest_files, path) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ipath;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ipath = <a href="#L704" title="backup/basebackup_incremental.c:704">GetIncrementalFilePath</a>(dboid, spcoid, relfilenumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum, segno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (backup_file_lookup(ib-&gt;manifest_files, ipath) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the special block reference table entry for the database as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whole.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rlocator.spcOid = spcoid;<br/></li>
<li>&nbsp; &nbsp; rlocator.dbOid = dboid;<br/></li>
<li>&nbsp; &nbsp; rlocator.relNumber = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BlockRefTableGetEntry(ib-&gt;brtab, &amp;rlocator, MAIN_FORKNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;limit_block) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * According to the WAL summary, this database OID/tablespace OID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pairing has been created since the previous backup. So, everything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in it must be backed up fully.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look up the block reference table entry for this relfilenode. */<br/></li>
<li></span>&nbsp; &nbsp; rlocator.relNumber = relfilenumber;<br/></li>
<li>&nbsp; &nbsp; brtentry = BlockRefTableGetEntry(ib-&gt;brtab, &amp;rlocator, forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;limit_block);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there is no entry, then there have been no WAL-logged changes to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation since the predecessor backup was taken, so we can back it up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * incrementally and need not include <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modified blocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, if the file is zero-length, we should do a full backup,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because an incremental file is always more than zero length, and it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * silly to take an incremental backup when a full backup would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * smaller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (brtentry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *num_blocks_required = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *truncation_block_length = size / BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_INCREMENTALLY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the limit_block is less than or <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the point where this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment starts, <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the whole file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (limit_block &lt;= segno * RELSEG_SIZE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get relevant entries from the block reference table entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We shouldn't overflow computing the start or stop block numbers, but if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it manages to happen somehow, detect it and throw an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; start_blkno = segno * RELSEG_SIZE;<br/></li>
<li>&nbsp; &nbsp; stop_blkno = start_blkno + (size / BLCKSZ);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (start_blkno / RELSEG_SIZE != segno || stop_blkno &lt; start_blkno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;overflow computing block number bounds for segment </span><span class="Special">%u</span><span class="Constant"> with size </span><span class="Special">%zu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; segno, size));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This will write *absolute* block numbers into the output array, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we'll transpose them below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nblocks = BlockRefTableEntryGetBlocks(brtentry, start_blkno, stop_blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative_block_numbers, RELSEG_SIZE);<br/></li>
<li>&nbsp; &nbsp; Assert(nblocks &lt;= RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're going to have to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> nearly all of the blocks, then just <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the whole file, because that won't require much extra storage or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transfer and will speed up and simplify backup restoration. It's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clear what threshold is most appropriate here and perhaps it ought to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be configurable, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we're just going to say that if we'd need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> 90% of the blocks anyway, give up and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the whole file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: If you change the threshold here, at least make sure to back up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file fully when every single block must be sent, because there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nothing good about sending an incremental file in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nblocks * BLCKSZ &gt; size * <span class="Constant">0.9</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_FULLY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Looks like we can <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an incremental file, so sort the block numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and then transpose them from absolute block numbers to relative block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numbers if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: If the block reference table was using the bitmap representation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for a given chunk, the block numbers in that chunk will already be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sorted, but when the array-of-offsets representation is used, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receive block numbers here out of order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qsort(relative_block_numbers, nblocks, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1117" title="backup/basebackup_incremental.c:1117">compare_block_numbers</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (start_blkno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nblocks; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relative_block_numbers[i] -= start_blkno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *num_blocks_required = nblocks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The truncation block length is the minimum length of the reconstructed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file. Any block numbers below this threshold that are not present in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the backup need to be fetched from the prior backup. At or above this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * threshold, blocks should only be included in the result if they are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present in the backup. (This may require inserting zero blocks if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks included in the backup are non-consecutive.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *truncation_block_length = size / BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(limit_block))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">unsigned</span>&nbsp; &nbsp; relative_limit = limit_block - segno * RELSEG_SIZE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*truncation_block_length &lt; relative_limit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *truncation_block_length = relative_limit;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Send it incrementally. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> BACK_UP_FILE_INCREMENTALLY;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the size for a header of an incremental file containing a given<br/></li>
<li></span><span class="Comment"> * number of blocks. The header is rounded to a multiple of BLCKSZ, but<br/></li>
<li></span><span class="Comment"> * only if the file will store some block data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">extern</span> <span class="Type">size_t<br/></li>
<li><a id="L948">&#x200c;</a></span><span class="linkable">GetIncrementalHeaderSize</span>(<span class="Type">unsigned</span> num_blocks_required)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're not going to overflow. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(num_blocks_required &lt;= RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Three four byte quantities (magic number, truncation block length,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * block count) followed by block numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <span class="Constant">3</span> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) + (<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BlockNumber) * num_blocks_required);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Round the header size to a multiple of BLCKSZ - when not a multiple of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BLCKSZ, add the missing fraction of a block. But do this only if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file will store data for some blocks, otherwise keep it small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((num_blocks_required &gt; <span class="Constant">0</span>) &amp;&amp; (result % BLCKSZ != <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result += BLCKSZ - (result % BLCKSZ);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the size for an incremental file containing a given number of blocks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">extern</span> <span class="Type">size_t<br/></li>
<li><a id="L976">&#x200c;</a></span><span class="linkable">GetIncrementalFileSize</span>(<span class="Type">unsigned</span> num_blocks_required)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're not going to overflow. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(num_blocks_required &lt;= RELSEG_SIZE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Header with three four byte quantities (magic number, truncation block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * length, block count) followed by block numbers, rounded to a multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of BLCKSZ (for files with block data), followed by block contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L948" title="backup/basebackup_incremental.c:948">GetIncrementalHeaderSize</a>(num_blocks_required);<br/></li>
<li>&nbsp; &nbsp; result += BLCKSZ * num_blocks_required;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Helper function for filemap <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint32<br/></li>
<li><a id="L998">&#x200c;</a><span class="linkable">hash_string_pointer</span>(<span class="Type">const</span> <span class="Type">char</span> *s)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> *ss = (<span class="Type">unsigned</span> <span class="Type">char</span> *) s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_bytes(ss, strlen(s));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This callback to validate the manifest version for incremental backup.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1009">&#x200c;</a></span><span class="linkable">manifest_process_version</span>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> manifest_version)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Incremental backups don't work with manifest version 1 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (manifest_version == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;error_cb(context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;backup manifest version 1 does not support incremental backup&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This callback to validate the manifest system identifier against the current<br/></li>
<li></span><span class="Comment"> * database server.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1023">&#x200c;</a></span><span class="linkable">manifest_process_system_identifier</span>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; uint64 manifest_system_identifier)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; system_identifier;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get system identifier of current system */<br/></li>
<li></span>&nbsp; &nbsp; system_identifier = <a href="../access/transam/xlog.c.html#L4535" title="access/transam/xlog.c:4535">GetSystemIdentifier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (manifest_system_identifier != system_identifier)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context-&gt;error_cb(context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;manifest system identifier is </span><span class="Special">%llu</span><span class="Constant">, but database system identifier is </span><span class="Special">%llu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) manifest_system_identifier,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) system_identifier);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This callback is invoked for each file mentioned in the backup manifest.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We store the path to each file and the size of each file for sanity-checking<br/></li>
<li></span><span class="Comment"> * purposes. For further details, see comments for <a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1045">&#x200c;</a></span><span class="linkable">manifest_process_file</span>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *pathname, <span class="Type">size_t</span> size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_checksum_type checksum_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> checksum_length,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint8 *checksum_payload)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib = context-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L62" title="backup/basebackup_incremental.c:62">backup_file_entry</a> *entry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entry = backup_file_insert(ib-&gt;manifest_files, pathname, &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;path = <a href="../utils/mmgr/mcxt.c.html#L1682" title="utils/mmgr/mcxt.c:1682">MemoryContextStrdup</a>(ib-&gt;manifest_files-&gt;ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pathname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry-&gt;size = size;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This callback is invoked for each WAL <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> mentioned in the backup<br/></li>
<li></span><span class="Comment"> * manifest.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We're just interested in learning the oldest LSN and the corresponding TLI<br/></li>
<li></span><span class="Comment"> * that appear in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1072">&#x200c;</a></span><span class="linkable">manifest_process_wal_range</span>(JsonManifestParseContext *context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TimeLineID tli, XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr end_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="backup/basebackup_incremental.c:76">IncrementalBackupInfo</a> *ib = context-&gt;private_data;<br/></li>
<li>&nbsp; &nbsp; <a href="#L52" title="backup/basebackup_incremental.c:52">backup_wal_range</a> *<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L52" title="backup/basebackup_incremental.c:52">backup_wal_range</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;tli = tli;<br/></li>
<li>&nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;start_lsn = start_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>-&gt;end_lsn = end_lsn;<br/></li>
<li>&nbsp; &nbsp; ib-&gt;manifest_wal_ranges = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(ib-&gt;manifest_wal_ranges, <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This callback is invoked if an error occurs while parsing the backup<br/></li>
<li></span><span class="Comment"> * manifest.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1090">&#x200c;</a></span><span class="linkable">manifest_report_error</span>(JsonManifestParseContext *context, <span class="Type">const</span> <span class="Type">char</span> *fmt,...)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData errbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;errbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">va_list</span>&nbsp; &nbsp; &nbsp; &nbsp; ap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; va_start(ap, fmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; needed = appendStringInfoVA(&amp;errbuf, fmt, ap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; va_end(ap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (needed == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; enlargeStringInfo(&amp;errbuf, needed);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, errbuf.data));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Quicksort comparator for block numbers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1117">&#x200c;</a></span><span class="linkable">compare_block_numbers</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BlockNumber aa = *(BlockNumber *) a;<br/></li>
<li>&nbsp; &nbsp; BlockNumber bb = *(BlockNumber *) b;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_u32(aa, bb);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
