<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/bgworker.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/bgworker.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L108">BackgroundWorkerData</a></li>
<li><a href="#L40">BackgroundWorkerList</a></li>
<li><a href="#L118">InternalBGWorkers</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L94">BackgroundWorkerArray</a></li>
<li><a href="#L100">BackgroundWorkerArray</a></li>
<li><a href="#L102">BackgroundWorkerHandle</a></li>
<li><a href="#L74">BackgroundWorkerSlot</a></li>
<li><a href="#L81">BackgroundWorkerSlot</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L723">BackgroundWorkerMain</a></li>
<li><a href="#L162">BackgroundWorkerShmemInit</a></li>
<li><a href="#L146">BackgroundWorkerShmemSize</a></li>
<li><a href="#L246">BackgroundWorkerStateChange</a></li>
<li><a href="#L520">BackgroundWorkerStopNotifications</a></li>
<li><a href="#L221">FindRegisteredWorkerBySlotNumber</a></li>
<li><a href="#L432">ForgetBackgroundWorker</a></li>
<li><a href="#L547">ForgetUnstartedBackgroundWorkers</a></li>
<li><a href="#L1082">GetBackgroundWorkerPid</a></li>
<li><a href="#L1296">GetBackgroundWorkerTypeByPid</a></li>
<li><a href="#L1262">LookupBackgroundWorkerFunction</a></li>
<li><a href="#L862">RegisterBackgroundWorker</a></li>
<li><a href="#L970">RegisterDynamicBackgroundWorker</a></li>
<li><a href="#L486">ReportBackgroundWorkerExit</a></li>
<li><a href="#L467">ReportBackgroundWorkerPID</a></li>
<li><a href="#L585">ResetBackgroundWorkerCrashTimes</a></li>
<li><a href="#L637">SanityCheckBackgroundWorker</a></li>
<li><a href="#L1221">TerminateBackgroundWorker</a></li>
<li><a href="#L1182">WaitForBackgroundWorkerShutdown</a></li>
<li><a href="#L1137">WaitForBackgroundWorkerStartup</a></li>
<li><a href="#L709">bgworker_die</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*--------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * bgworker.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; POSTGRES pluggable background workers implementation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/bgworker.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/atomics.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/<a href="../utils/adt/oracle_compat.c.html#L925" title="utils/adt/oracle_compat.c:925">ascii</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The postmaster's list of registered background workers, in private memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L40">&#x200c;</a></span>slist_head&nbsp; &nbsp; <span class="linkable">BackgroundWorkerList</span> = SLIST_STATIC_INIT(<span class="linkable">BackgroundWorkerList</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * BackgroundWorkerSlots exist in shared memory and can be accessed (via<br/></li>
<li></span><span class="Comment"> * the <a href="#L94" title="postmaster/bgworker.c:94">BackgroundWorkerArray</a>) by both the postmaster and by regular backends.<br/></li>
<li></span><span class="Comment"> * However, the postmaster cannot take locks, even spinlocks, because this<br/></li>
<li></span><span class="Comment"> * might allow it to crash or become wedged if shared memory gets corrupted.<br/></li>
<li></span><span class="Comment"> * Such an outcome is intolerable.&nbsp; Therefore, we need a lockless protocol<br/></li>
<li></span><span class="Comment"> * for coordinating access to this data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The 'in_use' flag is used to hand off responsibility for the slot between<br/></li>
<li></span><span class="Comment"> * the postmaster and the rest of the system.&nbsp; When 'in_use' is false,<br/></li>
<li></span><span class="Comment"> * the postmaster will ignore the slot entirely, except for the 'in_use' flag<br/></li>
<li></span><span class="Comment"> * itself, which it may read.&nbsp; In this state, regular backends may modify the<br/></li>
<li></span><span class="Comment"> * slot.&nbsp; Once a backend sets 'in_use' to true, the slot becomes the<br/></li>
<li></span><span class="Comment"> * responsibility of the postmaster.&nbsp; Regular backends may no longer modify it,<br/></li>
<li></span><span class="Comment"> * but the postmaster may examine it.&nbsp; Thus, a backend initializing a slot<br/></li>
<li></span><span class="Comment"> * must fully <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the slot - and insert a write memory barrier - <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * marking it as in use.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As an exception, however, even when the slot is in use, regular backends<br/></li>
<li></span><span class="Comment"> * may set the 'terminate' flag for a slot, telling the postmaster not<br/></li>
<li></span><span class="Comment"> * to restart it.&nbsp; Once the background worker is no longer running, the slot<br/></li>
<li></span><span class="Comment"> * will be released for reuse.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to coordinating with the postmaster, backends modifying this<br/></li>
<li></span><span class="Comment"> * data structure must coordinate with each other.&nbsp; Since they can take locks,<br/></li>
<li></span><span class="Comment"> * this is straightforward: <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend wishing to manipulate a slot must<br/></li>
<li></span><span class="Comment"> * take BackgroundWorkerLock in exclusive mode.&nbsp; Backends wishing to read<br/></li>
<li></span><span class="Comment"> * data that might get concurrently modified by other backends should take<br/></li>
<li></span><span class="Comment"> * this lock in shared mode.&nbsp; No matter what, backends reading this data<br/></li>
<li></span><span class="Comment"> * structure must be able to tolerate concurrent modifications by the<br/></li>
<li></span><span class="Comment"> * postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L74">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BackgroundWorkerSlot</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; in_use;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; terminate;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* InvalidPid = not started yet; 0 = dead */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; generation;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* incremented when slot is recycled */<br/></li>
<li></span>&nbsp; &nbsp; BackgroundWorker worker;<br/></li>
<li><a id="L81">&#x200c;</a>} <span class="linkable">BackgroundWorkerSlot</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In order to limit the total number of parallel workers (according to<br/></li>
<li></span><span class="Comment"> * <a href="../utils/init/globals.c.html#L142" title="utils/init/globals.c:142">max_parallel_workers</a> GUC), we maintain the number of active parallel<br/></li>
<li></span><span class="Comment"> * workers.&nbsp; Since the postmaster cannot take locks, two variables are used for<br/></li>
<li></span><span class="Comment"> * this purpose: the number of registered parallel workers (modified by the<br/></li>
<li></span><span class="Comment"> * backends, protected by BackgroundWorkerLock) and the number of terminated<br/></li>
<li></span><span class="Comment"> * parallel workers (modified only by the postmaster, lockless).&nbsp; The active<br/></li>
<li></span><span class="Comment"> * number of parallel workers is the number of registered workers minus the<br/></li>
<li></span><span class="Comment"> * terminated ones.&nbsp; These counters can of course overflow, but it's not<br/></li>
<li></span><span class="Comment"> * important here since the subtraction will still give the right number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L94">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BackgroundWorkerArray</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_slots;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; parallel_register_count;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; parallel_terminate_count;<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> slot[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L100">&#x200c;</a>} <span class="linkable">BackgroundWorkerArray</span>;<br/></li>
<li><br/></li>
<li><a id="L102">&#x200c;</a><span class="Type">struct</span> <span class="linkable">BackgroundWorkerHandle</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; generation;<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L108">&#x200c;</a><span class="Type">static</span> <a href="#L94" title="postmaster/bgworker.c:94">BackgroundWorkerArray</a> *<span class="linkable">BackgroundWorkerData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> background worker entry points.&nbsp; We need this for<br/></li>
<li></span><span class="Comment"> * reasons explained in <a href="#L1262" title="postmaster/bgworker.c:1262">LookupBackgroundWorkerFunction</a>(), below.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *fn_name;<br/></li>
<li>&nbsp; &nbsp; bgworker_main_type fn_addr;<br/></li>
<li><a id="L118">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">InternalBGWorkers</span>[] =<br/></li>
<li><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../access/transam/parallel.c.html#L1271" title="access/transam/parallel.c:1271">ParallelWorkerMain</a>&quot;</span>, <a href="../access/transam/parallel.c.html#L1271" title="access/transam/parallel.c:1271">ParallelWorkerMain</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../replication/logical/launcher.c.html#L1122" title="replication/logical/launcher.c:1122">ApplyLauncherMain</a>&quot;</span>, <a href="../replication/logical/launcher.c.html#L1122" title="replication/logical/launcher.c:1122">ApplyLauncherMain</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../replication/logical/worker.c.html#L4685" title="replication/logical/worker.c:4685">ApplyWorkerMain</a>&quot;</span>, <a href="../replication/logical/worker.c.html#L4685" title="replication/logical/worker.c:4685">ApplyWorkerMain</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../replication/logical/applyparallelworker.c.html#L857" title="replication/logical/applyparallelworker.c:857">ParallelApplyWorkerMain</a>&quot;</span>, <a href="../replication/logical/applyparallelworker.c.html#L857" title="replication/logical/applyparallelworker.c:857">ParallelApplyWorkerMain</a><br/></li>
<li>&nbsp; &nbsp; },<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../replication/logical/tablesync.c.html#L1711" title="replication/logical/tablesync.c:1711">TablesyncWorkerMain</a>&quot;</span>, <a href="../replication/logical/tablesync.c.html#L1711" title="replication/logical/tablesync.c:1711">TablesyncWorkerMain</a><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Private <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. */<br/></li>
<li></span><span class="Type">static</span> bgworker_main_type <a href="#L1262" title="postmaster/bgworker.c:1262">LookupBackgroundWorkerFunction</a>(<span class="Type">const</span> <span class="Type">char</span> *libraryname, <span class="Type">const</span> <span class="Type">char</span> *funcname);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate shared memory needed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L146">&#x200c;</a><span class="linkable">BackgroundWorkerShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Array of workers is variably sized. */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(<a href="#L94" title="postmaster/bgworker.c:94">BackgroundWorkerArray</a>, slot);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize shared memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="linkable">BackgroundWorkerShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a> = <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Background Worker Data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L146" title="postmaster/bgworker.c:146">BackgroundWorkerShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;found);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_iter&nbsp; &nbsp; siter;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;total_slots = <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_register_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_terminate_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy contents of worker list into shared memory.&nbsp; Record the shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * memory slot assigned to each worker.&nbsp; This ensures a 1-to-1<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correspondence between the postmaster's private list and the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slist_foreach(siter, &amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(slotno &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;terminate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pid = InvalidPid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;generation = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_shmem_slot = slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_notify_pid = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* might be reinit after crash */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;slot-&gt;worker, &amp;rw-&gt;rw_worker, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackgroundWorker));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining slots as not in use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (slotno &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[slotno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;in_use = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search the postmaster's backend-private list of RegisteredBgWorker objects<br/></li>
<li></span><span class="Comment"> * for the one that <a href="../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to the given slot number.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> RegisteredBgWorker *<br/></li>
<li><a id="L221">&#x200c;</a><span class="linkable">FindRegisteredWorkerBySlotNumber</span>(<span class="Type">int</span> slotno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; siter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach(siter, &amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_shmem_slot == slotno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> rw;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Notice changes to shared memory made by other backends.<br/></li>
<li></span><span class="Comment"> * Accept new worker requests only if allow_new_workers is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code runs in the postmaster, so we must be very careful not to assume<br/></li>
<li></span><span class="Comment"> * that shared memory contents are sane.&nbsp; Otherwise, a rogue backend could<br/></li>
<li></span><span class="Comment"> * take out the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L246">&#x200c;</a></span><span class="linkable">BackgroundWorkerStateChange</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_new_workers)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The total number of slots stored in shared memory should match our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * notion of <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>.&nbsp; If it does not, something is very<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong.&nbsp; Further down, we always refer to this value as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>, in case shared memory gets corrupted while we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a> != <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;total_slots)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inconsistent background worker state (<a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>=</span><span class="Special">%d</span><span class="Constant">, total_slots=</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;total_slots)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterate through slots, looking for newly-registered workers or workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * who must <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (slotno = <span class="Constant">0</span>; slotno &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>; ++slotno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[slotno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slot-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure we don't see the in_use flag <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the updated slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pg_read_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* See whether we already know about this worker. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rw = <a href="#L221" title="postmaster/bgworker.c:221">FindRegisteredWorkerBySlotNumber</a>(slotno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In general, the worker data can't change after it's initially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * registered.&nbsp; However, someone can set the terminate flag.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;terminate &amp;&amp; !rw-&gt;rw_terminate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_terminate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(rw-&gt;rw_pid, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report never-started, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-terminated worker as dead. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L467" title="postmaster/bgworker.c:467">ReportBackgroundWorkerPID</a>(rw);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't allowing new workers, then immediately mark it for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * termination; the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stanza will take care of cleaning it up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doing this ensures that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the worker will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * awoken, even though the worker will never be allowed to run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!allow_new_workers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;terminate = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the worker is marked for termination, we don't need to add it to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the registered workers list; we can just free the slot. However, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bgw_notify_pid is set, the process that registered the worker may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to know that we've processed the terminate request, so be sure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to signal it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;terminate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notify_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a memory barrier here to make sure that the load of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bgw_notify_pid and the update of parallel_terminate_count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * complete <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the store to in_use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notify_pid = slot-&gt;worker.bgw_notify_pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((slot-&gt;worker.bgw_flags &amp; BGWORKER_CLASS_PARALLEL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_terminate_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;in_use = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(notify_pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the registration data into the registered workers list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rw = <a href="../utils/mmgr/mcxt.c.html#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RegisteredBgWorker),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM | MCXT_ALLOC_ZERO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy strings in a paranoid way.&nbsp; If shared memory is corrupted, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * source data might not even be NUL-terminated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ascii.c.html#L174" title="utils/adt/ascii.c:174">ascii_safe_strlcpy</a>(rw-&gt;rw_worker.bgw_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;worker.bgw_name, BGW_MAXLEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ascii.c.html#L174" title="utils/adt/ascii.c:174">ascii_safe_strlcpy</a>(rw-&gt;rw_worker.bgw_type,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;worker.bgw_type, BGW_MAXLEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ascii.c.html#L174" title="utils/adt/ascii.c:174">ascii_safe_strlcpy</a>(rw-&gt;rw_worker.bgw_library_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;worker.bgw_library_name, MAXPGPATH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/ascii.c.html#L174" title="utils/adt/ascii.c:174">ascii_safe_strlcpy</a>(rw-&gt;rw_worker.bgw_function_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot-&gt;worker.bgw_function_name, BGW_MAXLEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy various fixed-size fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flags, start_time, and restart_time are examined by the postmaster,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but nothing too bad will happen if they are corrupted.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remaining fields will only be examined by the child process.&nbsp; It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might crash, but we won't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_flags = slot-&gt;worker.bgw_flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_start_time = slot-&gt;worker.bgw_start_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_restart_time = slot-&gt;worker.bgw_restart_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_main_arg = slot-&gt;worker.bgw_main_arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(rw-&gt;rw_worker.bgw_extra, slot-&gt;worker.bgw_extra, BGW_EXTRALEN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy the PID to be notified about state changes, but only if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster knows about a backend with that PID.&nbsp; It isn't an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if the postmaster doesn't know about the PID, because the backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that requested the worker could have died (or been killed) just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after doing so.&nbsp; Nonetheless, at least until we get some experience<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with how this plays out in the wild, log a message at a relative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * high debug level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_notify_pid = slot-&gt;worker.bgw_notify_pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="postmaster.c.html#L4528" title="postmaster/postmaster.c:4528">PostmasterMarkPIDForWorkerNotify</a>(rw-&gt;rw_worker.bgw_notify_pid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;worker notification PID </span><span class="Special">%d</span><span class="Constant"> is not valid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) rw-&gt;rw_worker.bgw_notify_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_notify_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Initialize postmaster bookkeeping. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_backend = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_child_slot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_shmem_slot = slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_terminate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Log it! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;registering background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw-&gt;rw_worker.bgw_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_push_head(&amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>, &amp;rw-&gt;rw_lnode);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Forget about a background worker that's no longer needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The worker must be identified by passing an slist_mutable_iter that<br/></li>
<li></span><span class="Comment"> * points to it.&nbsp; This convention allows deletion of workers during<br/></li>
<li></span><span class="Comment"> * searches of the worker list, and saves having to search the list again.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller is responsible for notifying bgw_notify_pid, if appropriate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function must be invoked only in the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L432">&#x200c;</a></span><span class="linkable">ForgetBackgroundWorker</span>(slist_mutable_iter *cur)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, cur-&gt;cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rw-&gt;rw_shmem_slot &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[rw-&gt;rw_shmem_slot];<br/></li>
<li>&nbsp; &nbsp; Assert(slot-&gt;in_use);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need a memory barrier here to make sure that the update of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel_terminate_count completes <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the store to in_use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((rw-&gt;rw_worker.bgw_flags &amp; BGWORKER_CLASS_PARALLEL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_terminate_count++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_memory_barrier();<br/></li>
<li>&nbsp; &nbsp; slot-&gt;in_use = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unregistering background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw-&gt;rw_worker.bgw_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_delete_current(cur);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rw);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report the PID of a newly-launched background worker in shared memory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should only be called from the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L467">&#x200c;</a></span><span class="linkable">ReportBackgroundWorkerPID</span>(RegisteredBgWorker *rw)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rw-&gt;rw_shmem_slot &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[rw-&gt;rw_shmem_slot];<br/></li>
<li>&nbsp; &nbsp; slot-&gt;pid = rw-&gt;rw_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_worker.bgw_notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kill(rw-&gt;rw_worker.bgw_notify_pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Report that the PID of a background worker is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> zero because a<br/></li>
<li></span><span class="Comment"> * previously-running background worker has exited.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should only be called from the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L486">&#x200c;</a></span><span class="linkable">ReportBackgroundWorkerExit</span>(slist_mutable_iter *cur)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notify_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, cur-&gt;cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rw-&gt;rw_shmem_slot &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[rw-&gt;rw_shmem_slot];<br/></li>
<li>&nbsp; &nbsp; slot-&gt;pid = rw-&gt;rw_pid;<br/></li>
<li>&nbsp; &nbsp; notify_pid = rw-&gt;rw_worker.bgw_notify_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this worker is slated for deregistration, do that <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> notifying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the process which started it.&nbsp; Otherwise, if that process tries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reuse the slot immediately, it might not be available yet.&nbsp; In theory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that could happen anyway if the process checks slot-&gt;pid at just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong moment, but this makes the window narrower.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_terminate ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_restart_time == BGW_NEVER_RESTART)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L432" title="postmaster/bgworker.c:432">ForgetBackgroundWorker</a>(cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; kill(notify_pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel SIGUSR1 notifications for a PID belonging to an exiting backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should only be called from the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L520">&#x200c;</a></span><span class="linkable">BackgroundWorkerStopNotifications</span>(pid_t pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; siter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach(siter, &amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_worker.bgw_notify_pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_notify_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> not-yet-started worker requests that have <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> processes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during a normal (&quot;smart&quot; or &quot;fast&quot;) database shutdown.<br/></li>
<li></span><span class="Comment"> * After this point, no new background workers will be started, so anything<br/></li>
<li></span><span class="Comment"> * that might be <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for them needs to be kicked off its wait.&nbsp; We do<br/></li>
<li></span><span class="Comment"> * that by canceling the bgworker registration entirely, which is perhaps<br/></li>
<li></span><span class="Comment"> * overkill, but since we're shutting down it does not matter whether the<br/></li>
<li></span><span class="Comment"> * registration record sticks around.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should only be called from the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L547">&#x200c;</a></span><span class="linkable">ForgetUnstartedBackgroundWorkers</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach_modify(iter, &amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(rw-&gt;rw_shmem_slot &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[rw-&gt;rw_shmem_slot];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not yet started, and there's someone <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pid == InvalidPid &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... then zap it, and notify the waiter */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notify_pid = rw-&gt;rw_worker.bgw_notify_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L432" title="postmaster/bgworker.c:432">ForgetBackgroundWorker</a>(&amp;iter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(notify_pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Reset background worker crash state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We assume that, after a crash-and-restart cycle, background workers without<br/></li>
<li></span><span class="Comment"> * the never-restart flag should be restarted immediately, instead of <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment"> * for bgw_restart_time to elapse.&nbsp; On the other hand, workers with that flag<br/></li>
<li></span><span class="Comment"> * should be forgotten immediately, since we won't ever restart them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function should only be called from the postmaster.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L585">&#x200c;</a></span><span class="linkable">ResetBackgroundWorkerCrashTimes</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; slist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach_modify(iter, &amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_worker.bgw_restart_time == BGW_NEVER_RESTART)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Workers marked BGW_NEVER_RESTART shouldn't get relaunched after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the crash, so forget about them.&nbsp; (If we wait until after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash to forget about them, and they are parallel workers,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel_terminate_count will get incremented after we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already zeroed parallel_register_count, which would be bad.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L432" title="postmaster/bgworker.c:432">ForgetBackgroundWorker</a>(&amp;iter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The accounting which we do via parallel_register_count and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel_terminate_count would get messed up if a worker marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parallel could survive a crash and restart cycle. All such<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workers should be marked BGW_NEVER_RESTART, and thus control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never reach this branch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert((rw-&gt;rw_worker.bgw_flags &amp; BGWORKER_CLASS_PARALLEL) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allow this worker to be restarted immediately after we finish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * resetting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there was anyone <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for it, they're history.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_notify_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Complain about the BackgroundWorker definition using error level elevel.<br/></li>
<li></span><span class="Comment"> * Return true if it looks ok, false if not (unless elevel &gt;= ERROR, in<br/></li>
<li></span><span class="Comment"> * which case we won't return at all in the not-OK case).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L637">&#x200c;</a></span><span class="linkable">SanityCheckBackgroundWorker</span>(BackgroundWorker *worker, <span class="Type">int</span> elevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* sanity check for flags */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We used to support workers not connected to shared memory, but don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anymore. Thus this is a required flag <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. We're not removing the flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for compatibility reasons and because the flag still provides some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signal when reading code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(worker-&gt;bgw_flags &amp; BGWORKER_SHMEM_ACCESS))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: background workers without shared memory access are not supported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;bgw_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;bgw_flags &amp; BGWORKER_BACKEND_DATABASE_CONNECTION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;bgw_start_time == BgWorkerStart_PostmasterStart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: cannot request database access if starting at postmaster start&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;bgw_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> other checks? */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((worker-&gt;bgw_restart_time &lt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; worker-&gt;bgw_restart_time != BGW_NEVER_RESTART) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (worker-&gt;bgw_restart_time &gt; USECS_PER_DAY / <span class="Constant">1000</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: invalid restart interval&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;bgw_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parallel workers may not be configured for restart, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel_register_count/parallel_terminate_count accounting can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle parallel workers lasting through a crash-and-restart cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;bgw_restart_time != BGW_NEVER_RESTART &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (worker-&gt;bgw_flags &amp; BGWORKER_CLASS_PARALLEL) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(elevel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: parallel workers may not be configured for restart&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;bgw_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If bgw_type is not filled in, use bgw_name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(worker-&gt;bgw_type, <span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcpy(worker-&gt;bgw_type, worker-&gt;bgw_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Standard SIGTERM handler for background workers<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L709">&#x200c;</a></span><span class="linkable">bgworker_die</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> due to administrator command&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="postmaster.c.html#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>-&gt;bgw_type)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point for background worker processes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L723">&#x200c;</a></span><span class="linkable">BackgroundWorkerMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li>&nbsp; &nbsp; BackgroundWorker *worker;<br/></li>
<li>&nbsp; &nbsp; bgworker_main_type entrypt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (startup_data == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;unable to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> bgworker entry&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackgroundWorker));<br/></li>
<li>&nbsp; &nbsp; worker = <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackgroundWorker));<br/></li>
<li>&nbsp; &nbsp; memcpy(worker, startup_data, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackgroundWorker));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we're done reading the startup data, release postmaster's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * working memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="postmaster.c.html#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a> = worker;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_BG_WORKER;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L267" title="utils/misc/ps_status.c:267">init_ps_display</a>(worker-&gt;bgw_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(InitProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply <a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> * <span class="Constant">1000000L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up signal handlers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;bgw_flags &amp; BGWORKER_BACKEND_DATABASE_CONNECTION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SIGINT is used to signal canceling the current action<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="../tcop/postgres.c.html#L3002" title="tcop/postgres.c:3002">StatementCancelHandler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGFPE</span>, <a href="../tcop/postgres.c.html#L3019" title="tcop/postgres.c:3019">FloatExceptionHandler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> Any other handlers needed here? */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGFPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="#L709" title="postmaster/bgworker.c:709">bgworker_die</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establishes SIGALRM handler */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We just need to clean up, report the error, and go away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sigsetjmp will have blocked all signals, but we may need to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signals while communicating with our parallel leader.&nbsp; Once we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done HOLD_INTERRUPTS() it should be safe to unblock signals.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="postmaster.c.html#L4229" title="postmaster/postmaster.c:4229">BackgroundWorkerUnblockSignals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the parallel leader and the server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do we need more <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> here?&nbsp; For shmem-connected bgworkers, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will call <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a> below, which will install <a href="../storage/lmgr/proc.c.html#L834" title="storage/lmgr/proc.c:834">ProcKill</a> as exit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callback.&nbsp; That will take care of releasing locks, etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and go away */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a per-backend PGPROC struct in shared memory.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can use LWLocks or access <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Early initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L645" title="utils/init/postinit.c:645">BaseInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the entry point function, loading its library if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entrypt = <a href="#L1262" title="postmaster/bgworker.c:1262">LookupBackgroundWorkerFunction</a>(worker-&gt;bgw_library_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; worker-&gt;bgw_function_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that in normal processes, we would call <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> here.&nbsp; For a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker, however, we don't know what database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to, yet; so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to wait until the user code does it via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="postmaster.c.html#L4155" title="postmaster/postmaster.c:4155">BackgroundWorkerInitializeConnection</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now invoke the user-defined worker code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; entrypt(worker-&gt;bgw_main_arg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and if it returns, we're done */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a new static background worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can only be called directly from postmaster or in the <a href="../replication/libpqwalreceiver/libpqwalreceiver.c.html#L120" title="replication/libpqwalreceiver/libpqwalreceiver.c:120">_PG_init</a><br/></li>
<li></span><span class="Comment"> * function of a module library that's loaded by shared_preload_libraries;<br/></li>
<li></span><span class="Comment"> * otherwise it will have no effect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L862">&#x200c;</a></span><span class="linkable">RegisterBackgroundWorker</span>(BackgroundWorker *worker)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; numworkers = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Static background workers can only be registered in the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> || !<a href="../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In EXEC_BACKEND or single-user mode, we process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shared_preload_libraries in backend processes too.&nbsp; We cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * register static background workers at that stage, but many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * libraries' <a href="../replication/libpqwalreceiver/libpqwalreceiver.c.html#L120" title="replication/libpqwalreceiver/libpqwalreceiver.c:120">_PG_init</a>() <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> don't distinguish whether they're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * being loaded in the postmaster or in a backend, they just check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/init/miscinit.c.html#L1778" title="utils/init/miscinit.c:1778">process_shared_preload_libraries_in_progress</a>.&nbsp; It's a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> sloppy,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but for historical reasons we tolerate it.&nbsp; In EXEC_BACKEND mode,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the background workers should already have been registered when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * library was loaded in postmaster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/miscinit.c.html#L1778" title="utils/init/miscinit.c:1778">process_shared_preload_libraries_in_progress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: must be registered in shared_preload_libraries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;bgw_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Cannot register static background workers after calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L162" title="postmaster/bgworker.c:162">BackgroundWorkerShmemInit</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot register background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> after shmem init&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; worker-&gt;bgw_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;registering background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, worker-&gt;bgw_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L637" title="postmaster/bgworker.c:637">SanityCheckBackgroundWorker</a>(worker, LOG))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;bgw_notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: only dynamic background workers can request notification&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;bgw_name)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Enforce maximum number of workers.&nbsp; Note this is overly restrictive: we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * could allow more non-shmem-connected workers, because these don't count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * towards the MAX_BACKENDS limit elsewhere.&nbsp; For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, it doesn't seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * important to relax this restriction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (++numworkers &gt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;too many background workers&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1297" title="utils/error/elog.c:1297">errdetail_plural</a>(<span class="Constant">&quot;Up to </span><span class="Special">%d</span><span class="Constant"> background worker can be registered with the current settings.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Up to </span><span class="Special">%d</span><span class="Constant"> background workers can be registered with the current settings.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Consider increasing the configuration parameter <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the registration data into the registered workers list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rw = <a href="../utils/mmgr/mcxt.c.html#L1237" title="utils/mmgr/mcxt.c:1237">MemoryContextAllocExtended</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RegisteredBgWorker),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MCXT_ALLOC_NO_OOM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rw == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_worker = *worker;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_backend = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_child_slot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_crashed_at = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_terminate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_push_head(&amp;<a href="#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>, &amp;rw-&gt;rw_lnode);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Register a new background worker from a regular backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success and false on failure.&nbsp; Failure typically indicates<br/></li>
<li></span><span class="Comment"> * that no background worker slots are currently available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If handle != NULL, we'll set *handle to a pointer that can subsequently<br/></li>
<li></span><span class="Comment"> * be used as an argument to <a href="#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>().&nbsp; The caller can<br/></li>
<li></span><span class="Comment"> * free this pointer using <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(), if desired.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L970">&#x200c;</a></span><span class="linkable">RegisterDynamicBackgroundWorker</span>(BackgroundWorker *worker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> **handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; parallel;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; generation = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can't register dynamic background workers from the postmaster. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this is a standalone backend, we're the only process and can't start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more.&nbsp; In a multi-process environment, it might be theoretically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible, but we don't currently support it due to locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considerations; see comments on the <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L637" title="postmaster/bgworker.c:637">SanityCheckBackgroundWorker</a>(worker, ERROR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; parallel = (worker-&gt;bgw_flags &amp; BGWORKER_CLASS_PARALLEL) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BackgroundWorkerLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is a parallel worker, check whether there are already too many<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel workers; if so, don't register another one.&nbsp; Our view of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parallel_terminate_count may be slightly stale, but that doesn't really<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter: we would have gotten the same result if we'd arrived here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slightly earlier anyway.&nbsp; There's no <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> for it, either, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster must not take locks; a memory barrier wouldn't guarantee<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything useful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parallel &amp;&amp; (<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_register_count -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_terminate_count) &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L142" title="utils/init/globals.c:142">max_parallel_workers</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_register_count -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_terminate_count &lt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAX_PARALLEL_WORKER_LIMIT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BackgroundWorkerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look for an unused slot.&nbsp; If we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one, grab it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (slotno = <span class="Constant">0</span>; slotno &lt; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;total_slots; ++slotno)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[slotno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!slot-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;slot-&gt;worker, worker, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackgroundWorker));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;pid = InvalidPid; <span class="Comment">/* indicates not started yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;generation++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;terminate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generation = slot-&gt;generation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (parallel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;parallel_register_count++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure postmaster doesn't see the slot as in use <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sees the new contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_write_barrier();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;in_use = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BackgroundWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we found a slot, tell the postmaster to notice the change. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (success)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_BACKGROUND_WORKER_CHANGE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found a slot and the user has provided a handle, <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (success &amp;&amp; handle)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *handle = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*handle)-&gt;slot = slotno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*handle)-&gt;generation = generation;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> success;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the PID of a dynamically-registered background worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the worker is determined to be running, the return value will be<br/></li>
<li></span><span class="Comment"> * BGWH_STARTED and *pidp will get the PID of the worker process.&nbsp; If the<br/></li>
<li></span><span class="Comment"> * postmaster has not yet attempted to start the worker, the return value will<br/></li>
<li></span><span class="Comment"> * be BGWH_NOT_YET_STARTED.&nbsp; Otherwise, the return value is BGWH_STOPPED.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * BGWH_STOPPED can indicate either that the worker is temporarily stopped<br/></li>
<li></span><span class="Comment"> * (because it is configured for automatic restart and exited non-zero),<br/></li>
<li></span><span class="Comment"> * or that the worker is permanently stopped (because it exited with exit<br/></li>
<li></span><span class="Comment"> * code 0, or was not configured for automatic restart), or even that the<br/></li>
<li></span><span class="Comment"> * worker was unregistered without ever starting (either because startup<br/></li>
<li></span><span class="Comment"> * failed and the worker is not configured for automatic restart, or because<br/></li>
<li></span><span class="Comment"> * <a href="#L1221" title="postmaster/bgworker.c:1221">TerminateBackgroundWorker</a> was used <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the worker was successfully<br/></li>
<li></span><span class="Comment"> * started).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BgwHandleStatus<br/></li>
<li><a id="L1082">&#x200c;</a><span class="linkable">GetBackgroundWorkerPid</span>(<a href="#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle, pid_t *pidp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot;<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(handle-&gt;slot &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[handle-&gt;slot];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We could probably arrange to synchronize access to data using memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * barriers only, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, let's just keep it simple and grab the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.&nbsp; It seems unlikely that there will be enough traffic here to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * result in meaningful contention.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BackgroundWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The generation number can't be concurrently changed while we hold the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock.&nbsp; The pid, which is updated by the postmaster, can change at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time, but we assume such changes are atomic.&nbsp; So the value we read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't be garbage, but it might be out of date by the time the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * examines it (but that's unavoidable anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The in_use flag could be in the process of changing from true to false,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but if it is already false then it can't change further.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (handle-&gt;generation != slot-&gt;generation || !slot-&gt;in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pid = slot-&gt;pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All done. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BackgroundWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BGWH_STOPPED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pid == InvalidPid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> BGWH_NOT_YET_STARTED;<br/></li>
<li>&nbsp; &nbsp; *pidp = pid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> BGWH_STARTED;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for a background worker to start up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is like <a href="#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(), except that if the worker has not<br/></li>
<li></span><span class="Comment"> * yet started, we wait for it to do so; thus, BGWH_NOT_YET_STARTED is never<br/></li>
<li></span><span class="Comment"> * returned.&nbsp; However, if the postmaster has died, we give up and return<br/></li>
<li></span><span class="Comment"> * BGWH_POSTMASTER_DIED, since it that case we know that startup will not<br/></li>
<li></span><span class="Comment"> * take place.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller *must* have set our PID as the worker's bgw_notify_pid,<br/></li>
<li></span><span class="Comment"> * else we will not be awoken promptly when the worker's state changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BgwHandleStatus<br/></li>
<li><a id="L1137">&#x200c;</a><span class="linkable">WaitForBackgroundWorkerStartup</span>(<a href="#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle, pid_t *pidp)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(handle, &amp;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == BGWH_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pidp = pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status != BGWH_NOT_YET_STARTED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_POSTMASTER_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_BGWORKER_STARTUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = BGWH_POSTMASTER_DIED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> status;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait for a background worker to stop.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the worker hasn't yet started, or is running, we wait for it to stop<br/></li>
<li></span><span class="Comment"> * and then return BGWH_STOPPED.&nbsp; However, if the postmaster has died, we give<br/></li>
<li></span><span class="Comment"> * up and return BGWH_POSTMASTER_DIED, because it's the postmaster that<br/></li>
<li></span><span class="Comment"> * notifies us when a worker's state changes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller *must* have set our PID as the worker's bgw_notify_pid,<br/></li>
<li></span><span class="Comment"> * else we will not be awoken promptly when the worker's state changes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>BgwHandleStatus<br/></li>
<li><a id="L1182">&#x200c;</a><span class="linkable">WaitForBackgroundWorkerShutdown</span>(<a href="#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BgwHandleStatus status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L1082" title="postmaster/bgworker.c:1082">GetBackgroundWorkerPid</a>(handle, &amp;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == BGWH_STOPPED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_POSTMASTER_DEATH, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_BGWORKER_SHUTDOWN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = BGWH_POSTMASTER_DIED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> status;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Instruct the postmaster to terminate a background worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that it's safe to do this without regard to whether the worker is<br/></li>
<li></span><span class="Comment"> * still running, or even if the worker may already have exited and been<br/></li>
<li></span><span class="Comment"> * unregistered.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1221">&#x200c;</a></span><span class="linkable">TerminateBackgroundWorker</span>(<a href="#L102" title="postmaster/bgworker.c:102">BackgroundWorkerHandle</a> *handle)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; signal_postmaster = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(handle-&gt;slot &lt; <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>&nbsp; &nbsp; slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[handle-&gt;slot];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set terminate flag in shared memory, unless slot has been reused. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BackgroundWorkerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (handle-&gt;generation == slot-&gt;generation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slot-&gt;terminate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; signal_postmaster = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BackgroundWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure the postmaster notices the change to shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (signal_postmaster)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_BACKGROUND_WORKER_CHANGE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up (and possibly load) a bgworker entry point function.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> contained in the core code, we use library name &quot;postgres&quot;<br/></li>
<li></span><span class="Comment"> * and consult the <a href="#L118" title="postmaster/bgworker.c:118">InternalBGWorkers</a> array.&nbsp; External <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are<br/></li>
<li></span><span class="Comment"> * looked up, and loaded if necessary, using <a href="../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The point of this is to pass function names as strings across process<br/></li>
<li></span><span class="Comment"> * boundaries.&nbsp; We can't pass actual function addresses because of the<br/></li>
<li></span><span class="Comment"> * possibility that the function has been loaded at a different address<br/></li>
<li></span><span class="Comment"> * in a different process.&nbsp; This is obviously a hazard for <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in<br/></li>
<li></span><span class="Comment"> * loadable libraries, but it can happen even for <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the core code<br/></li>
<li></span><span class="Comment"> * on platforms using EXEC_BACKEND (e.g., Windows).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * At some point it might be worthwhile to get rid of <a href="#L118" title="postmaster/bgworker.c:118">InternalBGWorkers</a>[]<br/></li>
<li></span><span class="Comment"> * in favor of applying <a href="../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>() for core <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> too;<br/></li>
<li></span><span class="Comment"> * but that raises portability issues that are not worth addressing <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> bgworker_main_type<br/></li>
<li><a id="L1262">&#x200c;</a><span class="linkable">LookupBackgroundWorkerFunction</span>(<span class="Type">const</span> <span class="Type">char</span> *libraryname, <span class="Type">const</span> <span class="Type">char</span> *funcname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the function is to be loaded from postgres itself, search the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L118" title="postmaster/bgworker.c:118">InternalBGWorkers</a> array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(libraryname, <span class="Constant">&quot;postgres&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; lengthof(<a href="#L118" title="postmaster/bgworker.c:118">InternalBGWorkers</a>); i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="#L118" title="postmaster/bgworker.c:118">InternalBGWorkers</a>[i].fn_name, funcname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L118" title="postmaster/bgworker.c:118">InternalBGWorkers</a>[i].fn_addr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can only reach this by programming error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> function </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> not found&quot;</span>, funcname);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise load from external library. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (bgworker_main_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>(libraryname, funcname, <span class="Constant">true</span>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a PID, get the bgw_type of the background worker.&nbsp; Returns NULL if<br/></li>
<li></span><span class="Comment"> * not a valid background worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is in static memory belonging to this function, so it has<br/></li>
<li></span><span class="Comment"> * to be used <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling this function again.&nbsp; This is so that the caller<br/></li>
<li></span><span class="Comment"> * doesn't have to worry about the background worker locking protocol.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1296">&#x200c;</a><span class="linkable">GetBackgroundWorkerTypeByPid</span>(pid_t pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slotno;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">char</span> result[BGW_MAXLEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(BackgroundWorkerLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (slotno = <span class="Constant">0</span>; slotno &lt; <a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;total_slots; slotno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L74" title="postmaster/bgworker.c:74">BackgroundWorkerSlot</a> *slot = &amp;<a href="#L108" title="postmaster/bgworker.c:108">BackgroundWorkerData</a>-&gt;slot[slotno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (slot-&gt;pid &gt; <span class="Constant">0</span> &amp;&amp; slot-&gt;pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(result, slot-&gt;worker.bgw_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(BackgroundWorkerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
