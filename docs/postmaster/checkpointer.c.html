<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/checkpointer.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/checkpointer.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L138">CheckPointCompletionTarget</a></li>
<li><a href="#L136">CheckPointTimeout</a></li>
<li><a href="#L137">CheckPointWarning</a></li>
<li><a href="#L128">CheckpointerShmem</a></li>
<li><a href="#L143">ckpt_active</a></li>
<li><a href="#L148">ckpt_cached_elapsed</a></li>
<li><a href="#L147">ckpt_start_recptr</a></li>
<li><a href="#L146">ckpt_start_time</a></li>
<li><a href="#L150">last_checkpoint_time</a></li>
<li><a href="#L151">last_xlog_switch_time</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L106">CheckpointerRequest</a></li>
<li><a href="#L126">CheckpointerShmemStruct</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1260">AbsorbSyncRequests</a></li>
<li><a href="#L623">CheckArchiveTimeout</a></li>
<li><a href="#L711">CheckpointWriteDelay</a></li>
<li><a href="#L173">CheckpointerMain</a></li>
<li><a href="#L898">CheckpointerShmemInit</a></li>
<li><a href="#L879">CheckpointerShmemSize</a></li>
<li><a href="#L1154">CompactCheckpointerRequestQueue</a></li>
<li><a href="#L1326">FirstCallSinceLastCheckpoint</a></li>
<li><a href="#L1093">ForwardSyncRequest</a></li>
<li><a href="#L558">HandleCheckpointerInterrupts</a></li>
<li><a href="#L684">ImmediateCheckpointRequested</a></li>
<li><a href="#L780">IsCheckpointOnSchedule</a></li>
<li><a href="#L859">ReqCheckpointHandler</a></li>
<li><a href="#L941">RequestCheckpoint</a></li>
<li><a href="#L1307">UpdateSharedMemoryConfig</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L991">MAX_SIGNAL_TRIES</a></li>
<li><a href="#L131">WRITES_PER_ABSORB</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * checkpointer.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The checkpointer is new as of Postgres 9.2.&nbsp; It handles all checkpoints.<br/></li>
<li></span><span class="Comment"> * Checkpoints are automatically dispatched after a certain amount of time has<br/></li>
<li></span><span class="Comment"> * elapsed since the last one, and it can be signaled to perform requested<br/></li>
<li></span><span class="Comment"> * checkpoints as well.&nbsp; (The GUC parameter that mandates a checkpoint every<br/></li>
<li></span><span class="Comment"> * so many WAL segments is implemented by having backends signal when they<br/></li>
<li></span><span class="Comment"> * fill WAL segments; the checkpointer itself doesn't watch for the<br/></li>
<li></span><span class="Comment"> * condition.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normal termination is by SIGUSR2, which instructs the checkpointer to<br/></li>
<li></span><span class="Comment"> * execute a shutdown checkpoint and then exit(0).&nbsp; (All backends must be<br/></li>
<li></span><span class="Comment"> * stopped <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> SIGUSR2 is issued!)&nbsp; Emergency termination is by SIGQUIT;<br/></li>
<li></span><span class="Comment"> * like <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> backend, the checkpointer will simply abort and exit on SIGQUIT.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the checkpointer exits unexpectedly, the postmaster treats that the same<br/></li>
<li></span><span class="Comment"> * as a backend crash: shared memory may be corrupted, so remaining backends<br/></li>
<li></span><span class="Comment"> * should be killed by SIGQUIT and then a recovery cycle started.&nbsp; (Even if<br/></li>
<li></span><span class="Comment"> * shared memory isn't corrupted, we have lost information about which<br/></li>
<li></span><span class="Comment"> * files need to be fsync'd for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint, and so a system<br/></li>
<li></span><span class="Comment"> * restart needs to be forced.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/checkpointer.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/auxprocess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgwriter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/syncrep.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/spin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*----------<br/></li>
<li></span><span class="Comment"> * Shared memory area for communication between checkpointer and backends<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The ckpt counters allow backends to watch for completion of a checkpoint<br/></li>
<li></span><span class="Comment"> * request they <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.&nbsp; Here's how it works:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * At start of a checkpoint, checkpointer reads (and clears) the request<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; flags and increments ckpt_started, while holding ckpt_lck.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * On completion of a checkpoint, checkpointer sets ckpt_done to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> ckpt_started.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; * On failure of a checkpoint, checkpointer increments ckpt_failed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and sets ckpt_done to <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> ckpt_started.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The algorithm for backends is:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 1. Record current <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of ckpt_failed and ckpt_started, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; set request flags, while holding ckpt_lck.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 2. Send signal to request checkpoint.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 3. Sleep until ckpt_started changes.&nbsp; Now you know a checkpoint has<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; begun since you started this algorithm (although *not* that it was<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; specifically initiated by your signal), and that it is using your flags.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 4. Record new value of ckpt_started.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 5. Sleep until ckpt_done &gt;= saved value of ckpt_started.&nbsp; (Use modulo<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; arithmetic here in case counters wrap around.)&nbsp; Now you know a<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; checkpoint has started and completed, but not whether it was<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; successful.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; 6. If ckpt_failed is different from the originally saved value,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; assume request failed; otherwise it was definitely successful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ckpt_flags holds the OR of the checkpoint request flags sent by all<br/></li>
<li></span><span class="Comment"> * requesting backends since the last checkpoint start.&nbsp; The flags are<br/></li>
<li></span><span class="Comment"> * chosen so that OR'ing is the correct way to <a href="../regex/regc_nfa.c.html#L1980" title="regex/regc_nfa.c:1980">combine</a> multiple requests.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The requests array holds fsync requests sent by backends and not yet<br/></li>
<li></span><span class="Comment"> * absorbed by the checkpointer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike the checkpoint fields, requests related fields are protected by<br/></li>
<li></span><span class="Comment"> * CheckpointerCommLock.<br/></li>
<li></span><span class="Comment"> *----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; SyncRequestType type;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* request type */<br/></li>
<li></span>&nbsp; &nbsp; FileTag&nbsp; &nbsp; &nbsp; &nbsp; ftag;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* file identifier */<br/></li>
<li><a id="L106">&#x200c;</a></span>} <span class="linkable">CheckpointerRequest</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; checkpointer_pid;&nbsp; &nbsp; <span class="Comment">/* PID (0 if not started) */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; slock_t&nbsp; &nbsp; &nbsp; &nbsp; ckpt_lck;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* protects all the ckpt_* fields */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_started;&nbsp; &nbsp; <span class="Comment">/* advances when checkpoint starts */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_done;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* advances when checkpoint done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_failed;&nbsp; &nbsp; <span class="Comment">/* advances when checkpoint fails */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_flags;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* checkpoint flags, as defined in xlog.h */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ConditionVariable start_cv; <span class="Comment">/* signaled when ckpt_started advances */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable done_cv;&nbsp; &nbsp; <span class="Comment">/* signaled when ckpt_done advances */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_requests;&nbsp; &nbsp; <span class="Comment">/* current # of requests */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_requests;&nbsp; &nbsp; <span class="Comment">/* allocated array size */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> requests[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L126">&#x200c;</a>} <span class="linkable">CheckpointerShmemStruct</span>;<br/></li>
<li><br/></li>
<li><a id="L128">&#x200c;</a><span class="Type">static</span> <a href="#L126" title="postmaster/checkpointer.c:126">CheckpointerShmemStruct</a> *<span class="linkable">CheckpointerShmem</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* interval for calling <a href="#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a> in <a href="#L711" title="postmaster/checkpointer.c:711">CheckpointWriteDelay</a> */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WRITES_PER_ABSORB</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">1000<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CheckPointTimeout</span> = <span class="Constant">300</span>;<br/></li>
<li><a id="L137">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CheckPointWarning</span> = <span class="Constant">30</span>;<br/></li>
<li><a id="L138">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CheckPointCompletionTarget</span> = <span class="Constant">0.9</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L143">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">ckpt_active</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* these <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are valid when <a href="#L143" title="postmaster/checkpointer.c:143">ckpt_active</a> is true: */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type">static</span> pg_time_t <span class="linkable">ckpt_start_time</span>;<br/></li>
<li><a id="L147">&#x200c;</a><span class="Type">static</span> XLogRecPtr <span class="linkable">ckpt_start_recptr</span>;<br/></li>
<li><a id="L148">&#x200c;</a><span class="Type">static</span> <span class="Type">double</span> <span class="linkable">ckpt_cached_elapsed</span>;<br/></li>
<li><br/></li>
<li><a id="L150">&#x200c;</a><span class="Type">static</span> pg_time_t <span class="linkable">last_checkpoint_time</span>;<br/></li>
<li><a id="L151">&#x200c;</a><span class="Type">static</span> pg_time_t <span class="linkable">last_xlog_switch_time</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Prototypes for private <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L558" title="postmaster/checkpointer.c:558">HandleCheckpointerInterrupts</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L623" title="postmaster/checkpointer.c:623">CheckArchiveTimeout</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L780" title="postmaster/checkpointer.c:780">IsCheckpointOnSchedule</a>(<span class="Type">double</span> progress);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L684" title="postmaster/checkpointer.c:684">ImmediateCheckpointRequested</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1154" title="postmaster/checkpointer.c:1154">CompactCheckpointerRequestQueue</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1307" title="postmaster/checkpointer.c:1307">UpdateSharedMemoryConfig</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Signal handlers */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L859" title="postmaster/checkpointer.c:859">ReqCheckpointHandler</a>(SIGNAL_ARGS);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point for checkpointer process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is invoked from AuxiliaryProcessMain, which has already created the<br/></li>
<li></span><span class="Comment"> * basic execution environment, but not enabled signals yet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L173">&#x200c;</a></span><span class="linkable">CheckpointerMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li>&nbsp; &nbsp; MemoryContext checkpointer_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_CHECKPOINTER;<br/></li>
<li>&nbsp; &nbsp; <a href="auxprocess.c.html#L44" title="postmaster/auxprocess.c:44">AuxiliaryProcessMainCommon</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;checkpointer_pid = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Properly <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> or ignore signals the postmaster might <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we deliberately ignore SIGTERM, because during a standard Unix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system shutdown cycle, init will SIGTERM all processes at once.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to wait for the backends to exit, whereupon the postmaster will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tell us it's okay to shut down (via SIGUSR2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="#L859" title="postmaster/checkpointer.c:859">ReqCheckpointHandler</a>); <span class="Comment">/* request checkpoint */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* ignore SIGTERM */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <a href="interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset some signals that are accepted by postmaster but not here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize so that first time-driven event happens at the correct time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L150" title="postmaster/checkpointer.c:150">last_checkpoint_time</a> = <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a> = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write out stats after shutdown. This needs to be called by exactly one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process during a normal shutdown, and since checkpointer is shut down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * very late...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Walsenders are shut down after the checkpointer, but currently don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * report stats. If that changes, we need a more complicated solution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="../utils/activity/pgstat.c.html#L462" title="utils/activity/pgstat.c:462">pgstat_before_server_shutdown</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a memory context that we will do all our work in.&nbsp; We do this so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can reset the context during error recovery and thereby avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible memory leaks.&nbsp; Formerly this code just ran in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, but resetting that would be a really bad idea.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; checkpointer_context = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Checkpointer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(checkpointer_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * You might wonder why this isn't coded as an infinite loop around a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PG_TRY construct.&nbsp; The reason is that this is the bottom of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exception stack, and so with PG_TRY there would be no exception handler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in force at all during the CATCH part.&nbsp; By leaving the outermost setjmp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always active, we have at least some chance of recovering from an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during error recovery.&nbsp; (If we get into an infinite loop thereby, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will soon be stopped by overflow of elog.c's <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state stack.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we use sigsetjmp(..., 1), so that the prevailing signal mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (to wit, <a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>) will be restored when longjmp'ing to here.&nbsp; Thus,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signals other than SIGQUIT will be blocked until we complete error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery.&nbsp; It might seem that this policy makes the HOLD_INTERRUPTS()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call redundant, but it is not since <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> might be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These operations are really just a minimal <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>().&nbsp; We don't have very many resources to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about in checkpointer, but we do have LWLocks, buffers, and temp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L5057" title="storage/buffer/bufmgr.c:5057">UnlockBuffers</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L1002" title="utils/resowner/resowner.c:1002">ReleaseAuxProcessResources</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L3502" title="storage/buffer/bufmgr.c:3502">AtEOXact_Buffers</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Warn <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> backends that the checkpoint failed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L143" title="postmaster/checkpointer.c:143">ckpt_active</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_failed++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_done = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_started;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;done_cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="postmaster/checkpointer.c:143">ckpt_active</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now return to normal top-level context and clear <a href="../utils/mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(checkpointer_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaked data in the top-level context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(checkpointer_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can allow interrupts again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep at least 1 second after <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error.&nbsp; A write error is likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be repeated, and we don't want to be filling the error logs as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fast as we can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000000L</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unblock signals (they were blocked when the postmaster forked us)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure all shared memory <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are set correctly for the config. Doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this here ensures no race conditions from other concurrent updaters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1307" title="postmaster/checkpointer.c:1307">UpdateSharedMemoryConfig</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advertise our latch that backends can use to wake us up while we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sleeping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;checkpointerLatch = &amp;<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;procLatch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop forever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_checkpoint = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_time_t&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; chkpt_or_rstpt_requested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; chkpt_or_rstpt_timed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-pending wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests or signals received recently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L558" title="postmaster/checkpointer.c:558">HandleCheckpointerInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Detect a pending checkpoint request by checking whether the flags<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> in shared memory is nonzero.&nbsp; We shouldn't need to acquire the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ckpt_lck for this.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<span class="Type">volatile</span> <a href="#L126" title="postmaster/checkpointer.c:126">CheckpointerShmemStruct</a> *) <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>)-&gt;ckpt_flags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_checkpoint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chkpt_or_rstpt_requested = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force a checkpoint if too much time has elapsed since the last one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we count a timed checkpoint in stats only when this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occurs without an external request, but we set the CAUSE_TIME flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> even if there is also an external request.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L150" title="postmaster/checkpointer.c:150">last_checkpoint_time</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elapsed_secs &gt;= <a href="#L136" title="postmaster/checkpointer.c:136">CheckPointTimeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!do_checkpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chkpt_or_rstpt_timed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_checkpoint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= CHECKPOINT_CAUSE_TIME;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do a checkpoint if requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_checkpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ckpt_performed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; do_restartpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we should perform a checkpoint or a restartpoint. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_restartpoint = <a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Atomically fetch the request flags to figure out what kind of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint we should perform, and increase the started-counter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to acknowledge that we've started a new checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags |= <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_flags;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_flags = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_started++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;start_cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The end-of-recovery checkpoint is a real checkpoint that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performed while we're still in recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_END_OF_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do_restartpoint = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chkpt_or_rstpt_timed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chkpt_or_rstpt_timed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.restartpoints_timed++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.num_timed++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chkpt_or_rstpt_requested)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chkpt_or_rstpt_requested = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.restartpoints_requested++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.num_requested++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will warn if (a) too soon since last checkpoint (whatever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caused it) and (b) somebody set the CHECKPOINT_CAUSE_XLOG flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since the last checkpoint start.&nbsp; Note in particular that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implementation will not generate warnings caused by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L136" title="postmaster/checkpointer.c:136">CheckPointTimeout</a> &lt; <a href="#L137" title="postmaster/checkpointer.c:137">CheckPointWarning</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!do_restartpoint &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (flags &amp; CHECKPOINT_CAUSE_XLOG) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs &lt; <a href="#L137" title="postmaster/checkpointer.c:137">CheckPointWarning</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;checkpoints are occurring too frequently (</span><span class="Special">%d</span><span class="Constant"> second apart)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;checkpoints are occurring too frequently (</span><span class="Special">%d</span><span class="Constant"> seconds apart)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elapsed_secs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; elapsed_secs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Consider increasing the configuration parameter max_wal_size.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Initialize checkpointer-private variables used during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="postmaster/checkpointer.c:143">ckpt_active</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="postmaster/checkpointer.c:147">ckpt_start_recptr</a> = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="postmaster/checkpointer.c:147">ckpt_start_recptr</a> = <a href="../access/transam/xlog.c.html#L6438" title="access/transam/xlog.c:6438">GetInsertRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="postmaster/checkpointer.c:146">ckpt_start_time</a> = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L148" title="postmaster/checkpointer.c:148">ckpt_cached_elapsed</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do the checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!do_restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>(flags);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_performed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ckpt_performed = <a href="../access/transam/xlog.c.html#L7512" title="access/transam/xlog.c:7512">CreateRestartPoint</a>(flags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> checkpoint, free all smgr objects.&nbsp; Otherwise we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would never do so for dropped relations, as the checkpointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * does not process shared invalidation messages or call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/smgr/smgr.c.html#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L332" title="storage/smgr/smgr.c:332">smgrdestroyall</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Indicate checkpoint completion to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_done = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_started;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;done_cv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ckpt_performed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we record the checkpoint start time not end time as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L150" title="postmaster/checkpointer.c:150">last_checkpoint_time</a>.&nbsp; This is so that time-driven<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoints happen at a predictable spacing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="postmaster/checkpointer.c:150">last_checkpoint_time</a> = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (do_restartpoint)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.restartpoints_performed++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We were not able to perform the restartpoint (checkpoints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throw an ERROR in case of error).&nbsp; Most likely because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have not received <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new checkpoint WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last restartpoint. Try again in 15 s.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="postmaster/checkpointer.c:150">last_checkpoint_time</a> = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L136" title="postmaster/checkpointer.c:136">CheckPointTimeout</a> + <span class="Constant">15</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L143" title="postmaster/checkpointer.c:143">ckpt_active</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We may have received an interrupt during the checkpoint. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L558" title="postmaster/checkpointer.c:558">HandleCheckpointerInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for archive_timeout and switch xlog files if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="postmaster/checkpointer.c:623">CheckArchiveTimeout</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report pending statistics to the cumulative stats system */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L30" title="utils/activity/pgstat_checkpointer.c:30">pgstat_report_checkpointer</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_wal.c.html#L48" title="utils/activity/pgstat_wal.c:48">pgstat_report_wal</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> checkpoint flags have been set, redo the loop to handle the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint without sleeping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<span class="Type">volatile</span> <a href="#L126" title="postmaster/checkpointer.c:126">CheckpointerShmemStruct</a> *) <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>)-&gt;ckpt_flags)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep until we are signaled or it's time for another checkpoint or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * xlog file switch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L150" title="postmaster/checkpointer.c:150">last_checkpoint_time</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elapsed_secs &gt;= <a href="#L136" title="postmaster/checkpointer.c:136">CheckPointTimeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no sleep for us ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = <a href="#L136" title="postmaster/checkpointer.c:136">CheckPointTimeout</a> - elapsed_secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a> &gt; <span class="Constant">0</span> &amp;&amp; !<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elapsed_secs = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (elapsed_secs &gt;= <a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no sleep for us ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(cur_timeout, <a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a> - elapsed_secs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_timeout * <span class="Constant">1000L</span> <span class="Comment">/* convert to ms */</span> ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_CHECKPOINTER_MAIN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new interrupts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L558">&#x200c;</a></span><span class="linkable">HandleCheckpointerInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Checkpointer is the last process to shut down, so we ask it to hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the keys for a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of other tasks required most of which have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nothing to do with checkpointing at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For various reasons, some config <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can change dynamically so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the primary copy of them is held in shared memory to make sure all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends see the same value.&nbsp; We make Checkpointer responsible for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updating the shared memory copy if the parameter setting changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because of SIGHUP.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1307" title="postmaster/checkpointer.c:1307">UpdateSharedMemoryConfig</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * From here on, elog(ERROR) should end with exit(1), not <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back to the sigsetjmp block above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L120" title="utils/init/globals.c:120">ExitOnAnyError</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Close down the database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since <a href="../access/transam/xlog.c.html#L6539" title="access/transam/xlog.c:6539">ShutdownXLOG</a>() creates restartpoint or checkpoint, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * updates the statistics, increment the checkpoint request and flush<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * out pending statistic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L23" title="utils/activity/pgstat_checkpointer.c:23">PendingCheckpointerStats</a>.num_requested++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L6539" title="access/transam/xlog.c:6539">ShutdownXLOG</a>(<span class="Constant">0</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L30" title="utils/activity/pgstat_checkpointer.c:30">pgstat_report_checkpointer</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_wal.c.html#L48" title="utils/activity/pgstat_wal.c:48">pgstat_report_wal</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Normal exit from the checkpointer is here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform logging of memory contexts of this process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L623" title="postmaster/checkpointer.c:623">CheckArchiveTimeout</a> -- check for archive_timeout and switch xlog files<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This will switch to a new WAL file and force an archive file write if<br/></li>
<li></span><span class="Comment"> * meaningful activity is recorded in the current WAL file. This includes most<br/></li>
<li></span><span class="Comment"> * writes, including just a single checkpoint record, but excludes WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a><br/></li>
<li></span><span class="Comment"> * that were inserted with the XLOG_MARK_UNIMPORTANT flag being set (like<br/></li>
<li></span><span class="Comment"> * snapshots of running transactions).&nbsp; Such <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, depending on<br/></li>
<li></span><span class="Comment"> * configuration, occur on regular intervals and don't contain important<br/></li>
<li></span><span class="Comment"> * information.&nbsp; This avoids generating archives with a few unimportant<br/></li>
<li></span><span class="Comment"> * <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L623">&#x200c;</a></span><span class="linkable">CheckArchiveTimeout</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; last_time;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; last_switch_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a> &lt;= <span class="Constant">0</span> || <a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* First we do a quick check using possibly-stale local state. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a>) &lt; <a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update local state ... note that <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a> is the last time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a switch was performed *or requested*.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; last_time = <a href="../access/transam/xlog.c.html#L6522" title="access/transam/xlog.c:6522">GetLastSegSwitchData</a>(&amp;last_switch_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a> = Max(<a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a>, last_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can do the real checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">int</span>) (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a>) &gt;= <a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch segment only when &quot;important&quot; WAL has been logged since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last segment switch (last_switch_lsn points to end of segment<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * switch occurred in).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L6493" title="access/transam/xlog.c:6493">GetLastImportantRecPtr</a>() &gt; last_switch_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; switchpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark switch as unimportant, avoids triggering checkpoints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switchpoint = <a href="../access/transam/xlog.c.html#L7981" title="access/transam/xlog.c:7981">RequestXLogSwitch</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the returned pointer points exactly to a segment boundary,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume nothing happened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogSegmentOffset(switchpoint, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG1, <span class="Constant">&quot;write-ahead log switch forced (archive_timeout=</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/xlog.c.html#L118" title="access/transam/xlog.c:118">XLogArchiveTimeout</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update state in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, so we don't retry constantly when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * system is idle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="postmaster/checkpointer.c:151">last_xlog_switch_time</a> = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns true if an immediate checkpoint request is pending.&nbsp; (Note that<br/></li>
<li></span><span class="Comment"> * this does not check the *current* checkpoint's IMMEDIATE flag, but whether<br/></li>
<li></span><span class="Comment"> * there is one pending behind it.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">ImmediateCheckpointRequested</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <a href="#L126" title="postmaster/checkpointer.c:126">CheckpointerShmemStruct</a> *cps = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to acquire the ckpt_lck in this case because we're only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * looking at a single flag <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cps-&gt;ckpt_flags &amp; CHECKPOINT_IMMEDIATE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L711" title="postmaster/checkpointer.c:711">CheckpointWriteDelay</a> -- control rate of checkpoint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is called after each page write performed by <a href="../storage/buffer/bufmgr.c.html#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>().<br/></li>
<li></span><span class="Comment"> * It is responsible for throttling <a href="../storage/buffer/bufmgr.c.html#L2855" title="storage/buffer/bufmgr.c:2855">BufferSync</a>()'s write rate to hit<br/></li>
<li></span><span class="Comment"> * checkpoint_completion_target.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The checkpoint request flags should be passed in; currently the only one<br/></li>
<li></span><span class="Comment"> * examined is CHECKPOINT_IMMEDIATE, which disables delays between writes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'progress' is an estimate of how much of the work has been done, as a<br/></li>
<li></span><span class="Comment"> * fraction between 0.0 meaning <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>, and 1.0 meaning all done.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L711">&#x200c;</a></span><span class="linkable">CheckpointWriteDelay</span>(<span class="Type">int</span> flags, <span class="Type">double</span> progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; absorb_counter = <a href="#L131" title="postmaster/checkpointer.c:131">WRITES_PER_ABSORB</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if checkpoint is being executed by non-checkpointer process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!AmCheckpointerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform the usual duties and take a nap, unless we're behind schedule,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in which case we just try to catch up as quickly as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(flags &amp; CHECKPOINT_IMMEDIATE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L684" title="postmaster/checkpointer.c:684">ImmediateCheckpointRequested</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L780" title="postmaster/checkpointer.c:780">IsCheckpointOnSchedule</a>(progress))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* update shmem copies of config variables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1307" title="postmaster/checkpointer.c:1307">UpdateSharedMemoryConfig</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = <a href="#L131" title="postmaster/checkpointer.c:131">WRITES_PER_ABSORB</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L623" title="postmaster/checkpointer.c:623">CheckArchiveTimeout</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report interim statistics to the cumulative stats system */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_checkpointer.c.html#L30" title="utils/activity/pgstat_checkpointer.c:30">pgstat_report_checkpointer</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This sleep used to be connected to bgwriter_delay, typically 200ms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * That resulted in more frequent wakeups if not much work to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Checkpointer and bgwriter are no longer related so take the Big<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, WL_LATCH_SET | WL_EXIT_ON_PM_DEATH | WL_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">100</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_CHECKPOINT_WRITE_DELAY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (--absorb_counter &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Absorb pending fsync requests after each <a href="#L131" title="postmaster/checkpointer.c:131">WRITES_PER_ABSORB</a> write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operations even when we don't sleep, to prevent overflow of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fsync request queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; absorb_counter = <a href="#L131" title="postmaster/checkpointer.c:131">WRITES_PER_ABSORB</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for barrier events. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L780" title="postmaster/checkpointer.c:780">IsCheckpointOnSchedule</a> -- are we on schedule to finish this checkpoint<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (or restartpoint) in time?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compares the current progress against the time/segments elapsed since last<br/></li>
<li></span><span class="Comment"> * checkpoint, and returns true if the progress we've made this far is greater<br/></li>
<li></span><span class="Comment"> * than the elapsed time/segments.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L780">&#x200c;</a></span><span class="linkable">IsCheckpointOnSchedule</span>(<span class="Type">double</span> progress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; recptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; elapsed_xlogs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/explain.c.html#L1266" title="commands/explain.c:1266">elapsed_time</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L143" title="postmaster/checkpointer.c:143">ckpt_active</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Scale progress according to checkpoint_completion_target. */<br/></li>
<li></span>&nbsp; &nbsp; progress *= <a href="#L138" title="postmaster/checkpointer.c:138">CheckPointCompletionTarget</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check against the cached value first. Only do the more expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculations once we reach the target previously calculated. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * neither time or WAL insert pointer moves backwards, a freshly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculated value can only be greater than or <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the cached value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (progress &lt; <a href="#L148" title="postmaster/checkpointer.c:148">ckpt_cached_elapsed</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check progress against WAL segments written and <a href="../access/transam/xlog.c.html#L156" title="access/transam/xlog.c:156">CheckPointSegments</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the current WAL insert location against the location<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * computed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>. The code in <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually triggers a checkpoint when <a href="../access/transam/xlog.c.html#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> is exceeded<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * compares against <a href="../access/transam/xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a>, so this is not completely accurate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, it's good enough for our purposes, we're only calculating an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During recovery, we <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> last replayed WAL record's location with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the location computed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="../access/transam/xlog.c.html#L7512" title="access/transam/xlog.c:7512">CreateRestartPoint</a>. That maintains<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same pacing as we have during checkpoints in normal operation, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we might exceed max_wal_size by a fair amount. That's because there can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be a large gap between a checkpoint's redo-pointer and the checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record itself, and we only start the restartpoint after we've seen the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint record. (The gap is typically up to <a href="../access/transam/xlog.c.html#L156" title="access/transam/xlog.c:156">CheckPointSegments</a> *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpoint_completion_target where checkpoint_completion_target is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value that was in effect when the WAL was generated).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; recptr = <a href="../access/transam/xlog.c.html#L6438" title="access/transam/xlog.c:6438">GetInsertRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; elapsed_xlogs = (((<span class="Type">double</span>) (recptr - <a href="#L147" title="postmaster/checkpointer.c:147">ckpt_start_recptr</a>)) /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>) / <a href="../access/transam/xlog.c.html#L156" title="access/transam/xlog.c:156">CheckPointSegments</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress &lt; elapsed_xlogs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L148" title="postmaster/checkpointer.c:148">ckpt_cached_elapsed</a> = elapsed_xlogs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check progress against time elapsed and checkpoint_timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; gettimeofday(&amp;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../commands/explain.c.html#L1266" title="commands/explain.c:1266">elapsed_time</a> = ((<span class="Type">double</span>) ((pg_time_t) <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.tv_sec - <a href="#L146" title="postmaster/checkpointer.c:146">ckpt_start_time</a>) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.tv_usec / <span class="Constant">1000000.0</span>) / <a href="#L136" title="postmaster/checkpointer.c:136">CheckPointTimeout</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress &lt; <a href="../commands/explain.c.html#L1266" title="commands/explain.c:1266">elapsed_time</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L148" title="postmaster/checkpointer.c:148">ckpt_cached_elapsed</a> = <a href="../commands/explain.c.html#L1266" title="commands/explain.c:1266">elapsed_time</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It looks like we're on schedule. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; signal handler routines<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* SIGINT: set flag to run a normal checkpoint right away */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">ReqCheckpointHandler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The signaling process should have set ckpt_flags nonzero, so all we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need do is ensure that our <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop gets kicked out of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> wait.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; communication with backends<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L879" title="postmaster/checkpointer.c:879">CheckpointerShmemSize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute space needed for checkpointer-related shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L879">&#x200c;</a><span class="linkable">CheckpointerShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, the size of the requests[] array is arbitrarily set <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>.&nbsp; This may prove too large or small ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = offsetof(<a href="#L126" title="postmaster/checkpointer.c:126">CheckpointerShmemStruct</a>, requests);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L898" title="postmaster/checkpointer.c:898">CheckpointerShmemInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> checkpointer-related shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L898">&#x200c;</a></span><span class="linkable">CheckpointerShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L879" title="postmaster/checkpointer.c:879">CheckpointerShmemSize</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a> = (<a href="#L126" title="postmaster/checkpointer.c:126">CheckpointerShmemStruct</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Checkpointer Data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First time through, so <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.&nbsp; Note that we zero the whole<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requests array; this is so that <a href="#L1154" title="postmaster/checkpointer.c:1154">CompactCheckpointerRequestQueue</a> can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pad bytes in the request structs are zeroes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>, <span class="Constant">0</span>, size);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SpinLockInit(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;max_requests = <a href="../utils/init/globals.c.html#L139" title="utils/init/globals.c:139">NBuffers</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;start_cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;done_cv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L941" title="postmaster/checkpointer.c:941">RequestCheckpoint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Called in backend processes to request a checkpoint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * flags is a bitwise OR of the following:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ignoring checkpoint_completion_target parameter.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; since the last one (implied by CHECKPOINT_IS_SHUTDOWN or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CHECKPOINT_END_OF_RECOVERY).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_WAIT: wait for completion <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning (otherwise,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; just signal checkpointer to do it, and return).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; CHECKPOINT_CAUSE_XLOG: checkpoint is requested due to xlog filling.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (This affects logging, and in particular enables <a href="#L137" title="postmaster/checkpointer.c:137">CheckPointWarning</a>.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L941">&#x200c;</a></span><span class="linkable">RequestCheckpoint</span>(<span class="Type">int</span> flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ntries;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_failed,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_started;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If in a standalone backend, just do it ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There's no point in doing slow checkpoints in a standalone backend,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because there's no other backends the checkpoint could disrupt.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>(flags | CHECKPOINT_IMMEDIATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Free all smgr objects, as <a href="#L173" title="postmaster/checkpointer.c:173">CheckpointerMain</a>() normally would. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L332" title="storage/smgr/smgr.c:332">smgrdestroyall</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Atomically set the request flags, and take a snapshot of the counters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we see ckpt_started &gt; old_started, we know the flags we set here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have been seen by checkpointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we OR the flags with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing flags, to avoid overriding<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a &quot;stronger&quot; request by another backend.&nbsp; The flag senses must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chosen to make this work!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old_failed = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_failed;<br/></li>
<li>&nbsp; &nbsp; old_started = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_started;<br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_flags |= (flags | CHECKPOINT_REQUESTED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send signal to request checkpoint.&nbsp; It's possible that the checkpointer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hasn't started yet, or is in process of restarting, so we will retry a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * few times if needed.&nbsp; (Actually, more than a few times, since on slow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or overloaded buildfarm machines, it's been observed that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checkpointer can take several seconds to start.)&nbsp; However, if not told<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to wait for the checkpoint to occur, we consider failure to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signal to be nonfatal and merely LOG it.&nbsp; The checkpointer should see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the request when it does start, with or without getting a signal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li><a id="L991">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SIGNAL_TRIES</span> </span><span class="Constant">600</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* max wait 60.0 sec */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (ntries = <span class="Constant">0</span>;; ntries++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;checkpointer_pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntries &gt;= <a href="#L991" title="postmaster/checkpointer.c:991">MAX_SIGNAL_TRIES</a> || !(flags &amp; CHECKPOINT_WAIT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog((flags &amp; CHECKPOINT_WAIT) ? ERROR : LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;could not signal for checkpoint: checkpointer is not running&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (kill(<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;checkpointer_pid, <span class="Constant">SIGINT</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ntries &gt;= <a href="#L991" title="postmaster/checkpointer.c:991">MAX_SIGNAL_TRIES</a> || !(flags &amp; CHECKPOINT_WAIT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog((flags &amp; CHECKPOINT_WAIT) ? ERROR : LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;could not signal for checkpoint: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* signal sent successfully */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">100000L</span>);&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait 0.1 sec, then retry */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If requested, wait for completion.&nbsp; We detect completion according to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the algorithm given above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; CHECKPOINT_WAIT)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_started,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_failed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait for a new checkpoint to start. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;start_cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_started = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_started;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_started != old_started)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;start_cv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_CHECKPOINT_START);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for ckpt_done &gt;= new_started, in a modulo sense.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L56" title="storage/lmgr/condition_variable.c:56">ConditionVariablePrepareToSleep</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;done_cv);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_done = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_done;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_failed = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_failed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_done - new_started &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L96" title="storage/lmgr/condition_variable.c:96">ConditionVariableSleep</a>(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;done_cv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_CHECKPOINT_DONE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (new_failed != old_failed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;checkpoint request failed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Consult recent messages in the server log for details.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1093" title="postmaster/checkpointer.c:1093">ForwardSyncRequest</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Forward a file-fsync request from a backend to the checkpointer<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Whenever a backend is compelled to write directly to a relation<br/></li>
<li></span><span class="Comment"> * (which should be seldom, if the background writer is getting its job done),<br/></li>
<li></span><span class="Comment"> * the backend calls this routine to pass over knowledge that the relation<br/></li>
<li></span><span class="Comment"> * is dirty and must be fsync'd <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> checkpoint.&nbsp; We also use this<br/></li>
<li></span><span class="Comment"> * opportunity to count such writes for statistical purposes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid holding the lock for longer than necessary, we normally write<br/></li>
<li></span><span class="Comment"> * to the requests[] queue without checking for duplicates.&nbsp; The checkpointer<br/></li>
<li></span><span class="Comment"> * will have to eliminate dups internally anyway.&nbsp; However, if we discover<br/></li>
<li></span><span class="Comment"> * that the queue is full, we make a pass over the entire queue to <a href="../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a><br/></li>
<li></span><span class="Comment"> * it.&nbsp; This is somewhat expensive, but the alternative is for the backend<br/></li>
<li></span><span class="Comment"> * to perform its own fsync, which is far more expensive in practice.&nbsp; It<br/></li>
<li></span><span class="Comment"> * is theoretically possible a backend fsync might still be necessary, if<br/></li>
<li></span><span class="Comment"> * the queue is full and contains no duplicate entries.&nbsp; In that case, we<br/></li>
<li></span><span class="Comment"> * let the backend know by returning false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1093">&#x200c;</a></span><span class="linkable">ForwardSyncRequest</span>(<span class="Type">const</span> FileTag *ftag, SyncRequestType type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> *request;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; too_full;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* probably shouldn't even get here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (AmCheckpointerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1093" title="postmaster/checkpointer.c:1093">ForwardSyncRequest</a> must not be called in checkpointer&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(CheckpointerCommLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the checkpointer isn't running or the request queue is full, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend will have to perform its own fsync request.&nbsp; But <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> forcing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that to happen, we can try to <a href="../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> the request queue.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;checkpointer_pid == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests &gt;= <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;max_requests &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !<a href="#L1154" title="postmaster/checkpointer.c:1154">CompactCheckpointerRequestQueue</a>()))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(CheckpointerCommLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, insert request */<br/></li>
<li></span>&nbsp; &nbsp; request = &amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;requests[<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests++];<br/></li>
<li>&nbsp; &nbsp; request-&gt;ftag = *ftag;<br/></li>
<li>&nbsp; &nbsp; request-&gt;type = type;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If queue is more than half full, nudge the checkpointer to empty it */<br/></li>
<li></span>&nbsp; &nbsp; too_full = (<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;max_requests / <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(CheckpointerCommLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... but not till after we release the lock */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (too_full &amp;&amp; <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;checkpointerLatch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;checkpointerLatch);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1154" title="postmaster/checkpointer.c:1154">CompactCheckpointerRequestQueue</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove duplicates from the request queue to avoid backend fsyncs.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns &quot;true&quot; if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries were removed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Although a full fsync request queue is not common, it can lead to severe<br/></li>
<li></span><span class="Comment"> * performance problems when it does happen.&nbsp; So far, this situation has<br/></li>
<li></span><span class="Comment"> * only been observed to occur when the system is under heavy write load,<br/></li>
<li></span><span class="Comment"> * and especially during the &quot;sync&quot; phase of a checkpoint.&nbsp; Without this<br/></li>
<li></span><span class="Comment"> * logic, each backend begins doing an fsync for every block written, which<br/></li>
<li></span><span class="Comment"> * gets very expensive and can slow down the whole system.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Trying to do this every time the queue is full could lose if there<br/></li>
<li></span><span class="Comment"> * aren't <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> removable entries.&nbsp; But that should be vanishingly rare in<br/></li>
<li></span><span class="Comment"> * practice: there's one queue entry per shared buffer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1154">&#x200c;</a></span><span class="linkable">CompactCheckpointerRequestQueue</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> CheckpointerSlotMapping<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> request;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slot;<br/></li>
<li>&nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; preserve_count;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_skipped = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *htab;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp;&nbsp; *skip_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must hold CheckpointerCommLock in exclusive mode */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(CheckpointerCommLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize skip_slot array */<br/></li>
<li></span>&nbsp; &nbsp; skip_slot = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>) * <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize temporary <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a>);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> CheckpointerSlotMapping);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; htab = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;<a href="#L1154" title="postmaster/checkpointer.c:1154">CompactCheckpointerRequestQueue</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The basic idea here is that a request can be skipped if it's followed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by a later, identical request.&nbsp; It might seem more sensible to work<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backwards from the end of the queue and check whether a request is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * *preceded* by an earlier, identical request, in the hopes of doing less<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copying.&nbsp; But that might change the semantics, if there's an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * intervening SYNC_FORGET_REQUEST or SYNC_FILTER_REQUEST, so we do it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this way.&nbsp; It would be possible to be even smarter if we made the code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below understand the specific semantics of such requests (it could blow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * away preceding entries that would end up being canceled anyhow), but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's not clear that the extra complexity would buy us anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (n = <span class="Constant">0</span>; n &lt; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests; n++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> *request;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> CheckpointerSlotMapping *slotmap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We use the request struct directly as a hashtable key.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assumes that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> padding bytes in the structs are consistently the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same, which should be okay because we zeroed them in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L898" title="postmaster/checkpointer.c:898">CheckpointerShmemInit</a>.&nbsp; Note also that RelFileLocator had better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain no pad bytes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; request = &amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;requests[n];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slotmap = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(htab, request, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Duplicate, so mark the previous occurrence as skippable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skip_slot[slotmap-&gt;slot] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_skipped++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember slot containing latest occurrence of this request value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slotmap-&gt;slot = n;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(htab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no duplicates, we're out of luck. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!num_skipped)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(skip_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We found some duplicates; remove them. */<br/></li>
<li></span>&nbsp; &nbsp; preserve_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = <span class="Constant">0</span>; n &lt; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests; n++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skip_slot[n])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;requests[preserve_count++] = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;requests[n];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;compacted fsync request queue from </span><span class="Special">%d</span><span class="Constant"> entries to </span><span class="Special">%d</span><span class="Constant"> entries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests, preserve_count)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests = preserve_count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Cleanup. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(skip_slot);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1260" title="postmaster/checkpointer.c:1260">AbsorbSyncRequests</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Retrieve queued sync requests and pass them to sync mechanism.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported because it must be called during <a href="../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a>;<br/></li>
<li></span><span class="Comment"> * we have to be sure we have accepted all pending requests just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * we start fsync'ing.&nbsp; Since <a href="../access/transam/xlog.c.html#L6821" title="access/transam/xlog.c:6821">CreateCheckPoint</a> sometimes runs in<br/></li>
<li></span><span class="Comment"> * non-checkpointer processes, do nothing if not checkpointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1260">&#x200c;</a></span><span class="linkable">AbsorbSyncRequests</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> *requests = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> *request;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!AmCheckpointerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(CheckpointerCommLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We try to avoid holding the lock for a long time by copying the request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array, and processing the requests after releasing the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we have cleared the requests from shared memory, we have to PANIC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we then fail to absorb them (eg, because our hashtable runs out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory).&nbsp; This is because the system cannot run safely if we are unable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to fsync what we have been told to fsync.&nbsp; Fortunately, the hashtable<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is so small that the problem is quite unlikely to arise in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; n = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (n &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; requests = (<a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(requests, <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;requests, n * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L106" title="postmaster/checkpointer.c:106">CheckpointerRequest</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; START_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;num_requests = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(CheckpointerCommLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (request = requests; n &gt; <span class="Constant">0</span>; request++, n--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/sync/sync.c.html#L487" title="storage/sync/sync.c:487">RememberSyncRequest</a>(&amp;request-&gt;ftag, request-&gt;type);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; END_CRIT_SECTION();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (requests)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(requests);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory configurations based on config parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1307">&#x200c;</a></span><span class="linkable">UpdateSharedMemoryConfig</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update global shmem state for sync rep */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../replication/syncrep.c.html#L921" title="replication/syncrep.c:921">SyncRepUpdateSyncStandbysDefined</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If full_page_writes has been changed by SIGHUP, we update it in shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * memory and write an XLOG_FPW_CHANGE record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L8087" title="access/transam/xlog.c:8087">UpdateFullPageWrites</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2, <span class="Constant">&quot;checkpointer updated shared memory configuration <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1326" title="postmaster/checkpointer.c:1326">FirstCallSinceLastCheckpoint</a> allows a process to take an action once<br/></li>
<li></span><span class="Comment"> * per checkpoint cycle by asynchronously checking for checkpoint completion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1326">&#x200c;</a></span><span class="linkable">FirstCallSinceLastCheckpoint</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; ckpt_done = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_done;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; FirstCall = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SpinLockAcquire(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li>&nbsp; &nbsp; new_done = <a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_done;<br/></li>
<li>&nbsp; &nbsp; SpinLockRelease(&amp;<a href="#L128" title="postmaster/checkpointer.c:128">CheckpointerShmem</a>-&gt;ckpt_lck);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (new_done != ckpt_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FirstCall = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ckpt_done = new_done;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FirstCall;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
