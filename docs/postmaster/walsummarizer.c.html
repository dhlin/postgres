<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/walsummarizer.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/walsummarizer.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L107">WalSummarizerCtl</a></li>
<li><a href="#L132">pages_read_since_last_sleep</a></li>
<li><a href="#L137">redo_pointer_at_last_summary_removal</a></li>
<li><a href="#L115">sleep_quanta</a></li>
<li><a href="#L142">summarize_wal</a></li>
<li><a href="#L143">wal_summary_keep_time</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L104">SummarizerReadLocalXLogPrivate</a></li>
<li><a href="#L93">WalSummarizerData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L702">GetLatestLSN</a></li>
<li><a href="#L494">GetOldestUnsummarizedLSN</a></li>
<li><a href="#L433">GetWalSummarizerState</a></li>
<li><a href="#L744">HandleWalSummarizerInterrupts</a></li>
<li><a href="#L1459">MaybeRemoveOldWalSummaries</a></li>
<li><a href="#L621">SetWalSummarizerLatch</a></li>
<li><a href="#L1093">SummarizeDbaseRecord</a></li>
<li><a href="#L1162">SummarizeSmgrRecord</a></li>
<li><a href="#L792">SummarizeWAL</a></li>
<li><a href="#L1211">SummarizeXactRecord</a></li>
<li><a href="#L1266">SummarizeXlogRecord</a></li>
<li><a href="#L646">WaitForWalSummarization</a></li>
<li><a href="#L210">WalSummarizerMain</a></li>
<li><a href="#L179">WalSummarizerShmemInit</a></li>
<li><a href="#L170">WalSummarizerShmemSize</a></li>
<li><a href="#L690">WalSummarizerShutdown</a></li>
<li><a href="#L1296">summarizer_read_local_xlog_page</a></li>
<li><a href="#L1416">summarizer_wait_for_wal</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L125">MAX_SLEEP_QUANTA</a></li>
<li><a href="#L126">MS_PER_SLEEP_QUANTUM</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * walsummarizer.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Background process to perform WAL summarization, if it is enabled.<br/></li>
<li></span><span class="Comment"> * It continuously scans the write-ahead log and periodically emits a<br/></li>
<li></span><span class="Comment"> * summary file which indicates which blocks in which relation forks<br/></li>
<li></span><span class="Comment"> * were modified by WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> in the LSN <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> covered by the summary<br/></li>
<li></span><span class="Comment"> * file. See walsummary.c and blkreftable.c for more details on the<br/></li>
<li></span><span class="Comment"> * naming and contents of WAL summary files.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If configured to do, this background process will also remove WAL<br/></li>
<li></span><span class="Comment"> * summary files when the file timestamp is older than a configurable<br/></li>
<li></span><span class="Comment"> * threshold (but only if the WAL has been removed first).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/walsummarizer.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/timeline.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;backup/walsummary.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/blkreftable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/auxprocess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/walsummarizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walreceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/wait_event.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Data in shared memory related to WAL summarization.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These fields are protected by WALSummarizerLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Until we've discovered what summary files already exist on disk and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stored that information in shared memory, initialized is false and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other fields here contain no meaningful information. After that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been done, initialized is true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summarized_tli and summarized_lsn indicate the last LSN and TLI at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> summary file will start. Normally, these are the LSN and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TLI at which the last file ended; in such case, lsn_is_exact is true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If, however, the LSN is just an approximation, then lsn_is_exact is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * false. This can happen if, for example, there are no existing WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summary files at startup. In that case, we have to derive the position<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at which to start summarizing from the WAL files that exist on disk,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and so the LSN might point to the start of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> file even though<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that might happen to be in the middle of a WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summarizer_pgprocno is the proc number of the summarizer process, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one is running, or else INVALID_PROC_NUMBER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pending_lsn is used by the summarizer to advertise the ending LSN of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record it has recently read. It shouldn't ever be less than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summarized_lsn, but might be greater, because the summarizer buffers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data for a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of LSNs in memory <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> writing out a new file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; initialized;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; summarized_tli;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lsn_is_exact;<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; summarizer_pgprocno;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; pending_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This field handles its own synchronization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ConditionVariable summary_file_cv;<br/></li>
<li><a id="L93">&#x200c;</a>} <span class="linkable">WalSummarizerData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private data for our <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>'s page read callback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; tli;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; historic;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; read_upto;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; end_of_wal;<br/></li>
<li><a id="L104">&#x200c;</a>} <span class="linkable">SummarizerReadLocalXLogPrivate</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointer to shared memory state. */<br/></li>
<li><a id="L107">&#x200c;</a></span><span class="Type">static</span> <a href="#L93" title="postmaster/walsummarizer.c:93">WalSummarizerData</a> *<span class="linkable">WalSummarizerCtl</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When we reach end of WAL and need to read more, we sleep for a number of<br/></li>
<li></span><span class="Comment"> * milliseconds that is an integer multiple of <a href="#L126" title="postmaster/walsummarizer.c:126">MS_PER_SLEEP_QUANTUM</a>. This is<br/></li>
<li></span><span class="Comment"> * the multiplier. It should vary between 1 and <a href="#L125" title="postmaster/walsummarizer.c:125">MAX_SLEEP_QUANTA</a>, depending<br/></li>
<li></span><span class="Comment"> * on system activity. See <a href="#L1416" title="postmaster/walsummarizer.c:1416">summarizer_wait_for_wal</a>() for how we adjust this.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L115">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">sleep_quanta</span> = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The sleep time will always be a multiple of 200ms and will not exceed<br/></li>
<li></span><span class="Comment"> * thirty seconds (150 * 200 = 30 * 1000). Note that the timeout here needs<br/></li>
<li></span><span class="Comment"> * to be substantially less than the maximum amount of time for which an<br/></li>
<li></span><span class="Comment"> * incremental backup will wait for this process to catch up. Otherwise, an<br/></li>
<li></span><span class="Comment"> * incremental backup might time out on an idle system just because we sleep<br/></li>
<li></span><span class="Comment"> * for too long.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_SLEEP_QUANTA</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">150<br/></li>
<li><a id="L126">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MS_PER_SLEEP_QUANTUM</span>&nbsp; &nbsp; </span><span class="Constant">200<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is a count of the number of pages of WAL that we've read since the<br/></li>
<li></span><span class="Comment"> * last time we waited for more WAL to appear.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L132">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">pages_read_since_last_sleep</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Most recent <a href="../access/transam/xlog.c.html#L273" title="access/transam/xlog.c:273">RedoRecPtr</a> value observed by <a href="#L1459" title="postmaster/walsummarizer.c:1459">MaybeRemoveOldWalSummaries</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type">static</span> XLogRecPtr <span class="linkable">redo_pointer_at_last_summary_removal</span> = InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L142">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">summarize_wal</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L143">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_summary_keep_time</span> = <span class="Constant">10</span> * HOURS_PER_DAY * MINS_PER_HOUR;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L690" title="postmaster/walsummarizer.c:690">WalSummarizerShutdown</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L702" title="postmaster/walsummarizer.c:702">GetLatestLSN</a>(TimeLineID *tli);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> XLogRecPtr <a href="#L792" title="postmaster/walsummarizer.c:792">SummarizeWAL</a>(TimeLineID tli, XLogRecPtr start_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exact, XLogRecPtr switch_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr maximum_lsn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1093" title="postmaster/walsummarizer.c:1093">SummarizeDbaseRecord</a>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; BlockRefTable *brtab);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1162" title="postmaster/walsummarizer.c:1162">SummarizeSmgrRecord</a>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTable *brtab);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1211" title="postmaster/walsummarizer.c:1211">SummarizeXactRecord</a>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTable *brtab);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1266" title="postmaster/walsummarizer.c:1266">SummarizeXlogRecord</a>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1296" title="postmaster/walsummarizer.c:1296">summarizer_read_local_xlog_page</a>(XLogReaderState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr targetPagePtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr targetRecPtr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> *cur_page);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1416" title="postmaster/walsummarizer.c:1416">summarizer_wait_for_wal</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1459" title="postmaster/walsummarizer.c:1459">MaybeRemoveOldWalSummaries</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Amount of shared memory required for this module.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L170">&#x200c;</a><span class="linkable">WalSummarizerShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L93" title="postmaster/walsummarizer.c:93">WalSummarizerData</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create or attach to shared memory segment for this module.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L179">&#x200c;</a></span><span class="linkable">WalSummarizerShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a> = (<a href="#L93" title="postmaster/walsummarizer.c:93">WalSummarizerData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Wal Summarizer Ctl&quot;</span>, <a href="#L170" title="postmaster/walsummarizer.c:170">WalSummarizerShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * First time through, so <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're just filling in dummy <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> here -- the real initialization<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will happen when <a href="#L494" title="postmaster/walsummarizer.c:494">GetOldestUnsummarizedLSN</a>() is called for the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;initialized = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_tli = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;lsn_is_exact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarizer_pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L35" title="storage/lmgr/condition_variable.c:35">ConditionVariableInit</a>(&amp;<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summary_file_cv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entry point for walsummarizer process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">WalSummarizerMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li>&nbsp; &nbsp; MemoryContext context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Within this function, 'current_lsn' and 'current_tli' refer to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * point from which the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> WAL summary file should start. 'exact' is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true if 'current_lsn' is known to be the start of a WAL record or WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * segment, and false if it might be in the middle of a record someplace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'switch_lsn' and 'switch_tli', if set, are the LSN at which we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to a new timeline and the timeline to which we need to switch.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not set, we either haven't figured out the answers yet or we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already on the latest timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; current_lsn;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; current_tli;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exact;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; switch_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; switch_tli = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_WAL_SUMMARIZER;<br/></li>
<li>&nbsp; &nbsp; <a href="auxprocess.c.html#L44" title="postmaster/auxprocess.c:44">AuxiliaryProcessMainCommon</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;WAL summarizer started&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Properly <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> or ignore signals the postmaster might <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have no particular use for SIGINT at the moment, but seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reasonable to treat like SIGTERM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* not used */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Advertise ourselves. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L690" title="postmaster/walsummarizer.c:690">WalSummarizerShutdown</a>, (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarizer_pgprocno = <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create and switch to a memory context that we can reset on error. */<br/></li>
<li></span>&nbsp; &nbsp; context = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Wal Summarizer&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset some signals that are accepted by postmaster but not here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release resources we might have acquired. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L1002" title="utils/resowner/resowner.c:1002">ReleaseAuxProcessResources</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now return to normal top-level context and clear <a href="../utils/mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaked data in the top-level context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can allow interrupts again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep for 10 seconds <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting to resume operations in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * order to avoid excessive logging.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Many of the likely error conditions are things that will <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * every time. For example, if the WAL can't be read or the summary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't be written, only administrator action will cure the problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So a really fast retry time doesn't seem to be especially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beneficial, and it will clutter the logs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">10000</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_WAL_SUMMARIZER_ERROR);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unblock signals (they were blocked when the postmaster forked us)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch information about previous progress from shared memory, and ask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L494" title="postmaster/walsummarizer.c:494">GetOldestUnsummarizedLSN</a> to reset pending_lsn to summarized_lsn. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might be recovering from an error, and if so, pending_lsn might have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * advanced past summarized_lsn, but <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> WAL we read previously has been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lost and will need to be reread.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we discover that WAL summarization is not enabled, just exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; current_lsn = <a href="#L494" title="postmaster/walsummarizer.c:494">GetOldestUnsummarizedLSN</a>(&amp;current_tli, &amp;exact, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(current_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop forever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; latest_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; latest_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; end_of_summary_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaked data in the top-level context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> signals received recently. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's time to remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> old WAL summaries, do that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1459" title="postmaster/walsummarizer.c:1459">MaybeRemoveOldWalSummaries</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find the LSN and TLI up to which we can safely summarize. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; latest_lsn = <a href="#L702" title="postmaster/walsummarizer.c:702">GetLatestLSN</a>(&amp;latest_tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're summarizing a historic timeline and we haven't yet<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * computed the point at which to switch to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline, do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that if this is a standby, what was previously the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline could become historic at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could try to make this more efficient by caching the results of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a> when latest_tli has not changed, but since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only have to do this once per timeline switch, we probably wouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * save <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> significant amount of work in practice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (current_tli != latest_tli &amp;&amp; XLogRecPtrIsInvalid(switch_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tles = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(latest_tli);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch_lsn = <a href="../access/transam/timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a>(current_tli, tles, &amp;switch_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;switch point from TLI </span><span class="Special">%u</span><span class="Constant"> to TLI </span><span class="Special">%u</span><span class="Constant"> is at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; current_tli, switch_tli, LSN_FORMAT_ARGS(switch_lsn)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've reached the switch LSN, we can't summarize anything else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on this timeline. Switch to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> timeline and go around again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(switch_lsn) &amp;&amp; current_lsn &gt;= switch_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_tli = switch_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch_tli = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Summarize WAL. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; end_of_summary_lsn = <a href="#L792" title="postmaster/walsummarizer.c:792">SummarizeWAL</a>(current_tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_lsn, exact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch_lsn, latest_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(end_of_summary_lsn));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(end_of_summary_lsn &gt;= current_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update state for <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> loop iteration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Next summary file should start from exactly where this one ended.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; current_lsn = end_of_summary_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exact = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update state in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn &lt;= end_of_summary_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn = end_of_summary_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_tli = current_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;lsn_is_exact = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn = end_of_summary_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wake up anyone <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for more summary files to be written. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L282" title="storage/lmgr/condition_variable.c:282">ConditionVariableBroadcast</a>(&amp;<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summary_file_cv);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get information about the state of the WAL summarizer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L433">&#x200c;</a></span><span class="linkable">GetWalSummarizerState</span>(TimeLineID *summarized_tli, XLogRecPtr *summarized_lsn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr *pending_lsn, <span class="Type">int</span> *summarizer_pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;initialized)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If initialized is false, the rest of the structure contents are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * undefined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *summarized_tli = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *summarized_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pending_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *summarizer_pid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summarizer_pgprocno = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarizer_pgprocno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *summarized_tli = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *summarized_lsn = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarizer_pgprocno == INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the summarizer has exited, the fact that it had processed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beyond summarized_lsn is irrelevant <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pending_lsn = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *summarizer_pid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *pending_lsn = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're not fussed about inexact answers here, since they could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become stale instantly, so we don't bother taking the lock, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure that invalid PID <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are normalized to -1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *summarizer_pid = GetPGProcByNumber(summarizer_pgprocno)-&gt;pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*summarizer_pid &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *summarizer_pid = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the oldest LSN in this server's timeline history that has not yet been<br/></li>
<li></span><span class="Comment"> * summarized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *tli != NULL, it will be set to the TLI for the LSN that is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If *lsn_is_exact != NULL, it will be set to true if the returned LSN is<br/></li>
<li></span><span class="Comment"> * necessarily the start of a WAL record and false if it's just the beginning<br/></li>
<li></span><span class="Comment"> * of a WAL segment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If reset_pending_lsn is true, resets the pending_lsn in shared memory to<br/></li>
<li></span><span class="Comment"> * be <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the summarized_lsn.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L494">&#x200c;</a><span class="linkable">GetOldestUnsummarizedLSN</span>(TimeLineID *tli, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *lsn_is_exact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> reset_pending_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; latest_tli;<br/></li>
<li>&nbsp; &nbsp; LWLockMode&nbsp; &nbsp; mode = reset_pending_lsn ? LW_EXCLUSIVE : LW_SHARED;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tles;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; unsummarized_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; TimeLineID&nbsp; &nbsp; unsummarized_tli = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; should_make_exact = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *existing_summaries;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If not summarizing WAL, do nothing. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L142" title="postmaster/walsummarizer.c:142">summarize_wal</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidXLogRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless we need to reset the pending_lsn, we initially acquire the lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in shared mode and try to fetch the required information. If we acquire<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in shared mode and <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that the data structure hasn't been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized, we reacquire the lock in exclusive mode so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> it. However, if someone else does that first <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the lock, then we can just return the requested information after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, mode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;initialized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsummarized_lsn = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tli != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tli = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lsn_is_exact != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *lsn_is_exact = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;lsn_is_exact;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reset_pending_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> unsummarized_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mode == LW_EXCLUSIVE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mode = LW_EXCLUSIVE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The data structure needs to be initialized, and we are the first to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * obtain the lock in exclusive mode, so it's our job to do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * So, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the oldest timeline on which WAL still exists, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * earliest segment for which it exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L702" title="postmaster/walsummarizer.c:702">GetLatestLSN</a>(&amp;latest_tli);<br/></li>
<li>&nbsp; &nbsp; tles = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(latest_tli);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (n = list_length(tles) - <span class="Constant">1</span>; n &gt;= <span class="Constant">0</span>; --n)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineHistoryEntry *tle = list_nth(tles, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldest_segno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldest_segno = <a href="../access/transam/xlog.c.html#L3763" title="access/transam/xlog.c:3763">XLogGetOldestSegno</a>(tle-&gt;tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_segno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Compute oldest LSN that still exists on disk. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNoOffsetToRecPtr(oldest_segno, <span class="Constant">0</span>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsummarized_lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsummarized_tli = tle-&gt;tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* It really should not be possible for us to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> no WAL. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unsummarized_tli == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;no WAL found on timeline </span><span class="Special">%u</span><span class="Constant">&quot;</span>, latest_tli));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't try to summarize anything older than the end LSN of the newest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summary file that exists for this timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; existing_summaries =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../backup/walsummary.c.html#L43" title="backup/walsummary.c:43">GetWalSummaries</a>(unsummarized_tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidXLogRecPtr, InvalidXLogRecPtr);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, existing_summaries)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WalSummaryFile *ws = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ws-&gt;end_lsn &gt; unsummarized_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unsummarized_lsn = ws-&gt;end_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; should_make_exact = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update shared memory with the discovered <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;initialized = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn = unsummarized_lsn;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_tli = unsummarized_tli;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;lsn_is_exact = should_make_exact;<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn = unsummarized_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also return the to the caller as required. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tli != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *tli = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_tli;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lsn_is_exact != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *lsn_is_exact = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;lsn_is_exact;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> unsummarized_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attempt to set the WAL summarizer's latch.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This might not work, because there's no guarantee that the WAL summarizer<br/></li>
<li></span><span class="Comment"> * process was successfully started, and it also might have started but<br/></li>
<li></span><span class="Comment"> * subsequently terminated. So, under normal circumstances, this will get the<br/></li>
<li></span><span class="Comment"> * latch set, but there's no guarantee.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L621">&#x200c;</a></span><span class="linkable">SetWalSummarizerLatch</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; pgprocno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; pgprocno = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarizer_pgprocno;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pgprocno != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;<a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../storage/ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[pgprocno].procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wait until WAL summarization reaches the given LSN, but not longer than<br/></li>
<li></span><span class="Comment"> * the given timeout.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the first still-unsummarized LSN. If it's greater than<br/></li>
<li></span><span class="Comment"> * or <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to the passed LSN, then that LSN was reached. If not, we timed out.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Either way, *pending_lsn is set to the value taken from <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>XLogRecPtr<br/></li>
<li><a id="L646">&#x200c;</a><span class="linkable">WaitForWalSummarization</span>(XLogRecPtr lsn, <span class="Type">long</span> timeout, XLogRecPtr *pending_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz start_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; TimestampTz deadline = TimestampTzPlusMilliseconds(start_time, timeout);<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; summarized_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!XLogRecPtrIsInvalid(lsn));<br/></li>
<li>&nbsp; &nbsp; Assert(timeout &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; remaining_timeout;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the LSN summarized on disk has reached the target value, stop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; summarized_lsn = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *pending_lsn = <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (summarized_lsn &gt;= lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Timeout reached? If yes, stop. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; remaining_timeout = <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, deadline);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remaining_timeout &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Wait and see. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L112" title="storage/lmgr/condition_variable.c:112">ConditionVariableTimedSleep</a>(&amp;<a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summary_file_cv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remaining_timeout,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_WAL_SUMMARY_READY);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> summarized_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * On exit, update shared memory to make it clear that we're no longer<br/></li>
<li></span><span class="Comment"> * running.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L690">&#x200c;</a></span><span class="linkable">WalSummarizerShutdown</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarizer_pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the latest LSN that is eligible to be summarized, and set *tli to the<br/></li>
<li></span><span class="Comment"> * corresponding timeline.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L702">&#x200c;</a><span class="linkable">GetLatestLSN</span>(TimeLineID *tli)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L6290" title="access/transam/xlog.c:6290">RecoveryInProgress</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't summarize WAL <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it's flushed. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/transam/xlog.c.html#L6455" title="access/transam/xlog.c:6455">GetFlushRecPtr</a>(tli);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; flush_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; flush_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; replay_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; replay_tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * What we really want to know is how much WAL has been flushed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disk, but the only flush position available is the one provided by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the walreceiver, which may not be running, because this could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash recovery or recovery via restore_command. So use either the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL receiver's flush position or the replay position, whichever is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * further ahead, on the theory that if the WAL has been replayed then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it must also have been flushed to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; flush_lsn = <a href="../replication/walreceiverfuncs.c.html#L331" title="replication/walreceiverfuncs.c:331">GetWalRcvFlushRecPtr</a>(<span class="Constant">NULL</span>, &amp;flush_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replay_lsn = <a href="../access/transam/xlogrecovery.c.html#L4539" title="access/transam/xlogrecovery.c:4539">GetXLogReplayRecPtr</a>(&amp;replay_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flush_lsn &gt; replay_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tli = flush_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> flush_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *tli = replay_tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> replay_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interrupt handler for <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop of WAL summarizer process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L744">&#x200c;</a></span><span class="linkable">HandleWalSummarizerInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a> || !<a href="#L142" title="postmaster/walsummarizer.c:142">summarize_wal</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;WAL summarizer shutting down&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform logging of memory contexts of this process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Summarize a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> on a single timeline.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'tli' is the timeline to be summarized.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'start_lsn' is the point at which we should start summarizing. If this<br/></li>
<li></span><span class="Comment"> * value comes from the end LSN of the previous record as returned by the<br/></li>
<li></span><span class="Comment"> * <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> machinery, 'exact' should be true; otherwise, 'exact' should<br/></li>
<li></span><span class="Comment"> * be false, and this function will search forward for the start of a valid<br/></li>
<li></span><span class="Comment"> * WAL record.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'switch_lsn' is the point at which we should switch to a later timeline,<br/></li>
<li></span><span class="Comment"> * if we're summarizing a historic timeline.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'maximum_lsn' identifies the point beyond which we can't count on being<br/></li>
<li></span><span class="Comment"> * able to read <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more WAL. It should be the switch point when reading a<br/></li>
<li></span><span class="Comment"> * historic timeline, or the most-recently-measured end of WAL when reading<br/></li>
<li></span><span class="Comment"> * the current timeline.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the LSN at which the WAL summary actually ends. Most<br/></li>
<li></span><span class="Comment"> * often, a summary file ends because we notice that a checkpoint has<br/></li>
<li></span><span class="Comment"> * occurred and reach the redo pointer of that checkpoint, but sometimes<br/></li>
<li></span><span class="Comment"> * we stop for other reasons, such as a timeline switch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> XLogRecPtr<br/></li>
<li><a id="L792">&#x200c;</a><span class="linkable">SummarizeWAL</span>(TimeLineID tli, XLogRecPtr start_lsn, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exact,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLogRecPtr switch_lsn, XLogRecPtr maximum_lsn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L104" title="postmaster/walsummarizer.c:104">SummarizerReadLocalXLogPrivate</a> *private_data;<br/></li>
<li>&nbsp; &nbsp; XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; summary_start_lsn;<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; summary_end_lsn = switch_lsn;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; temp_path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; final_path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; WalSummaryIO io;<br/></li>
<li>&nbsp; &nbsp; BlockRefTable *brtab = CreateEmptyBlockRefTable();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize private data for <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>. */<br/></li>
<li></span>&nbsp; &nbsp; private_data = (<a href="#L104" title="postmaster/walsummarizer.c:104">SummarizerReadLocalXLogPrivate</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L104" title="postmaster/walsummarizer.c:104">SummarizerReadLocalXLogPrivate</a>));<br/></li>
<li>&nbsp; &nbsp; private_data-&gt;tli = tli;<br/></li>
<li>&nbsp; &nbsp; private_data-&gt;historic = !XLogRecPtrIsInvalid(switch_lsn);<br/></li>
<li>&nbsp; &nbsp; private_data-&gt;read_upto = maximum_lsn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> = <a href="../access/transam/xlogreader.c.html#L106" title="access/transam/xlogreader.c:106">XLogReaderAllocate</a>(<a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XL_ROUTINE(.page_read = &amp;<a href="#L1296" title="postmaster/walsummarizer.c:1296">summarizer_read_local_xlog_page</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_open = &amp;<a href="../access/transam/xlogutils.c.html#L817" title="access/transam/xlogutils.c:817">wal_segment_open</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; .segment_close = &amp;<a href="../access/transam/xlogutils.c.html#L842" title="access/transam/xlogutils.c:842">wal_segment_close</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed while allocating a WAL reading processor.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When exact = false, we're starting from an arbitrary point in the WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and must search forward for the start of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When exact = true, start_lsn should be either the LSN where a record<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * begins, or the LSN of a page where the page header is immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * followed by the start of a new record. <a href="../access/transam/xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a> should tolerate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to allow for both cases because the behavior of <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varies. When a record spans two or more xlog pages, the ending LSN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reported by <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a> will be the starting LSN of the following<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record, but when an xlog page boundary falls between two <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * end LSN for the first will be reported as the first byte of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * following page. We can't know until we read that page how large the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * header will be, but we'll have to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> over it to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (exact)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even if start_lsn is the beginning of a page rather than the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beginning of the first record on that page, we should still use it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as the start LSN for the summary file. That's because we detect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * missing summary files by looking for cases where the end LSN of one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file is less than the start LSN of the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> file. When only a page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * header is skipped, nothing has been missed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogreader.c.html#L231" title="access/transam/xlogreader.c:231">XLogBeginRead</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, start_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; summary_start_lsn = start_lsn;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; summary_start_lsn = <a href="../access/transam/xlogreader.c.html#L1383" title="access/transam/xlogreader.c:1383">XLogFindNextRecord</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, start_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(summary_start_lsn))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we hit end-of-WAL while trying to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record, we must be on a historic timeline that has no valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that begin after start_lsn and <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> end of WAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (private_data-&gt;end_of_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not read WAL from timeline </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: end of WAL at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(private_data-&gt;read_upto)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The timeline ends at or after start_lsn, without containing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. Thus, we must make sure the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop does not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * iterate. If start_lsn is the end of the timeline, then we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't actually emit an empty summary file, but otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we must, to capture the fact that the LSN <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> in question<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains no interesting WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summary_start_lsn = start_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summary_end_lsn = private_data-&gt;read_upto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switch_lsn = <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a valid record after </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(start_lsn))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't go backward. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(summary_start_lsn &gt;= start_lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Main loop: read xlog <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> one by one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; block_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *errormsg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecord *record;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stop_requested = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't go backward. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(summary_start_lsn &lt;= <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now read the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; record = <a href="../access/transam/xlogreader.c.html#L389" title="access/transam/xlogreader.c:389">XLogReadRecord</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, &amp;errormsg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (record == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (private_data-&gt;end_of_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This timeline must be historic and must end <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * able to read a complete record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not read WAL from timeline </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: end of WAL at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LSN_FORMAT_ARGS(private_data-&gt;read_upto)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Summary ends at end of WAL. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summary_end_lsn = private_data-&gt;read_upto;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errormsg)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read WAL from timeline </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli, LSN_FORMAT_ARGS(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errormsg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read WAL from timeline </span><span class="Special">%u</span><span class="Constant"> at </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tli, LSN_FORMAT_ARGS(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We shouldn't go backward. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(summary_start_lsn &lt;= <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(switch_lsn) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr &gt;= switch_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Whoops! We've read a record that *starts* after the switch LSN,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contrary to our goal of reading only until we hit the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * record that ends at or after the switch LSN. Pretend we didn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * read it after all by bailing out of this loop right here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do anything with this record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This can happen because the last record <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the switch LSN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be continued across multiple pages, and then we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * come to a page with XLP_FIRST_IS_OVERWRITE_CONTRECORD set. In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that case, the record that was continued across multiple pages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is incomplete and will be disregarded, and the read will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart from the beginning of the page that is flagged<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLP_FIRST_IS_OVERWRITE_CONTRECORD.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this case occurs, we can fairly say that the current summary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file ends at the switch LSN exactly. The first record on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page marked XLP_FIRST_IS_OVERWRITE_CONTRECORD will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * discovered when generating the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> summary file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summary_end_lsn = switch_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special handling for particular types of WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (XLogRecGetRmid(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RM_DBASE_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1093" title="postmaster/walsummarizer.c:1093">SummarizeDbaseRecord</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, brtab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RM_SMGR_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1162" title="postmaster/walsummarizer.c:1162">SummarizeSmgrRecord</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, brtab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RM_XACT_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1211" title="postmaster/walsummarizer.c:1211">SummarizeXactRecord</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, brtab);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RM_XLOG_ID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stop_requested = <a href="#L1266" title="postmaster/walsummarizer.c:1266">SummarizeXlogRecord</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've been told that it's time to end this WAL summary file, do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so. As an exception, if there's nothing included in this WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * summary file yet, then stopping doesn't make <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> sense, and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should wait until the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> stop point instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stop_requested &amp;&amp; <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr &gt; summary_start_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; summary_end_lsn = <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;ReadRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Feed block references from xlog record to block reference table. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (block_id = <span class="Constant">0</span>; block_id &lt;= XLogRecMaxBlockId(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; block_id++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlogreader.c.html#L1997" title="access/transam/xlogreader.c:1997">XLogRecGetBlockTagExtended</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, block_id, &amp;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;forknum, &amp;blocknum, <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As we do elsewhere, ignore the FSM fork, because it's not fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forknum != FSM_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableMarkBlockModified(brtab, &amp;rlocator, forknum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; blocknum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update our notion of where this summary file ends. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; summary_end_lsn = <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also update shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(WALSummarizerLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(summary_end_lsn &gt;= <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(summary_end_lsn &gt;= <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;summarized_lsn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L107" title="postmaster/walsummarizer.c:107">WalSummarizerCtl</a>-&gt;pending_lsn = summary_end_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(WALSummarizerLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have a switch LSN and have reached it, stop <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!XLogRecPtrIsInvalid(switch_lsn) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;EndRecPtr &gt;= switch_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Destroy <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>-&gt;private_data);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xlogreader.c.html#L161" title="access/transam/xlogreader.c:161">XLogReaderFree</a>(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a timeline switch occurs, we may fail to make <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> progress at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting the loop above. If that happens, we don't write a WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * summary file at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (summary_end_lsn &gt; summary_start_lsn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate temporary and final path name. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(temp_path, MAXPGPATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLOGDIR <span class="Constant">&quot;/summaries/temp.summary&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(final_path, MAXPGPATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLOGDIR <span class="Constant">&quot;/summaries/</span><span class="Special">%08X%08X%08X%08X%08X</span><span class="Constant">.summary&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(summary_start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(summary_end_lsn));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Open the temporary file for writing. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; io.filepos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; io.file = <a href="../storage/file/fd.c.html#L1575" title="storage/file/fd.c:1575">PathNameOpenFile</a>(temp_path, O_WRONLY | O_CREAT | O_TRUNC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (io.file &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, temp_path)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Write the data. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; WriteBlockRefTable(brtab, <a href="../backup/walsummary.c.html#L294" title="backup/walsummary.c:294">WriteWalSummary</a>, &amp;io);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close temporary file and shut down <a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1978" title="storage/file/fd.c:1978">FileClose</a>(io.file);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Tell the user what we did. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;summarized WAL on TLI </span><span class="Special">%u</span><span class="Constant"> from </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant"> to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tli,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(summary_start_lsn),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LSN_FORMAT_ARGS(summary_end_lsn)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Durably rename the new summary into place. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L782" title="storage/file/fd.c:782">durable_rename</a>(temp_path, final_path, ERROR);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> summary_end_lsn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling for WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> with RM_DBASE_ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1093">&#x200c;</a></span><span class="linkable">SummarizeDbaseRecord</span>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, BlockRefTable *brtab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use relfilenode zero for a given database OID and tablespace OID to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicate that all relations with that pair of IDs have been recreated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if they exist at all. Effectively, we're setting a limit block of 0 for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all such relfilenodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Technically, this special handling is only needed in the case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * XLOG_DBASE_CREATE_FILE_COPY, because that can create a whole bunch of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation files in a directory without logging anything specific to each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one. If we didn't mark the whole DB OID/TS OID combination in some way,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then a tablespace that was dropped after the reference backup and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recreated using the FILE_COPY method prior to the incremental backup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would look just like one that was never touched at all, which would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catastrophic.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But it seems best to adopt this treatment for all <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> that drop or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a DB OID/TS OID combination. That's similar to how we treat the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limit block for individual relations, and it's an extra layer of safety<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here. We can never lose data by marking more stuff as needing to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backed up in full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_DBASE_CREATE_FILE_COPY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbase_create_file_copy_rec *xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (xl_dbase_create_file_copy_rec *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.spcOid = xlrec-&gt;tablespace_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.dbOid = xlrec-&gt;db_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.relNumber = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;rlocator, MAIN_FORKNUM, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_DBASE_CREATE_WAL_LOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbase_create_wal_log_rec *xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec = (xl_dbase_create_wal_log_rec *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.spcOid = xlrec-&gt;tablespace_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.dbOid = xlrec-&gt;db_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.relNumber = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;rlocator, MAIN_FORKNUM, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_DBASE_DROP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_dbase_drop_rec *xlrec;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec = (xl_dbase_drop_rec *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.dbOid = xlrec-&gt;db_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rlocator.relNumber = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; xlrec-&gt;ntablespaces; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator.spcOid = xlrec-&gt;tablespace_ids[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;rlocator, MAIN_FORKNUM, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling for WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> with RM_SMGR_ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1162">&#x200c;</a></span><span class="linkable">SummarizeSmgrRecord</span>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, BlockRefTable *brtab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_SMGR_CREATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_create *xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a new relation fork is created on disk, there is no point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tracking anything about which blocks have been modified, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the whole thing will be new. Hence, set the limit block for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fork to 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore the FSM fork, which is not fully WAL-logged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; xlrec = (xl_smgr_create *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (xlrec-&gt;forkNum != FSM_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;xlrec-&gt;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xlrec-&gt;forkNum, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_SMGR_TRUNCATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_truncate *xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec = (xl_smgr_truncate *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a relation fork is truncated on disk, there is no point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tracking anything about block modifications beyond the truncation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We ignore SMGR_TRUNCATE_FSM here because the FSM isn't fully<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-logged and thus we can't track modified blocks for it anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((xlrec-&gt;flags &amp; SMGR_TRUNCATE_HEAP) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;xlrec-&gt;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAIN_FORKNUM, xlrec-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((xlrec-&gt;flags &amp; SMGR_TRUNCATE_VM) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;xlrec-&gt;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VISIBILITYMAP_FORKNUM, xlrec-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling for WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> with RM_XACT_ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1211">&#x200c;</a></span><span class="linkable">SummarizeXactRecord</span>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>, BlockRefTable *brtab)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) &amp; ~XLR_INFO_MASK;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; xact_info = info &amp; XLOG_XACT_OPMASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xact_info == XLOG_XACT_COMMIT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xact_info == XLOG_XACT_COMMIT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_commit *xlrec = (xl_xact_commit *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_commit parsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't track modified blocks for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations that were removed on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/rmgrdesc/xactdesc.c.html#L35" title="access/rmgrdesc/xactdesc.c:35">ParseCommitRecord</a>(XLogRecGetInfo(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), xlrec, &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; parsed.nrels; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; ++forknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forknum != FSM_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;parsed.xlocators[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (xact_info == XLOG_XACT_ABORT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; xact_info == XLOG_XACT_ABORT_PREPARED)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_abort *xlrec = (xl_xact_abort *) XLogRecGetData(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_xact_parsed_abort parsed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't track modified blocks for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> relations that were removed on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/rmgrdesc/xactdesc.c.html#L141" title="access/rmgrdesc/xactdesc.c:141">ParseAbortRecord</a>(XLogRecGetInfo(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>), xlrec, &amp;parsed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; parsed.nrels; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forknum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (forknum = <span class="Constant">0</span>; forknum &lt;= MAX_FORKNUM; ++forknum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (forknum != FSM_FORKNUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockRefTableSetLimitBlock(brtab, &amp;parsed.xlocators[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forknum, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling for WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> with RM_XLOG_ID.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1266">&#x200c;</a></span><span class="linkable">SummarizeXlogRecord</span>(XLogReaderState *<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(<a href="../replication/walsender.c.html#L137" title="replication/walsender.c:137">xlogreader</a>) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_CHECKPOINT_REDO || info == XLOG_CHECKPOINT_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is an LSN at which redo might begin, so we'd like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * summarization to stop just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this WAL record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Similar to <a href="../access/transam/xlogutils.c.html#L861" title="access/transam/xlogutils.c:861">read_local_xlog_page</a>, but limited to read from one particular<br/></li>
<li></span><span class="Comment"> * timeline. If the end of WAL is reached, it will wait for more if reading<br/></li>
<li></span><span class="Comment"> * from the current timeline, or give up if reading from a historic timeline.<br/></li>
<li></span><span class="Comment"> * In the latter case, it will also set private_data-&gt;end_of_wal = true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must set private_data-&gt;tli to the TLI of interest,<br/></li>
<li></span><span class="Comment"> * private_data-&gt;read_upto to the lowest LSN that is not known to be safe<br/></li>
<li></span><span class="Comment"> * to read on that timeline, and private_data-&gt;historic to true if and only<br/></li>
<li></span><span class="Comment"> * if the timeline is not the current timeline. This function will update<br/></li>
<li></span><span class="Comment"> * private_data-&gt;read_upto and private_data-&gt;historic if more WAL appears<br/></li>
<li></span><span class="Comment"> * on the current timeline or if the current timeline becomes historic.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1296">&#x200c;</a></span><span class="linkable">summarizer_read_local_xlog_page</span>(XLogReaderState *state,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr targetPagePtr, <span class="Type">int</span> reqLen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr targetRecPtr, <span class="Type">char</span> *cur_page)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; WALReadError errinfo;<br/></li>
<li>&nbsp; &nbsp; <a href="#L104" title="postmaster/walsummarizer.c:104">SummarizerReadLocalXLogPrivate</a> *private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; private_data = (<a href="#L104" title="postmaster/walsummarizer.c:104">SummarizerReadLocalXLogPrivate</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; state-&gt;private_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetPagePtr + XLOG_BLCKSZ &lt;= private_data-&gt;read_upto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more than one block available; read only that block, have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * caller come back if they need more.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = XLOG_BLCKSZ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (targetPagePtr + reqLen &gt; private_data-&gt;read_upto)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't seem to have enough data. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (private_data-&gt;historic)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is a historic timeline, so there will never be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more data than we have currently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data-&gt;end_of_wal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; latest_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; latest_tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is - or at least was up until very recently - the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current timeline, so more data might show up.&nbsp; Delay here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so we don't tight-loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1416" title="postmaster/walsummarizer.c:1416">summarizer_wait_for_wal</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Recheck end-of-WAL. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; latest_lsn = <a href="#L702" title="postmaster/walsummarizer.c:702">GetLatestLSN</a>(&amp;latest_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (private_data-&gt;tli == latest_tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Still the current timeline, update max LSN. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(latest_lsn &gt;= private_data-&gt;read_upto);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data-&gt;read_upto = latest_lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tles = <a href="../access/transam/timeline.c.html#L76" title="access/transam/timeline.c:76">readTimeLineHistory</a>(latest_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; switchpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The timeline we're scanning is no longer the latest<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one. Figure out when it ended.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data-&gt;historic = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; switchpoint = <a href="../access/transam/timeline.c.html#L572" title="access/transam/timeline.c:572">tliSwitchPoint</a>(private_data-&gt;tli, tles,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allow reads up to exactly the switch point.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that this will cause read_upto to move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backwards, because walreceiver might have read a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partial record and flushed it to disk, and we'd view<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that data as safe to read. However, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * XLOG_END_OF_RECOVERY record will be written at the end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the last complete WAL record, not at the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL that we've flushed to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * So switchpoint &lt; private-&gt;read_upto is possible here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but switchpoint &lt; state-&gt;EndRecPtr should not be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(switchpoint &gt;= state-&gt;EndRecPtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; private_data-&gt;read_upto = switchpoint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Debugging output. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;timeline </span><span class="Special">%u</span><span class="Constant"> became historic, can read up to </span><span class="Special">%X</span><span class="Constant">/</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; private_data-&gt;tli, LSN_FORMAT_ARGS(private_data-&gt;read_upto)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Go around and try again. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* enough bytes available to satisfy the request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = private_data-&gt;read_upto - targetPagePtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlogreader.c.html#L1503" title="access/transam/xlogreader.c:1503">WALRead</a>(state, cur_page, targetPagePtr, count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; private_data-&gt;tli, &amp;errinfo))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L1020" title="access/transam/xlogutils.c:1020">WALReadRaiseError</a>(&amp;errinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Track that we read a page, for sleep time calculation. */<br/></li>
<li></span>&nbsp; &nbsp; ++<a href="#L132" title="postmaster/walsummarizer.c:132">pages_read_since_last_sleep</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of valid bytes in the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sleep for long enough that we believe it's likely that more WAL will<br/></li>
<li></span><span class="Comment"> * be available afterwards.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1416">&#x200c;</a></span><span class="linkable">summarizer_wait_for_wal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="postmaster/walsummarizer.c:132">pages_read_since_last_sleep</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No pages were read since the last sleep, so double the sleep time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not beyond the maximum allowable value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="postmaster/walsummarizer.c:115">sleep_quanta</a> = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L115" title="postmaster/walsummarizer.c:115">sleep_quanta</a> * <span class="Constant">2</span>, <a href="#L125" title="postmaster/walsummarizer.c:125">MAX_SLEEP_QUANTA</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L132" title="postmaster/walsummarizer.c:132">pages_read_since_last_sleep</a> &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Multiple pages were read since the last sleep, so reduce the sleep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A large burst of activity should be able to quickly reduce the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sleep time to the minimum, but we don't want a handful of extra WAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> to provoke a strong reaction. We choose to reduce the sleep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time by 1 quantum for each page read beyond the first, which is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fairly arbitrary way of trying to be reactive without overreacting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="postmaster/walsummarizer.c:132">pages_read_since_last_sleep</a> &gt; <a href="#L115" title="postmaster/walsummarizer.c:115">sleep_quanta</a> - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="postmaster/walsummarizer.c:115">sleep_quanta</a> = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L115" title="postmaster/walsummarizer.c:115">sleep_quanta</a> -= <a href="#L132" title="postmaster/walsummarizer.c:132">pages_read_since_last_sleep</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> sleep. */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L115" title="postmaster/walsummarizer.c:115">sleep_quanta</a> * <a href="#L126" title="postmaster/walsummarizer.c:126">MS_PER_SLEEP_QUANTUM</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_WAL_SUMMARIZER_WAL);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset count of pages read. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L132" title="postmaster/walsummarizer.c:132">pages_read_since_last_sleep</a> = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove WAL summaries whose mtimes are older than <a href="#L143" title="postmaster/walsummarizer.c:143">wal_summary_keep_time</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1459">&#x200c;</a></span><span class="linkable">MaybeRemoveOldWalSummaries</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; redo_pointer = <a href="../access/transam/xlog.c.html#L6393" title="access/transam/xlog.c:6393">GetRedoRecPtr</a>();<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *wslist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; cutoff_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If WAL summary removal is disabled, don't do anything. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L143" title="postmaster/walsummarizer.c:143">wal_summary_keep_time</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the redo pointer has not advanced, don't do anything.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This has the effect that we only try to remove old WAL summary files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once per checkpoint cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (redo_pointer == <a href="#L137" title="postmaster/walsummarizer.c:137">redo_pointer_at_last_summary_removal</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L137" title="postmaster/walsummarizer.c:137">redo_pointer_at_last_summary_removal</a> = redo_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Files should only be removed if the last modification time precedes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cutoff time we compute here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cutoff_time = time(<span class="Constant">NULL</span>) - <a href="#L143" title="postmaster/walsummarizer.c:143">wal_summary_keep_time</a> * SECS_PER_MINUTE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get all the summaries that currently exist. */<br/></li>
<li></span>&nbsp; &nbsp; wslist = <a href="../backup/walsummary.c.html#L43" title="backup/walsummary.c:43">GetWalSummaries</a>(<span class="Constant">0</span>, InvalidXLogRecPtr, InvalidXLogRecPtr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Loop until all summaries have been considered for removal. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (wslist != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogSegNo&nbsp; &nbsp; oldest_segno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; oldest_lsn = InvalidXLogRecPtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimeLineID&nbsp; &nbsp; selected_tli;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Pick a timeline for which some summary files still exist on disk,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the oldest LSN that still exists on disk for that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeline.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selected_tli = ((WalSummaryFile *) linitial(wslist))-&gt;tli;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldest_segno = <a href="../access/transam/xlog.c.html#L3763" title="access/transam/xlog.c:3763">XLogGetOldestSegno</a>(selected_tli);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (oldest_segno != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; XLogSegNoOffsetToRecPtr(oldest_segno, <span class="Constant">0</span>, <a href="../access/transam/xlog.c.html#L143" title="access/transam/xlog.c:143">wal_segment_size</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldest_lsn);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Consider each WAL file on the selected timeline in turn. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, wslist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WalSummaryFile *ws = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L744" title="postmaster/walsummarizer.c:744">HandleWalSummarizerInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not on this timeline, it's not time to consider it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selected_tli != ws-&gt;tli)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the WAL doesn't exist <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more, we can remove it if the file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * modification time is old enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogRecPtrIsInvalid(oldest_lsn) || ws-&gt;end_lsn &lt;= oldest_lsn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../backup/walsummary.c.html#L230" title="backup/walsummary.c:230">RemoveWalSummaryIfOlderThan</a>(ws, cutoff_time);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Whether we removed the file or not, we need not consider it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wslist = foreach_delete_current(wslist, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ws);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
