<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/autovacuum.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/autovacuum.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L299">AutoVacuumShmem</a></li>
<li><a href="#L164">AutovacMemCxt</a></li>
<li><a href="#L312">AutovacuumLauncherPid</a></li>
<li><a href="#L305">DatabaseList</a></li>
<li><a href="#L306">DatabaseListCxt</a></li>
<li><a href="#L132">Log_autovacuum_min_duration</a></li>
<li><a href="#L309">MyWorkerInfo</a></li>
<li><a href="#L125">autovacuum_anl_scale</a></li>
<li><a href="#L124">autovacuum_anl_thresh</a></li>
<li><a href="#L126">autovacuum_freeze_max_age</a></li>
<li><a href="#L117">autovacuum_max_workers</a></li>
<li><a href="#L127">autovacuum_multixact_freeze_max_age</a></li>
<li><a href="#L119">autovacuum_naptime</a></li>
<li><a href="#L116">autovacuum_start_daemon</a></li>
<li><a href="#L129">autovacuum_vac_cost_delay</a></li>
<li><a href="#L130">autovacuum_vac_cost_limit</a></li>
<li><a href="#L123">autovacuum_vac_ins_scale</a></li>
<li><a href="#L122">autovacuum_vac_ins_thresh</a></li>
<li><a href="#L121">autovacuum_vac_scale</a></li>
<li><a href="#L120">autovacuum_vac_thresh</a></li>
<li><a href="#L118">autovacuum_work_mem</a></li>
<li><a href="#L147">av_storage_param_cost_delay</a></li>
<li><a href="#L148">av_storage_param_cost_limit</a></li>
<li><a href="#L158">default_freeze_min_age</a></li>
<li><a href="#L159">default_freeze_table_age</a></li>
<li><a href="#L160">default_multixact_freeze_min_age</a></li>
<li><a href="#L161">default_multixact_freeze_table_age</a></li>
<li><a href="#L151">got_SIGUSR2</a></li>
<li><a href="#L155">recentMulti</a></li>
<li><a href="#L154">recentXid</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L297">AutoVacuumShmemStruct</a></li>
<li><a href="#L250">AutoVacuumSignal</a></li>
<li><a href="#L258">AutoVacuumWorkItem</a></li>
<li><a href="#L266">AutoVacuumWorkItem</a></li>
<li><a href="#L238">WorkerInfo</a></li>
<li><a href="#L227">WorkerInfoData</a></li>
<li><a href="#L236">WorkerInfoData</a></li>
<li><a href="#L196">autovac_table</a></li>
<li><a href="#L207">autovac_table</a></li>
<li><a href="#L186">av_relation</a></li>
<li><a href="#L193">av_relation</a></li>
<li><a href="#L167">avl_dbase</a></li>
<li><a href="#L173">avl_dbase</a></li>
<li><a href="#L176">avw_dbase</a></li>
<li><a href="#L183">avw_dbase</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L361">AutoVacLauncherMain</a></li>
<li><a href="#L775">AutoVacLauncherShutdown</a></li>
<li><a href="#L1337">AutoVacWorkerFailed</a></li>
<li><a href="#L1359">AutoVacWorkerMain</a></li>
<li><a href="#L3201">AutoVacuumRequestWork</a></li>
<li><a href="#L3275">AutoVacuumShmemInit</a></li>
<li><a href="#L3256">AutoVacuumShmemSize</a></li>
<li><a href="#L1702">AutoVacuumUpdateCostLimit</a></li>
<li><a href="#L3189">AutoVacuumingActive</a></li>
<li><a href="#L1585">FreeWorkerInfo</a></li>
<li><a href="#L740">HandleAutoVacLauncherInterrupts</a></li>
<li><a href="#L1633">VacuumUpdateCosts</a></li>
<li><a href="#L3243">autovac_init</a></li>
<li><a href="#L1748">autovac_recalculate_workers_for_balance</a></li>
<li><a href="#L3114">autovac_report_activity</a></li>
<li><a href="#L3149">autovac_report_workitem</a></li>
<li><a href="#L3078">autovacuum_do_vac_analyze</a></li>
<li><a href="#L1344">avl_sigusr2_handler</a></li>
<li><a href="#L3320">check_autovacuum_work_mem</a></li>
<li><a href="#L1055">db_comparator</a></li>
<li><a href="#L1873">do_autovacuum</a></li>
<li><a href="#L1073">do_start_worker</a></li>
<li><a href="#L2674">extract_autovac_opts</a></li>
<li><a href="#L1788">get_database_list</a></li>
<li><a href="#L1285">launch_worker</a></li>
<li><a href="#L792">launcher_determine_sleep</a></li>
<li><a href="#L2560">perform_work_item</a></li>
<li><a href="#L876">rebuild_database_list</a></li>
<li><a href="#L2844">recheck_relation_needs_vacanalyze</a></li>
<li><a href="#L2905">relation_needs_vacanalyze</a></li>
<li><a href="#L2704">table_recheck_autovac</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L3116">MAX_AUTOVAC_ACTIV_LEN</a></li>
<li><a href="#L136">MAX_AUTOVAC_SLEEPTIME</a></li>
<li><a href="#L135">MIN_AUTOVAC_SLEEPTIME</a></li>
<li><a href="#L268">NUM_WORKITEMS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * autovacuum.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * PostgreSQL Integrated Autovacuum Daemon<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The autovacuum system is structured in two different kinds of processes: the<br/></li>
<li></span><span class="Comment"> * autovacuum launcher and the autovacuum worker.&nbsp; The launcher is an<br/></li>
<li></span><span class="Comment"> * always-running process, started by the postmaster when the autovacuum GUC<br/></li>
<li></span><span class="Comment"> * parameter is set.&nbsp; The launcher schedules autovacuum workers to be started<br/></li>
<li></span><span class="Comment"> * when appropriate.&nbsp; The workers are the processes which execute the actual<br/></li>
<li></span><span class="Comment"> * vacuuming; they <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to a database as determined in the launcher, and<br/></li>
<li></span><span class="Comment"> * once connected they examine the catalogs to <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the tables to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The autovacuum launcher cannot start the worker processes by itself,<br/></li>
<li></span><span class="Comment"> * because doing so would cause robustness issues (namely, failure to shut<br/></li>
<li></span><span class="Comment"> * them down on exceptional conditions, and also, since the launcher is<br/></li>
<li></span><span class="Comment"> * connected to shared memory and is thus subject to corruption there, it is<br/></li>
<li></span><span class="Comment"> * not as robust as the postmaster).&nbsp; So it leaves that task to the postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is an autovacuum shared memory area, where the launcher stores<br/></li>
<li></span><span class="Comment"> * information about the database it wants vacuumed.&nbsp; When it wants a new<br/></li>
<li></span><span class="Comment"> * worker to start, it sets a flag in shared memory and sends a signal to the<br/></li>
<li></span><span class="Comment"> * postmaster.&nbsp; Then postmaster knows nothing more than it must start a worker;<br/></li>
<li></span><span class="Comment"> * so it forks a new child, which turns into a worker.&nbsp; This new process<br/></li>
<li></span><span class="Comment"> * connects to shared memory, and there it can inspect the information that the<br/></li>
<li></span><span class="Comment"> * launcher has set up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the fork() call fails in the postmaster, it sets a flag in the shared<br/></li>
<li></span><span class="Comment"> * memory area, and sends a signal to the launcher.&nbsp; The launcher, upon<br/></li>
<li></span><span class="Comment"> * noticing the flag, can try starting the worker again by resending the<br/></li>
<li></span><span class="Comment"> * signal.&nbsp; Note that the failure can only be transient (fork failure due to<br/></li>
<li></span><span class="Comment"> * high load, memory pressure, too many processes, etc); more permanent<br/></li>
<li></span><span class="Comment"> * problems, like failure to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to a database, are detected later in the<br/></li>
<li></span><span class="Comment"> * worker and dealt with just by having the worker exit normally.&nbsp; The launcher<br/></li>
<li></span><span class="Comment"> * will launch a new worker again later, per schedule.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the worker is done vacuuming it sends SIGUSR2 to the launcher.&nbsp; The<br/></li>
<li></span><span class="Comment"> * launcher then wakes up and is able to launch another worker, if the schedule<br/></li>
<li></span><span class="Comment"> * is so tight that a new worker is needed immediately.&nbsp; At this time the<br/></li>
<li></span><span class="Comment"> * launcher can also balance the settings for the various remaining workers'<br/></li>
<li></span><span class="Comment"> * cost-based <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> delay feature.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that there can be more than one worker in a database concurrently.<br/></li>
<li></span><span class="Comment"> * They will store the table they are currently vacuuming in shared memory, so<br/></li>
<li></span><span class="Comment"> * that other workers avoid being blocked <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> lock for that<br/></li>
<li></span><span class="Comment"> * table.&nbsp; They will also fetch the last time the table was vacuumed from<br/></li>
<li></span><span class="Comment"> * pgstats just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> vacuuming each table, to avoid vacuuming a table that<br/></li>
<li></span><span class="Comment"> * was just finished being vacuumed by another worker and thus is no longer<br/></li>
<li></span><span class="Comment"> * noted in shared memory.&nbsp; However, there is a small window (due to not yet<br/></li>
<li></span><span class="Comment"> * holding the relation lock) during which a worker may choose a table that was<br/></li>
<li></span><span class="Comment"> * already vacuumed; this is a bug in the current design.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/autovacuum.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/dbcommands.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/int.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC parameters<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_start_daemon</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L117">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_max_workers</span>;<br/></li>
<li><a id="L118">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_work_mem</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L119">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_naptime</span>;<br/></li>
<li><a id="L120">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_vac_thresh</span>;<br/></li>
<li><a id="L121">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_vac_scale</span>;<br/></li>
<li><a id="L122">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_vac_ins_thresh</span>;<br/></li>
<li><a id="L123">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_vac_ins_scale</span>;<br/></li>
<li><a id="L124">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_anl_thresh</span>;<br/></li>
<li><a id="L125">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_anl_scale</span>;<br/></li>
<li><a id="L126">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_freeze_max_age</span>;<br/></li>
<li><a id="L127">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_multixact_freeze_max_age</span>;<br/></li>
<li><br/></li>
<li><a id="L129">&#x200c;</a><span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_vac_cost_delay</span>;<br/></li>
<li><a id="L130">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">autovacuum_vac_cost_limit</span>;<br/></li>
<li><br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_autovacuum_min_duration</span> = <span class="Constant">600000</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* the minimum allowed time between two awakenings of the launcher */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MIN_AUTOVAC_SLEEPTIME</span> </span><span class="Constant">100.0</span><span class="PreProc"> </span><span class="Comment">/* milliseconds */<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_AUTOVAC_SLEEPTIME</span> </span><span class="Constant">300</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* seconds */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Variables to save the cost-related storage parameters for the current<br/></li>
<li></span><span class="Comment"> * relation being vacuumed by this autovacuum worker. Using these, we can<br/></li>
<li></span><span class="Comment"> * ensure we don't overwrite the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> and<br/></li>
<li></span><span class="Comment"> * <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> after reloading the configuration file. They are<br/></li>
<li></span><span class="Comment"> * initialized to &quot;invalid&quot; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to indicate that no cost-related storage<br/></li>
<li></span><span class="Comment"> * parameters were specified and will be set in <a href="#L1873" title="postmaster/autovacuum.c:1873">do_autovacuum</a>() after checking<br/></li>
<li></span><span class="Comment"> * the storage parameters in <a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L147">&#x200c;</a></span><span class="Type">static</span> <span class="Type">double</span> <span class="linkable">av_storage_param_cost_delay</span> = -<span class="Constant">1</span>;<br/></li>
<li><a id="L148">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">av_storage_param_cost_limit</span> = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Flags set by signal handlers */<br/></li>
<li><a id="L151">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">got_SIGUSR2</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Comparison points for determining whether freeze_max_age is exceeded */<br/></li>
<li><a id="L154">&#x200c;</a></span><span class="Type">static</span> TransactionId <span class="linkable">recentXid</span>;<br/></li>
<li><a id="L155">&#x200c;</a><span class="Type">static</span> MultiXactId <span class="linkable">recentMulti</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Default freeze ages to use for autovacuum (varies by database) */<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">default_freeze_min_age</span>;<br/></li>
<li><a id="L159">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">default_freeze_table_age</span>;<br/></li>
<li><a id="L160">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">default_multixact_freeze_min_age</span>;<br/></li>
<li><a id="L161">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">default_multixact_freeze_table_age</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Memory context for long-lived data */<br/></li>
<li><a id="L164">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">AutovacMemCxt</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* struct to keep track of databases in launcher */<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">avl_dbase</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adl_datid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key -- must be first */<br/></li>
<li></span>&nbsp; &nbsp; TimestampTz adl_next_worker;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adl_score;<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; adl_node;<br/></li>
<li><a id="L173">&#x200c;</a>} <span class="linkable">avl_dbase</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* struct to keep track of databases in worker */<br/></li>
<li><a id="L176">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">avw_dbase</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; adw_datid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *adw_name;<br/></li>
<li>&nbsp; &nbsp; TransactionId adw_frozenxid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId adw_minmulti;<br/></li>
<li>&nbsp; &nbsp; PgStat_StatDBEntry *adw_entry;<br/></li>
<li><a id="L183">&#x200c;</a>} <span class="linkable">avw_dbase</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* struct to keep track of tables to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> and/or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>, in 1st pass */<br/></li>
<li><a id="L186">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">av_relation</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ar_toastrelid;&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> key - must be first */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ar_relid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ar_hasrelopts;<br/></li>
<li>&nbsp; &nbsp; AutoVacOpts ar_reloptions;&nbsp; &nbsp; <span class="Comment">/* copy of AutoVacOpts from the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reloptions, or NULL if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> */<br/></li>
<li><a id="L193">&#x200c;</a></span>} <span class="linkable">av_relation</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* struct to keep track of tables to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> and/or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>, after rechecking */<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">autovac_table</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at_relid;<br/></li>
<li>&nbsp; &nbsp; VacuumParams at_params;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; at_storage_param_vac_cost_delay;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; at_storage_param_vac_cost_limit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; at_dobalance;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; at_sharedrel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *at_relname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *at_nspname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *at_datname;<br/></li>
<li><a id="L207">&#x200c;</a>} <span class="linkable">autovac_table</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*-------------<br/></li>
<li></span><span class="Comment"> * This struct holds information about a single worker's whereabouts.&nbsp; We keep<br/></li>
<li></span><span class="Comment"> * an array of these in shared memory, sized according to<br/></li>
<li></span><span class="Comment"> * <a href="#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * wi_links&nbsp; &nbsp; &nbsp; &nbsp; entry into free list or running list<br/></li>
<li></span><span class="Comment"> * wi_dboid&nbsp; &nbsp; &nbsp; &nbsp; OID of the database this worker is supposed to work on<br/></li>
<li></span><span class="Comment"> * wi_tableoid&nbsp; &nbsp; OID of the table currently being vacuumed, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * wi_sharedrel flag indicating whether table is marked relisshared<br/></li>
<li></span><span class="Comment"> * wi_proc&nbsp; &nbsp; &nbsp; &nbsp; pointer to PGPROC of the running worker, NULL if not started<br/></li>
<li></span><span class="Comment"> * wi_launchtime Time at which this worker was launched<br/></li>
<li></span><span class="Comment"> * wi_dobalance Whether this worker should be included in balance calculations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All fields are protected by AutovacuumLock, except for wi_tableoid and<br/></li>
<li></span><span class="Comment"> * wi_sharedrel which are protected by AutovacuumScheduleLock (note these<br/></li>
<li></span><span class="Comment"> * two fields are read-only for everyone except that worker itself).<br/></li>
<li></span><span class="Comment"> *-------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L227">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">WorkerInfoData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; wi_links;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wi_dboid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; wi_tableoid;<br/></li>
<li>&nbsp; &nbsp; PGPROC&nbsp; &nbsp; &nbsp;&nbsp; *wi_proc;<br/></li>
<li>&nbsp; &nbsp; TimestampTz wi_launchtime;<br/></li>
<li>&nbsp; &nbsp; pg_atomic_flag wi_dobalance;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wi_sharedrel;<br/></li>
<li><a id="L236">&#x200c;</a>} <span class="linkable">WorkerInfoData</span>;<br/></li>
<li><br/></li>
<li><a id="L238">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <a href="#L227" title="postmaster/autovacuum.c:227">WorkerInfoData</a> *<span class="linkable">WorkerInfo</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Possible signals received by the launcher from remote processes.&nbsp; These are<br/></li>
<li></span><span class="Comment"> * stored atomically in shared memory so that other processes can set them<br/></li>
<li></span><span class="Comment"> * without locking.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; AutoVacForkFailed,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* failed trying to start a worker */<br/></li>
<li></span>&nbsp; &nbsp; AutoVacRebalance,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rebalance the cost limits */<br/></li>
<li></span>&nbsp; &nbsp; AutoVacNumSignals,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must be last */<br/></li>
<li><a id="L250">&#x200c;</a></span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">AutoVacuumSignal</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Autovacuum workitem array, stored in <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_workItems.&nbsp; This<br/></li>
<li></span><span class="Comment"> * list is mostly protected by AutovacuumLock, except that if an item is<br/></li>
<li></span><span class="Comment"> * marked 'active' other processes must not modify the work-identifying<br/></li>
<li></span><span class="Comment"> * members.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L258">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">AutoVacuumWorkItem</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AutoVacuumWorkItemType avw_type;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; avw_used;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* below data is valid */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; avw_active;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* being processed */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avw_database;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avw_relation;<br/></li>
<li>&nbsp; &nbsp; BlockNumber avw_blockNumber;<br/></li>
<li><a id="L266">&#x200c;</a>} <span class="linkable">AutoVacuumWorkItem</span>;<br/></li>
<li><br/></li>
<li><a id="L268">&#x200c;</a><span class="PreProc">#define <span class="linkable">NUM_WORKITEMS</span>&nbsp; &nbsp; </span><span class="Constant">256<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*-------------<br/></li>
<li></span><span class="Comment"> * The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> autovacuum shmem struct.&nbsp; On shared memory we store this <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment"> * struct and the array of <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> structs.&nbsp; This struct keeps:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * av_signal&nbsp; &nbsp; &nbsp; &nbsp; set by other processes to indicate various conditions<br/></li>
<li></span><span class="Comment"> * av_launcherpid&nbsp; &nbsp; the PID of the autovacuum launcher<br/></li>
<li></span><span class="Comment"> * av_freeWorkers&nbsp; &nbsp; the <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> freelist<br/></li>
<li></span><span class="Comment"> * av_runningWorkers the <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> non-free queue<br/></li>
<li></span><span class="Comment"> * av_startingWorker pointer to <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> currently being started (cleared by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the worker itself as soon as it's up and running)<br/></li>
<li></span><span class="Comment"> * av_workItems&nbsp; &nbsp; &nbsp; &nbsp; work item array<br/></li>
<li></span><span class="Comment"> * av_nworkersForBalance the number of autovacuum workers to use when<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; calculating the per worker cost limit<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This struct is protected by AutovacuumLock, except for av_signal and parts<br/></li>
<li></span><span class="Comment"> * of the worker list (see above).<br/></li>
<li></span><span class="Comment"> *-------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">sig_atomic_t</span> av_signal[AutoVacNumSignals];<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; av_launcherpid;<br/></li>
<li>&nbsp; &nbsp; dlist_head&nbsp; &nbsp; av_freeWorkers;<br/></li>
<li>&nbsp; &nbsp; dlist_head&nbsp; &nbsp; av_runningWorkers;<br/></li>
<li>&nbsp; &nbsp; <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>&nbsp; &nbsp; av_startingWorker;<br/></li>
<li>&nbsp; &nbsp; <a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> av_workItems[<a href="#L268" title="postmaster/autovacuum.c:268">NUM_WORKITEMS</a>];<br/></li>
<li>&nbsp; &nbsp; pg_atomic_uint32 av_nworkersForBalance;<br/></li>
<li><a id="L297">&#x200c;</a>} <span class="linkable">AutoVacuumShmemStruct</span>;<br/></li>
<li><br/></li>
<li><a id="L299">&#x200c;</a><span class="Type">static</span> <a href="#L297" title="postmaster/autovacuum.c:297">AutoVacuumShmemStruct</a> *<span class="linkable">AutoVacuumShmem</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * the database list (of <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a> elements) in the launcher, and the context<br/></li>
<li></span><span class="Comment"> * that contains it<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L305">&#x200c;</a></span><span class="Type">static</span> dlist_head <span class="linkable">DatabaseList</span> = DLIST_STATIC_INIT(<span class="linkable">DatabaseList</span>);<br/></li>
<li><a id="L306">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">DatabaseListCxt</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Pointer to my own <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>, valid on each worker */<br/></li>
<li><a id="L309">&#x200c;</a></span><span class="Type">static</span> <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> <span class="linkable">MyWorkerInfo</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* PID of launcher, valid only in worker while shutting down */<br/></li>
<li><a id="L312">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">AutovacuumLauncherPid</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L1073" title="postmaster/autovacuum.c:1073">do_start_worker</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L740" title="postmaster/autovacuum.c:740">HandleAutoVacLauncherInterrupts</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L775" title="postmaster/autovacuum.c:775">AutoVacLauncherShutdown</a>(<span class="Type">void</span>) pg_attribute_noreturn();<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L792" title="postmaster/autovacuum.c:792">launcher_determine_sleep</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canlaunch, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">struct</span> timeval *nap);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1285" title="postmaster/autovacuum.c:1285">launch_worker</a>(TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>);<br/></li>
<li><span class="Type">static</span> List *<a href="#L1788" title="postmaster/autovacuum.c:1788">get_database_list</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a>(Oid newdb);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1055" title="postmaster/autovacuum.c:1055">db_comparator</a>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1748" title="postmaster/autovacuum.c:1748">autovac_recalculate_workers_for_balance</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1873" title="postmaster/autovacuum.c:1873">do_autovacuum</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1585" title="postmaster/autovacuum.c:1585">FreeWorkerInfo</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *<a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a>(Oid relid, <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *table_toast_map,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc pg_class_desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> effective_multixact_freeze_max_age);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2844" title="postmaster/autovacuum.c:2844">recheck_relation_needs_vacanalyze</a>(Oid relid, AutoVacOpts *avopts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *dovacuum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *doanalyze, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *wraparound);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2905" title="postmaster/autovacuum.c:2905">relation_needs_vacanalyze</a>(Oid relid, AutoVacOpts *relopts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatTabEntry *tabentry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *dovacuum, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *doanalyze, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *wraparound);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3078" title="postmaster/autovacuum.c:3078">autovacuum_do_vac_analyze</a>(<a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *tab,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BufferAccessStrategy bstrategy);<br/></li>
<li><span class="Type">static</span> AutoVacOpts *<a href="#L2674" title="postmaster/autovacuum.c:2674">extract_autovac_opts</a>(HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleDesc pg_class_desc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2560" title="postmaster/autovacuum.c:2560">perform_work_item</a>(<a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> *workitem);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3114" title="postmaster/autovacuum.c:3114">autovac_report_activity</a>(<a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *tab);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3149" title="postmaster/autovacuum.c:3149">autovac_report_workitem</a>(<a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> *workitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nspname, <span class="Type">const</span> <span class="Type">char</span> *relname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1344" title="postmaster/autovacuum.c:1344">avl_sigusr2_handler</a>(SIGNAL_ARGS);<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AUTOVACUUM LAUNCHER CODE<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point for the autovacuum launcher process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L361">&#x200c;</a></span><span class="linkable">AutoVacLauncherMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release postmaster's working memory context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_AUTOVAC_LAUNCHER;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L267" title="utils/misc/ps_status.c:267">init_ps_display</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;autovacuum launcher started&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> * <span class="Constant">1000000L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(InitProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up signal handlers.&nbsp; We operate on databases much like a regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend, so we use the same signal handling.&nbsp; See equivalent code in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tcop/postgres.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="../tcop/postgres.c.html#L3002" title="tcop/postgres.c:3002">StatementCancelHandler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establishes SIGALRM handler */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <a href="#L1344" title="postmaster/autovacuum.c:1344">avl_sigusr2_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGFPE</span>, <a href="../tcop/postgres.c.html#L3019" title="tcop/postgres.c:3019">FloatExceptionHandler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a per-backend PGPROC struct in shared memory.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can use LWLocks or access <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Early initialization */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L645" title="utils/init/postinit.c:645">BaseInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>(<span class="Constant">NULL</span>, InvalidOid, <span class="Constant">NULL</span>, InvalidOid, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(NormalProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a memory context that we will do all our work in.&nbsp; We do this so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that we can reset the context during error recovery and thereby avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible memory leaks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a> = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Autovacuum Launcher&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This code is a stripped down version of <a href="../tcop/postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a> error recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we use sigsetjmp(..., 1), so that the prevailing signal mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (to wit, <a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>) will be restored when longjmp'ing to here.&nbsp; Thus,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signals other than SIGQUIT will be blocked until we complete error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery.&nbsp; It might seem that this policy makes the HOLD_INTERRUPTS()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call redundant, but it is not since <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> might be set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevents interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Forget <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending QueryCancel or timeout request */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L751" title="utils/misc/timeout.c:751">disable_all_timeouts</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>; <span class="Comment">/* second to avoid race condition */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Abort the current transaction in order to recover */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other resources, for the case where we were not in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L5057" title="storage/buffer/bufmgr.c:5057">UnlockBuffers</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this is probably dead code, but let's be safe: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/resowner/resowner.c.html#L168" title="utils/resowner/resowner.c:168">AuxProcessResourceOwner</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L1002" title="utils/resowner/resowner.c:1002">ReleaseAuxProcessResources</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/buffer/bufmgr.c.html#L3502" title="storage/buffer/bufmgr.c:3502">AtEOXact_Buffers</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L807" title="storage/smgr/smgr.c:807">AtEOXact_SMgr</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now return to normal top-level context and clear <a href="../utils/mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaked data in the top-level context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't leave dangling pointers to freed memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L306" title="postmaster/autovacuum.c:306">DatabaseListCxt</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can allow interrupts again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if in shutdown mode, no need for anything further; just go away */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L775" title="postmaster/autovacuum.c:775">AutoVacLauncherShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep at least 1 second after <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> error.&nbsp; We don't want to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * filling the error logs as fast as we can.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000000L</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must unblock signals <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a> */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set always-secure search path.&nbsp; Launcher doesn't <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to a database,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so this has no effect.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;search_path&quot;</span>, <span class="Constant">&quot;&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force <a href="../storage/buffer/bufmgr.c.html#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a> <a href="../regex/regexec.c.html#L131" title="regex/regexec.c:131">OFF</a> in the autovac process, even if it is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in postgresql.conf.&nbsp; We don't really want such a dangerous option being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applied non-interactively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../storage/buffer/bufmgr.c.html#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a>&quot;</span>, <span class="Constant">&quot;false&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force settable timeouts off to avoid letting these settings prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular maintenance from being executed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;statement_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;transaction_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;lock_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;idle_in_transaction_session_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force default_transaction_isolation to READ COMMITTED.&nbsp; We don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to pay the overhead of serializable mode, nor add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> risk of causing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlocks or delaying other transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;default_transaction_isolation&quot;</span>, <span class="Constant">&quot;read committed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even when system is configured to use a different fetch consistency,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for autovac we always want fresh stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L258" title="utils/misc/guc_tables.c:258">stats_fetch_consistency</a>&quot;</span>, <span class="Constant">&quot;<a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In emergency mode, just start a worker (unless shutdown was requested)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and go away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3189" title="postmaster/autovacuum.c:3189">AutoVacuumingActive</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1073" title="postmaster/autovacuum.c:1073">do_start_worker</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_launcherpid = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the initial database list.&nbsp; The invariant we want this list to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keep is that it's ordered by decreasing next_time.&nbsp; As soon as an entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is updated to a higher time, it will be moved to the front (which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct because the only operation is to add <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry, and time always increases).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a>(InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* loop until shutdown request */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> timeval nap;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz current_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; can_launch;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This loop is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> different from the normal use of <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because we'd like to sleep <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the first launch of a child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process.&nbsp; So it's <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>, then <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>, then check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wakening conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L792" title="postmaster/autovacuum.c:792">launcher_determine_sleep</a>(!dlist_is_empty(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, &amp;nap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait until naptime expires or we get some type of signal (all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * signal handlers will wake us by calling <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_EXIT_ON_PM_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (nap.tv_sec * <span class="Constant">1000L</span>) + (nap.tv_usec / <span class="Constant">1000L</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_AUTOVACUUM_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L740" title="postmaster/autovacuum.c:740">HandleAutoVacLauncherInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a worker finished, or postmaster signaled failure to start a worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L197" title="replication/walsender.c:197">got_SIGUSR2</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L197" title="replication/walsender.c:197">got_SIGUSR2</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rebalance cost limits, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_signal[AutoVacRebalance])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_signal[AutoVacRebalance] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1748" title="postmaster/autovacuum.c:1748">autovac_recalculate_workers_for_balance</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_signal[AutoVacForkFailed])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the postmaster failed to start a new worker, we sleep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for a little while and resend the signal.&nbsp; The new worker's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state is still in memory, so this is sufficient.&nbsp; After<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that, we restart the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should we put a limit to the number of times we retry?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * I don't think it makes much sense, because a future start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of a worker will continue to fail in the same way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_signal[AutoVacForkFailed] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000000L</span>);&nbsp; &nbsp; <span class="Comment">/* 1s */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_WORKER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There are some conditions that we need to check <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start a worker.&nbsp; First, we need to make sure that there is a worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot available.&nbsp; Second, we need to make sure that no other worker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed while starting up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; can_launch = !dlist_is_empty(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waittime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>&nbsp; &nbsp; worker = <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't launch another worker when another one is still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting up (or failed while doing so), so just sleep for a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more; that worker will wake us up again as soon as it's ready.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will only wait <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> seconds (up to a maximum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of 60 seconds) for this to happen however.&nbsp; Note that failure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to a particular database is not a problem here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the worker removes itself from the startingWorker<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a>.&nbsp; Problems detected by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster (like fork() failure) are also reported and handled<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * differently.&nbsp; The only problems that may cause this code to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fire are errors in the earlier sections of <a href="#L1359" title="postmaster/autovacuum.c:1359">AutoVacWorkerMain</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the worker removes the <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * startingWorker pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; waittime = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a>, <span class="Constant">60</span>) * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(worker-&gt;wi_launchtime, current_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; waittime))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No other process can put a worker in starting mode, so if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * startingWorker is still INVALID after exchanging our lock,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we assume it's the same one we saw above (so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * recheck the launch time).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker = <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_dboid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_tableoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_sharedrel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_launchtime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;worker-&gt;wi_links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;autovacuum worker took too long to start; canceled&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; can_launch = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);&nbsp; &nbsp; <span class="Comment">/* either shared or exclusive */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if we can't do anything, just go back to sleep */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!can_launch)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We're OK to start a new worker */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special case when the list is empty: start a worker right away.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This covers the initial case, when no database is in pgstats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (thus the list is empty).&nbsp; Note that the constraints in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L792" title="postmaster/autovacuum.c:792">launcher_determine_sleep</a> keep us from starting workers too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quickly (at most once every <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> when the list is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * empty).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1285" title="postmaster/autovacuum.c:1285">launch_worker</a>(current_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a> constructs a list with most<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * distant adl_next_worker first, we obtain our database from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tail of the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *avdb;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avdb = dlist_tail_element(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>, adl_node, &amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * launch a worker if next_worker is right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> or it is in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * past<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(avdb-&gt;adl_next_worker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; current_time, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1285" title="postmaster/autovacuum.c:1285">launch_worker</a>(current_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L775" title="postmaster/autovacuum.c:775">AutoVacLauncherShutdown</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new interrupts.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L740">&#x200c;</a></span><span class="linkable">HandleAutoVacLauncherInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the normal shutdown case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L775" title="postmaster/autovacuum.c:775">AutoVacLauncherShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shutdown requested in config file? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3189" title="postmaster/autovacuum.c:3189">AutoVacuumingActive</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L775" title="postmaster/autovacuum.c:775">AutoVacLauncherShutdown</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rebuild the list in case the naptime changed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a>(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process barrier events */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform logging of memory contexts of this process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process sinval catchup interrupts that happened while sleeping */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/sinval.c.html#L174" title="storage/ipc/sinval.c:174">ProcessCatchupInterrupt</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform a normal exit from the autovac launcher.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L775">&#x200c;</a></span><span class="linkable">AutoVacLauncherShutdown</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;autovacuum launcher shutting down&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_launcherpid = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine the time to sleep, based on the database list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;canlaunch&quot; parameter indicates whether we can start a worker right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment"> * for example due to the workers being all busy.&nbsp; If this is false, we will<br/></li>
<li></span><span class="Comment"> * cause a long sleep, which will be interrupted when a worker exits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L792">&#x200c;</a></span><span class="linkable">launcher_determine_sleep</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canlaunch, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> recursing, <span class="Type">struct</span> timeval *nap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We sleep until the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> scheduled <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; We trust that when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * database list was built, care was taken so that no entries have times<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the past; if the first entry has too close a next_worker value, or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time in the past, we will sleep a small nominal time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!canlaunch)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_sec = <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_usec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!dlist_is_empty(&amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz current_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz next_wakeup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *avdb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avdb = dlist_tail_element(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>, adl_node, &amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_wakeup = avdb-&gt;adl_next_worker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(current_time, next_wakeup, &amp;secs, &amp;usecs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_sec = secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_usec = usecs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list is empty, sleep for whole <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> seconds&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_sec = <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_usec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the result is exactly zero, it means a database had an entry with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time in the past.&nbsp; Rebuild the list so that the databases are evenly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * distributed again, and recalculate the time to sleep.&nbsp; This can happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if there are more tables needing <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> than workers, and they all take<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> than <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only recurse once.&nbsp; <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a> should always return times<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in the future, but it seems best not to trust too much on that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nap-&gt;tv_sec == <span class="Constant">0</span> &amp;&amp; nap-&gt;tv_usec == <span class="Constant">0</span> &amp;&amp; !recursing)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a>(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L792" title="postmaster/autovacuum.c:792">launcher_determine_sleep</a>(canlaunch, <span class="Constant">true</span>, nap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The smallest time we'll allow the launcher to sleep. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nap-&gt;tv_sec &lt;= <span class="Constant">0</span> &amp;&amp; nap-&gt;tv_usec &lt;= <a href="#L135" title="postmaster/autovacuum.c:135">MIN_AUTOVAC_SLEEPTIME</a> * <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_sec = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_usec = <a href="#L135" title="postmaster/autovacuum.c:135">MIN_AUTOVAC_SLEEPTIME</a> * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the sleep time is too large, clamp it to an arbitrary maximum (plus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fractional seconds, for simplicity).&nbsp; This avoids an essentially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * infinite sleep in strange cases like the system clock going backwards a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * few years.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (nap-&gt;tv_sec &gt; <a href="#L136" title="postmaster/autovacuum.c:136">MAX_AUTOVAC_SLEEPTIME</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nap-&gt;tv_sec = <a href="#L136" title="postmaster/autovacuum.c:136">MAX_AUTOVAC_SLEEPTIME</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Build an updated <a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>.&nbsp; It must only contain databases that appear<br/></li>
<li></span><span class="Comment"> * in pgstats, and must be sorted by next_worker from highest to lowest,<br/></li>
<li></span><span class="Comment"> * distributed regularly across the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> interval.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Receives the Oid of the database that made this list be generated (we call<br/></li>
<li></span><span class="Comment"> * this the &quot;new&quot; database, because when the database was already present on<br/></li>
<li></span><span class="Comment"> * the list, we expect that this function is not called at all).&nbsp; The<br/></li>
<li></span><span class="Comment"> * preexisting list, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, will be used to preserve the order of the<br/></li>
<li></span><span class="Comment"> * databases in the <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> period.&nbsp; The new database is put at the<br/></li>
<li></span><span class="Comment"> * end of the interval.&nbsp; The actual <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are not saved, which should not be<br/></li>
<li></span><span class="Comment"> * much of a problem.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L876">&#x200c;</a></span><span class="linkable">rebuild_database_list</span>(Oid newdb)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *dblist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; MemoryContext newcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tmpcxt;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; hctl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; score;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nelems;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *dbhash;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newcxt = AllocSetContextCreate(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Autovacuum database list&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; tmpcxt = AllocSetContextCreate(newcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Autovacuum database list (tmp)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(tmpcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Implementing this is not as simple as it sounds, because we need to put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the new database at the end of the list; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> the databases that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already on the list, and finally (at the tail of the list) all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other databases that are not on the existing list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To do this, we build an empty <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table of scored databases.&nbsp; We will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start with the lowest score (zero) for the new database, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * increasing scores for the databases in the existing list, in order, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lastly increasing scores for all databases gotten via<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1788" title="postmaster/autovacuum.c:1788">get_database_list</a>() that are not already on the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Then we will put all the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> elements into an array, sort the array by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * score, and finally put the array elements into the new doubly linked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; hctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>);<br/></li>
<li>&nbsp; &nbsp; hctl.hcxt = tmpcxt;<br/></li>
<li>&nbsp; &nbsp; dbhash = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;autovacuum db <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>, <span class="Constant">20</span>, &amp;hctl,&nbsp; &nbsp; <span class="Comment">/* magic number here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">FIXME</span><span class="Comment"> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* start by inserting the new database */<br/></li>
<li></span>&nbsp; &nbsp; score = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(newdb))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *db;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatDBEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only consider this database if it has a pgstat entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../utils/activity/pgstat_database.c.html#L242" title="utils/activity/pgstat_database.c:242">pgstat_fetch_stat_dbentry</a>(newdb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we assume it isn't found because the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> was just created */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(dbhash, &amp;newdb, HASH_ENTER, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> already filled in the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db-&gt;adl_score = score++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* next_worker is filled in later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now insert the databases from the existing list */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *avdb = dlist_container(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>, adl_node, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *db;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatDBEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> databases with no stat entries -- in particular, this gets rid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of dropped databases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../utils/activity/pgstat_database.c.html#L242" title="utils/activity/pgstat_database.c:242">pgstat_fetch_stat_dbentry</a>(avdb-&gt;adl_datid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; db = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(dbhash, &amp;(avdb-&gt;adl_datid), HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> already filled in the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db-&gt;adl_score = score++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* next_worker is filled in later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finally, insert all qualifying databases not previously inserted */<br/></li>
<li></span>&nbsp; &nbsp; dblist = <a href="#L1788" title="postmaster/autovacuum.c:1788">get_database_list</a>();<br/></li>
<li>&nbsp; &nbsp; foreach(cell, dblist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L176" title="postmaster/autovacuum.c:176">avw_dbase</a>&nbsp; *avdb = lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *db;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatDBEntry *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only consider databases with a pgstat entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../utils/activity/pgstat_database.c.html#L242" title="utils/activity/pgstat_database.c:242">pgstat_fetch_stat_dbentry</a>(avdb-&gt;adw_datid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (entry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; db = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(dbhash, &amp;(avdb-&gt;adw_datid), HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only update the score if the database was not already on the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> already filled in the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db-&gt;adl_score = score++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* next_worker is filled in later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; nelems = score;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* from here on, the allocated memory belongs to the new list */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(newcxt);<br/></li>
<li>&nbsp; &nbsp; dlist_init(&amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nelems &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TimestampTz current_time;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; millis_increment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *dbary;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *db;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASH_SEQ_STATUS seq;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* put all the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> elements into an array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dbary = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nelems * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;seq, dbhash);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((db = <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;seq)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;(dbary[i++]), db, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* sort the array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qsort(dbary, nelems, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>), <a href="#L1055" title="postmaster/autovacuum.c:1055">db_comparator</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the time interval between databases in the schedule. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we see that the configured naptime would take us to sleep times<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> than our min sleep time (which <a href="#L792" title="postmaster/autovacuum.c:792">launcher_determine_sleep</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coded not to allow), silently use a larger naptime (but don't touch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the GUC variable).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; millis_increment = <span class="Constant">1000.0</span> * <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> / nelems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (millis_increment &lt;= <a href="#L135" title="postmaster/autovacuum.c:135">MIN_AUTOVAC_SLEEPTIME</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; millis_increment = <a href="#L135" title="postmaster/autovacuum.c:135">MIN_AUTOVAC_SLEEPTIME</a> * <span class="Constant">1.1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; current_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * move the elements from the array into the dlist, setting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * next_worker while walking the array<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nelems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db = &amp;(dbary[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_time = TimestampTzPlusMilliseconds(current_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; millis_increment);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; db-&gt;adl_next_worker = current_time;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* later elements should go closer to the head of the list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>, &amp;db-&gt;adl_node);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* all done, clean up memory */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L306" title="postmaster/autovacuum.c:306">DatabaseListCxt</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="#L306" title="postmaster/autovacuum.c:306">DatabaseListCxt</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmpcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="#L306" title="postmaster/autovacuum.c:306">DatabaseListCxt</a> = newcxt;<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* qsort comparator for <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>, using adl_score */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1055">&#x200c;</a></span><span class="linkable">db_comparator</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_cmp_s32(((<span class="Type">const</span> <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a> *) a)-&gt;adl_score,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((<span class="Type">const</span> <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a> *) b)-&gt;adl_score);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1073" title="postmaster/autovacuum.c:1073">do_start_worker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bare-bones procedure for starting an autovacuum worker from the launcher.<br/></li>
<li></span><span class="Comment"> * It determines what database to work on, sets up shared memory stuff and<br/></li>
<li></span><span class="Comment"> * signals postmaster to start the worker.&nbsp; It fails gracefully if invoked when<br/></li>
<li></span><span class="Comment"> * autovacuum_workers are already active.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value is the OID of the database that the worker is going to process,<br/></li>
<li></span><span class="Comment"> * or InvalidOid if no worker was actually started.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L1073">&#x200c;</a><span class="linkable">do_start_worker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *dblist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; TransactionId xidForceLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiForceLimit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; for_xid_wrap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; for_multi_wrap;<br/></li>
<li>&nbsp; &nbsp; <a href="#L176" title="postmaster/autovacuum.c:176">avw_dbase</a>&nbsp; *avdb;<br/></li>
<li>&nbsp; &nbsp; TimestampTz current_time;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retval = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; MemoryContext tmpcxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* return quickly when there are no free workers */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create and switch to a temporary context to avoid leaking the memory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated for the database list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tmpcxt = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Autovacuum start worker (tmp)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(tmpcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a list of databases */<br/></li>
<li></span>&nbsp; &nbsp; dblist = <a href="#L1788" title="postmaster/autovacuum.c:1788">get_database_list</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the oldest datfrozenxid/relfrozenxid that we will allow to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass without forcing a <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.&nbsp; (This limit can be tightened for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * particular tables, but not loosened.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L154" title="postmaster/autovacuum.c:154">recentXid</a> = ReadNextTransactionId();<br/></li>
<li>&nbsp; &nbsp; xidForceLimit = <a href="#L154" title="postmaster/autovacuum.c:154">recentXid</a> - <a href="#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure it's a &quot;normal&quot; XID, else <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a> misbehaves */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* this can cause the limit to go backwards by 3, but that's OK */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (xidForceLimit &lt; FirstNormalTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidForceLimit -= FirstNormalTransactionId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Also determine the oldest datminmxid we will consider. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L155" title="postmaster/autovacuum.c:155">recentMulti</a> = <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>();<br/></li>
<li>&nbsp; &nbsp; multiForceLimit = <a href="#L155" title="postmaster/autovacuum.c:155">recentMulti</a> - <a href="../access/transam/multixact.c.html#L2929" title="access/transam/multixact.c:2929">MultiXactMemberFreezeThreshold</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (multiForceLimit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multiForceLimit -= FirstMultiXactId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose a database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to.&nbsp; We pick the database that was least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recently auto-vacuumed, or one that needs vacuuming to prevent Xid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wraparound-related data loss.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> db at risk of Xid wraparound is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found, we pick the one with oldest datfrozenxid, independently of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * autovacuum times; similarly we pick the one with the oldest datminmxid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> is in MultiXactId wraparound.&nbsp; Note that those in Xid wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * danger are given more priority than those in multi wraparound danger.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that a database with no stats entry is not considered, except for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Xid wraparound purposes.&nbsp; The theory is that if no one has ever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * connected to it since the stats were last initialized, it doesn't need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> This could be improved if we had more info about whether it needs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> connecting to it.&nbsp; Perhaps look through the pgstats<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data for the database's tables?&nbsp; One idea is to keep track of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of new and dead tuples per database in pgstats.&nbsp; However it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't clear how to construct a metric that measures that and not cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starvation for less busy databases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; avdb = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; for_xid_wrap = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; for_multi_wrap = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; current_time = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; foreach(cell, dblist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L176" title="postmaster/autovacuum.c:176">avw_dbase</a>&nbsp; *tmp = lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check to see if this one is at risk of wraparound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(tmp-&gt;adw_frozenxid, xidForceLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (avdb == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(tmp-&gt;adw_frozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adw_frozenxid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avdb = tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_xid_wrap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (for_xid_wrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore not-at-risk DBs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(tmp-&gt;adw_minmulti, multiForceLimit))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (avdb == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(tmp-&gt;adw_minmulti, avdb-&gt;adw_minmulti))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avdb = tmp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for_multi_wrap = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (for_multi_wrap)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore not-at-risk DBs */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Find pgstat entry if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;adw_entry = <a href="../utils/activity/pgstat_database.c.html#L242" title="utils/activity/pgstat_database.c:242">pgstat_fetch_stat_dbentry</a>(tmp-&gt;adw_datid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip a database with no pgstat entry; it means it hasn't seen <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * activity.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tmp-&gt;adw_entry)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a database that appears on the database list as having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been processed recently (less than <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> seconds ago).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do this so that we don't <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a database which we just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selected, but that pgstat hasn't gotten around to updating the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovacuum time yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; skipit = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_reverse_foreach(iter, &amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *dbp = dlist_container(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>, adl_node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbp-&gt;adl_datid == tmp-&gt;adw_datid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip this database if its next_worker value falls between<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current time and the current time plus naptime.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(dbp-&gt;adl_next_worker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_time, <span class="Constant">0</span>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(current_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbp-&gt;adl_next_worker,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> * <span class="Constant">1000</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipit = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skipit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember the db with oldest autovac time.&nbsp; (If we are here, both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tmp-&gt;entry and db-&gt;entry must be non-null.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (avdb == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp-&gt;adw_entry-&gt;last_autovac_time &lt; avdb-&gt;adw_entry-&gt;last_autovac_time)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avdb = tmp;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Found a database -- process it */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (avdb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>&nbsp; &nbsp; worker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_node *wptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get a worker entry from the freelist.&nbsp; We checked above, so there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * really should be a free slot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; wptr = dlist_pop_head_node(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worker = dlist_container(<a href="#L227" title="postmaster/autovacuum.c:227">WorkerInfoData</a>, wi_links, wptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_dboid = avdb-&gt;adw_datid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worker-&gt;wi_launchtime = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker = worker;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L181" title="storage/ipc/pmsignal.c:181">SendPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_WORKER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retval = avdb-&gt;adw_datid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (skipit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we skipped all databases on the list, rebuild it, because it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably contains a dropped database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a>(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(tmpcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> retval;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1285" title="postmaster/autovacuum.c:1285">launch_worker</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Wrapper for starting a worker from the launcher.&nbsp; Besides actually starting<br/></li>
<li></span><span class="Comment"> * it, update the database list to reflect the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time that another one will<br/></li>
<li></span><span class="Comment"> * need to be started on the selected database.&nbsp; The actual database choice is<br/></li>
<li></span><span class="Comment"> * left to <a href="#L1073" title="postmaster/autovacuum.c:1073">do_start_worker</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine is also expected to insert an entry into the database list if<br/></li>
<li></span><span class="Comment"> * the selected database was previously absent from the list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1285">&#x200c;</a></span><span class="linkable">launch_worker</span>(TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbid;<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dbid = <a href="#L1073" title="postmaster/autovacuum.c:1073">do_start_worker</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(dbid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Walk the database list and update the corresponding entry.&nbsp; If the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * database is not on the list, we'll recreate the list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>&nbsp; *avdb = dlist_container(<a href="#L167" title="postmaster/autovacuum.c:167">avl_dbase</a>, adl_node, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (avdb-&gt;adl_datid == dbid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> seconds to the current time, and use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that as the new &quot;next_worker&quot; field for this database.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adl_next_worker =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTzPlusMilliseconds(<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, <a href="#L119" title="postmaster/autovacuum.c:119">autovacuum_naptime</a> * <span class="Constant">1000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_move_head(&amp;<a href="#L305" title="postmaster/autovacuum.c:305">DatabaseList</a>, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the database was not present in the database list, we rebuild<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the list.&nbsp; It's possible that the database does not get into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list anyway, for example if it's a database that doesn't have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pgstat entry, but this is not a problem because we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * schedule workers regularly into those in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L876" title="postmaster/autovacuum.c:876">rebuild_database_list</a>(dbid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called from postmaster to signal a failure to fork a process to become<br/></li>
<li></span><span class="Comment"> * worker.&nbsp; The postmaster should kill(SIGUSR2) the launcher shortly<br/></li>
<li></span><span class="Comment"> * after calling this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1337">&#x200c;</a></span><span class="linkable">AutoVacWorkerFailed</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_signal[AutoVacForkFailed] = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* SIGUSR2: a worker is up and running, or just finished, or failed to fork */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1344">&#x200c;</a></span><span class="linkable">avl_sigusr2_handler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../replication/walsender.c.html#L197" title="replication/walsender.c:197">got_SIGUSR2</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/********************************************************************<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AUTOVACUUM <a href="../utils/sort/tuplesort.c.html#L407" title="utils/sort/tuplesort.c:407">WORKER</a> CODE<br/></li>
<li></span><span class="Comment"> ********************************************************************/<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point for autovacuum worker processes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1359">&#x200c;</a></span><span class="linkable">AutoVacWorkerMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dbid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release postmaster's working memory context */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_AUTOVAC_WORKER;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L267" title="utils/misc/ps_status.c:267">init_ps_display</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(InitProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up signal handlers.&nbsp; We operate on databases much like a regular<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend, so we use the same signal handling.&nbsp; See equivalent code in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tcop/postgres.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGINT is used to signal canceling the current table's <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>; SIGTERM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * means abort and exit cleanly, and SIGQUIT means abandon ship.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="../tcop/postgres.c.html#L3002" title="tcop/postgres.c:3002">StatementCancelHandler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establishes SIGALRM handler */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGFPE</span>, <a href="../tcop/postgres.c.html#L3019" title="tcop/postgres.c:3019">FloatExceptionHandler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a per-backend PGPROC struct in shared memory.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can use LWLocks or access <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Early initialization */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L645" title="utils/init/postinit.c:645">BaseInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike most auxiliary processes, we don't attempt to continue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing after an error; we just clean up and exit.&nbsp; The autovac<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * launcher is responsible for spawning another worker later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we use sigsetjmp(..., 1), so that the prevailing signal mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (to wit, <a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>) will be restored when longjmp'ing to here.&nbsp; Thus,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signals other than SIGQUIT will be blocked until we exit.&nbsp; It might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seem that this policy makes the HOLD_INTERRUPTS() call redundant, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is not since <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> might be set already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevents interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> go away.&nbsp; Note that because we called <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>, a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callback was registered to do <a href="../storage/lmgr/proc.c.html#L834" title="storage/lmgr/proc.c:834">ProcKill</a>, which will clean up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set always-secure search path, so malicious users can't redirect user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code (e.g. pg_index.indexprs).&nbsp; (That code runs in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SECURITY_RESTRICTED_OPERATION sandbox, so malicious users could not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take control of the entire autovacuum worker in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;search_path&quot;</span>, <span class="Constant">&quot;&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force <a href="../storage/buffer/bufmgr.c.html#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a> <a href="../regex/regexec.c.html#L131" title="regex/regexec.c:131">OFF</a> in the autovac process, even if it is set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in postgresql.conf.&nbsp; We don't really want such a dangerous option being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * applied non-interactively.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../storage/buffer/bufmgr.c.html#L139" title="storage/buffer/bufmgr.c:139">zero_damaged_pages</a>&quot;</span>, <span class="Constant">&quot;false&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force settable timeouts off to avoid letting these settings prevent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular maintenance from being executed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;statement_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;transaction_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;lock_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;idle_in_transaction_session_timeout&quot;</span>, <span class="Constant">&quot;0&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force default_transaction_isolation to READ COMMITTED.&nbsp; We don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to pay the overhead of serializable mode, nor add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> risk of causing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deadlocks or delaying other transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;default_transaction_isolation&quot;</span>, <span class="Constant">&quot;read committed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force synchronous replication off to allow regular maintenance even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for standbys to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a>. This is important to ensure we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aren't blocked from performing anti-wraparound tasks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L85" title="access/transam/xact.c:85">synchronous_commit</a> &gt; SYNCHRONOUS_COMMIT_LOCAL_FLUSH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../access/transam/xact.c.html#L85" title="access/transam/xact.c:85">synchronous_commit</a>&quot;</span>, <span class="Constant">&quot;local&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even when system is configured to use a different fetch consistency,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for autovac we always want fresh stats.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L258" title="utils/misc/guc_tables.c:258">stats_fetch_consistency</a>&quot;</span>, <span class="Constant">&quot;<a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>&quot;</span>, PGC_SUSET, PGC_S_OVERRIDE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the info about the database we're going to work on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beware of startingWorker being INVALID; this should normally not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen, but if a worker fails after forking and <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * launcher might have decided to remove it from the queue and start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a> = <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbid = <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dboid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_proc = <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* insert into the running list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_runningWorkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_links);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * remove from the &quot;starting&quot; pointer, so that the launcher can start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a new worker if required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L1585" title="postmaster/autovacuum.c:1585">FreeWorkerInfo</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wake up the launcher */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_launcherpid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_launcherpid, <span class="Constant">SIGUSR2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no worker entry for me, go away */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;autovacuum worker started without a worker entry&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(dbid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; dbname[NAMEDATALEN];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Report autovac startup to the cumulative stats system.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deliberately do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last_autovac_time will get updated even if the connection attempt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fails.&nbsp; This is to prevent autovac from getting &quot;stuck&quot; repeatedly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * selecting an unopenable database, rather than making <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> progress<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on stuff it can <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_database.c.html#L55" title="utils/activity/pgstat_database.c:55">pgstat_report_autovac</a>(dbid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Connect to the selected database, specifying no particular user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: if we have selected a just-deleted database (due to using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stale stats info), we'll fail and exit here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>(<span class="Constant">NULL</span>, dbid, <span class="Constant">NULL</span>, InvalidOid, <span class="Constant">0</span>, dbname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SetProcessingMode(NormalProcessing);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(dbname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;autovacuum: processing database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, dbname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="../tcop/postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a> * <span class="Constant">1000000L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And do an appropriate amount of work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L154" title="postmaster/autovacuum.c:154">recentXid</a> = ReadNextTransactionId();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L155" title="postmaster/autovacuum.c:155">recentMulti</a> = <a href="../access/transam/multixact.c.html#L729" title="access/transam/multixact.c:729">ReadNextMultiXactId</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1873" title="postmaster/autovacuum.c:1873">do_autovacuum</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The launcher will be notified of my death in <a href="../storage/lmgr/proc.c.html#L834" title="storage/lmgr/proc.c:834">ProcKill</a>, *if* we managed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to get a worker slot at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* All done, go away */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return a <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> to the free list<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1585">&#x200c;</a></span><span class="linkable">FreeWorkerInfo</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wake the launcher up so that he can launch a new worker immediately<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if required.&nbsp; We only save the launcher's PID in local memory here;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the actual signal will be sent when the PGPROC is recycled.&nbsp; Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we always do this, so that the launcher can rebalance the cost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * limit setting of the remaining workers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We somewhat ignore the risk that the launcher changes its PID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * between us reading it and the actual kill; we expect <a href="../storage/lmgr/proc.c.html#L834" title="storage/lmgr/proc.c:834">ProcKill</a> to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * called shortly after us, and we assume that PIDs are not reused too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quickly after a process exits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L312" title="postmaster/autovacuum.c:312">AutovacuumLauncherPid</a> = <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_launcherpid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dboid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_tableoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_sharedrel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_proc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_launchtime = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_clear_flag(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dobalance);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not mine anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that we're inactive, cause a rebalancing of the surviving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_signal[AutoVacRebalance] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cost-based delay-related parameters for autovacuum workers and<br/></li>
<li></span><span class="Comment"> * backends executing VACUUM or ANALYZE using the value of relevant GUCs and<br/></li>
<li></span><span class="Comment"> * global state. This must be called during setup for <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> and after every<br/></li>
<li></span><span class="Comment"> * config reload to ensure up-to-date <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1633">&#x200c;</a></span><span class="linkable">VacuumUpdateCosts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L147" title="postmaster/autovacuum.c:147">av_storage_param_cost_delay</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> = <a href="#L147" title="postmaster/autovacuum.c:147">av_storage_param_cost_delay</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L129" title="postmaster/autovacuum.c:129">autovacuum_vac_cost_delay</a> &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> = <a href="#L129" title="postmaster/autovacuum.c:129">autovacuum_vac_cost_delay</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall back to <a href="../utils/init/globals.c.html#L152" title="utils/init/globals.c:152">VacuumCostDelay</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> = <a href="../utils/init/globals.c.html#L152" title="utils/init/globals.c:152">VacuumCostDelay</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1702" title="postmaster/autovacuum.c:1702">AutoVacuumUpdateCostLimit</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be explicit VACUUM or ANALYZE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> = <a href="../utils/init/globals.c.html#L152" title="utils/init/globals.c:152">VacuumCostDelay</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> = <a href="../utils/init/globals.c.html#L151" title="utils/init/globals.c:151">VacuumCostLimit</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If configuration changes are allowed to impact <a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>, make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure it is updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L159" title="utils/init/globals.c:159">VacuumCostActive</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L158" title="utils/init/globals.c:158">VacuumCostBalance</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the cost logging requires a lock, avoid rendering the log message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case we are using a message level where the log wouldn't be emitted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a> &amp;&amp; <a href="../utils/error/elog.c.html#L276" title="utils/error/elog.c:276">message_level_is_interesting</a>(DEBUG2))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dboid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(AutovacuumLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dboid = <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dboid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tableoid = <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_tableoid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Autovacuum <a href="#L1633" title="postmaster/autovacuum.c:1633">VacuumUpdateCosts</a>(db=</span><span class="Special">%u</span><span class="Constant">, rel=</span><span class="Special">%u</span><span class="Constant">, dobalance=</span><span class="Special">%s</span><span class="Constant">, cost_limit=</span><span class="Special">%d</span><span class="Constant">, cost_delay=</span><span class="Special">%g</span><span class="Constant"> active=</span><span class="Special">%s</span><span class="Constant"> failsafe=</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dboid, tableoid, pg_atomic_unlocked_test_flag(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dobalance) ? <span class="Constant">&quot;no&quot;</span> : <span class="Constant">&quot;yes&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a>, <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> &gt; <span class="Constant">0</span> ? <span class="Constant">&quot;yes&quot;</span> : <span class="Constant">&quot;no&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../commands/vacuum.c.html#L96" title="commands/vacuum.c:96">VacuumFailsafeActive</a> ? <span class="Constant">&quot;yes&quot;</span> : <span class="Constant">&quot;no&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Update <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> with the correct value for an autovacuum worker,<br/></li>
<li></span><span class="Comment"> * given the value of other relevant cost limit parameters and the number of<br/></li>
<li></span><span class="Comment"> * workers across which the limit must be balanced. Autovacuum workers must<br/></li>
<li></span><span class="Comment"> * call this regularly in case av_nworkersForBalance has been updated by<br/></li>
<li></span><span class="Comment"> * another worker or by the autovacuum launcher. They must also call it after a<br/></li>
<li></span><span class="Comment"> * config reload.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1702">&#x200c;</a></span><span class="linkable">AutoVacuumUpdateCostLimit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * note: in cost_limit, zero also means use value from elsewhere, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero is not a valid value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L148" title="postmaster/autovacuum.c:148">av_storage_param_cost_limit</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> = <a href="#L148" title="postmaster/autovacuum.c:148">av_storage_param_cost_limit</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers_for_balance;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L130" title="postmaster/autovacuum.c:130">autovacuum_vac_cost_limit</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> = <a href="#L130" title="postmaster/autovacuum.c:130">autovacuum_vac_cost_limit</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> = <a href="../utils/init/globals.c.html#L151" title="utils/init/globals.c:151">VacuumCostLimit</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Only balance limit if no cost-related storage parameters specified */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_unlocked_test_flag(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dobalance))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nworkers_for_balance = pg_atomic_read_u32(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_nworkersForBalance);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There is at least 1 autovac worker (this worker) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nworkers_for_balance &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;nworkers_for_balance must be &gt; 0&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> = Max(<a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> / nworkers_for_balance, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1748" title="postmaster/autovacuum.c:1748">autovac_recalculate_workers_for_balance</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recalculate the number of workers to consider, given cost-related<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; storage parameters and the current number of active workers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must hold the AutovacuumLock in at least shared mode to access<br/></li>
<li></span><span class="Comment"> * worker-&gt;wi_proc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1748">&#x200c;</a></span><span class="linkable">autovac_recalculate_workers_for_balance</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_nworkers_for_balance;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers_for_balance = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(AutovacuumLock));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; orig_nworkers_for_balance =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_read_u32(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_nworkersForBalance);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_runningWorkers)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>&nbsp; &nbsp; worker = dlist_container(<a href="#L227" title="postmaster/autovacuum.c:227">WorkerInfoData</a>, wi_links, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;wi_proc == <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_unlocked_test_flag(&amp;worker-&gt;wi_dobalance))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nworkers_for_balance++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nworkers_for_balance != orig_nworkers_for_balance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_write_u32(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_nworkersForBalance,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nworkers_for_balance);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1788" title="postmaster/autovacuum.c:1788">get_database_list</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return a list of all databases found in pg_database.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list and associated data is allocated in the caller's memory context,<br/></li>
<li></span><span class="Comment"> * which is in <a href="../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a> of ensuring that it's properly cleaned up afterwards.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is the only function in which the autovacuum launcher uses a<br/></li>
<li></span><span class="Comment"> * transaction.&nbsp; Although we aren't attached to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> particular database and<br/></li>
<li></span><span class="Comment"> * therefore can't access most catalogs, we do have enough infrastructure<br/></li>
<li></span><span class="Comment"> * to do a seqscan on pg_database.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L1788">&#x200c;</a><span class="linkable">get_database_list</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *dblist = NIL;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; MemoryContext resultcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This is the context that we will allocate our output data in */<br/></li>
<li></span>&nbsp; &nbsp; resultcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start a transaction so we can access pg_database, and get a snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't have a use for the snapshot itself, but we're interested in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the secondary effect that it sets RecentGlobalXmin.&nbsp; (This is critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for anything that reads heap pages, because HOT may decide to prune<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them even if the process doesn't attempt to modify <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">FIXME</span><span class="Comment">: This comment is inaccurate / the code buggy. A snapshot that is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not pushed/active does not reliably prevent HOT pruning (-&gt;xmin could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * e.g. be cleared when cache invalidations are processed).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DatabaseRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(rel, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tup = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(scan, ForwardScanDirection)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_database pgdatabase = (Form_pg_database) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L176" title="postmaster/autovacuum.c:176">avw_dbase</a>&nbsp; *avdb;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If database has partially been dropped, we can't, nor need to,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../commands/dbcommands.c.html#L3177" title="commands/dbcommands.c:3177">database_is_invalid_form</a>(pgdatabase))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;autovacuum: skipping invalid database </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(pgdatabase-&gt;datname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate our results in the caller's context, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction's. We do this inside the loop, and restore the original<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context at the end, so that leaky things like <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>() are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not called in a potentially long-lived context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(resultcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avdb = (<a href="#L176" title="postmaster/autovacuum.c:176">avw_dbase</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L176" title="postmaster/autovacuum.c:176">avw_dbase</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adw_datid = pgdatabase-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adw_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(pgdatabase-&gt;datname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adw_frozenxid = pgdatabase-&gt;datfrozenxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adw_minmulti = pgdatabase-&gt;datminmxid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this gets set later: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; avdb-&gt;adw_entry = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dblist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(dblist, avdb);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Be sure to restore caller's memory context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(resultcxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> dblist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process a database table-by-table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that CHECK_FOR_INTERRUPTS is supposed to be used in certain spots in<br/></li>
<li></span><span class="Comment"> * order not to ignore shutdown commands for too long.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1873">&#x200c;</a></span><span class="linkable">do_autovacuum</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; classRel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; TableScanDesc relScan;<br/></li>
<li>&nbsp; &nbsp; Form_pg_database dbForm;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *table_oids = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *orphan_oids = NIL;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *table_toast_map;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *<span class="Type">volatile</span> cell;<br/></li>
<li>&nbsp; &nbsp; BufferAccessStrategy bstrategy;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; pg_class_desc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; did_vacuum = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_concurrent_worker = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a> and <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a> will automatically<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * switch to other contexts.&nbsp; We need this one to keep the list of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> across transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a> = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Autovacuum worker&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start a transaction so our commands have one to play into. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the multixact age for which freezing is urgent.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normally <a href="#L127" title="postmaster/autovacuum.c:127">autovacuum_multixact_freeze_max_age</a>, but may be less if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * short of multixact member space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; effective_multixact_freeze_max_age = <a href="../access/transam/multixact.c.html#L2929" title="access/transam/multixact.c:2929">MultiXactMemberFreezeThreshold</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find the pg_database entry and <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> the default freeze ages. We use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * zero in template and nonconnectable databases, else the system-wide<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(DATABASEOID, ObjectIdGetDatum(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for database </span><span class="Special">%u</span><span class="Constant">&quot;</span>, <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; dbForm = (Form_pg_database) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dbForm-&gt;datistemplate || !dbForm-&gt;datallowconn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="postmaster/autovacuum.c:158">default_freeze_min_age</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="postmaster/autovacuum.c:159">default_freeze_table_age</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="postmaster/autovacuum.c:160">default_multixact_freeze_min_age</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="postmaster/autovacuum.c:161">default_multixact_freeze_table_age</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="postmaster/autovacuum.c:158">default_freeze_min_age</a> = <a href="../commands/vacuum.c.html#L67" title="commands/vacuum.c:67">vacuum_freeze_min_age</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L159" title="postmaster/autovacuum.c:159">default_freeze_table_age</a> = <a href="../commands/vacuum.c.html#L68" title="commands/vacuum.c:68">vacuum_freeze_table_age</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="postmaster/autovacuum.c:160">default_multixact_freeze_min_age</a> = <a href="../commands/vacuum.c.html#L69" title="commands/vacuum.c:69">vacuum_multixact_freeze_min_age</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="postmaster/autovacuum.c:161">default_multixact_freeze_table_age</a> = <a href="../commands/vacuum.c.html#L70" title="commands/vacuum.c:70">vacuum_multixact_freeze_table_age</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a> changed elsewhere */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; classRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create a copy so we can use it after closing pg_class */<br/></li>
<li></span>&nbsp; &nbsp; pg_class_desc = <a href="../access/common/tupdesc.c.html#L133" title="access/common/tupdesc.c:133">CreateTupleDescCopy</a>(RelationGetDescr(classRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table for toast &lt;-&gt; <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> relid mapping */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L186" title="postmaster/autovacuum.c:186">av_relation</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_toast_map = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;TOAST to <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> relid map&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">100</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan pg_class to determine which tables to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do this in two passes: on the first one we collect the list of plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations and materialized views, and on the second one we collect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TOAST tables. The reason for doing the second pass is that during it we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to use the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> relation's pg_class.reloptions entry if the TOAST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table does not have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and we cannot obtain it unless we know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beforehand what's the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to check TOAST tables separately because in cases with short,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wide tables there might be proportionally much more activity in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * TOAST table than in its parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; relScan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(classRel, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On the first pass, we collect <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> tables to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>, and also the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table relid to TOAST relid mapping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(relScan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatTabEntry *tabentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AutoVacOpts *relopts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dovacuum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; doanalyze;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wraparound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relkind != RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = classForm-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if it is a temp table (presumably, of some other backend's).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot safely process other backends' temp tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relpersistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We just ignore it if the owning backend is still active and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using the temporary schema.&nbsp; Also, for safety, ignore it if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * namespace doesn't exist or isn't a temp namespace after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/namespace.c.html#L3714" title="catalog/namespace.c:3714">checkTempNamespaceStatus</a>(classForm-&gt;relnamespace) == TEMP_NAMESPACE_IDLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The table seems to be orphaned -- although it might be that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the owning backend has already deleted it and exited; our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_class scan snapshot is not necessarily up-to-date<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anymore, so we could be looking at a committed-dead entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember it so we can try to delete it later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orphan_oids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(orphan_oids, relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch reloptions and the pgstat entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relopts = <a href="#L2674" title="postmaster/autovacuum.c:2674">extract_autovac_opts</a>(tuple, pg_class_desc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tabentry = <a href="../utils/activity/pgstat_relation.c.html#L466" title="utils/activity/pgstat_relation.c:466">pgstat_fetch_stat_tabentry_ext</a>(classForm-&gt;relisshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if it needs <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2905" title="postmaster/autovacuum.c:2905">relation_needs_vacanalyze</a>(relid, relopts, classForm, tabentry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dovacuum, &amp;doanalyze, &amp;wraparound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Relations that need work are added to table_oids */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dovacuum || doanalyze)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_oids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(table_oids, relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember TOAST associations for the second pass.&nbsp; Note: we must do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this whether or not the table is going to be vacuumed, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't automatically <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> toast tables along the parent table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(classForm-&gt;reltoastrelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L186" title="postmaster/autovacuum.c:186">av_relation</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(table_toast_map,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;classForm-&gt;reltoastrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a> already filled in the key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;ar_relid = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;ar_hasrelopts = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relopts != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry-&gt;ar_hasrelopts = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;hentry-&gt;ar_reloptions, relopts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AutoVacOpts));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(relScan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* second pass: check TOAST tables */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_CHAREQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CharGetDatum(RELKIND_TOASTVALUE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relScan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(classRel, <span class="Constant">1</span>, &amp;key);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(relScan, ForwardScanDirection)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatTabEntry *tabentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AutoVacOpts *relopts = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dovacuum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; doanalyze;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wraparound;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot safely process other backends' temp tables, so <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> 'em.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relpersistence == RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relid = classForm-&gt;oid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fetch reloptions -- if this toast table does not have them, try the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> rel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; relopts = <a href="#L2674" title="postmaster/autovacuum.c:2674">extract_autovac_opts</a>(tuple, pg_class_desc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (relopts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L186" title="postmaster/autovacuum.c:186">av_relation</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hentry = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(table_toast_map, &amp;relid, HASH_FIND, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; hentry-&gt;ar_hasrelopts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relopts = &amp;hentry-&gt;ar_reloptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fetch the pgstat entry for this table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tabentry = <a href="../utils/activity/pgstat_relation.c.html#L466" title="utils/activity/pgstat_relation.c:466">pgstat_fetch_stat_tabentry_ext</a>(classForm-&gt;relisshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2905" title="postmaster/autovacuum.c:2905">relation_needs_vacanalyze</a>(relid, relopts, classForm, tabentry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dovacuum, &amp;doanalyze, &amp;wraparound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> for toast tables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dovacuum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_oids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(table_oids, relid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(relScan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(classRel, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recheck orphan temporary tables, and if they still seem orphaned, drop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them.&nbsp; We'll eat a transaction per dropped table, which might seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * excessive, but we should only need to do anything as a result of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous backend crash, so this should not happen often enough to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * justify &quot;optimizing&quot;.&nbsp; Using separate transactions ensures that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't bloat the lock table if there are many temp tables to be dropped,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it ensures that we don't lose work if a deletion attempt fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, orphan_oids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress object;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for user-requested abort.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to lock the table.&nbsp; If we can't get the lock immediately,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * somebody else is using (or dropping) the table, so it's not our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concern anymore.&nbsp; Having the lock prevents race conditions below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/lmgr/lmgr.c.html#L151" title="storage/lmgr/lmgr.c:151">ConditionalLockRelationOid</a>(relid, AccessExclusiveLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-fetch the pg_class tuple and re-check whether it still seems to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be an orphaned temp table.&nbsp; If it's not there or no longer the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation, ignore it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be sure to drop useless lock so we don't bloat lock table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(relid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; classForm = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make all the same tests made in the loop above.&nbsp; In event of OID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counter wraparound, the pg_class entry we have <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completely unrelated to the one we saw <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!((classForm-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classForm-&gt;relkind == RELKIND_MATVIEW) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classForm-&gt;relpersistence == RELPERSISTENCE_TEMP))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(relid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/namespace.c.html#L3714" title="catalog/namespace.c:3714">checkTempNamespaceStatus</a>(classForm-&gt;relnamespace) != TEMP_NAMESPACE_IDLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(relid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to lock the temp namespace, too.&nbsp; Even though we have lock on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table itself, there's a risk of deadlock against an incoming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend trying to clean out the temp namespace, in case this table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has dependencies (such as sequences) that the backend's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a> call might visit in a different order.&nbsp; If we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * get AccessShareLock on the namespace, that's sufficient to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're not running concurrently with <a href="../catalog/namespace.c.html#L4583" title="catalog/namespace.c:4583">RemoveTempRelations</a>.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't, back off and let <a href="../catalog/namespace.c.html#L4583" title="catalog/namespace.c:4583">RemoveTempRelations</a> do its thing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/lmgr/lmgr.c.html#L1028" title="storage/lmgr/lmgr.c:1028">ConditionalLockDatabaseObject</a>(NamespaceRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; classForm-&gt;relnamespace, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L227" title="storage/lmgr/lmgr.c:227">UnlockRelationOid</a>(relid, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, let's delete it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;autovacuum: dropping orphan temp table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(classForm-&gt;relnamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(classForm-&gt;relname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.objectId = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.objectSubId = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;object, DROP_CASCADE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PERFORM_DELETION_INTERNAL |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PERFORM_DELETION_QUIETLY |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PERFORM_DELETION_SKIP_EXTENSIONS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * To commit the deletion, end current transaction and start a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one.&nbsp; Note this also releases the locks we took.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a> changed current memory context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Optionally, create a buffer access strategy object for VACUUM to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use the same BufferAccessStrategy object for all tables VACUUMed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this worker to prevent autovacuum from blowing out shared buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L146" title="utils/init/globals.c:146">VacuumBufferUsageLimit</a> being set to 0 results in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/buffer/freelist.c.html#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a> returning NULL, effectively meaning we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * use up to all of shared buffers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we later enter failsafe mode on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the tables being vacuumed, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will cease use of the BufferAccessStrategy only for that table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should we consider adding code to adjust the size of this if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L146" title="utils/init/globals.c:146">VacuumBufferUsageLimit</a> changes?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bstrategy = <a href="../storage/buffer/freelist.c.html#L584" title="storage/buffer/freelist.c:584">GetAccessStrategyWithSize</a>(BAS_VACUUM, <a href="../utils/init/globals.c.html#L146" title="utils/init/globals.c:146">VacuumBufferUsageLimit</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a memory context to act as fake <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>, so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contexts created in the <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> code are cleaned up for each table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = AllocSetContextCreate(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Autovacuum Portal&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform operations on collected tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(cell, table_oids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = lfirst_oid(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *tab;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isshared;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for config changes <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> processing each collected table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * You might be tempted to bail out if we see autovacuum is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disabled.&nbsp; Must resist that temptation -- this might be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for-wraparound emergency worker, in which case that would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entirely inappropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Find out whether the table is shared or not.&nbsp; (It's slightly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * annoying to fetch the syscache entry just for this, but in typical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases it adds little cost because <a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a> would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * refetch the entry anyway.&nbsp; We could buy that back by copying the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * tuple here and passing it to <a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a>, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * increases the odds of that function working with stale data.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; classTup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(classTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* somebody deleted the rel, forget it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; isshared = ((Form_pg_class) GETSTRUCT(classTup))-&gt;relisshared;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(classTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hold schedule lock from here until we've claimed the table.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also need the AutovacuumLock to walk the worker array, but that one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can just be a shared lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumScheduleLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether the table is being vacuumed concurrently by another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; skipit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_runningWorkers)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>&nbsp; &nbsp; worker = dlist_container(<a href="#L227" title="postmaster/autovacuum.c:227">WorkerInfoData</a>, wi_links, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore myself */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker == <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore workers in other databases (unless table is shared) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!worker-&gt;wi_sharedrel &amp;&amp; worker-&gt;wi_dboid != <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (worker-&gt;wi_tableoid == relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found_concurrent_worker = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (skipit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumScheduleLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store the table's OID in shared memory <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> releasing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * schedule lock, so that other workers don't try to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrently.&nbsp; (We claim it here so as not to hold<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AutovacuumScheduleLock while rechecking the stats.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_tableoid = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_sharedrel = isshared;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumScheduleLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether pgstat data still says we need to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> this table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It could have changed if something else processed the table while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we weren't looking. This doesn't entirely close the race condition,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but it is very small.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a>(relid, table_toast_map, pg_class_desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* someone else vacuumed the table, or it went away */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumScheduleLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_tableoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_sharedrel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumScheduleLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the cost-related storage parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in global variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for reference when updating <a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> and <a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during vacuuming this table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="postmaster/autovacuum.c:147">av_storage_param_cost_delay</a> = tab-&gt;at_storage_param_vac_cost_delay;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L148" title="postmaster/autovacuum.c:148">av_storage_param_cost_limit</a> = tab-&gt;at_storage_param_vac_cost_limit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We only expect this worker to ever set the flag, so don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checking the return value. We shouldn't have to retry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;at_dobalance)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_test_set_flag(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dobalance);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_clear_flag(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dobalance);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1748" title="postmaster/autovacuum.c:1748">autovac_recalculate_workers_for_balance</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We wait until this point to update cost delay and cost limit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, even though we reloaded the configuration file above, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we can take into account the cost-related storage parameters.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1633" title="postmaster/autovacuum.c:1633">VacuumUpdateCosts</a>();<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* clean up memory <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save the relation name for a possible error message, to avoid a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * catalog lookup in case of an error.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these return NULL,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then the relation has been dropped since last we checked; <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: they must live in a long-lived memory context because we call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> and <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> in different transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_relname = <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(tab-&gt;at_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_nspname = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(<a href="../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(tab-&gt;at_relid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_datname = <a href="../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tab-&gt;at_relname || !tab-&gt;at_nspname || !tab-&gt;at_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> deleted;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will abort vacuuming the current table if something errors out,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and continue with the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one in schedule; in particular, this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happens if we are interrupted with SIGINT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> per-table allocations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have at it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3078" title="postmaster/autovacuum.c:3078">autovacuum_do_vac_analyze</a>(tab, bstrategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear a possible query-cancel signal, to avoid a late reaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to an automatically-sent signal because of vacuuming the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current table (we're done with it, so it would make no sense to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cancel at this point.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort the transaction, start a new one, and proceed with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> table in our list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;at_params.options &amp; VACOPT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;automatic <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;at_datname, tab-&gt;at_nspname, tab-&gt;at_relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;automatic <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> of table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;at_datname, tab-&gt;at_nspname, tab-&gt;at_relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this resets <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[i] too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L4811" title="access/transam/xact.c:4811">AbortOutOfAnyTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restart our transaction for the following operations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we're back in <a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; did_vacuum = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[i] are reset at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> end of xact */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span><span class="Statement">deleted</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;at_datname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tab-&gt;at_datname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;at_nspname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tab-&gt;at_nspname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;at_relname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tab-&gt;at_relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(tab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove my info from shared memory.&nbsp; We set wi_dobalance on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assumption that we are more likely than not to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> a table with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no cost-related storage parameters <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>, so we want to claim our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * share of I/O as soon as possible to avoid thrashing the global<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * balance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumScheduleLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_tableoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_sharedrel = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumScheduleLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_test_set_flag(&amp;<a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>-&gt;wi_dobalance);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Perform additional work items, as requested by backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L268" title="postmaster/autovacuum.c:268">NUM_WORKITEMS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> *workitem = &amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_workItems[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!workitem-&gt;avw_used)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (workitem-&gt;avw_active)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (workitem-&gt;avw_database != <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* claim this one, and release lock while performing it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_active = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2560" title="postmaster/autovacuum.c:2560">perform_work_item</a>(workitem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for config changes <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> acquiring lock for further jobs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1633" title="postmaster/autovacuum.c:1633">VacuumUpdateCosts</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and mark it done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_active = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_used = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We leak table_toast_map here (among other things), but since we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * going away soon, it's not a problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update pg_database.datfrozenxid, and truncate pg_xact if possible. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only need to do this once, not after each table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Even if we didn't <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> anything, it may still be important to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, because one indirect effect of <a href="../commands/vacuum.c.html#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>() is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * update <a href="../access/transam/varsup.c.html#L34" title="access/transam/varsup.c:34">TransamVariables</a>-&gt;xidVacLimit.&nbsp; That might need to be done even<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we haven't vacuumed anything, because relations with older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relfrozenxid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> or other databases with older datfrozenxid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might have been dropped, allowing xidVacLimit to advance.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, it's also important not to do this blindly in all cases,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because when autovacuum=off this will restart the autovacuum launcher.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're not careful, an infinite loop can result, where workers <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no work to do and restart the launcher, which starts another worker in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same database that finds no work to do.&nbsp; To prevent that, we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this if (1) we found no work to do and (2) we skipped at least one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table due to concurrent autovacuum activity.&nbsp; In that case, the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * worker has already done it, or will do so when it finishes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (did_vacuum || !found_concurrent_worker)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/vacuum.c.html#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally close out the last transaction. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Execute a previously registered work item.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2560">&#x200c;</a></span><span class="linkable">perform_work_item</span>(<a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> *workitem)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cur_datname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cur_nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cur_relname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we do not store table info in <a href="#L309" title="postmaster/autovacuum.c:309">MyWorkerInfo</a>, since this is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming proper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save the relation name for a possible error message, to avoid a catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lookup in case of an error.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of these return NULL, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation has been dropped since last we checked; <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> == <a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cur_relname = <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(workitem-&gt;avw_relation);<br/></li>
<li>&nbsp; &nbsp; cur_nspname = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(<a href="../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(workitem-&gt;avw_relation));<br/></li>
<li>&nbsp; &nbsp; cur_datname = <a href="../commands/dbcommands.c.html#L3153" title="commands/dbcommands.c:3153">get_database_name</a>(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!cur_relname || !cur_nspname || !cur_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> deleted2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3149" title="postmaster/autovacuum.c:3149">autovac_report_workitem</a>(workitem, cur_nspname, cur_relname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* clean up memory <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> each work item */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We will abort the current work item if something errors out, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * continue with the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one; in particular, this happens if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupted with SIGINT.&nbsp; Note that this means that the work item list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can be lossy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> per-work-item allocations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Have at it.&nbsp; Functions called here are responsible for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user switch and sandbox.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (workitem-&gt;avw_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AVW_BRINSummarizeRange:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DirectFunctionCall2(<a href="../access/brin/brin.c.html#L1369" title="access/brin/brin.c:1369">brin_summarize_range</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(workitem-&gt;avw_relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>((int64) workitem-&gt;avw_blockNumber));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;unrecognized work item found: type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; workitem-&gt;avw_type);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear a possible query-cancel signal, to avoid a late reaction to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an automatically-sent signal because of vacuuming the current table<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (we're done with it, so it would make no sense to cancel at this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort the transaction, start a new one, and proceed with the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * table in our list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;processing work entry for relation </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cur_datname, cur_nspname, cur_relname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this resets <a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;statusFlags[i] too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L4811" title="access/transam/xact.c:4811">AbortOutOfAnyTransaction</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* restart our transaction for the following operations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure we're back in <a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a> */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L164" title="postmaster/autovacuum.c:164">AutovacMemCxt</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We intentionally do not set did_vacuum here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* be tidy */<br/></li>
<li></span><span class="Statement">deleted2</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cur_datname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cur_datname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_nspname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cur_nspname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cur_relname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cur_relname);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2674" title="postmaster/autovacuum.c:2674">extract_autovac_opts</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Given a relation's pg_class tuple, return the AutoVacOpts portion of<br/></li>
<li></span><span class="Comment"> * reloptions, if set; otherwise, return NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: callers do not have a relation lock on the table at this point,<br/></li>
<li></span><span class="Comment"> * so the table could have been dropped, and its catalog rows gone, after<br/></li>
<li></span><span class="Comment"> * we acquired the pg_class row.&nbsp; If pg_class had a TOAST table, this would<br/></li>
<li></span><span class="Comment"> * be a risk; fortunately, it doesn't.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> AutoVacOpts *<br/></li>
<li><a id="L2674">&#x200c;</a><span class="linkable">extract_autovac_opts</span>(HeapTuple tup, TupleDesc pg_class_desc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; bytea&nbsp; &nbsp; &nbsp;&nbsp; *relopts;<br/></li>
<li>&nbsp; &nbsp; AutoVacOpts *av;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(((Form_pg_class) GETSTRUCT(tup))-&gt;relkind == RELKIND_RELATION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Form_pg_class) GETSTRUCT(tup))-&gt;relkind == RELKIND_MATVIEW ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((Form_pg_class) GETSTRUCT(tup))-&gt;relkind == RELKIND_TOASTVALUE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relopts = <a href="../access/common/reloptions.c.html#L1379" title="access/common/reloptions.c:1379">extractRelOptions</a>(tup, pg_class_desc, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relopts == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; av = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AutoVacOpts));<br/></li>
<li>&nbsp; &nbsp; memcpy(av, &amp;(((StdRdOptions *) relopts)-&gt;autovacuum), <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(AutoVacOpts));<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(relopts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> av;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Recheck whether a table still needs <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.&nbsp; Return value is a<br/></li>
<li></span><span class="Comment"> * valid <a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> pointer if it does, NULL otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the returned <a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> does not have the name fields set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *<br/></li>
<li><a id="L2704">&#x200c;</a><span class="linkable">table_recheck_autovac</span>(Oid relid, <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *table_toast_map,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDesc pg_class_desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> effective_multixact_freeze_max_age)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_class classForm;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classTup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dovacuum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; doanalyze;<br/></li>
<li>&nbsp; &nbsp; <a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *tab = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; wraparound;<br/></li>
<li>&nbsp; &nbsp; AutoVacOpts *avopts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch the relation's relcache entry */<br/></li>
<li></span>&nbsp; &nbsp; classTup = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(classTup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; classForm = (Form_pg_class) GETSTRUCT(classTup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the applicable reloptions.&nbsp; If it is a TOAST table, try to get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table reloptions if the toast table itself doesn't have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; avopts = <a href="#L2674" title="postmaster/autovacuum.c:2674">extract_autovac_opts</a>(classTup, pg_class_desc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relkind == RELKIND_TOASTVALUE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; avopts == <span class="Constant">NULL</span> &amp;&amp; table_toast_map != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L186" title="postmaster/autovacuum.c:186">av_relation</a> *hentry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hentry = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(table_toast_map, &amp;relid, HASH_FIND, &amp;found);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found &amp;&amp; hentry-&gt;ar_hasrelopts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avopts = &amp;hentry-&gt;ar_reloptions;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2844" title="postmaster/autovacuum.c:2844">recheck_relation_needs_vacanalyze</a>(relid, avopts, classForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;dovacuum, &amp;doanalyze, &amp;wraparound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK, it needs something done */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (doanalyze || dovacuum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; log_min_duration;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate the <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> cost parameters and the freeze ages.&nbsp; If there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are options set in pg_class.reloptions, use them; in the case of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * toast table, try the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table too.&nbsp; Otherwise use the GUC<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defaults, autovacuum's own first and plain <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> second.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* -1 in autovac setting means use log_autovacuum_min_duration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; log_min_duration = (avopts &amp;&amp; avopts-&gt;log_min_duration &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? avopts-&gt;log_min_duration<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L132" title="postmaster/autovacuum.c:132">Log_autovacuum_min_duration</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* these do not have autovacuum-specific settings */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; freeze_min_age = (avopts &amp;&amp; avopts-&gt;freeze_min_age &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? avopts-&gt;freeze_min_age<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L158" title="postmaster/autovacuum.c:158">default_freeze_min_age</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; freeze_table_age = (avopts &amp;&amp; avopts-&gt;freeze_table_age &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? avopts-&gt;freeze_table_age<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L159" title="postmaster/autovacuum.c:159">default_freeze_table_age</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_min_age = (avopts &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avopts-&gt;multixact_freeze_min_age &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? avopts-&gt;multixact_freeze_min_age<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L160" title="postmaster/autovacuum.c:160">default_multixact_freeze_min_age</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_table_age = (avopts &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avopts-&gt;multixact_freeze_table_age &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ? avopts-&gt;multixact_freeze_table_age<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L161" title="postmaster/autovacuum.c:161">default_multixact_freeze_table_age</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_relid = relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_sharedrel = classForm-&gt;relisshared;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select VACUUM options.&nbsp; Note we don't say VACOPT_PROCESS_TOAST, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>() skips toast relations.&nbsp; Also note we tell <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>() to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> <a href="../commands/vacuum.c.html#L1565" title="commands/vacuum.c:1565">vac_update_datfrozenxid</a>(); we'll do that separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.options =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (dovacuum ? (VACOPT_VACUUM |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_PROCESS_MAIN |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; VACOPT_SKIP_DATABASE_STATS) : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (doanalyze ? VACOPT_ANALYZE : <span class="Constant">0</span>) |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!wraparound ? VACOPT_SKIP_LOCKED : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index_cleanup and truncate are unspecified at first in autovacuum.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * They will be filled in with usable <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> using their reloptions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (or reloption defaults) later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.index_cleanup = VACOPTVALUE_UNSPECIFIED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.truncate = VACOPTVALUE_UNSPECIFIED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As of <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't support parallel <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> for autovacuum */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.nworkers = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.freeze_min_age = freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.freeze_table_age = freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.multixact_freeze_min_age = multixact_freeze_min_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.multixact_freeze_table_age = multixact_freeze_table_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.is_wraparound = wraparound;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.log_min_duration = log_min_duration;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_params.toast_parent = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_storage_param_vac_cost_limit = avopts ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avopts-&gt;<a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_storage_param_vac_cost_delay = avopts ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; avopts-&gt;<a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> : -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_relname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_nspname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_datname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the cost delay parameters has been set individually for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this table, disable the balancing algorithm.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tab-&gt;at_dobalance =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !(avopts &amp;&amp; (avopts-&gt;<a href="../commands/vacuum.c.html#L81" title="commands/vacuum.c:81">vacuum_cost_limit</a> &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; avopts-&gt;<a href="../commands/vacuum.c.html#L80" title="commands/vacuum.c:80">vacuum_cost_delay</a> &gt;= <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(classTup);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tab;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2844" title="postmaster/autovacuum.c:2844">recheck_relation_needs_vacanalyze</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Subroutine for <a href="#L2704" title="postmaster/autovacuum.c:2704">table_recheck_autovac</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Fetch the pgstat of a relation and recheck whether a relation<br/></li>
<li></span><span class="Comment"> * needs to be vacuumed or analyzed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2844">&#x200c;</a></span><span class="linkable">recheck_relation_needs_vacanalyze</span>(Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutoVacOpts *avopts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *dovacuum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *doanalyze,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *wraparound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PgStat_StatTabEntry *tabentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch the pgstat table entry */<br/></li>
<li></span>&nbsp; &nbsp; tabentry = <a href="../utils/activity/pgstat_relation.c.html#L466" title="utils/activity/pgstat_relation.c:466">pgstat_fetch_stat_tabentry_ext</a>(classForm-&gt;relisshared,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2905" title="postmaster/autovacuum.c:2905">relation_needs_vacanalyze</a>(relid, avopts, classForm, tabentry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; effective_multixact_freeze_max_age,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dovacuum, doanalyze, wraparound);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore ANALYZE for toast tables */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (classForm-&gt;relkind == RELKIND_TOASTVALUE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *doanalyze = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2905" title="postmaster/autovacuum.c:2905">relation_needs_vacanalyze</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check whether a relation needs to be vacuumed or analyzed; return each into<br/></li>
<li></span><span class="Comment"> * &quot;dovacuum&quot; and &quot;doanalyze&quot;, respectively.&nbsp; Also return whether the <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> is<br/></li>
<li></span><span class="Comment"> * being forced because of Xid or multixact wraparound.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * relopts is a pointer to the AutoVacOpts options (either for itself in the<br/></li>
<li></span><span class="Comment"> * case of a plain table, or for either itself or its parent table in the case<br/></li>
<li></span><span class="Comment"> * of a TOAST table), NULL if <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>; tabentry is the pgstats entry, which can be<br/></li>
<li></span><span class="Comment"> * NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A table needs to be vacuumed if the number of dead tuples exceeds a<br/></li>
<li></span><span class="Comment"> * threshold.&nbsp; This threshold is calculated as<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * threshold = vac_base_thresh + vac_scale_factor * reltuples<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>, the analysis done is that the number of tuples inserted,<br/></li>
<li></span><span class="Comment"> * deleted and updated since the last <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> exceeds a threshold calculated<br/></li>
<li></span><span class="Comment"> * in the same fashion as above.&nbsp; Note that the cumulative stats system stores<br/></li>
<li></span><span class="Comment"> * the number of tuples (both live and dead) that there were as of the last<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.&nbsp; This is asymmetric to the VACUUM case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also force <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> if the table's relfrozenxid is more than freeze_max_age<br/></li>
<li></span><span class="Comment"> * transactions back, and if its relminmxid is more than<br/></li>
<li></span><span class="Comment"> * multixact_freeze_max_age multixacts back.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A table whose autovacuum_enabled option is false is<br/></li>
<li></span><span class="Comment"> * automatically skipped (unless we have to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> it due to freeze_max_age).<br/></li>
<li></span><span class="Comment"> * Thus autovacuum can be disabled for specific tables. Also, when the cumulative<br/></li>
<li></span><span class="Comment"> * stats system does not have data about a table, it will be skipped.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A table whose vac_base_thresh value is &lt; 0 takes the base value from the<br/></li>
<li></span><span class="Comment"> * autovacuum_vacuum_threshold GUC variable.&nbsp; Similarly, a vac_scale_factor<br/></li>
<li></span><span class="Comment"> * value &lt; 0 is substituted with the value of<br/></li>
<li></span><span class="Comment"> * autovacuum_vacuum_scale_factor GUC variable.&nbsp; Ditto for <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2905">&#x200c;</a></span><span class="linkable">relation_needs_vacanalyze</span>(Oid relid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutoVacOpts *relopts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_class classForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PgStat_StatTabEntry *tabentry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> effective_multixact_freeze_max_age,<br/></li>
<li> <span class="Comment">/* output params below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *dovacuum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *doanalyze,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *wraparound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; force_vacuum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; av_enabled;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; reltuples;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* pg_class.reltuples */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* constants from reloptions or GUC variables */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac_base_thresh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac_ins_base_thresh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anl_base_thresh;<br/></li>
<li>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; vac_scale_factor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vac_ins_scale_factor,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anl_scale_factor;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* thresholds calculated from above constants */<br/></li>
<li></span>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; vacthresh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; vacinsthresh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anlthresh;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* number of <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> (resp. <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>) tuples at this time */<br/></li>
<li></span>&nbsp; &nbsp; float4&nbsp; &nbsp; &nbsp; &nbsp; vactuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; instuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anltuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* freeze parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multixact_freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; TransactionId xidForceLimit;<br/></li>
<li>&nbsp; &nbsp; MultiXactId multiForceLimit;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(classForm != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(relid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> equation parameters.&nbsp; We have two possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sources: the passed reloptions (which could be a <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table or a toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table), or the autovacuum GUC variables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* -1 in autovac setting means use plain vacuum_scale_factor */<br/></li>
<li></span>&nbsp; &nbsp; vac_scale_factor = (relopts &amp;&amp; relopts-&gt;vacuum_scale_factor &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? relopts-&gt;vacuum_scale_factor<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L121" title="postmaster/autovacuum.c:121">autovacuum_vac_scale</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vac_base_thresh = (relopts &amp;&amp; relopts-&gt;vacuum_threshold &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? relopts-&gt;vacuum_threshold<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L120" title="postmaster/autovacuum.c:120">autovacuum_vac_thresh</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vac_ins_scale_factor = (relopts &amp;&amp; relopts-&gt;vacuum_ins_scale_factor &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? relopts-&gt;vacuum_ins_scale_factor<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L123" title="postmaster/autovacuum.c:123">autovacuum_vac_ins_scale</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* -1 is used to disable insert vacuums */<br/></li>
<li></span>&nbsp; &nbsp; vac_ins_base_thresh = (relopts &amp;&amp; relopts-&gt;vacuum_ins_threshold &gt;= -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? relopts-&gt;vacuum_ins_threshold<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L122" title="postmaster/autovacuum.c:122">autovacuum_vac_ins_thresh</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; anl_scale_factor = (relopts &amp;&amp; relopts-&gt;analyze_scale_factor &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? relopts-&gt;analyze_scale_factor<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L125" title="postmaster/autovacuum.c:125">autovacuum_anl_scale</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; anl_base_thresh = (relopts &amp;&amp; relopts-&gt;analyze_threshold &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? relopts-&gt;analyze_threshold<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L124" title="postmaster/autovacuum.c:124">autovacuum_anl_thresh</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; freeze_max_age = (relopts &amp;&amp; relopts-&gt;freeze_max_age &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(relopts-&gt;freeze_max_age, <a href="#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : <a href="#L126" title="postmaster/autovacuum.c:126">autovacuum_freeze_max_age</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; multixact_freeze_max_age = (relopts &amp;&amp; relopts-&gt;multixact_freeze_max_age &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ? <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(relopts-&gt;multixact_freeze_max_age, effective_multixact_freeze_max_age)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; : effective_multixact_freeze_max_age;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; av_enabled = (relopts ? relopts-&gt;enabled : <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Force <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> if table is at risk of wraparound */<br/></li>
<li></span>&nbsp; &nbsp; xidForceLimit = <a href="#L154" title="postmaster/autovacuum.c:154">recentXid</a> - freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (xidForceLimit &lt; FirstNormalTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xidForceLimit -= FirstNormalTransactionId;<br/></li>
<li>&nbsp; &nbsp; force_vacuum = (TransactionIdIsNormal(classForm-&gt;relfrozenxid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/transam.c.html#L280" title="access/transam/transam.c:280">TransactionIdPrecedes</a>(classForm-&gt;relfrozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xidForceLimit));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!force_vacuum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; multiForceLimit = <a href="#L155" title="postmaster/autovacuum.c:155">recentMulti</a> - multixact_freeze_max_age;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (multiForceLimit &lt; FirstMultiXactId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multiForceLimit -= FirstMultiXactId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; force_vacuum = MultiXactIdIsValid(classForm-&gt;relminmxid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/multixact.c.html#L3260" title="access/transam/multixact.c:3260">MultiXactIdPrecedes</a>(classForm-&gt;relminmxid, multiForceLimit);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *wraparound = force_vacuum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* User disabled it in pg_class.reloptions?&nbsp; (But ignore if at risk) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!av_enabled &amp;&amp; !force_vacuum)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *doanalyze = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *dovacuum = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found stats for the table, and autovacuum is currently enabled,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make a threshold-based decision whether to <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> and/or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * autovacuum is currently disabled, we must be here for anti-wraparound<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vacuuming only, so don't <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> (or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>) anything that's not being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forced.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PointerIsValid(tabentry) &amp;&amp; <a href="#L3189" title="postmaster/autovacuum.c:3189">AutoVacuumingActive</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = classForm-&gt;reltuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vactuples = tabentry-&gt;dead_tuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; instuples = tabentry-&gt;ins_since_vacuum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; anltuples = tabentry-&gt;mod_since_analyze;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the table hasn't yet been vacuumed, take reltuples as zero */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reltuples &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reltuples = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacthresh = (float4) vac_base_thresh + vac_scale_factor * reltuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; vacinsthresh = (float4) vac_ins_base_thresh + vac_ins_scale_factor * reltuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; anlthresh = (float4) anl_base_thresh + anl_scale_factor * reltuples;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we don't need to take special consideration for stat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset, because if that happens, the last <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> and <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> counts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be reset too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (vac_ins_base_thresh &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: vac: </span><span class="Special">%.0f</span><span class="Constant"> (threshold </span><span class="Special">%.0f</span><span class="Constant">), ins: </span><span class="Special">%.0f</span><span class="Constant"> (threshold </span><span class="Special">%.0f</span><span class="Constant">), anl: </span><span class="Special">%.0f</span><span class="Constant"> (threshold </span><span class="Special">%.0f</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(classForm-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vactuples, vacthresh, instuples, vacinsthresh, anltuples, anlthresh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: vac: </span><span class="Special">%.0f</span><span class="Constant"> (threshold </span><span class="Special">%.0f</span><span class="Constant">), ins: (disabled), anl: </span><span class="Special">%.0f</span><span class="Constant"> (threshold </span><span class="Special">%.0f</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(classForm-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; vactuples, vacthresh, anltuples, anlthresh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Determine if this table needs <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *dovacuum = force_vacuum || (vactuples &gt; vacthresh) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (vac_ins_base_thresh &gt;= <span class="Constant">0</span> &amp;&amp; instuples &gt; vacinsthresh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *doanalyze = (anltuples &gt; anlthresh);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip a table not found in stat <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, unless we have to force <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for anti-wrap purposes.&nbsp; If it's not acted upon, there's no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a> it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; *dovacuum = force_vacuum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *doanalyze = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ANALYZE refuses to work with pg_statistic */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relid == StatisticRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *doanalyze = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3078" title="postmaster/autovacuum.c:3078">autovacuum_do_vac_analyze</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Vacuum and/or <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> the specified table<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We expect the caller to have switched into a memory context that won't<br/></li>
<li></span><span class="Comment"> * disappear at transaction commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3078">&#x200c;</a></span><span class="linkable">autovacuum_do_vac_analyze</span>(<a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *tab, BufferAccessStrategy bstrategy)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rangevar;<br/></li>
<li>&nbsp; &nbsp; VacuumRelation *rel;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rel_list;<br/></li>
<li>&nbsp; &nbsp; MemoryContext vac_context;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Let pgstat know what we're doing */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3114" title="postmaster/autovacuum.c:3114">autovac_report_activity</a>(tab);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up one VacuumRelation target, identified by OID, for <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>() */<br/></li>
<li></span>&nbsp; &nbsp; rangevar = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(tab-&gt;at_nspname, tab-&gt;at_relname, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; rel = <a href="../nodes/makefuncs.c.html#L832" title="nodes/makefuncs.c:832">makeVacuumRelation</a>(rangevar, tab-&gt;at_relid, NIL);<br/></li>
<li>&nbsp; &nbsp; rel_list = list_make1(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; vac_context = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Vacuum&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../commands/vacuum.c.html#L478" title="commands/vacuum.c:478">vacuum</a>(rel_list, &amp;tab-&gt;at_params, bstrategy, vac_context, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(vac_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3114" title="postmaster/autovacuum.c:3114">autovac_report_activity</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Report to pgstat what autovacuum is doing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a SQL string corresponding to what the user would see if the<br/></li>
<li></span><span class="Comment"> * equivalent command was to be issued manually.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note we assume that we are going to report the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command as soon as we're<br/></li>
<li></span><span class="Comment"> * done with the current one, and exit right after the last one, so we don't<br/></li>
<li></span><span class="Comment"> * bother to report &quot;&lt;IDLE&gt;&quot; or some such.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3114">&#x200c;</a></span><span class="linkable">autovac_report_activity</span>(<a href="#L196" title="postmaster/autovacuum.c:196">autovac_table</a> *tab)<br/></li>
<li>{<br/></li>
<li><a id="L3116">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_AUTOVAC_ACTIV_LEN</span> (NAMEDATALEN * </span><span class="Constant">2</span><span class="PreProc"> + </span><span class="Constant">56</span><span class="PreProc">)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activity[<a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report the command and possible options */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (tab-&gt;at_params.options &amp; VACOPT_VACUUM)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activity, <a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;autovacuum: VACUUM</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;at_params.options &amp; VACOPT_ANALYZE ? <span class="Constant">&quot; ANALYZE&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activity, <a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;autovacuum: ANALYZE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report the qualified name of the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(activity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(activity + len, <a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a> - len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>, tab-&gt;at_nspname, tab-&gt;at_relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tab-&gt;at_params.is_wraparound ? <span class="Constant">&quot; (to prevent wraparound)&quot;</span> : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() to current time for pg_stat_activity */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, activity);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3149" title="postmaster/autovacuum.c:3149">autovac_report_workitem</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Report to pgstat that autovacuum is processing a work item<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3149">&#x200c;</a></span><span class="linkable">autovac_report_workitem</span>(<a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> *workitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *nspname, <span class="Type">const</span> <span class="Type">char</span> *relname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activity[<a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a> + <span class="Constant">12</span> + <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; blk[<span class="Constant">12</span> + <span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (workitem-&gt;avw_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AVW_BRINSummarizeRange:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(activity, <a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;autovacuum: BRIN summarize&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report the qualified name of the relation, and the block number if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; len = strlen(activity);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(workitem-&gt;avw_blockNumber))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(blk, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(blk), <span class="Constant">&quot; </span><span class="Special">%u</span><span class="Constant">&quot;</span>, workitem-&gt;avw_blockNumber);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; blk[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(activity + len, <a href="#L3116" title="postmaster/autovacuum.c:3116">MAX_AUTOVAC_ACTIV_LEN</a> - len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>, nspname, relname, blk);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() to current time for pg_stat_activity */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, activity);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3189" title="postmaster/autovacuum.c:3189">AutoVacuumingActive</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check GUC <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and report whether the autovacuum process should be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; running.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3189">&#x200c;</a></span><span class="linkable">AutoVacuumingActive</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L116" title="postmaster/autovacuum.c:116">autovacuum_start_daemon</a> || !<a href="../utils/activity/pgstat.c.html#L184" title="utils/activity/pgstat.c:184">pgstat_track_counts</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Request one work item to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> autovacuum run processing our database.<br/></li>
<li></span><span class="Comment"> * Return false if the request can't be recorded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3201">&#x200c;</a></span><span class="linkable">AutoVacuumRequestWork</span>(AutoVacuumWorkItemType type, Oid relationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blkno)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(AutovacuumLock, LW_EXCLUSIVE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Locate an unused work item and fill it with the given data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L268" title="postmaster/autovacuum.c:268">NUM_WORKITEMS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a> *workitem = &amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_workItems[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (workitem-&gt;avw_used)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_used = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_active = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_type = type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_database = <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_relation = relationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; workitem-&gt;avw_blockNumber = blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* done */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(AutovacuumLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3243" title="postmaster/autovacuum.c:3243">autovac_init</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This is called at postmaster initialization.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All we do here is annoy the user if he got it wrong.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3243">&#x200c;</a></span><span class="linkable">autovac_init</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="postmaster/autovacuum.c:116">autovacuum_start_daemon</a> &amp;&amp; !<a href="../utils/activity/pgstat.c.html#L184" title="utils/activity/pgstat.c:184">pgstat_track_counts</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;autovacuum not started because of misconfiguration&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Enable the </span><span class="Special">\&quot;</span><span class="Constant">track_counts</span><span class="Special">\&quot;</span><span class="Constant"> option.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3256" title="postmaster/autovacuum.c:3256">AutoVacuumShmemSize</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Compute space needed for autovacuum-related shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L3256">&#x200c;</a><span class="linkable">AutoVacuumShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need the fixed struct and the array of <a href="#L227" title="postmaster/autovacuum.c:227">WorkerInfoData</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L297" title="postmaster/autovacuum.c:297">AutoVacuumShmemStruct</a>);<br/></li>
<li>&nbsp; &nbsp; size = MAXALIGN(size);<br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L227" title="postmaster/autovacuum.c:227">WorkerInfoData</a>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3275" title="postmaster/autovacuum.c:3275">AutoVacuumShmemInit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> autovacuum-related shared memory<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3275">&#x200c;</a></span><span class="linkable">AutoVacuumShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a> = (<a href="#L297" title="postmaster/autovacuum.c:297">AutoVacuumShmemStruct</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;AutoVacuum Data&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3256" title="postmaster/autovacuum.c:3256">AutoVacuumShmemSize</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>&nbsp; &nbsp; worker;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_launcherpid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dlist_init(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_runningWorkers);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_startingWorker = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_workItems, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L258" title="postmaster/autovacuum.c:258">AutoVacuumWorkItem</a>) * <a href="#L268" title="postmaster/autovacuum.c:268">NUM_WORKITEMS</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; worker = (<a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a>) ((<span class="Type">char</span> *) <a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L297" title="postmaster/autovacuum.c:297">AutoVacuumShmemStruct</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="#L238" title="postmaster/autovacuum.c:238">WorkerInfo</a> free list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_freeWorkers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;worker[i].wi_links);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_flag(&amp;worker[i].wi_dobalance);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;<a href="#L299" title="postmaster/autovacuum.c:299">AutoVacuumShmem</a>-&gt;av_nworkersForBalance, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(found);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="#L118" title="postmaster/autovacuum.c:118">autovacuum_work_mem</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3320">&#x200c;</a></span><span class="linkable">check_autovacuum_work_mem</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * -1 indicates fallback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we haven't yet changed the boot_val default of -1, just let it be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Autovacuum will look to <a href="../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> instead.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We clamp manually-set <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to at least 1MB.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a> is always set to at least this value, do the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &lt; <span class="Constant">1024</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> = <span class="Constant">1024</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
