<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/postmaster.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/postmaster.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L343">AbortStartTime</a></li>
<li><a href="#L228">AuthenticationTimeout</a></li>
<li><a href="#L247">AutoVacPID</a></li>
<li><a href="#L179">BackendList</a></li>
<li><a href="#L242">BgWriterPID</a></li>
<li><a href="#L243">CheckpointerPID</a></li>
<li><a href="#L350">ClientAuthInProgress</a></li>
<li><a href="#L225">EnableSSL</a></li>
<li><a href="#L271">FatalError</a></li>
<li><a href="#L366">HaveCrashedWorker</a></li>
<li><a href="#L196">ListenAddresses</a></li>
<li><a href="#L222">ListenSockets</a></li>
<li><a href="#L381">LoadedSSL</a></li>
<li><a href="#L231">Log_connections</a></li>
<li><a href="#L185">MyBgworkerEntry</a></li>
<li><a href="#L221">NumListenSockets</a></li>
<li><a href="#L248">PgArchPID</a></li>
<li><a href="#L190">PostPortNumber</a></li>
<li><a href="#L482">PostmasterHandle</a></li>
<li><a href="#L227">PreAuthDelay</a></li>
<li><a href="#L348">ReachedNormalRunning</a></li>
<li><a href="#L217">ReservedConnections</a></li>
<li><a href="#L182">ShmemBackendArray</a></li>
<li><a href="#L269">Shutdown</a></li>
<li><a href="#L250">SlotSyncWorkerPID</a></li>
<li><a href="#L365">StartWorkerNeeded</a></li>
<li><a href="#L241">StartupPID</a></li>
<li><a href="#L261">StartupStatus</a></li>
<li><a href="#L216">SuperuserReservedConnections</a></li>
<li><a href="#L249">SysLoggerPID</a></li>
<li><a href="#L193">Unix_socket_directories</a></li>
<li><a href="#L245">WalReceiverPID</a></li>
<li><a href="#L362">WalReceiverRequested</a></li>
<li><a href="#L246">WalSummarizerPID</a></li>
<li><a href="#L244">WalWriterPID</a></li>
<li><a href="#L359">avlauncher_needs_signal</a></li>
<li><a href="#L234">bonjour_name</a></li>
<li><a href="#L385">bonjour_sdref</a></li>
<li><a href="#L339">connsAllowed</a></li>
<li><a href="#L233">enable_bonjour</a></li>
<li><a href="#L230">log_hostname</a></li>
<li><a href="#L370">pending_pm_child_exit</a></li>
<li><a href="#L373">pending_pm_fast_shutdown_request</a></li>
<li><a href="#L374">pending_pm_immediate_shutdown_request</a></li>
<li><a href="#L369">pending_pm_pmsignal</a></li>
<li><a href="#L371">pending_pm_reload_request</a></li>
<li><a href="#L372">pending_pm_shutdown_request</a></li>
<li><a href="#L331">pmState</a></li>
<li><a href="#L377">pm_wait_set</a></li>
<li><a href="#L479">postmaster_alive_fds</a></li>
<li><a href="#L353">redirection_done</a></li>
<li><a href="#L236">remove_temp_files_after_crash</a></li>
<li><a href="#L235">restart_after_crash</a></li>
<li><a href="#L237">send_abort_for_crash</a></li>
<li><a href="#L238">send_abort_for_kill</a></li>
<li><a href="#L356">start_autovac_launcher</a></li>
<li><a href="#L455">win32ChildQueue</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L177">Backend</a></li>
<li><a href="#L329">PMState</a></li>
<li><a href="#L259">StartupStatusEnum</a></li>
<li><a href="#L168">bkend</a></li>
<li><a href="#L462">win32_deadchild_waitinfo</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L3544">BackendStartup</a></li>
<li><a href="#L4223">BackgroundWorkerBlockSignals</a></li>
<li><a href="#L4155">BackgroundWorkerInitializeConnection</a></li>
<li><a href="#L4189">BackgroundWorkerInitializeConnectionByOid</a></li>
<li><a href="#L4229">BackgroundWorkerUnblockSignals</a></li>
<li><a href="#L2790">CleanupBackend</a></li>
<li><a href="#L2695">CleanupBackgroundWorker</a></li>
<li><a href="#L1955">ClosePostmasterPorts</a></li>
<li><a href="#L1387">CloseServerPorts</a></li>
<li><a href="#L1601">ConfigurePostmasterWaitSet</a></li>
<li><a href="#L3878">CountChildren</a></li>
<li><a href="#L4101">CreateOptsFile</a></li>
<li><a href="#L1516">DetermineSleepTime</a></li>
<li><a href="#L3668">ExitPostmaster</a></li>
<li><a href="#L2874">HandleChildCrash</a></li>
<li><a href="#L4703">InitPostmasterDeathWatchHandle</a></li>
<li><a href="#L2032">InitProcessGlobals</a></li>
<li><a href="#L3061">LogChildExit</a></li>
<li><a href="#L4145">MaxLivePostmasterChildren</a></li>
<li><a href="#L4089">MaybeStartSlotSyncWorker</a></li>
<li><a href="#L4051">MaybeStartWalReceiver</a></li>
<li><a href="#L4070">MaybeStartWalSummarizer</a></li>
<li><a href="#L489">PostmasterMain</a></li>
<li><a href="#L4528">PostmasterMarkPIDForWorkerNotify</a></li>
<li><a href="#L3127">PostmasterStateMachine</a></li>
<li><a href="#L3868">RandomCancelKey</a></li>
<li><a href="#L1624">ServerLoop</a></li>
<li><a href="#L4564">ShmemBackendArrayAdd</a></li>
<li><a href="#L4554">ShmemBackendArrayAllocation</a></li>
<li><a href="#L4574">ShmemBackendArrayRemove</a></li>
<li><a href="#L4548">ShmemBackendArraySize</a></li>
<li><a href="#L3465">SignalSomeChildren</a></li>
<li><a href="#L3960">StartAutovacuumWorker</a></li>
<li><a href="#L3924">StartChildProcess</a></li>
<li><a href="#L3509">TerminateChildren</a></li>
<li><a href="#L4345">assign_backendlist_entry</a></li>
<li><a href="#L4303">bgworker_should_start_now</a></li>
<li><a href="#L1895">canAcceptConnections</a></li>
<li><a href="#L1487">checkControlFile</a></li>
<li><a href="#L4244">do_start_bgworker</a></li>
<li><a href="#L3860">dummy_handler</a></li>
<li><a href="#L1433">getInstallationPaths</a></li>
<li><a href="#L2343">handle_pm_child_exit_signal</a></li>
<li><a href="#L2075">handle_pm_pmsignal_signal</a></li>
<li><a href="#L2085">handle_pm_reload_request_signal</a></li>
<li><a href="#L2168">handle_pm_shutdown_request_signal</a></li>
<li><a href="#L4409">maybe_start_bgworkers</a></li>
<li><a href="#L4646">pgwin32_deadchild_callback</a></li>
<li><a href="#L4675">pgwin32_register_deadchild_callback</a></li>
<li><a href="#L1835">processCancelRequest</a></li>
<li><a href="#L2353">process_pm_child_exit</a></li>
<li><a href="#L3702">process_pm_pmsignal</a></li>
<li><a href="#L2095">process_pm_reload_request</a></li>
<li><a href="#L2192">process_pm_shutdown_request</a></li>
<li><a href="#L3641">report_fork_failure_to_client</a></li>
<li><a href="#L3421">signal_child</a></li>
<li><a href="#L3451">sigquit_child</a></li>
<li><a href="#L1421">unlink_external_pid_file</a></li>
<li><a href="#L4592">waitpid</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L140">BACKEND_TYPE_ALL</a></li>
<li><a href="#L137">BACKEND_TYPE_AUTOVAC</a></li>
<li><a href="#L139">BACKEND_TYPE_BGWORKER</a></li>
<li><a href="#L136">BACKEND_TYPE_NORMAL</a></li>
<li><a href="#L138">BACKEND_TYPE_WALSND</a></li>
<li><a href="#L470">EXIT_STATUS_0</a></li>
<li><a href="#L471">EXIT_STATUS_1</a></li>
<li><a href="#L472">EXIT_STATUS_3</a></li>
<li><a href="#L266">FastShutdown</a></li>
<li><a href="#L267">ImmediateShutdown</a></li>
<li><a href="#L220">MAXLISTEN</a></li>
<li><a href="#L4411">MAX_BGWORKERS_TO_LAUNCH</a></li>
<li><a href="#L264">NoShutdown</a></li>
<li><a href="#L4106">OPTS_FILE</a></li>
<li><a href="#L441">PgArchStartupAllowed</a></li>
<li><a href="#L346">SIGKILL_CHILDREN_AFTER_SECS</a></li>
<li><a href="#L422">SignalChildren</a></li>
<li><a href="#L265">SmartShutdown</a></li>
<li><a href="#L450">WNOHANG</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * postmaster.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This program acts as a clearing house for requests to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES system.&nbsp; Frontend programs <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the Postmaster,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and postmaster forks a new backend process to handle the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; connection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The postmaster also manages system-wide operations such as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; startup and shutdown. The postmaster itself doesn't do those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; operations, mind you --- it just forks off a subprocess to do them<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; at the right times.&nbsp; It also takes care of resetting the system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; if a backend crashes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The postmaster process creates the shared memory and semaphore<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; pools during startup, but as a rule does not touch them itself.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; In particular, it is not a member of the PGPROC array of backends<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and so it cannot participate in lock-manager operations.&nbsp; Keeping<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; the postmaster away from shared memory operations makes it simpler<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; and more reliable.&nbsp; The postmaster is almost always able to recover<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; from crashes of individual backends by resetting shared memory;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; if it did much with shared memory then it would be prone to crashing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; along with the backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; When a request message is received, we <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fork() immediately.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; The child process performs authentication of the request, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; then becomes a backend if successful.&nbsp; This allows the auth code<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; to be written in a simple single-threaded style (as opposed to the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; crufty &quot;poor man's multitasking&quot; code that used to be needed).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; More importantly, it ensures that blockages in non-multithreaded<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; libraries like SSL or PAM cannot cause denial of service to other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; clients.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/postmaster.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialization:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The Postmaster sets up shared memory data structures<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for the backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Synchronization:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The Postmaster shares memory with the backends but should avoid<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; touching shared memory, so as not to become stuck if a crashing<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; backend screws up locks or shared memory.&nbsp; Likewise, the Postmaster<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; should never block on messages from frontend clients.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Garbage Collection:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The Postmaster cleans up after backends if they have an emergency<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; exit and/or core <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Error Reporting:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Use <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>() only for reporting &quot;interactive&quot; errors<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (essentially, bogus arguments on the command line).&nbsp; Once the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; postmaster is launched, use ereport().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/wait.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/param.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;netdb.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_BONJOUR<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;dns_sd.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;systemd/sd-daemon.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef HAVE_PTHREAD_IS_THREADED_NP<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;pthread.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogrecovery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_perm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/file_utils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/ip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/ilist.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_getopt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bswap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/auxprocess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/bgworker_internals.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/pgarch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/syslogger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/walsummarizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slotsync.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/backend_startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/datetime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pidfile.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/varlena.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Possible types of a backend. Beyond being the possible bkend_type <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in<br/></li>
<li></span><span class="Comment"> * struct <a href="#L168" title="postmaster/postmaster.c:168">bkend</a>, these are OR-able request flag bits for <a href="#L3465" title="postmaster/postmaster.c:3465">SignalSomeChildren</a>()<br/></li>
<li></span><span class="Comment"> * and <a href="#L3878" title="postmaster/postmaster.c:3878">CountChildren</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BACKEND_TYPE_NORMAL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0001</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* normal backend */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BACKEND_TYPE_AUTOVAC</span>&nbsp; &nbsp; </span><span class="Constant">0x0002</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* autovacuum worker process */<br/></li>
<li><a id="L138">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BACKEND_TYPE_WALSND</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x0004</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* walsender process */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BACKEND_TYPE_BGWORKER</span>&nbsp; &nbsp; </span><span class="Constant">0x0008</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* bgworker process */<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BACKEND_TYPE_ALL</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0x000F</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* OR of all the above */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * List of active backends (or child processes anyway; we don't actually<br/></li>
<li></span><span class="Comment"> * know whether a given child has become a backend or is still in the<br/></li>
<li></span><span class="Comment"> * authorization phase).&nbsp; This is used mainly to keep track of how many<br/></li>
<li></span><span class="Comment"> * children we have and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> them appropriate signals when necessary.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As shown in the above set of backend types, this list includes not only<br/></li>
<li></span><span class="Comment"> * &quot;normal&quot; client sessions, but also autovacuum workers, walsenders, and<br/></li>
<li></span><span class="Comment"> * background workers.&nbsp; (Note that at the time of launch, walsenders are<br/></li>
<li></span><span class="Comment"> * labeled <a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a>; we relabel them to <a href="#L138" title="postmaster/postmaster.c:138">BACKEND_TYPE_WALSND</a><br/></li>
<li></span><span class="Comment"> * upon noticing they've changed their PMChildFlags entry.&nbsp; Hence that check<br/></li>
<li></span><span class="Comment"> * must be done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> operation that needs to distinguish walsenders<br/></li>
<li></span><span class="Comment"> * from normal backends.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also, &quot;dead_end&quot; children are in it: these are children launched just for<br/></li>
<li></span><span class="Comment"> * the purpose of sending a friendly rejection message to a would-be client.<br/></li>
<li></span><span class="Comment"> * We must track them because they are attached to shared memory, but we know<br/></li>
<li></span><span class="Comment"> * they will never become live backends.&nbsp; dead_end children are not assigned a<br/></li>
<li></span><span class="Comment"> * PMChildSlot.&nbsp; dead_end children have bkend_type NORMAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;Special&quot; children such as the startup, bgwriter, autovacuum launcher, and<br/></li>
<li></span><span class="Comment"> * slot sync worker tasks are not in this list.&nbsp; They are tracked via <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a><br/></li>
<li></span><span class="Comment"> * and other pid_t variables below.&nbsp; (Thus, there can't be more than one of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * given &quot;special&quot; child process type.&nbsp; We use <a href="#L179" title="postmaster/postmaster.c:179">BackendList</a> entries for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * child process there can be more than one of.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">bkend</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process id of backend */<br/></li>
<li></span>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cancel_key;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cancel key for cancels for this backend */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child_slot;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PMChildSlot for this backend, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bkend_type;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* child process flavor, see above */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dead_end;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* is it going to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an error and quit? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; bgworker_notify;&nbsp; &nbsp; <span class="Comment">/* gets bgworker start/stop notifications */<br/></li>
<li></span>&nbsp; &nbsp; dlist_node&nbsp; &nbsp; elem;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* list link in <a href="#L179" title="postmaster/postmaster.c:179">BackendList</a> */<br/></li>
<li><a id="L177">&#x200c;</a></span>} <span class="linkable">Backend</span>;<br/></li>
<li><br/></li>
<li><a id="L179">&#x200c;</a><span class="Type">static</span> dlist_head <span class="linkable">BackendList</span> = DLIST_STATIC_INIT(<span class="linkable">BackendList</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li><a id="L182">&#x200c;</a></span><a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *<span class="linkable">ShmemBackendArray</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><a id="L185">&#x200c;</a>BackgroundWorker *<span class="linkable">MyBgworkerEntry</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* The <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> number we are listening for connections on */<br/></li>
<li><a id="L190">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PostPortNumber</span> = DEF_PGPORT;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The directory names for Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(s) */<br/></li>
<li><a id="L193">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">Unix_socket_directories</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The TCP <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> address(es) */<br/></li>
<li><a id="L196">&#x200c;</a></span><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">ListenAddresses</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a> is the number of backends reserved for<br/></li>
<li></span><span class="Comment"> * <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> use, and <a href="#L217" title="postmaster/postmaster.c:217">ReservedConnections</a> is the number of backends reserved<br/></li>
<li></span><span class="Comment"> * for use by roles with privileges of the pg_use_reserved_connections<br/></li>
<li></span><span class="Comment"> * predefined role.&nbsp; These are taken out of the pool of <a href="../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> backend<br/></li>
<li></span><span class="Comment"> * slots, so the number of backend slots available for roles that are neither<br/></li>
<li></span><span class="Comment"> * <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> nor have privileges of pg_use_reserved_connections is<br/></li>
<li></span><span class="Comment"> * (<a href="../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> - <a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a> - <a href="#L217" title="postmaster/postmaster.c:217">ReservedConnections</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the number of remaining slots is less than or <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment"> * <a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a>, only superusers can make new connections.&nbsp; If<br/></li>
<li></span><span class="Comment"> * the number of remaining slots is greater than <a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a><br/></li>
<li></span><span class="Comment"> * but less than or <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment"> * (<a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a> + <a href="#L217" title="postmaster/postmaster.c:217">ReservedConnections</a>), only superusers and<br/></li>
<li></span><span class="Comment"> * roles with privileges of pg_use_reserved_connections can make new<br/></li>
<li></span><span class="Comment"> * connections.&nbsp; Note that pre-existing <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> and<br/></li>
<li></span><span class="Comment"> * pg_use_reserved_connections connections don't count against the limits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L216">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SuperuserReservedConnections</span>;<br/></li>
<li><a id="L217">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ReservedConnections</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* The <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(s) we're listening to. */<br/></li>
<li><a id="L220">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAXLISTEN</span>&nbsp; &nbsp; </span><span class="Constant">64<br/></li>
<li><a id="L221">&#x200c;</a></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">NumListenSockets</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L222">&#x200c;</a><span class="Type">static</span> pgsocket *<span class="linkable">ListenSockets</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* still more option variables */<br/></li>
<li><a id="L225">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">EnableSSL</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L227">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PreAuthDelay</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L228">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">AuthenticationTimeout</span> = <span class="Constant">60</span>;<br/></li>
<li><br/></li>
<li><a id="L230">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">log_hostname</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for ps display and logging */<br/></li>
<li><a id="L231">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_connections</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L233">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">enable_bonjour</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L234">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">bonjour_name</span>;<br/></li>
<li><a id="L235">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">restart_after_crash</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L236">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">remove_temp_files_after_crash</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L237">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">send_abort_for_crash</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L238">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">send_abort_for_kill</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* PIDs of special child processes; 0 when not running */<br/></li>
<li><a id="L241">&#x200c;</a></span><span class="Type">static</span> pid_t <span class="linkable">StartupPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L242">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">BgWriterPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L243">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">CheckpointerPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L244">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">WalWriterPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L245">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">WalReceiverPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L246">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">WalSummarizerPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L247">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">AutoVacPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L248">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PgArchPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L249">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SysLoggerPID</span> = <span class="Constant">0</span>,<br/></li>
<li><a id="L250">&#x200c;</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SlotSyncWorkerPID</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Startup process's status */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; STARTUP_NOT_RUNNING,<br/></li>
<li>&nbsp; &nbsp; STARTUP_RUNNING,<br/></li>
<li>&nbsp; &nbsp; STARTUP_SIGNALED,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we sent it a SIGQUIT or SIGKILL */<br/></li>
<li></span>&nbsp; &nbsp; STARTUP_CRASHED,<br/></li>
<li><a id="L259">&#x200c;</a>} <span class="linkable">StartupStatusEnum</span>;<br/></li>
<li><br/></li>
<li><a id="L261">&#x200c;</a><span class="Type">static</span> <a href="#L259" title="postmaster/postmaster.c:259">StartupStatusEnum</a> <span class="linkable">StartupStatus</span> = STARTUP_NOT_RUNNING;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Startup/shutdown state */<br/></li>
<li><a id="L264">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">NoShutdown</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">0<br/></li>
<li><a id="L265">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">SmartShutdown</span>&nbsp; &nbsp; </span><span class="Constant">1<br/></li>
<li><a id="L266">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">FastShutdown</span>&nbsp; &nbsp; </span><span class="Constant">2<br/></li>
<li><a id="L267">&#x200c;</a></span><span class="PreProc">#define&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ImmediateShutdown</span>&nbsp; &nbsp; </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><a id="L269">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">Shutdown</span> = <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a>;<br/></li>
<li><br/></li>
<li><a id="L271">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">FatalError</span> = <span class="Constant">false</span>; <span class="Comment">/* T if recovering from backend crash */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We use a simple state machine to control startup, shutdown, and<br/></li>
<li></span><span class="Comment"> * crash recovery (which is rather like shutdown followed by startup).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After doing all the postmaster initialization work, we enter PM_STARTUP<br/></li>
<li></span><span class="Comment"> * state and the startup process is launched. The startup process begins by<br/></li>
<li></span><span class="Comment"> * reading the control file and other preliminary initialization steps.<br/></li>
<li></span><span class="Comment"> * In a normal startup, or after crash recovery, the startup process exits<br/></li>
<li></span><span class="Comment"> * with exit code 0 and we switch to PM_RUN state.&nbsp; However, archive recovery<br/></li>
<li></span><span class="Comment"> * is handled specially since it takes much longer and we would like to support<br/></li>
<li></span><span class="Comment"> * hot standby during archive recovery.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When the startup process is ready to start archive recovery, it signals the<br/></li>
<li></span><span class="Comment"> * postmaster, and we switch to PM_RECOVERY state. The background writer and<br/></li>
<li></span><span class="Comment"> * checkpointer are launched, while the startup process continues applying WAL.<br/></li>
<li></span><span class="Comment"> * If Hot Standby is enabled, then, after reaching a consistent point in WAL<br/></li>
<li></span><span class="Comment"> * redo, startup process signals us again, and we switch to PM_HOT_STANDBY<br/></li>
<li></span><span class="Comment"> * state and begin accepting connections to perform read-only queries.&nbsp; When<br/></li>
<li></span><span class="Comment"> * archive recovery is finished, the startup process exits with exit code 0<br/></li>
<li></span><span class="Comment"> * and we switch to PM_RUN state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Normal child backends can only be launched when we are in PM_RUN or<br/></li>
<li></span><span class="Comment"> * PM_HOT_STANDBY state.&nbsp; (<a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a> can also restrict launching.)<br/></li>
<li></span><span class="Comment"> * In other states we handle connection requests by launching &quot;dead_end&quot;<br/></li>
<li></span><span class="Comment"> * child processes, which will simply <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the client an error message and<br/></li>
<li></span><span class="Comment"> * quit.&nbsp; (We track these in the <a href="#L179" title="postmaster/postmaster.c:179">BackendList</a> so that we can know when they<br/></li>
<li></span><span class="Comment"> * are all gone; this is important because they're still connected to shared<br/></li>
<li></span><span class="Comment"> * memory, and would interfere with an attempt to destroy the shmem segment,<br/></li>
<li></span><span class="Comment"> * possibly leading to SHMALL failure when we try to make a new one.)<br/></li>
<li></span><span class="Comment"> * In PM_WAIT_DEAD_END state we are <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for all the dead_end children<br/></li>
<li></span><span class="Comment"> * to <a href="../storage/ipc/latch.c.html#L2292" title="storage/ipc/latch.c:2292">drain</a> out of the system, and therefore stop accepting connection<br/></li>
<li></span><span class="Comment"> * requests at all until the last existing child has quit (which hopefully<br/></li>
<li></span><span class="Comment"> * will not be very long).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notice that this state variable does not distinguish *why* we entered<br/></li>
<li></span><span class="Comment"> * states later than PM_RUN --- <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> and <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> must be consulted<br/></li>
<li></span><span class="Comment"> * to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that out.&nbsp; <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> is never true in PM_RECOVERY, PM_HOT_STANDBY,<br/></li>
<li></span><span class="Comment"> * or PM_RUN states, nor in PM_SHUTDOWN states (because we don't enter those<br/></li>
<li></span><span class="Comment"> * states when trying to recover from a crash).&nbsp; It can be true in PM_STARTUP<br/></li>
<li></span><span class="Comment"> * state, because we don't clear it until we've successfully started WAL redo.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">enum<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; PM_INIT,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* postmaster starting */<br/></li>
<li></span>&nbsp; &nbsp; PM_STARTUP,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for startup subprocess */<br/></li>
<li></span>&nbsp; &nbsp; PM_RECOVERY,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in archive recovery mode */<br/></li>
<li></span>&nbsp; &nbsp; PM_HOT_STANDBY,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in hot standby mode */<br/></li>
<li></span>&nbsp; &nbsp; PM_RUN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal &quot;database is alive&quot; state */<br/></li>
<li></span>&nbsp; &nbsp; PM_STOP_BACKENDS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* need to stop remaining backends */<br/></li>
<li></span>&nbsp; &nbsp; PM_WAIT_BACKENDS,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for live backends to exit */<br/></li>
<li></span>&nbsp; &nbsp; PM_SHUTDOWN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for checkpointer to do shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ckpt */<br/></li>
<li></span>&nbsp; &nbsp; PM_SHUTDOWN_2,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for archiver and walsenders to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finish */<br/></li>
<li></span>&nbsp; &nbsp; PM_WAIT_DEAD_END,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for dead_end children to exit */<br/></li>
<li></span>&nbsp; &nbsp; PM_NO_CHILDREN,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all important children have exited */<br/></li>
<li><a id="L329">&#x200c;</a></span>} <span class="linkable">PMState</span>;<br/></li>
<li><br/></li>
<li><a id="L331">&#x200c;</a><span class="Type">static</span> <a href="#L329" title="postmaster/postmaster.c:329">PMState</a> <span class="linkable">pmState</span> = PM_INIT;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * While performing a &quot;smart shutdown&quot;, we restrict new connections but stay<br/></li>
<li></span><span class="Comment"> * in PM_RUN or PM_HOT_STANDBY state until all the client backends are gone.<br/></li>
<li></span><span class="Comment"> * <a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a> is a sub-state indicator showing the active restriction.<br/></li>
<li></span><span class="Comment"> * It is of no interest unless <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> is PM_RUN or PM_HOT_STANDBY.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L339">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">connsAllowed</span> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Start time of SIGKILL timeout during immediate shutdown or child crash */<br/></li>
<li></span><span class="Comment">/* Zero means timeout is not running */<br/></li>
<li><a id="L343">&#x200c;</a></span><span class="Type">static</span> <span class="Type">time_t</span> <span class="linkable">AbortStartTime</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Length of said timeout */<br/></li>
<li><a id="L346">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIGKILL_CHILDREN_AFTER_SECS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">5<br/></li>
<li></span><br/></li>
<li><a id="L348">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">ReachedNormalRunning</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* T if we've reached PM_RUN */<br/></li>
<li></span><br/></li>
<li><a id="L350">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ClientAuthInProgress</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* T during new-client<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * authentication */<br/></li>
<li></span><br/></li>
<li><a id="L353">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">redirection_done</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* stderr redirected for syslogger? */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* received START_AUTOVAC_LAUNCHER signal */<br/></li>
<li><a id="L356">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">start_autovac_launcher</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* the launcher needs to be signaled to communicate some condition */<br/></li>
<li><a id="L359">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">avlauncher_needs_signal</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* received START_WALRECEIVER signal */<br/></li>
<li><a id="L362">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">WalReceiverRequested</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* set when there's a worker that needs to be started up */<br/></li>
<li><a id="L365">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">StartWorkerNeeded</span> = <span class="Constant">true</span>;<br/></li>
<li><a id="L366">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">HaveCrashedWorker</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* set when signals arrive */<br/></li>
<li><a id="L369">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">pending_pm_pmsignal</span>;<br/></li>
<li><a id="L370">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">pending_pm_child_exit</span>;<br/></li>
<li><a id="L371">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">pending_pm_reload_request</span>;<br/></li>
<li><a id="L372">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">pending_pm_shutdown_request</span>;<br/></li>
<li><a id="L373">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">pending_pm_fast_shutdown_request</span>;<br/></li>
<li><a id="L374">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">pending_pm_immediate_shutdown_request</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* event multiplexing object */<br/></li>
<li><a id="L377">&#x200c;</a></span><span class="Type">static</span> <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *<span class="linkable">pm_wait_set</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span><span class="Comment">/* Set when and if SSL has been initialized properly */<br/></li>
<li><a id="L381">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">LoadedSSL</span> = <span class="Constant">false</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_BONJOUR<br/></li>
<li><a id="L385">&#x200c;</a></span><span class="Type">static</span> DNSServiceRef <span class="linkable">bonjour_sdref</span> = <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * postmaster.c - function prototypes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1387" title="postmaster/postmaster.c:1387">CloseServerPorts</a>(<span class="Type">int</span> status, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1421" title="postmaster/postmaster.c:1421">unlink_external_pid_file</a>(<span class="Type">int</span> status, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1433" title="postmaster/postmaster.c:1433">getInstallationPaths</a>(<span class="Type">const</span> <span class="Type">char</span> *argv0);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1487" title="postmaster/postmaster.c:1487">checkControlFile</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2075" title="postmaster/postmaster.c:2075">handle_pm_pmsignal_signal</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2343" title="postmaster/postmaster.c:2343">handle_pm_child_exit_signal</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2085" title="postmaster/postmaster.c:2085">handle_pm_reload_request_signal</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2168" title="postmaster/postmaster.c:2168">handle_pm_shutdown_request_signal</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3702" title="postmaster/postmaster.c:3702">process_pm_pmsignal</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2353" title="postmaster/postmaster.c:2353">process_pm_child_exit</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2095" title="postmaster/postmaster.c:2095">process_pm_reload_request</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2192" title="postmaster/postmaster.c:2192">process_pm_shutdown_request</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3860" title="postmaster/postmaster.c:3860">dummy_handler</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2790" title="postmaster/postmaster.c:2790">CleanupBackend</a>(<span class="Type">int</span> pid, <span class="Type">int</span> exitstatus);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2695" title="postmaster/postmaster.c:2695">CleanupBackgroundWorker</a>(<span class="Type">int</span> pid, <span class="Type">int</span> exitstatus);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(<span class="Type">int</span> pid, <span class="Type">int</span> exitstatus, <span class="Type">const</span> <span class="Type">char</span> *procname);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(<span class="Type">int</span> lev, <span class="Type">const</span> <span class="Type">char</span> *procname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> pid, <span class="Type">int</span> exitstatus);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Type">int</span> status) pg_attribute_noreturn();<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3544" title="postmaster/postmaster.c:3544">BackendStartup</a>(ClientSocket *client_sock);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3641" title="postmaster/postmaster.c:3641">report_fork_failure_to_client</a>(ClientSocket *client_sock, <span class="Type">int</span> errnum);<br/></li>
<li><span class="Type">static</span> CAC_state <a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a>(<span class="Type">int</span> backend_type);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3868" title="postmaster/postmaster.c:3868">RandomCancelKey</a>(int32 *cancel_key);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(pid_t pid, <span class="Type">int</span> signal);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(pid_t pid);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3465" title="postmaster/postmaster.c:3465">SignalSomeChildren</a>(<span class="Type">int</span> signal, <span class="Type">int</span> target);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3509" title="postmaster/postmaster.c:3509">TerminateChildren</a>(<span class="Type">int</span> signal);<br/></li>
<li><br/></li>
<li><a id="L422">&#x200c;</a><span class="PreProc">#define <span class="linkable">SignalChildren</span>(sig)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3465" title="postmaster/postmaster.c:3465">SignalSomeChildren</a>(sig, <a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a>)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L3878" title="postmaster/postmaster.c:3878">CountChildren</a>(<span class="Type">int</span> target);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4345" title="postmaster/postmaster.c:4345">assign_backendlist_entry</a>(RegisteredBgWorker *rw);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4409" title="postmaster/postmaster.c:4409">maybe_start_bgworkers</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4101" title="postmaster/postmaster.c:4101">CreateOptsFile</a>(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[], <span class="Type">char</span> *fullprogname);<br/></li>
<li><span class="Type">static</span> pid_t <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(BackendType type);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3960" title="postmaster/postmaster.c:3960">StartAutovacuumWorker</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4051" title="postmaster/postmaster.c:4051">MaybeStartWalReceiver</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4070" title="postmaster/postmaster.c:4070">MaybeStartWalSummarizer</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4703" title="postmaster/postmaster.c:4703">InitPostmasterDeathWatchHandle</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4089" title="postmaster/postmaster.c:4089">MaybeStartSlotSyncWorker</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Archiver is allowed to start up at the current postmaster state?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If WAL archiving is enabled always, we are allowed to start archiver<br/></li>
<li></span><span class="Comment"> * even during recovery.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L441">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PgArchStartupAllowed</span>()&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((XLogArchivingActive() &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN) ||&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; (XLogArchivingAlways() &amp;&amp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY))) &amp;&amp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="pgarch.c.html#L197" title="postmaster/pgarch.c:197">PgArchCanRestart</a>())<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li><a id="L450">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">WNOHANG</span> </span><span class="Constant">0</span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ignored, so <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> integer value will do */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> pid_t <a href="#L4592" title="postmaster/postmaster.c:4592">waitpid</a>(pid_t pid, <span class="Type">int</span> *exitstatus, <span class="Type">int</span> options);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> WINAPI <a href="#L4646" title="postmaster/postmaster.c:4646">pgwin32_deadchild_callback</a>(PVOID lpParameter, BOOLEAN TimerOrWaitFired);<br/></li>
<li><br/></li>
<li><a id="L455">&#x200c;</a><span class="Type">static</span> HANDLE <span class="linkable">win32ChildQueue</span>;<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; waitHandle;<br/></li>
<li>&nbsp; &nbsp; HANDLE&nbsp; &nbsp; &nbsp; &nbsp; procHandle;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; procId;<br/></li>
<li><a id="L462">&#x200c;</a>} <span class="linkable">win32_deadchild_waitinfo</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4564" title="postmaster/postmaster.c:4564">ShmemBackendArrayAdd</a>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *bn);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4574" title="postmaster/postmaster.c:4574">ShmemBackendArrayRemove</a>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *bn);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXEC_BACKEND */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Macros to check exit status of a child process */<br/></li>
<li><a id="L470">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXIT_STATUS_0</span>(st)&nbsp; ((st) == </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li><a id="L471">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXIT_STATUS_1</span>(st)&nbsp; (WIFEXITED(st) &amp;&amp; WEXITSTATUS(st) == </span><span class="Constant">1</span><span class="PreProc">)<br/></li>
<li><a id="L472">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EXIT_STATUS_3</span>(st)&nbsp; (WIFEXITED(st) &amp;&amp; WEXITSTATUS(st) == </span><span class="Constant">3</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * File descriptors for pipe used to monitor if postmaster is alive.<br/></li>
<li></span><span class="Comment"> * First is POSTMASTER_FD_WATCH, second is POSTMASTER_FD_OWN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L479">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">postmaster_alive_fds</span>[<span class="Constant">2</span>] = {-<span class="Constant">1</span>, -<span class="Constant">1</span>};<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><span class="Comment">/* Process handle of postmaster used for the same purpose on Windows */<br/></li>
<li><a id="L482">&#x200c;</a></span>HANDLE&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PostmasterHandle</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Postmaster <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> entry point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L489">&#x200c;</a></span><span class="linkable">PostmasterMain</span>(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[])<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../tcop/postgres.c.html#L161" title="tcop/postgres.c:161">userDoption</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; listen_addr_saved = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *output_config_variable = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2032" title="postmaster/postmaster.c:2032">InitProcessGlobals</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L103" title="utils/init/globals.c:103">PostmasterPid</a> = <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L116" title="utils/init/globals.c:116">IsPostmasterEnvironment</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start our win32 signal implementation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="../port/win32/signal.c.html#L79" title="port/win32/signal.c:79">pgwin32_signal_initialize</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should not be creating <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> files or directories <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we check the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data directory (see <a href="../utils/init/miscinit.c.html#L341" title="utils/init/miscinit.c:341">checkDataDir</a>()), but just in case set the umask to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the most restrictive (owner-only) permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/miscinit.c.html#L341" title="utils/init/miscinit.c:341">checkDataDir</a>() will reset the umask based on the data directory<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; umask(PG_MODE_MASK_OWNER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * By default, <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() requests in the postmaster will be allocated in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>, which is space that can be recycled by backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocated data that needs to be available to backends should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocated in <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Postmaster&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize paths to installation files */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1433" title="postmaster/postmaster.c:1433">getInstallationPaths</a>(argv[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up signal handlers for the postmaster process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CAUTION: when changing this list, check for side-effects on the signal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handling setup of child processes.&nbsp; See tcop/postgres.c,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bootstrap/bootstrap.c, postmaster/bgwriter.c, postmaster/walwriter.c,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster/autovacuum.c, postmaster/pgarch.c, postmaster/syslogger.c,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster/bgworker.c and postmaster/checkpointer.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqsignal.c.html#L41" title="libpq/pqsignal.c:41">pqinitmask</a>();<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="#L2085" title="postmaster/postmaster.c:2085">handle_pm_reload_request_signal</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="#L2168" title="postmaster/postmaster.c:2168">handle_pm_shutdown_request_signal</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGQUIT</span>, <a href="#L2168" title="postmaster/postmaster.c:2168">handle_pm_shutdown_request_signal</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="#L2168" title="postmaster/postmaster.c:2168">handle_pm_shutdown_request_signal</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* ignored */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* ignored */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="#L2075" title="postmaster/postmaster.c:2075">handle_pm_pmsignal_signal</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <a href="#L3860" title="postmaster/postmaster.c:3860">dummy_handler</a>);&nbsp; &nbsp; <span class="Comment">/* unused, reserve for children */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <a href="#L2343" title="postmaster/postmaster.c:2343">handle_pm_child_exit_signal</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This may configure SIGURG, depending on platform. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L232" title="storage/ipc/latch.c:232">InitializeLatchSupport</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L241" title="utils/init/miscinit.c:241">InitProcessLocalLatch</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No other place in Postgres should touch SIGTTIN/SIGTTOU handling.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ignore those signals in a postmaster environment, so that there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risk of a child process freezing up due to writing to stderr.&nbsp; But for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a standalone backend, their default handling is reasonable.&nbsp; Hence, all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * child processes should just allow the inherited settings to stand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef SIGTTIN<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTTIN</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* ignored */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#ifdef SIGTTOU<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTTOU</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* ignored */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore SIGXFSZ, so that ulimit violations work like disk full */<br/></li>
<li></span><span class="PreProc">#ifdef SIGXFSZ<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGXFSZ</span>, <span class="Constant">SIG_IGN</span>); <span class="Comment">/* ignored */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin accepting signals. */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Options setup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L1532" title="utils/misc/guc.c:1532">InitializeGUCOptions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opterr = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse command-line options.&nbsp; CAUTION: keep this in sync with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tcop/postgres.c (the option sets should not conflict) and with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * common <a href="../main/main.c.html#L320" title="main/main.c:320">help</a>() function in <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>/<a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((opt = getopt(argc, argv, <span class="Constant">&quot;B:bC:c:D:d:EeFf:h:ijk:lN:OPp:r:S:sTt:W:-:&quot;</span>)) != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (opt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'B'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;shared_buffers&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Undocumented flag used for binary upgrades */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'C'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; output_config_variable = strdup(optarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'-'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L6321" title="utils/misc/guc.c:6321">ParseLongOption</a>(optarg, &amp;name, &amp;value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opt == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;--</span><span class="Special">%s</span><span class="Constant"> requires a value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optarg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;-c </span><span class="Special">%s</span><span class="Constant"> requires a value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optarg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(name, value, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'D'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L161" title="tcop/postgres.c:161">userDoption</a> = strdup(optarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'d'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3679" title="tcop/postgres.c:3679">set_debug_options</a>(atoi(optarg), PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'E'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../tcop/postgres.c.html#L95" title="tcop/postgres.c:95">log_statement</a>&quot;</span>, <span class="Constant">&quot;all&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'e'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;datestyle&quot;</span>, <span class="Constant">&quot;euro&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'F'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;fsync&quot;</span>, <span class="Constant">&quot;false&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'f'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../tcop/postgres.c.html#L3708" title="tcop/postgres.c:3708">set_plan_disabling_options</a>(optarg, PGC_POSTMASTER, PGC_S_ARGV))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: invalid argument for option -f: </span><span class="Special">\&quot;%s\&quot;\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, optarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'h'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;listen_addresses&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'i'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;listen_addresses&quot;</span>, <span class="Constant">&quot;*&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'j'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only used by interactive backend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'k'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;unix_socket_directories&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'l'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;ssl&quot;</span>, <span class="Constant">&quot;true&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'N'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;max_connections&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'O'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;allow_system_table_mods&quot;</span>, <span class="Constant">&quot;true&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'P'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;ignore_system_indexes&quot;</span>, <span class="Constant">&quot;true&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'p'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;port&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'r'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* only used by single-user backend */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'s'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>&quot;</span>, <span class="Constant">&quot;true&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'T'</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This option used to be defined as sending SIGSTOP after a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend crash, but sending SIGABRT seems more useful.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="#L237" title="postmaster/postmaster.c:237">send_abort_for_crash</a>&quot;</span>, <span class="Constant">&quot;true&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'t'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tmp = <a href="../tcop/postgres.c.html#L3750" title="tcop/postgres.c:3750">get_stats_option_name</a>(optarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(tmp, <span class="Constant">&quot;true&quot;</span>, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: invalid argument for option -t: </span><span class="Special">\&quot;%s\&quot;\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, optarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'W'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;post_auth_delay&quot;</span>, optarg, PGC_POSTMASTER, PGC_S_ARGV);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;Try </span><span class="Special">\&quot;%s</span><span class="Constant"> --<a href="../main/main.c.html#L320" title="main/main.c:320">help</a></span><span class="Special">\&quot;</span><span class="Constant"> for more information.</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postmaster accepts no non-option switch arguments.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (optind &lt; argc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: invalid argument: </span><span class="Special">\&quot;%s\&quot;\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, argv[optind]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;Try </span><span class="Special">\&quot;%s</span><span class="Constant"> --<a href="../main/main.c.html#L320" title="main/main.c:320">help</a></span><span class="Special">\&quot;</span><span class="Constant"> for more information.</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Locate the proper configuration files and data directory, and read<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postgresql.conf for the first time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/guc.c.html#L1786" title="utils/misc/guc.c:1786">SelectConfigFiles</a>(<a href="../tcop/postgres.c.html#L161" title="tcop/postgres.c:161">userDoption</a>, <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (output_config_variable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is a runtime-computed GUC, it hasn't yet been initialized,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and the present value is not useful.&nbsp; However, this is a convenient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * place to <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the value for most GUCs because it is safe to run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster startup to this point even if the server is already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running.&nbsp; For the handful of runtime-computed GUCs that we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * provide meaningful <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for yet, we wait until later in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster startup to <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the value.&nbsp; We won't be able to use -C<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on running servers for those GUCs, but using this option <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lead to incorrect results for them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flags = <a href="../utils/misc/guc.c.html#L4405" title="utils/misc/guc.c:4405">GetConfigOptionFlags</a>(output_config_variable, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; GUC_RUNTIME_COMPUTED) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;-C guc&quot; was specified, so <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> GUC's value and exit.&nbsp; No<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * extra permission check is needed because the user is reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inside the data dir.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *config_val = <a href="../utils/misc/guc.c.html#L4308" title="utils/misc/guc.c:4308">GetConfigOption</a>(output_config_variable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; puts(config_val ? config_val : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A runtime-computed GUC will be printed later on.&nbsp; As we <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a server startup sequence, silence <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> log messages that may show<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up in the output generated.&nbsp; FATAL and more severe messages are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * useful to show, even if one would only expect at least PANIC.&nbsp; LOG<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * entries are hidden.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L524" title="utils/misc/guc_tables.c:524">log_min_messages</a>&quot;</span>, <span class="Constant">&quot;FATAL&quot;</span>, PGC_SUSET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PGC_S_OVERRIDE);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Verify that <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> looks reasonable */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L341" title="utils/init/miscinit.c:341">checkDataDir</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that pg_control exists */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1487" title="postmaster/postmaster.c:1487">checkControlFile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And switch working directory into it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L454" title="utils/init/miscinit.c:454">ChangeToDataDir</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for invalid combinations of GUC settings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a> + <a href="#L217" title="postmaster/postmaster.c:217">ReservedConnections</a> &gt;= <a href="../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: superuser_reserved_connections (</span><span class="Special">%d</span><span class="Constant">) plus reserved_connections (</span><span class="Special">%d</span><span class="Constant">) must be less than max_connections (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L216" title="postmaster/postmaster.c:216">SuperuserReservedConnections</a>, <a href="#L217" title="postmaster/postmaster.c:217">ReservedConnections</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L119" title="access/transam/xlog.c:119">XLogArchiveMode</a> &gt; ARCHIVE_MODE_OFF &amp;&amp; <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> == WAL_LEVEL_MINIMAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL archival cannot be enabled when <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> is </span><span class="Special">\&quot;</span><span class="Constant">minimal</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> &gt; <span class="Constant">0</span> &amp;&amp; <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> == WAL_LEVEL_MINIMAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL streaming (<a href="../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> &gt; 0) requires <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> </span><span class="Special">\&quot;</span><span class="Constant">replica</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">logical</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="walsummarizer.c.html#L142" title="postmaster/walsummarizer.c:142">summarize_wal</a> &amp;&amp; <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> == WAL_LEVEL_MINIMAL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;WAL cannot be summarized when <a href="../access/transam/xlog.c.html#L131" title="access/transam/xlog.c:131">wal_level</a> is </span><span class="Special">\&quot;</span><span class="Constant">minimal</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Other one-time <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> sanity checks can go here, if they are fast.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Put <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> slow processing further down, after postmaster.pid creation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/datetime.c.html#L4800" title="utils/adt/datetime.c:4800">CheckDateTokenTables</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: invalid datetoken tables, please fix</span><span class="Special">\n</span><span class="Constant">&quot;</span>, <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we are done processing the postmaster arguments, reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * getopt(3) library so that it will work correctly in subprocesses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; optind = <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT_OPTRESET<br/></li>
<li></span>&nbsp; &nbsp; optreset = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* some systems need this too */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For debugging: display postmaster environment */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">extern</span> <span class="Type">char</span> **environ;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **p;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: <a href="#L489" title="postmaster/postmaster.c:489">PostmasterMain</a>: initial environment <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>:&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;-----------------------------------------&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (p = environ; *p; ++p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">\t%s</span><span class="Constant">&quot;</span>, *p)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG3,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;-----------------------------------------&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create lockfile for data directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We want to do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try to grab the input sockets, because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * data directory interlock is more reliable than the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>-file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interlock (thanks to whoever decided to put <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> files in /tmp :-().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For the same reason, it's best to grab the TCP <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(s) <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(s).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also note that this internally sets up the <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> function that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is responsible for removing both data directory and <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> lockfiles;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it must happen <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> opening sockets so that at exit, the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lockfiles go away after <a href="#L1387" title="postmaster/postmaster.c:1387">CloseServerPorts</a> runs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1455" title="utils/init/miscinit.c:1455">CreateDataDirLockFile</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read the control file (for error checking and config info).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we verify the control file's CRC, this has a useful side effect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * on machines where we need a run-time test for CRC support instructions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The postmaster will do the test once at startup, and then its child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes will inherit the correct function pointer and not need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the test.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L4813" title="access/transam/xlog.c:4813">LocalProcessControlFile</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register the apply launcher.&nbsp; It's probably a good idea to call this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modules had a chance to take the background worker slots.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../replication/logical/launcher.c.html#L918" title="replication/logical/launcher.c:918">ApplyLauncherRegister</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> libraries that should be preloaded at postmaster start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1843" title="utils/init/miscinit.c:1843">process_shared_preload_libraries</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize SSL library, if specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L225" title="postmaster/postmaster.c:225">EnableSSL</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../libpq/be-secure.c.html#L73" title="libpq/be-secure.c:73">secure_initialize</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="postmaster/postmaster.c:381">LoadedSSL</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that loadable modules have had their chance to alter <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUCs,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calculate <a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L575" title="utils/init/postinit.c:575">InitializeMaxBackends</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Give preloaded libraries a chance to request additional shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1871" title="utils/init/miscinit.c:1871">process_shmem_requests</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that loadable modules have had their chance to request additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory, determine the value of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> runtime-computed GUCs that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on the amount of shared memory required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipci.c.html#L369" title="storage/ipc/ipci.c:369">InitializeShmemGUCs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that modules have been loaded, we can process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> custom resource<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * managers specified in the <a href="../access/transam/xlog.c.html#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a> GUC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L4751" title="access/transam/xlog.c:4751">InitializeWalConsistencyChecking</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If -C was specified with a runtime-computed GUC, we held off printing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the value earlier, as the GUC was not yet initialized.&nbsp; We handle -C<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for most GUCs <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we lock the data directory so that the option may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be used on a running server.&nbsp; However, a handful of GUCs are runtime-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * computed and do not have meaningful <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> until after locking the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directory, and we cannot safely calculate their <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> earlier on a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running server.&nbsp; At this point, such GUCs should be properly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized, and we haven't yet set up shared memory, so this is a good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time to handle the -C option for these special GUCs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (output_config_variable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *config_val = <a href="../utils/misc/guc.c.html#L4308" title="utils/misc/guc.c:4308">GetConfigOption</a>(output_config_variable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; puts(config_val ? config_val : <span class="Constant">&quot;&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up shared memory and semaphores.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: if using SysV shmem and/or semas, each postmaster startup will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normally choose the same IPC keys.&nbsp; This helps ensure that we will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clean up dead IPC objects if the postmaster crashes and is restarted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipci.c.html#L199" title="storage/ipc/ipci.c:199">CreateSharedMemoryAndSemaphores</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Estimate number of openable files.&nbsp; This must happen after setting up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * semaphores, because on some platforms semaphores count as open files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1044" title="storage/file/fd.c:1044">set_max_safe_fds</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set reference point for stack-depth checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../tcop/postgres.c.html#L3481" title="tcop/postgres.c:3481">set_stack_base</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize pipe (or process handle on Windows) that allows children to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wake up from sleep on postmaster death.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4703" title="postmaster/postmaster.c:4703">InitPostmasterDeathWatchHandle</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize I/O completion port used to deliver list of dead children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L455" title="postmaster/postmaster.c:455">win32ChildQueue</a> = CreateIoCompletionPort(INVALID_HANDLE_VALUE, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L455" title="postmaster/postmaster.c:455">win32ChildQueue</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create I/O completion port for child queue&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Write out nondefault GUC settings for child processes to use */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L5607" title="utils/misc/guc.c:5607">write_nondefault_variables</a>(PGC_POSTMASTER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Clean out the temp directory used to transmit parameters to child<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes (see <a href="launch_backend.c.html#L282" title="postmaster/launch_backend.c:282">internal_forkexec</a>).&nbsp; We must do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> launching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> child processes, else we have a race condition: we could remove a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter file <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the child can read it.&nbsp; It should be safe to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, because we verified earlier that there are no conflicting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postgres processes in this data directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3333" title="storage/file/fd.c:3333">RemovePgTempFilesInDir</a>(PG_TEMP_FILES_DIR, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forcibly remove the files signaling a standby promotion request.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, the existence of those files triggers a promotion too early,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether a user wants that or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This removal of files is usually unnecessary because they can exist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only during a few moments during a standby promotion. However there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a race condition: if pg_ctl promote is executed and creates the files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during a promotion, the files can stay around even after the server is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * brought up to be the primary.&nbsp; Then, if a new standby starts by using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the backup taken from the new primary, the files can exist at server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup and must be removed in order to avoid an unexpected promotion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that promotion signal files need to be removed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the startup<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process is invoked. Because, after that, they can be used by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster's SIGUSR1 signal handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L4454" title="access/transam/xlogrecovery.c:4454">RemovePromoteSignalFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do the same for logrotate signal file */<br/></li>
<li></span>&nbsp; &nbsp; <a href="syslogger.c.html#L1587" title="postmaster/syslogger.c:1587">RemoveLogrotateSignalFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outdated file holding the current log filenames. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlink(LOG_METAINFO_DATAFILE) &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If enabled, start up syslogger collection subprocess<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> = <a href="syslogger.c.html#L595" title="postmaster/syslogger.c:595">SysLogger_Start</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> from DestDebug (its starting state) to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DestNone. This stops ereport from sending log messages to stderr unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> permits.&nbsp; We don't do this until the postmaster is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fully launched, since startup failures may as well be reported to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stderr.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in fact disabling logging to stderr, first emit a log message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * saying so, to provide a breadcrumb trail for users who may not remember<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that their logging is configured to go somewhere else.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_STDERR))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ending log output to stderr&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Future log output will go to log destination </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L113" title="utils/error/elog.c:113">Log_destination_string</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report server startup in log.&nbsp; While we could emit this much earlier,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems best to do so after starting the log collector, if we intend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to use one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;starting </span><span class="Special">%s</span><span class="Constant">&quot;</span>, PG_VERSION_STR)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Establish input sockets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First set up an <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> function that's charged with closing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sockets again at postmaster shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a> = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<a href="#L220" title="postmaster/postmaster.c:220">MAXLISTEN</a> * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(pgsocket));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L1387" title="postmaster/postmaster.c:1387">CloseServerPorts</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L196" title="postmaster/postmaster.c:196">ListenAddresses</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawstring;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *elemlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need a modifiable copy of <a href="#L196" title="postmaster/postmaster.c:196">ListenAddresses</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rawstring = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L196" title="postmaster/postmaster.c:196">ListenAddresses</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse string into list of hostnames */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/varlena.c.html#L3705" title="utils/adt/varlena.c:3705">SplitGUCList</a>(rawstring, <span class="Constant">','</span>, &amp;elemlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syntax error in list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid list syntax in parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;listen_addresses&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, elemlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *curhost = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(curhost, <span class="Constant">&quot;*&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../libpq/pqcomm.c.html#L417" title="libpq/pqcomm.c:417">ListenServerPort</a>(AF_UNSPEC, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">short</span>) <a href="#L190" title="postmaster/postmaster.c:190">PostPortNumber</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L220" title="postmaster/postmaster.c:220">MAXLISTEN</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../libpq/pqcomm.c.html#L417" title="libpq/pqcomm.c:417">ListenServerPort</a>(AF_UNSPEC, curhost,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">short</span>) <a href="#L190" title="postmaster/postmaster.c:190">PostPortNumber</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L220" title="postmaster/postmaster.c:220">MAXLISTEN</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* record the first successful host addr in lockfile */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!listen_addr_saved)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_LISTEN_ADDR, curhost);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; listen_addr_saved = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> for </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curhost)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!success &amp;&amp; elemlist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> TCP/IP sockets&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_BONJOUR<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Register for Bonjour only if we opened TCP <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>(s) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L233" title="postmaster/postmaster.c:233">enable_bonjour</a> &amp;&amp; <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DNSServiceErrorType err;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We pass 0 for interface_index, which will result in registering on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all &quot;applicable&quot; interfaces.&nbsp; It's not entirely clear from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * DNS-SD docs whether this would be appropriate if we have bound to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just a <a href="../regex/regexec.c.html#L702" title="regex/regexec.c:702">subset</a> of the available network interfaces.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; err = DNSServiceRegister(&amp;<a href="#L385" title="postmaster/postmaster.c:385">bonjour_sdref</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L234" title="postmaster/postmaster.c:234">bonjour_name</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;_postgresql._tcp.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_hton16(<a href="#L190" title="postmaster/postmaster.c:190">PostPortNumber</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (err != kDNSServiceErr_NoError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DNSServiceRegister() failed: error code </span><span class="Special">%ld</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">long</span>) err)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't bother to read the mDNS daemon's reply, and we expect that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it will automatically terminate our registration when the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * closed at postmaster termination.&nbsp; So there's nothing more to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * done here.&nbsp; However, the <a href="#L385" title="postmaster/postmaster.c:385">bonjour_sdref</a> is kept around so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forked children can close their copies of the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L193" title="postmaster/postmaster.c:193">Unix_socket_directories</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rawstring;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *elemlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need a modifiable copy of <a href="#L193" title="postmaster/postmaster.c:193">Unix_socket_directories</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rawstring = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L193" title="postmaster/postmaster.c:193">Unix_socket_directories</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Parse string into list of directories */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/varlena.c.html#L3584" title="utils/adt/varlena.c:3584">SplitDirectoriesString</a>(rawstring, <span class="Constant">','</span>, &amp;elemlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syntax error in list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid list syntax in parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;unix_socket_directories&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, elemlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *socketdir = (<span class="Type">char</span> *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status = <a href="../libpq/pqcomm.c.html#L417" title="libpq/pqcomm.c:417">ListenServerPort</a>(AF_UNIX, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">short</span>) <a href="#L190" title="postmaster/postmaster.c:190">PostPortNumber</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; socketdir,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L220" title="postmaster/postmaster.c:220">MAXLISTEN</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; success++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* record the first successful Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> in lockfile */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (success == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_SOCKET_DIR, socketdir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create Unix-domain <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> in directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; socketdir)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!success &amp;&amp; elemlist != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Unix-domain sockets&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1560" title="nodes/list.c:1560">list_free_deep</a>(elemlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rawstring);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check that we have some <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> to <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> created for listening&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If no valid TCP ports, write an empty line for <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> address,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indicating the Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> must be used.&nbsp; Note that this line is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * added to the lock file until there is a <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> backing it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!listen_addr_saved)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_LISTEN_ADDR, <span class="Constant">&quot;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record postmaster options.&nbsp; We delay this till <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to avoid recording<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bogus options (eg, unusable port number).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4101" title="postmaster/postmaster.c:4101">CreateOptsFile</a>(argc, argv, <a href="../utils/init/globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Write the external PID file if requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fpidfile = fopen(<a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>, <span class="Constant">&quot;w&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fpidfile)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(fpidfile, <span class="Constant">&quot;</span><span class="Special">%d\n</span><span class="Constant">&quot;</span>, <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fpidfile);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make PID file world readable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (chmod(<a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: could not change permissions of external PID file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, <a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: could not write external PID file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, <a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L1421" title="postmaster/postmaster.c:1421">unlink_external_pid_file</a>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove old temporary files.&nbsp; At this point there can be no other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postgres processes running in this directory, so this should be safe.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3274" title="storage/file/fd.c:3274">RemovePgTempFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize the autovacuum subsystem (again, no process start yet)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="autovacuum.c.html#L3243" title="postmaster/autovacuum.c:3243">autovac_init</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Load configuration files for client authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../libpq/hba.c.html#L2583" title="libpq/hba.c:2583">load_hba</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It makes no sense to continue if we fail to load the HBA file,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * since there is no way to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to the database in this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a configuration file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not load </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/misc/guc_tables.c.html#L542" title="utils/misc/guc_tables.c:542">HbaFileName</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../libpq/hba.c.html#L2959" title="libpq/hba.c:2959">load_ident</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can start up without the IDENT file, although it means that you<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot log in using <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the authentication methods that need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * user name mapping. <a href="../libpq/hba.c.html#L2959" title="libpq/hba.c:2959">load_ident</a>() already logged the details of error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_PTHREAD_IS_THREADED_NP<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On macOS, libintl replaces setlocale() with a version that calls<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CFLocaleCopyCurrent() when its second argument is &quot;&quot; and every relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * environment variable is unset or empty.&nbsp; CFLocaleCopyCurrent() makes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the process multithreaded.&nbsp; The postmaster calls sigprocmask() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * calls fork() without an immediate exec(), both of which have undefined<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior in a multithreaded program.&nbsp; A multithreaded postmaster is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * normal case on Windows, which offers neither fork() nor sigprocmask().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pthread_is_threaded_np() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;postmaster became multithreaded during startup&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Set the LC_ALL environment variable to a valid locale.&quot;</span>)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember postmaster startup time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L52" title="utils/adt/timestamp.c:52">PgStartTime</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report postmaster status in the postmaster.pid file, to allow pg_ctl to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see what's happening.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STARTING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start bgwriter and checkpointer so they can <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> with recovery */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_CHECKPOINTER);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_BG_WRITER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We're ready to rock and roll...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_STARTUP);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_RUNNING;<br/></li>
<li>&nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_STARTUP;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Some workers may be scheduled to start <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4409" title="postmaster/postmaster.c:4409">maybe_start_bgworkers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status = <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> probably shouldn't ever return, but if it does, close down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(status != STATUS_OK);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; abort();&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not reached */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> callback to close server's <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> sockets<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1387">&#x200c;</a></span><span class="linkable">CloseServerPorts</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, explicitly close all the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> FDs.&nbsp; We used to just let this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen implicitly at postmaster exit, but it's better to close them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we remove the postmaster.pid lockfile; otherwise there's a race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * condition if a new postmaster wants to re-use the TCP port number.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (closesocket(<a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>[i]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not close <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next, remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> filesystem entries for Unix sockets.&nbsp; To avoid race<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conditions against incoming postmasters, this must happen after closing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sockets and <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> removing lock files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L847" title="libpq/pqcomm.c:847">RemoveSocketFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't do anything about <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> lock files here; those will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * removed in a later <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> callback to delete <a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1421">&#x200c;</a></span><span class="linkable">unlink_external_pid_file</span>(<span class="Type">int</span> status, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; unlink(<a href="../utils/misc/guc_tables.c.html#L544" title="utils/misc/guc_tables.c:544">external_pid_file</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute and check the directory paths to files that are part of the<br/></li>
<li></span><span class="Comment"> * installation (as deduced from the postgres executable's own location)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1433">&#x200c;</a></span><span class="linkable">getInstallationPaths</span>(<span class="Type">const</span> <span class="Type">char</span> *argv0)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *pdir;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Locate the postgres executable itself */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (find_my_exec(argv0, <a href="../utils/init/globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: could not locate my own executable path&quot;</span>, argv0)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Locate executable backend <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we change working directory */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (find_other_exec(argv0, <span class="Constant">&quot;postgres&quot;</span>, PG_BACKEND_VERSIONSTR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L82" title="utils/init/globals.c:82">postgres_exec_path</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: could not locate matching postgres executable&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argv0)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Locate the pkglib directory --- this has to be set early in case we try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to load <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> modules from it in response to postgresql.conf entries.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; get_pkglib_path(<a href="../utils/init/globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>, <a href="../utils/init/globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify that there's a readable directory there; otherwise the Postgres<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * installation is incomplete or corrupt.&nbsp; (A typical cause of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure is that the postgres executable has been moved or hardlinked to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some directory that's not a sibling of the installation lib/<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directory.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pdir = <a href="../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(<a href="../utils/init/globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pdir == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L79" title="utils/init/globals.c:79">pkglib_path</a>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;This may indicate an incomplete PostgreSQL installation, or that the file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> has been moved away from its proper location.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/init/globals.c.html#L78" title="utils/init/globals.c:78">my_exec_path</a>)));<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(pdir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's not worth checking the share/ directory.&nbsp; If the lib/ directory is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there, then share/ probably is too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check that pg_control exists in the correct location in the data directory.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No attempt is made to validate the contents of pg_control here.&nbsp; This is<br/></li>
<li></span><span class="Comment"> * just a sanity check to see if we are looking at a real data directory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1487">&#x200c;</a></span><span class="linkable">checkControlFile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; path[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(path, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(path), <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/global/pg_control&quot;</span>, <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fp = <a href="../storage/file/fd.c.html#L2583" title="storage/file/fd.c:2583">AllocateFile</a>(path, PG_BINARY_R);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fp == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the database system</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;Expected to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> it in the directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">,</span><span class="Special">\n</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;but could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a>, path);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L2781" title="storage/file/fd.c:2781">FreeFile</a>(fp);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine how long should we let <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> sleep, in milliseconds.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In normal conditions we wait at most one minute, to ensure that the other<br/></li>
<li></span><span class="Comment"> * background tasks handled by <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> get done even when no requests are<br/></li>
<li></span><span class="Comment"> * arriving.&nbsp; However, if there are background workers <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> to be started,<br/></li>
<li></span><span class="Comment"> * we don't actually sleep so that they are quickly serviced.&nbsp; Other exception<br/></li>
<li></span><span class="Comment"> * cases are as shown in the code.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1516">&#x200c;</a></span><span class="linkable">DetermineSleepTime</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TimestampTz next_wakeup = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal case: either there are no background workers at all, or we're in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a shutdown sequence (during which we ignore bgworkers altogether).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt; <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!<a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> &amp;&amp; !<a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seconds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* time left to abort; clamp to 0 in case it already expired */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seconds = <a href="#L346" title="postmaster/postmaster.c:346">SIGKILL_CHILDREN_AFTER_SECS</a> -<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (time(<span class="Constant">NULL</span>) - <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> Max(seconds * <span class="Constant">1000</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">60</span> * <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; slist_mutable_iter siter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When there are crashed bgworkers, we sleep just long enough that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are restarted when they request to be.&nbsp; Scan the list to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * determine the minimum of all <a href="../replication/walreceiver.c.html#L129" title="replication/walreceiver.c:129">wakeup</a> times according to most recent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash time and requested restart interval.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; slist_foreach_modify(siter, &amp;<a href="bgworker.c.html#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TimestampTz this_wakeup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_crashed_at == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_worker.bgw_restart_time == BGW_NEVER_RESTART<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || rw-&gt;rw_terminate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L432" title="postmaster/bgworker.c:432">ForgetBackgroundWorker</a>(&amp;siter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_wakeup = TimestampTzPlusMilliseconds(rw-&gt;rw_crashed_at,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1000L</span> * rw-&gt;rw_worker.bgw_restart_time);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (next_wakeup == <span class="Constant">0</span> || this_wakeup &lt; next_wakeup)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_wakeup = this_wakeup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (next_wakeup != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ms;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* result of <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a> is in [0, INT_MAX] */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ms = (<span class="Type">int</span>) <a href="../utils/adt/timestamp.c.html#L1766" title="utils/adt/timestamp.c:1766">TimestampDifferenceMilliseconds</a>(<a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_wakeup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(<span class="Constant">60</span> * <span class="Constant">1000</span>, ms);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">60</span> * <span class="Constant">1000</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Activate or deactivate notifications of server <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> events.&nbsp; Since we<br/></li>
<li></span><span class="Comment"> * don't currently have a way to remove events from an existing <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>,<br/></li>
<li></span><span class="Comment"> * we'll just destroy and recreate the whole thing.&nbsp; This is called during<br/></li>
<li></span><span class="Comment"> * shutdown so we can wait for backends to exit without accepting new<br/></li>
<li></span><span class="Comment"> * connections, and during crash reinitialization when we need to start<br/></li>
<li></span><span class="Comment"> * listening for new connections again.&nbsp; The <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> will be freed in fork<br/></li>
<li></span><span class="Comment"> * children by <a href="#L1955" title="postmaster/postmaster.c:1955">ClosePostmasterPorts</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1601">&#x200c;</a></span><span class="linkable">ConfigurePostmasterWaitSet</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> accept_connections)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L874" title="storage/ipc/latch.c:874">FreeWaitEventSet</a>(<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a> = <a href="../storage/ipc/latch.c.html#L751" title="storage/ipc/latch.c:751">CreateWaitEventSet</a>(<span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; accept_connections ? (<span class="Constant">1</span> + <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>) : <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>, WL_LATCH_SET, PGINVALID_SOCKET, <a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (accept_connections)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>, WL_SOCKET_ACCEPT, <a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main idle loop of postmaster<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1624">&#x200c;</a></span><span class="linkable">ServerLoop</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; last_lockfile_recheck_time,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_touch_time;<br/></li>
<li>&nbsp; &nbsp; WaitEvent&nbsp; &nbsp; events[<a href="#L220" title="postmaster/postmaster.c:220">MAXLISTEN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nevents;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1601" title="postmaster/postmaster.c:1601">ConfigurePostmasterWaitSet</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; last_lockfile_recheck_time = last_touch_time = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nevents = <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1516" title="postmaster/postmaster.c:1516">DetermineSleepTime</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; events,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lengthof(events),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span> <span class="Comment">/* postmaster posts no wait_events */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Latch set by signal handler, or new connection pending on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * our sockets? If the latter, fork a child process to deal with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nevents; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events[i].events &amp; WL_LATCH_SET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The following requests are handled unconditionally, even if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't see WL_LATCH_SET.&nbsp; This gives high priority to shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and reload requests where the latch happens to appear later in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * events[] or will be reported by a later call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L372" title="postmaster/postmaster.c:372">pending_pm_shutdown_request</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2192" title="postmaster/postmaster.c:2192">process_pm_shutdown_request</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L371" title="postmaster/postmaster.c:371">pending_pm_reload_request</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2095" title="postmaster/postmaster.c:2095">process_pm_reload_request</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L370" title="postmaster/postmaster.c:370">pending_pm_child_exit</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2353" title="postmaster/postmaster.c:2353">process_pm_child_exit</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L369" title="postmaster/postmaster.c:369">pending_pm_pmsignal</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3702" title="postmaster/postmaster.c:3702">process_pm_pmsignal</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (events[i].events &amp; WL_SOCKET_ACCEPT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ClientSocket s;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L793" title="libpq/pqcomm.c:793">AcceptConnection</a>(events[i].fd, &amp;s) == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3544" title="postmaster/postmaster.c:3544">BackendStartup</a>(&amp;s);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We no longer need the open <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> in this process */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (s.sock != PGINVALID_SOCKET)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (closesocket(s.sock) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not close client <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have lost the log collector, try to start a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> == <span class="Constant">0</span> &amp;&amp; <a href="syslogger.c.html#L70" title="postmaster/syslogger.c:70">Logging_collector</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> = <a href="syslogger.c.html#L595" title="postmaster/syslogger.c:595">SysLogger_Start</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If no background writer process is running, and we are not in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state that prevents it, start one.&nbsp; It doesn't matter if this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fails, we'll just try again later.&nbsp; Likewise for the checkpointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_CHECKPOINTER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_BG_WRITER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, if we have lost the walwriter process, try to start a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one.&nbsp; But this is needed only in normal operation (else we cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be writing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new WAL).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> == <span class="Constant">0</span> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_WAL_WRITER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have lost the autovacuum launcher, try to start a new one. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want autovacuum to run in binary upgrade mode because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovacuum might update relfrozenxid for empty tables <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * physical files are put in place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> &amp;&amp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="autovacuum.c.html#L3189" title="postmaster/autovacuum.c:3189">AutoVacuumingActive</a>() || <a href="#L356" title="postmaster/postmaster.c:356">start_autovac_launcher</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_AUTOVAC_LAUNCHER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L356" title="postmaster/postmaster.c:356">start_autovac_launcher</a> = <span class="Constant">false</span>; <span class="Comment">/* signal processed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we have lost the archiver, try to start a new one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> == <span class="Constant">0</span> &amp;&amp; <a href="#L441" title="postmaster/postmaster.c:441">PgArchStartupAllowed</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_ARCHIVER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we need to start a slot sync worker, try to do that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4089" title="postmaster/postmaster.c:4089">MaybeStartSlotSyncWorker</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we need to signal the autovacuum launcher, do so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L359" title="postmaster/postmaster.c:359">avlauncher_needs_signal</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L359" title="postmaster/postmaster.c:359">avlauncher_needs_signal</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>, <span class="Constant">SIGUSR2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we need to start a WAL receiver, try to do that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L362" title="postmaster/postmaster.c:362">WalReceiverRequested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4051" title="postmaster/postmaster.c:4051">MaybeStartWalReceiver</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we need to start a WAL summarizer, try to do that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4070" title="postmaster/postmaster.c:4070">MaybeStartWalSummarizer</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get other worker processes running, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> || <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4409" title="postmaster/postmaster.c:4409">maybe_start_bgworkers</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_PTHREAD_IS_THREADED_NP<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * With assertions enabled, check regularly for appearance of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * additional threads.&nbsp; All builds check at start and exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(pthread_is_threaded_np() == <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lastly, check to see if it's time to do some things that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to do every single time through the loop, because they're a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> expensive.&nbsp; Note that there's up to a minute of slop in when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * these tasks will be performed, since <a href="#L1516" title="postmaster/postmaster.c:1516">DetermineSleepTime</a>() will let<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * us sleep at most that long; except for SIGKILL timeout which has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special-case logic there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we already sent SIGQUIT to children and they are slow to shut<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * down, it's time to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> them SIGKILL (or SIGABRT if requested).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This doesn't happen normally, but under certain conditions backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can get stuck while shutting down.&nbsp; This is a last measure to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them unwedged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note we also do this during recovery from a process crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt;= <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a> || <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a>) &gt;= <a href="#L346" title="postmaster/postmaster.c:346">SIGKILL_CHILDREN_AFTER_SECS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We were gentle with them <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>. Not anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is SIGKILL or SIGABRT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;issuing </span><span class="Special">%s</span><span class="Constant"> to recalcitrant children&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L238" title="postmaster/postmaster.c:238">send_abort_for_kill</a> ? <span class="Constant">&quot;SIGABRT&quot;</span> : <span class="Constant">&quot;SIGKILL&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3509" title="postmaster/postmaster.c:3509">TerminateChildren</a>(<a href="#L238" title="postmaster/postmaster.c:238">send_abort_for_kill</a> ? <span class="Constant">SIGABRT</span> : <span class="Constant">SIGKILL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset flag so we don't SIGKILL again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once a minute, verify that postmaster.pid hasn't been removed or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * overwritten.&nbsp; If it has, we force a shutdown.&nbsp; This avoids having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmasters and child processes hanging around after their database<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is gone, and maybe causing problems if a new database <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a> is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created in the same place.&nbsp; It also provides some protection<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against a DBA foolishly removing postmaster.pid and manually<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * starting a new postmaster.&nbsp; Data corruption is likely to ensue from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that anyway, but we can minimize the damage by aborting ASAP.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - last_lockfile_recheck_time &gt;= <span class="Constant">1</span> * SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/miscinit.c.html#L1638" title="utils/init/miscinit.c:1638">RecheckDataDirLockFile</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;performing immediate shutdown because data directory lock file is invalid&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(<a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <span class="Constant">SIGQUIT</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_lockfile_recheck_time = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Touch Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> and lock files every 58 minutes, to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they are not removed by overzealous /tmp-cleaning tasks.&nbsp; We assume<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * no one runs cleaners with cutoff times of less than an hour ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> - last_touch_time &gt;= <span class="Constant">58</span> * SECS_PER_MINUTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L829" title="libpq/pqcomm.c:829">TouchSocketFiles</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1482" title="utils/init/miscinit.c:1482">TouchSocketLockFiles</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_touch_time = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The client has sent a cancel request packet, not a normal<br/></li>
<li></span><span class="Comment"> * start-a-new-connection packet.&nbsp; Perform the necessary processing.<br/></li>
<li></span><span class="Comment"> * Nothing is sent back to the client.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1835">&#x200c;</a></span><span class="linkable">processCancelRequest</span>(<span class="Type">int</span> backendPID, int32 cancelAuthCode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bp;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See if we have a matching backend.&nbsp; In the EXEC_BACKEND case, we can no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer access the postmaster's own backend list, and must rely on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate array in shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bp = dlist_container(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>, elem, iter.cur);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <a href="#L4145" title="postmaster/postmaster.c:4145">MaxLivePostmasterChildren</a>() - <span class="Constant">1</span>; i &gt;= <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bp = (<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *) &amp;<a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>[i];<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;pid == backendPID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;cancel_key == cancelAuthCode)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Found a match; signal that backend to cancel current op */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;processing cancel request: sending SIGINT to process </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; backendPID)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(bp-&gt;pid, <span class="Constant">SIGINT</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Right PID, wrong key: no way, Jose */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;wrong key in cancel request for process </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendPID)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifndef EXEC_BACKEND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* make GNU Emacs 26.1 see brace balance */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No matching backend */<br/></li>
<li></span>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;PID </span><span class="Special">%d</span><span class="Constant"> in cancel request did not match <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> process&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendPID)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a> --- check to see if database state allows connections<br/></li>
<li></span><span class="Comment"> * of the specified type.&nbsp; backend_type can be <a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a>,<br/></li>
<li></span><span class="Comment"> * <a href="#L137" title="postmaster/postmaster.c:137">BACKEND_TYPE_AUTOVAC</a>, or <a href="#L139" title="postmaster/postmaster.c:139">BACKEND_TYPE_BGWORKER</a>.&nbsp; (Note that we don't yet<br/></li>
<li></span><span class="Comment"> * know whether a NORMAL connection might turn into a walsender.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CAC_state<br/></li>
<li><a id="L1895">&#x200c;</a><span class="linkable">canAcceptConnections</span>(<span class="Type">int</span> backend_type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CAC_state&nbsp; &nbsp; result = CAC_OK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Can't start backends when in startup/shutdown/inconsistent recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state.&nbsp; We treat autovac workers the same as user backends for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * purpose.&nbsp; However, bgworkers are excluded from this test; we expect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L4303" title="postmaster/postmaster.c:4303">bgworker_should_start_now</a>() decided whether the DB state allows them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> != PM_RUN &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> != PM_HOT_STANDBY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backend_type != <a href="#L139" title="postmaster/postmaster.c:139">BACKEND_TYPE_BGWORKER</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt; <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CAC_SHUTDOWN;&nbsp; &nbsp; <span class="Comment">/* shutdown is pending */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CAC_STARTUP; <span class="Comment">/* normal startup */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CAC_NOTCONSISTENT;&nbsp; &nbsp; <span class="Comment">/* not yet at consistent recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CAC_RECOVERY;&nbsp; &nbsp; <span class="Comment">/* else must be crash recovery */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;Smart shutdown&quot; restrictions are applied only to normal connections,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not to autovac workers or bgworkers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a> &amp;&amp; backend_type == <a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> CAC_SHUTDOWN;&nbsp; &nbsp; <span class="Comment">/* shutdown is pending */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't start too many children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We allow more connections here than we can have backends because some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might still be authenticating; they might fail auth, or some existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend might exit <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the auth cycle is completed.&nbsp; The exact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> limit is enforced when a new backend tries to join the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared-inval backend array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The limit here must match the sizes of the per-child-process arrays;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see comments for <a href="#L4145" title="postmaster/postmaster.c:4145">MaxLivePostmasterChildren</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3878" title="postmaster/postmaster.c:3878">CountChildren</a>(<a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a>) &gt;= <a href="#L4145" title="postmaster/postmaster.c:4145">MaxLivePostmasterChildren</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = CAC_TOOMANY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1955" title="postmaster/postmaster.c:1955">ClosePostmasterPorts</a> -- close all the postmaster's open sockets<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called during child process startup to release file descriptors<br/></li>
<li></span><span class="Comment"> * that are not needed by that child process.&nbsp; The postmaster still has<br/></li>
<li></span><span class="Comment"> * them open, of course.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we pass am_syslogger as a boolean because we don't want to set<br/></li>
<li></span><span class="Comment"> * the global variable yet when this is called.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1955">&#x200c;</a></span><span class="linkable">ClosePostmasterPorts</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> am_syslogger)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release resources held by the postmaster's <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L917" title="storage/ipc/latch.c:917">FreeWaitEventSetAfterFork</a>(<a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L377" title="postmaster/postmaster.c:377">pm_wait_set</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the write end of postmaster death watch pipe. It's important to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do this as early as possible, so that if postmaster dies, others won't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think that it's still running because we're holding the pipe open.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (close(<a href="#L479" title="postmaster/postmaster.c:479">postmaster_alive_fds</a>[POSTMASTER_FD_OWN]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not close postmaster death monitoring pipe in child process: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L479" title="postmaster/postmaster.c:479">postmaster_alive_fds</a>[POSTMASTER_FD_OWN] = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify fd.c that we released one pipe FD. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>();<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the postmaster's <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> sockets.&nbsp; These aren't tracked by fd.c,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so we don't call <a href="../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>() here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> sockets are marked as FD_CLOEXEC, so this isn't needed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXEC_BACKEND mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a>; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (closesocket(<a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>[i]) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(LOG, <span class="Constant">&quot;could not close <a href="../port/win32/socket.c.html#L33" title="port/win32/socket.c:33">listen</a> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>: %m&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(<a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="#L221" title="postmaster/postmaster.c:221">NumListenSockets</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L222" title="postmaster/postmaster.c:222">ListenSockets</a> = <span class="Constant">NULL</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If using syslogger, close the read side of the pipe.&nbsp; We don't bother<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tracking this in fd.c, either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!am_syslogger)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="syslogger.c.html#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>] &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(<a href="syslogger.c.html#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syslogger.c.html#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>] = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="syslogger.c.html#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(<a href="syslogger.c.html#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="syslogger.c.html#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>] = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_BONJOUR<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* If using Bonjour, close the connection to the mDNS daemon */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L385" title="postmaster/postmaster.c:385">bonjour_sdref</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(DNSServiceRefSockFD(<a href="#L385" title="postmaster/postmaster.c:385">bonjour_sdref</a>));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2032" title="postmaster/postmaster.c:2032">InitProcessGlobals</a> -- set <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>, <a href="../utils/init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a>[stamp], random seeds<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called early in the postmaster and every backend.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2032">&#x200c;</a></span><span class="linkable">InitProcessGlobals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> = getpid();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L47" title="utils/init/globals.c:47">MyStartTimestamp</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a> = <a href="../utils/adt/timestamp.c.html#L1833" title="utils/adt/timestamp.c:1833">timestamptz_to_time_t</a>(<a href="../utils/init/globals.c.html#L47" title="utils/init/globals.c:47">MyStartTimestamp</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set a different global seed in every process.&nbsp; We want something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unpredictable, so if possible, use high-quality random bits for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seed.&nbsp; Otherwise, fall back to a seed based on timestamp and PID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(!pg_prng_strong_seed(&amp;pg_global_prng_state)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; rseed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since PIDs and timestamps tend to change more frequently in their<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least significant bits, shift the timestamp left to allow a larger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * total number of seeds in a given time period.&nbsp; Since that would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave only 20 bits of the timestamp that cycle every ~1 second,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * also mix in some higher bits.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rseed = ((uint64) <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>) ^<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint64) <a href="../utils/init/globals.c.html#L47" title="utils/init/globals.c:47">MyStartTimestamp</a> &lt;&lt; <span class="Constant">12</span>) ^<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ((uint64) <a href="../utils/init/globals.c.html#L47" title="utils/init/globals.c:47">MyStartTimestamp</a> &gt;&gt; <span class="Constant">20</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_prng_seed(&amp;pg_global_prng_state, rseed);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also make sure that we've set a good seed for random(3).&nbsp; Use of that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is deprecated in core Postgres, but extensions might use it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; srandom(pg_prng_uint32(&amp;pg_global_prng_state));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Child processes use SIGUSR1 to notify us of 'pmsignals'.&nbsp; pg_ctl uses<br/></li>
<li></span><span class="Comment"> * SIGUSR1 to ask postmaster to check for logrotate and promote files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2075">&#x200c;</a></span><span class="linkable">handle_pm_pmsignal_signal</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L369" title="postmaster/postmaster.c:369">pending_pm_pmsignal</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_ctl uses SIGHUP to request a reload of the configuration files.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2085">&#x200c;</a></span><span class="linkable">handle_pm_reload_request_signal</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L371" title="postmaster/postmaster.c:371">pending_pm_reload_request</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Re-read config files, and tell children to do same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2095">&#x200c;</a></span><span class="linkable">process_pm_reload_request</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L371" title="postmaster/postmaster.c:371">pending_pm_reload_request</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;postmaster received reload request signal&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received SIGHUP, reloading configuration files&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="postmaster/postmaster.c:422">SignalChildren</a>(<span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a>, <span class="Constant">SIGHUP</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reload authentication config files too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../libpq/hba.c.html#L2583" title="libpq/hba.c:2583">load_hba</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a configuration file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> was not reloaded&quot;</span>, <a href="../utils/misc/guc_tables.c.html#L542" title="utils/misc/guc_tables.c:542">HbaFileName</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../libpq/hba.c.html#L2959" title="libpq/hba.c:2959">load_ident</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> was not reloaded&quot;</span>, <a href="../utils/misc/guc_tables.c.html#L543" title="utils/misc/guc_tables.c:543">IdentFileName</a>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reload SSL configuration as well */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L225" title="postmaster/postmaster.c:225">EnableSSL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/be-secure.c.html#L73" title="libpq/be-secure.c:73">secure_initialize</a>(<span class="Constant">false</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="postmaster/postmaster.c:381">LoadedSSL</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SSL configuration was not reloaded&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/be-secure.c.html#L86" title="libpq/be-secure.c:86">secure_destroy</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L381" title="postmaster/postmaster.c:381">LoadedSSL</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update the starting-point file for future children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L5607" title="utils/misc/guc.c:5607">write_nondefault_variables</a>(PGC_SIGHUP);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * pg_ctl uses SIGTERM, SIGINT and SIGQUIT to request different types of<br/></li>
<li></span><span class="Comment"> * shutdown.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2168">&#x200c;</a></span><span class="linkable">handle_pm_shutdown_request_signal</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (postgres_signal_arg)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGTERM</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* smart is implied if the other two flags aren't set */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="postmaster/postmaster.c:372">pending_pm_shutdown_request</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGINT</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="postmaster/postmaster.c:373">pending_pm_fast_shutdown_request</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="postmaster/postmaster.c:372">pending_pm_shutdown_request</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGQUIT</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L374" title="postmaster/postmaster.c:374">pending_pm_immediate_shutdown_request</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L372" title="postmaster/postmaster.c:372">pending_pm_shutdown_request</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process shutdown request.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2192">&#x200c;</a></span><span class="linkable">process_pm_shutdown_request</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;postmaster received shutdown request signal&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L372" title="postmaster/postmaster.c:372">pending_pm_shutdown_request</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If more than one shutdown request signal arrived since the last server<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop, take the one that is the most immediate.&nbsp; That matches the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * priority that would apply if we processed them one by one in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> order.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L374" title="postmaster/postmaster.c:374">pending_pm_immediate_shutdown_request</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L374" title="postmaster/postmaster.c:374">pending_pm_immediate_shutdown_request</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="postmaster/postmaster.c:373">pending_pm_fast_shutdown_request</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mode = <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L373" title="postmaster/postmaster.c:373">pending_pm_fast_shutdown_request</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="postmaster/postmaster.c:373">pending_pm_fast_shutdown_request</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mode = <a href="#L266" title="postmaster/postmaster.c:266">FastShutdown</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; mode = <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (mode)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Smart <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait for children to end their work, then shut down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> = <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received smart shutdown request&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);<br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sd_notify(<span class="Constant">0</span>, <span class="Constant">&quot;STOPPING=1&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we reached normal running, we go straight to <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * client backends to exit.&nbsp; If already in PM_STOP_BACKENDS or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later state, do not change it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* There should be no clients, so proceed to stop children */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_STOP_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now wait for online backup mode to end and backends to exit. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that is already the case, <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> will take the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L266" title="postmaster/postmaster.c:266">FastShutdown</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fast <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort all children with SIGTERM (rollback active transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and exit) and shut down when they are gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt;= <a href="#L266" title="postmaster/postmaster.c:266">FastShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> = <a href="#L266" title="postmaster/postmaster.c:266">FastShutdown</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received fast shutdown request&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);<br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sd_notify(<span class="Constant">0</span>, <span class="Constant">&quot;STOPPING=1&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Just shut down background processes silently */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_STOP_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report that we're about to zap live client sessions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aborting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active transactions&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_STOP_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> will issue <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> necessary signals, or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step if no child processes need to be killed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Immediate <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a>:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * abort all children with SIGQUIT, wait for them to exit,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminate remaining ones with SIGKILL, then exit without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attempt to properly shut down the data base system.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt;= <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> = <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received immediate shutdown request&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STOPPING);<br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sd_notify(<span class="Constant">0</span>, <span class="Constant">&quot;STOPPING=1&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tell children to shut down ASAP */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (note we don't apply <a href="#L237" title="postmaster/postmaster.c:237">send_abort_for_crash</a> here) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L218" title="storage/ipc/pmsignal.c:218">SetQuitSignalReason</a>(PMQUIT_FOR_STOP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3509" title="postmaster/postmaster.c:3509">TerminateChildren</a>(<span class="Constant">SIGQUIT</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_BACKENDS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* set stopwatch for them to <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now wait for backends to exit.&nbsp; If there are <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> will take the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2343">&#x200c;</a></span><span class="linkable">handle_pm_child_exit_signal</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L370" title="postmaster/postmaster.c:370">pending_pm_child_exit</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cleanup after a child process dies.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2353">&#x200c;</a></span><span class="linkable">process_pm_child_exit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* process id of dead child process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exitstatus;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* its exit status */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L370" title="postmaster/postmaster.c:370">pending_pm_child_exit</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;reaping dead processes&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((pid = <a href="#L4592" title="postmaster/postmaster.c:4592">waitpid</a>(-<span class="Constant">1</span>, &amp;exitstatus, <a href="#L450" title="postmaster/postmaster.c:450">WNOHANG</a>)) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if this child was a startup process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Startup process exited in response to a shutdown request (or it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completed normally regardless of the shutdown request).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt; <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) || <a href="#L471" title="postmaster/postmaster.c:471">EXIT_STATUS_1</a>(exitstatus)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_NOT_RUNNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> logic does the rest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L472" title="postmaster/postmaster.c:472">EXIT_STATUS_3</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;shutdown at recovery target&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_NOT_RUNNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> = Max(<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a>, <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3509" title="postmaster/postmaster.c:3509">TerminateChildren</a>(<span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> logic does the rest */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unexpected exit of startup process (including FATAL exit)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during PM_STARTUP is treated as catastrophic. There are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other processes running yet, so we can just exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> != STARTUP_SIGNALED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(LOG, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;startup process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pid, exitstatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;aborting startup due to startup process failure&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * After PM_STARTUP, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unexpected exit (including FATAL exit) of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the startup process is catastrophic, so kill other children,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and set <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> so we don't try to reinitialize after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * they're gone.&nbsp; Exception: if <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> is STARTUP_SIGNALED,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we previously sent the startup process a SIGQUIT; so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's probably the reason it died, and we do want to try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restart in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This stanza also handles the case where we sent a SIGQUIT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * during PM_STARTUP due to some dead_end child crashing: in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * situation, if the startup process dies on the SIGQUIT, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to transition to PM_WAIT_BACKENDS state which will allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> to restart the startup process.&nbsp; (On the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other hand, the startup process might complete normally, if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were too late with the SIGQUIT.&nbsp; In that case we'll fall<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through and commence normal operations.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> == STARTUP_SIGNALED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_NOT_RUNNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_CRASHED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;startup process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Startup succeeded, commence normal operations<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_NOT_RUNNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L348" title="postmaster/postmaster.c:348">ReachedNormalRunning</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_RUN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Crank up the background tasks, if we didn't do that already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when we entered consistent recovery state.&nbsp; It doesn't matter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if this fails, we'll just try again later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_CHECKPOINTER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_BG_WRITER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_WAL_WRITER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4070" title="postmaster/postmaster.c:4070">MaybeStartWalSummarizer</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, start other special children as needed.&nbsp; In a restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * situation, some of them may be alive already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> &amp;&amp; <a href="autovacuum.c.html#L3189" title="postmaster/autovacuum.c:3189">AutoVacuumingActive</a>() &amp;&amp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_AUTOVAC_LAUNCHER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L441" title="postmaster/postmaster.c:441">PgArchStartupAllowed</a>() &amp;&amp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_ARCHIVER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4089" title="postmaster/postmaster.c:4089">MaybeStartSlotSyncWorker</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* workers may be scheduled to start <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4409" title="postmaster/postmaster.c:4409">maybe_start_bgworkers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* at this point we are really open for business */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system is ready to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> connections&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_READY);<br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sd_notify(<span class="Constant">0</span>, <span class="Constant">&quot;READY=1&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the bgwriter?&nbsp; Normal exit can be ignored; we'll start a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary.&nbsp; Any other exit condition is treated as a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;background writer process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the checkpointer?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK, we saw normal exit of the checkpointer after it's been<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * told to shut down.&nbsp; We expect that it wrote a shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpoint.&nbsp; (If for some reason it didn't, recovery will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occur on <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> postmaster start.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we should have no normal backend children<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left (else we'd not be in PM_SHUTDOWN state) but we might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have dead_end children to wait for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have an archiver subprocess, tell it to do a last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive cycle and quit. Likewise, if we have walsender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processes, tell them to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining WAL and quit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt; <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Waken archiver for the last time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>, <span class="Constant">SIGUSR2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Waken walsenders for the last time. No regular backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be around anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="postmaster/postmaster.c:422">SignalChildren</a>(<span class="Constant">SIGUSR2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_SHUTDOWN_2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any unexpected exit of the checkpointer (including FATAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exit) is treated as a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;checkpointer process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the wal writer?&nbsp; Normal exit can be ignored; we'll start a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new one at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary.&nbsp; Any other exit condition is treated as a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;WAL writer process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the wal receiver?&nbsp; If exit status is zero (normal) or one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (FATAL exit), we assume everything is all right just like normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends.&nbsp; (If we need a new wal receiver, we'll start one at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) &amp;&amp; !<a href="#L471" title="postmaster/postmaster.c:471">EXIT_STATUS_1</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;WAL receiver process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the wal summarizer? Normal exit can be ignored; we'll start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a new one at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary.&nbsp; Any other exit condition is treated as a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;WAL summarizer process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the autovacuum launcher?&nbsp; &nbsp; Normal exit can be ignored; we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start a new one at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop, if necessary.&nbsp; Any other exit condition is treated as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;autovacuum launcher process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the archiver?&nbsp; If exit status is zero (normal) or one (FATAL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exit), we assume everything is all right just like normal backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and just try to restart a new one so that we immediately retry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archiving remaining files. (If fail, we'll try again in future<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cycles of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.) Unless we were <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it to shut down; don't restart it in that case, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>() will advance to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> shutdown step.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) &amp;&amp; !<a href="#L471" title="postmaster/postmaster.c:471">EXIT_STATUS_1</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;archiver process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L441" title="postmaster/postmaster.c:441">PgArchStartupAllowed</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_ARCHIVER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Was it the system logger?&nbsp; If so, try to start a new one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for safety's sake, launch new logger *first* */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> = <a href="syslogger.c.html#L595" title="postmaster/syslogger.c:595">SysLogger_Start</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(LOG, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;system logger process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pid, exitstatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Was it the slot sync worker? Normal exit or FATAL exit can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ignored (FATAL can be caused by libpqwalreceiver on receiving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shutdown request by the startup process during promotion); we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start a new one at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration of the postmaster's <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * loop, if necessary. Any other exit condition is treated as a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) &amp;&amp; !<a href="#L471" title="postmaster/postmaster.c:471">EXIT_STATUS_1</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;slot sync worker process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Was it one of our background workers? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2695" title="postmaster/postmaster.c:2695">CleanupBackgroundWorker</a>(pid, exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have it be restarted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Else do standard backend child <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2790" title="postmaster/postmaster.c:2790">CleanupBackend</a>(pid, exitstatus);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* loop over pending child-death reports */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After cleaning out the SIGCHLD queue, see if we have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> state changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or actions to make.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan the bgworkers list and see if the given PID (which has just stopped<br/></li>
<li></span><span class="Comment"> * or crashed) is in it.&nbsp; Handle its shutdown if so, and return true.&nbsp; If not a<br/></li>
<li></span><span class="Comment"> * bgworker, return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is heavily based on <a href="#L2790" title="postmaster/postmaster.c:2790">CleanupBackend</a>.&nbsp; One important difference is that<br/></li>
<li></span><span class="Comment"> * we don't know yet that the dying process is a bgworker, so we must be silent<br/></li>
<li></span><span class="Comment"> * until we're sure it is.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2695">&#x200c;</a></span><span class="linkable">CleanupBackgroundWorker</span>(<span class="Type">int</span> pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> exitstatus) <span class="Comment">/* child's exit status */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; namebuf[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; slist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach_modify(iter, &amp;<a href="bgworker.c.html#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_pid != pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see <a href="#L2790" title="postmaster/postmaster.c:2790">CleanupBackend</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exitstatus == ERROR_WAIT_NO_CHILDREN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exitstatus = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(namebuf, MAXPGPATH, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw-&gt;rw_worker.bgw_type);<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Record timestamp, so we know when to restart the worker. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Zero exit status means terminate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_terminate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Additionally, just like a backend, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> exit status other than 0 or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 1 is considered a crash and causes a system-wide restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) &amp;&amp; !<a href="#L471" title="postmaster/postmaster.c:471">EXIT_STATUS_1</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus, namebuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must release the postmaster child slot. If the worker failed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do so, it did not clean up after itself, requiring a crash-restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cycle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(rw-&gt;rw_child_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus, namebuf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get it out of the <a href="#L179" title="postmaster/postmaster.c:179">BackendList</a> and clear out remaining data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;rw-&gt;rw_backend-&gt;elem);<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4574" title="postmaster/postmaster.c:4574">ShmemBackendArrayRemove</a>(rw-&gt;rw_backend);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's possible that this background worker started some OTHER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * background worker and asked to be notified when that worker started<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or stopped.&nbsp; If so, cancel <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> notifications destined for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-dead backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_backend-&gt;bgworker_notify)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L520" title="postmaster/bgworker.c:520">BackgroundWorkerStopNotifications</a>(rw-&gt;rw_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rw-&gt;rw_backend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_backend = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_child_slot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L486" title="postmaster/bgworker.c:486">ReportBackgroundWorkerExit</a>(&amp;iter);&nbsp; &nbsp; <span class="Comment">/* report child death */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) ? DEBUG1 : LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; namebuf, pid, exitstatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2790" title="postmaster/postmaster.c:2790">CleanupBackend</a> -- <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> after terminated backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove all local state associated with backend.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If you change this, see also <a href="#L2695" title="postmaster/postmaster.c:2695">CleanupBackgroundWorker</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2790">&#x200c;</a></span><span class="linkable">CleanupBackend</span>(<span class="Type">int</span> pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> exitstatus)&nbsp; &nbsp; <span class="Comment">/* child's exit status. */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(DEBUG2, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;server process&quot;</span>), pid, exitstatus);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a backend dies in an ugly way then we must signal all other backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../tcop/postgres.c.html#L2875" title="tcop/postgres.c:2875">quickdie</a>.&nbsp; If exit status is zero (normal) or one (FATAL exit), we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume everything is all right and proceed to remove the backend from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the active backend list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On win32, also treat ERROR_WAIT_NO_CHILDREN (128) as nonfatal case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since that sometimes happens under load when the process fails to start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * properly (long <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it starts using shared memory). Microsoft reports<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it is related to mutex failure:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * http://archives.postgresql.org/pgsql-hackers/2010-09/msg00790.php<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (exitstatus == ERROR_WAIT_NO_CHILDREN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(LOG, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;server process&quot;</span>), pid, exitstatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exitstatus = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus) &amp;&amp; !<a href="#L471" title="postmaster/postmaster.c:471">EXIT_STATUS_1</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;server process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bp = dlist_container(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>, elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bp-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(bp-&gt;child_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Uh-oh, the child failed to clean itself up.&nbsp; Treat as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crash after all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a>(pid, exitstatus, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;server process&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4574" title="postmaster/postmaster.c:4574">ShmemBackendArrayRemove</a>(bp);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;bgworker_notify)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This backend may have been slated to receive SIGUSR1 when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some background worker started or stopped.&nbsp; Cancel those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notifications, as we don't want to signal PIDs that are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PostgreSQL backends.&nbsp; This gets skipped in the (probably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * very common) case where the backend has never requested <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such notifications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L520" title="postmaster/bgworker.c:520">BackgroundWorkerStopNotifications</a>(bp-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2874" title="postmaster/postmaster.c:2874">HandleChildCrash</a> -- <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> after failed backend, bgwriter, checkpointer,<br/></li>
<li></span><span class="Comment"> * walwriter, autovacuum, archiver, slot sync worker, or background worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The objectives here are to clean up our local state about the child<br/></li>
<li></span><span class="Comment"> * process, and to signal all other remaining children to <a href="../tcop/postgres.c.html#L2875" title="tcop/postgres.c:2875">quickdie</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2874">&#x200c;</a></span><span class="linkable">HandleChildCrash</span>(<span class="Type">int</span> pid, <span class="Type">int</span> exitstatus, <span class="Type">const</span> <span class="Type">char</span> *procname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_mutable_iter iter;<br/></li>
<li>&nbsp; &nbsp; slist_iter&nbsp; &nbsp; siter;<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; take_action;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only log messages and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> signals if this is the first process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash and we're not doing an immediate shutdown; otherwise, we're only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here to update postmaster's idea of live processes.&nbsp; If we have already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signaled children, nonzero exit status is to be expected, so don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clutter log.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; take_action = !<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> &amp;&amp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> != <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (take_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3061" title="postmaster/postmaster.c:3061">LogChildExit</a>(LOG, procname, pid, exitstatus);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other active server processes&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L218" title="storage/ipc/pmsignal.c:218">SetQuitSignalReason</a>(PMQUIT_FOR_CRASH);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process background workers. */<br/></li>
<li></span>&nbsp; &nbsp; slist_foreach(siter, &amp;<a href="bgworker.c.html#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, siter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_pid == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not running */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found entry for freshly-dead worker, so remove it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(rw-&gt;rw_child_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(&amp;rw-&gt;rw_backend-&gt;elem);<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4574" title="postmaster/postmaster.c:4574">ShmemBackendArrayRemove</a>(rw-&gt;rw_backend);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rw-&gt;rw_backend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_backend = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_child_slot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't reset crashed_at */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't report child stop, either */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep looping so we can signal remaining workers */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This worker is still alive.&nbsp; Unless we did so already, tell it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to commit hara-kiri.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(rw-&gt;rw_pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process regular backends */<br/></li>
<li></span>&nbsp; &nbsp; dlist_foreach_modify(iter, &amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bp = dlist_container(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>, elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found entry for freshly-dead backend, so remove it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bp-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(bp-&gt;child_slot);<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4574" title="postmaster/postmaster.c:4574">ShmemBackendArrayRemove</a>(bp);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_delete(iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Keep looping so we can signal remaining backends */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This backend is still alive.&nbsp; Unless we did so already, tell it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to commit hara-kiri.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could exclude dead_end children here, but at least when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sending SIGABRT it seems better to include them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Background workers were already processed above; ignore them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;bkend_type == <a href="#L139" title="postmaster/postmaster.c:139">BACKEND_TYPE_BGWORKER</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(bp-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the startup process too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Caller adjusts <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a>, so don't touch it here */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_SIGNALED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the bgwriter too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the checkpointer too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the walwriter too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the walreceiver too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the walsummarizer too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the autovacuum launcher too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the archiver too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Take care of the slot sync worker too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pid == <a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> != <span class="Constant">0</span> &amp;&amp; take_action)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3451" title="postmaster/postmaster.c:3451">sigquit_child</a>(<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We do NOT restart the syslogger */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> != <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> transit into a state of <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for children to <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STOP_BACKENDS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_SHUTDOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_BACKENDS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * .. and if this doesn't happen quickly enough, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> the clock is ticking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for us to kill them without mercy.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> = time(<span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Log the death of a child process.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3061">&#x200c;</a></span><span class="linkable">LogChildExit</span>(<span class="Type">int</span> lev, <span class="Type">const</span> <span class="Type">char</span> *procname, <span class="Type">int</span> pid, <span class="Type">int</span> exitstatus)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * size of activity_buffer is arbitrary, but set <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * track_activity_query_size<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activity_buffer[<span class="Constant">1024</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *activity = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L470" title="postmaster/postmaster.c:470">EXIT_STATUS_0</a>(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; activity = <a href="../utils/activity/backend_status.c.html#L963" title="utils/activity/backend_status.c:963">pgstat_get_crashed_backend_activity</a>(pid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activity_buffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activity_buffer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (WIFEXITED(exitstatus))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(lev,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a noun phrase describing a child process, such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;server process&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (PID </span><span class="Special">%d</span><span class="Constant">) exited with exit code </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procname, pid, WEXITSTATUS(exitstatus)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activity ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed process was running: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, activity) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (WIFSIGNALED(exitstatus))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#if defined(WIN32)<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(lev,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a noun phrase describing a child process, such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;server process&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (PID </span><span class="Special">%d</span><span class="Constant">) was terminated by exception 0x</span><span class="Special">%X</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procname, pid, WTERMSIG(exitstatus)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;See C include file </span><span class="Special">\&quot;</span><span class="Constant">ntstatus.h</span><span class="Special">\&quot;</span><span class="Constant"> for a description of the hexadecimal value.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activity ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed process was running: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, activity) : <span class="Constant">0</span>));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(lev,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a noun phrase describing a child process, such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;server process&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (PID </span><span class="Special">%d</span><span class="Constant">) was terminated by signal </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procname, pid, WTERMSIG(exitstatus),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_strsignal(WTERMSIG(exitstatus))),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activity ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed process was running: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, activity) : <span class="Constant">0</span>));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(lev,<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a noun phrase describing a child process, such as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;server process&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (PID </span><span class="Special">%d</span><span class="Constant">) exited with unrecognized status </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procname, pid, exitstatus),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; activity ? <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed process was running: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, activity) : <span class="Constant">0</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance the postmaster's state machine and take actions as appropriate<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is common code for <a href="#L2192" title="postmaster/postmaster.c:2192">process_pm_shutdown_request</a>(),<br/></li>
<li></span><span class="Comment"> * <a href="#L2353" title="postmaster/postmaster.c:2353">process_pm_child_exit</a>() and <a href="#L3702" title="postmaster/postmaster.c:3702">process_pm_pmsignal</a>(), which process the signals<br/></li>
<li></span><span class="Comment"> * that might mean we need to change state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3127">&#x200c;</a></span><span class="linkable">PostmasterStateMachine</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're doing a smart shutdown, try to advance that state. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This state ends when we have no normal client backends running.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Then we're ready to stop other children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3878" title="postmaster/postmaster.c:3878">CountChildren</a>(<a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_STOP_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're ready to do so, signal child processes to shut down.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * isn't a persistent state, but treating it as a distinct <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> allows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us to share this code across multiple shutdown code paths.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STOP_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forget <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending requests for background workers, since we're no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * longer willing to launch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new workers.&nbsp; (If additional requests<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arrive, <a href="bgworker.c.html#L246" title="postmaster/bgworker.c:246">BackgroundWorkerStateChange</a> will reject them.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L547" title="postmaster/bgworker.c:547">ForgetUnstartedBackgroundWorkers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Signal all backend children except walsenders */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3465" title="postmaster/postmaster.c:3465">SignalSomeChildren</a>(<span class="Constant">SIGTERM</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a> - <a href="#L138" title="postmaster/postmaster.c:138">BACKEND_TYPE_WALSND</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the autovac launcher too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the bgwriter too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and the walwriter too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we're in recovery, also stop startup and walreceiver procs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a>, <span class="Constant">SIGTERM</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* checkpointer, archiver, stats, and syslogger may continue for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now transition to PM_WAIT_BACKENDS state to wait for them to <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_BACKENDS;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in a state-machine state that implies <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for backends to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exit, see if they're all gone, and change state if so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_WAIT_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PM_WAIT_BACKENDS state ends when we have no regular backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (including autovac workers), no bgworkers (including unconnected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ones), and no walwriter, autovac launcher, bgwriter or slot sync<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worker.&nbsp; If we are doing crash recovery or an immediate shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we expect the checkpointer to exit as well, otherwise not. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * stats and syslogger processes are disregarded since they are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connected to shared memory; we also disregard dead_end children<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here. Walsenders and archiver are also disregarded, they will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * terminated later after writing the checkpoint record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3878" title="postmaster/postmaster.c:3878">CountChildren</a>(<a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a> - <a href="#L138" title="postmaster/postmaster.c:138">BACKEND_TYPE_WALSND</a>) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> &amp;&amp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt; <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a>)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt;= <a href="#L267" title="postmaster/postmaster.c:267">ImmediateShutdown</a> || <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for dead_end children to <a href="../tcop/postgres.c.html#L2972" title="tcop/postgres.c:2972">die</a>.&nbsp; This state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change causes <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> to stop creating new ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_DEAD_END;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We already SIGQUIT'd the archiver and stats processes, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, when we started immediate shutdown or entered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get here, we are proceeding with normal shutdown. All<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the regular children are gone, and it's time to tell the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * checkpointer to do a shutdown checkpoint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt; <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start the checkpointer if not running */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_CHECKPOINTER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* And tell it to shut down */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a>, <span class="Constant">SIGUSR2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_SHUTDOWN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we failed to fork a checkpointer, just shut down.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any required <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> will happen at <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> restart. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> so that an &quot;abnormal shutdown&quot; message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gets logged when we exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't consult <a href="#L237" title="postmaster/postmaster.c:237">send_abort_for_crash</a> here, as it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unlikely that dumping cores would illuminate the reason<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for checkpointer fork failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_DEAD_END;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Kill the walsenders and archiver too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L422" title="postmaster/postmaster.c:422">SignalChildren</a>(<span class="Constant">SIGQUIT</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>, <span class="Constant">SIGQUIT</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_SHUTDOWN_2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PM_SHUTDOWN_2 state ends when there's no other children than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dead_end children left. There shouldn't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> regular backends<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * left by <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> anyway; what we're really <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for is walsenders and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archiver.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> == <span class="Constant">0</span> &amp;&amp; <a href="#L3878" title="postmaster/postmaster.c:3878">CountChildren</a>(<a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_WAIT_DEAD_END;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_WAIT_DEAD_END)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't allow <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> connection events. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1601" title="postmaster/postmaster.c:1601">ConfigurePostmasterWaitSet</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PM_WAIT_DEAD_END state ends when the <a href="#L179" title="postmaster/postmaster.c:179">BackendList</a> is entirely empty<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (ie, no dead_end children remain), and the archiver is gone too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The reason we wait for those two is to protect them against a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postmaster starting conflicting subprocesses; this isn't an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ironclad protection, but it at least helps in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shutdown-and-immediately-restart scenario.&nbsp; Note that they have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already been sent appropriate shutdown signals, either during a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * normal state transition leading up to PM_WAIT_DEAD_END, or during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dlist_is_empty(&amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>) &amp;&amp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* These other guys should be dead already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* syslogger is not considered here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_NO_CHILDREN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we've been told to shut down, we exit as soon as there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remaining children.&nbsp; If there was a crash, <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> will occur at the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> startup.&nbsp; (Before PostgreSQL 8.3, we tried to recover from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * crash <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting, but that seems unwise if we are quitting because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we got SIGTERM from init --- there may well not be time for recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> init decides to SIGKILL us.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the syslogger continues to run.&nbsp; It will exit when it sees<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EOF on its input pipe, which happens when there are no more upstream<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &gt; <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_NO_CHILDREN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG, (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;abnormal database system shutdown&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normal exit from the postmaster is here.&nbsp; We don't need to log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything here, since the <a href="../utils/init/miscinit.c.html#L1115" title="utils/init/miscinit.c:1115">UnlinkLockFiles</a> <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> callback<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will do so, and that should be the last user-visible action.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the startup process failed, or the user does not want an automatic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart after backend crashes, wait for all non-syslogger children to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exit, and then exit postmaster.&nbsp; We don't try to reinitialize when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup process fails, because more than likely it will just fail again<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we will keep trying forever.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_NO_CHILDREN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> == STARTUP_CRASHED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;shutting down due to startup process failure&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L235" title="postmaster/postmaster.c:235">restart_after_crash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;shutting down because <a href="#L235" title="postmaster/postmaster.c:235">restart_after_crash</a> is off&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we need to recover from a crash, wait for all non-syslogger children<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to exit, then reset shmem and start the startup process.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_NO_CHILDREN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;all server processes terminated; reinitializing&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* remove leftover temporary files after a crash */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L236" title="postmaster/postmaster.c:236">remove_temp_files_after_crash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3274" title="storage/file/fd.c:3274">RemovePgTempFiles</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allow background workers to immediately restart */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L585" title="postmaster/bgworker.c:585">ResetBackgroundWorkerCrashTimes</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L228" title="storage/ipc/ipc.c:228">shmem_exit</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-read control file into local memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L4813" title="access/transam/xlog.c:4813">LocalProcessControlFile</a>(<span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* re-create shared memory and semaphores */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipci.c.html#L199" title="storage/ipc/ipci.c:199">CreateSharedMemoryAndSemaphores</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_STARTUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_RUNNING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_STARTUP;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* crash recovery started, reset SIGKILL flag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start accepting server <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> connection events again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1601" title="postmaster/postmaster.c:1601">ConfigurePostmasterWaitSet</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a signal to a postmaster child process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On systems that have setsid(), each child process sets itself up as a<br/></li>
<li></span><span class="Comment"> * process group leader.&nbsp; For signals that are generally interpreted in the<br/></li>
<li></span><span class="Comment"> * appropriate fashion, we signal the entire process group not just the<br/></li>
<li></span><span class="Comment"> * direct child process.&nbsp; This allows us to, for example, SIGQUIT a blocked<br/></li>
<li></span><span class="Comment"> * archive_recovery script, or SIGINT a script being run by a backend via<br/></li>
<li></span><span class="Comment"> * system().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * There is a race condition for recently-forked children: they might not<br/></li>
<li></span><span class="Comment"> * have executed setsid() yet.&nbsp; So we signal the child directly as well as<br/></li>
<li></span><span class="Comment"> * the group.&nbsp; We assume such a child will handle the signal <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying<br/></li>
<li></span><span class="Comment"> * to spawn <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> grandchild processes.&nbsp; We also assume that signaling the<br/></li>
<li></span><span class="Comment"> * child twice will not cause <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3421">&#x200c;</a></span><span class="linkable">signal_child</span>(pid_t pid, <span class="Type">int</span> signal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (kill(pid, signal) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;kill(</span><span class="Special">%ld</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">) failed: %m&quot;</span>, (<span class="Type">long</span>) pid, signal);<br/></li>
<li><span class="PreProc">#ifdef HAVE_SETSID<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (signal)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGINT</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGTERM</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGQUIT</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGKILL</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">SIGABRT</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kill(-pid, signal) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;kill(</span><span class="Special">%ld</span><span class="Constant">,</span><span class="Special">%d</span><span class="Constant">) failed: %m&quot;</span>, (<span class="Type">long</span>) (-pid), signal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience function for killing a child process after a crash of some<br/></li>
<li></span><span class="Comment"> * other child process.&nbsp; We log the action at a higher level than we would<br/></li>
<li></span><span class="Comment"> * otherwise do, and we apply <a href="#L237" title="postmaster/postmaster.c:237">send_abort_for_crash</a> to decide which signal<br/></li>
<li></span><span class="Comment"> * to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>.&nbsp; Normally it's SIGQUIT -- and most other comments in this file<br/></li>
<li></span><span class="Comment"> * are written on the assumption that it is -- but developers might prefer<br/></li>
<li></span><span class="Comment"> * to use SIGABRT to collect per-child core dumps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3451">&#x200c;</a></span><span class="linkable">sigquit_child</span>(pid_t pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;sending </span><span class="Special">%s</span><span class="Constant"> to process </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="#L237" title="postmaster/postmaster.c:237">send_abort_for_crash</a> ? <span class="Constant">&quot;SIGABRT&quot;</span> : <span class="Constant">&quot;SIGQUIT&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) pid)));<br/></li>
<li>&nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(pid, (<a href="#L237" title="postmaster/postmaster.c:237">send_abort_for_crash</a> ? <span class="Constant">SIGABRT</span> : <span class="Constant">SIGQUIT</span>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a signal to the targeted children (but NOT special children;<br/></li>
<li></span><span class="Comment"> * dead_end children are never signaled, either).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3465">&#x200c;</a></span><span class="linkable">SignalSomeChildren</span>(<span class="Type">int</span> signal, <span class="Type">int</span> target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; signaled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bp = dlist_container(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>, elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since target == <a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a> is the most common case, we test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it first and avoid touching shared memory for every child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target != <a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assign bkend_type for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recently announced WAL Sender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;bkend_type == <a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L307" title="storage/ipc/pmsignal.c:307">IsPostmasterChildWalSender</a>(bp-&gt;child_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp-&gt;bkend_type = <a href="#L138" title="postmaster/postmaster.c:138">BACKEND_TYPE_WALSND</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(target &amp; bp-&gt;bkend_type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG4,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;sending signal </span><span class="Special">%d</span><span class="Constant"> to process </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; signal, (<span class="Type">int</span>) bp-&gt;pid)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(bp-&gt;pid, signal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; signaled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> signaled;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a termination signal to children.&nbsp; This considers all of our children<br/></li>
<li></span><span class="Comment"> * processes, except syslogger and dead_end backends.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3509">&#x200c;</a></span><span class="linkable">TerminateChildren</span>(<span class="Type">int</span> signal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L422" title="postmaster/postmaster.c:422">SignalChildren</a>(signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (signal == <span class="Constant">SIGQUIT</span> || signal == <span class="Constant">SIGKILL</span> || signal == <span class="Constant">SIGABRT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L261" title="postmaster/postmaster.c:261">StartupStatus</a> = STARTUP_SIGNALED;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L242" title="postmaster/postmaster.c:242">BgWriterPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L243" title="postmaster/postmaster.c:243">CheckpointerPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L244" title="postmaster/postmaster.c:244">WalWriterPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a>, signal);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a>, signal);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3544" title="postmaster/postmaster.c:3544">BackendStartup</a> -- start backend process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns: STATUS_ERROR if the fork failed, STATUS_OK otherwise.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if you change this code, also consider <a href="#L3960" title="postmaster/postmaster.c:3960">StartAutovacuumWorker</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3544">&#x200c;</a></span><span class="linkable">BackendStartup</span>(ClientSocket *client_sock)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bn;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for backend <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> */<br/></li>
<li></span>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li>&nbsp; &nbsp; BackendStartupData startup_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create backend data structure.&nbsp; Better <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the fork() so we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handle failure cleanly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bn = (<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *) <a href="../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>), MCXT_ALLOC_NO_OOM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!bn)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the cancel key that will be assigned to this backend. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend will have its own copy in the forked-off process' value of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>, so that it can transmit the key to the frontend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3868" title="postmaster/postmaster.c:3868">RandomCancelKey</a>(&amp;<a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random cancel key&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pass down <a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a> state */<br/></li>
<li></span>&nbsp; &nbsp; startup_data.<a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a> = <a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a>(<a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a>);<br/></li>
<li>&nbsp; &nbsp; bn-&gt;dead_end = (startup_data.<a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a> != CAC_OK);<br/></li>
<li>&nbsp; &nbsp; bn-&gt;cancel_key = <a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unless it's a dead_end child, assign it a child slot number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bn-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;child_slot = <a href="../utils/init/globals.c.html#L51" title="utils/init/globals.c:51">MyPMChildSlot</a> = <a href="../storage/ipc/pmsignal.c.html#L247" title="storage/ipc/pmsignal.c:247">AssignPostmasterChildSlot</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;child_slot = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Hasn't asked to be notified about <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bgworkers yet */<br/></li>
<li></span>&nbsp; &nbsp; bn-&gt;bgworker_notify = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pid = <a href="launch_backend.c.html#L226" title="postmaster/launch_backend.c:226">postmaster_child_launch</a>(B_BACKEND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">char</span> *) &amp;startup_data, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(startup_data),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; client_sock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in parent, fork failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!bn-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(bn-&gt;child_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fork new process for connection: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3641" title="postmaster/postmaster.c:3641">report_fork_failure_to_client</a>(client_sock, save_errno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in parent, successful fork */<br/></li>
<li></span>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;forked new backend, pid=</span><span class="Special">%d</span><span class="Constant"> <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>=</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) pid, (<span class="Type">int</span>) client_sock-&gt;sock)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Everything's been successful, it's safe to add this backend to our list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of backends.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bn-&gt;pid = pid;<br/></li>
<li>&nbsp; &nbsp; bn-&gt;bkend_type = <a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a>;&nbsp; &nbsp; <span class="Comment">/* Can change later to WALSND */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_head(&amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>, &amp;bn-&gt;elem);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!bn-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4564" title="postmaster/postmaster.c:4564">ShmemBackendArrayAdd</a>(bn);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to report backend fork() failure to client <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we close the<br/></li>
<li></span><span class="Comment"> * connection.&nbsp; Since we do not care to risk blocking the postmaster on<br/></li>
<li></span><span class="Comment"> * this connection, we set the connection to non-blocking and try only once.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is grungy special-purpose code; we cannot use backend libpq since<br/></li>
<li></span><span class="Comment"> * it's not up and running.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3641">&#x200c;</a></span><span class="linkable">report_fork_failure_to_client</span>(ClientSocket *client_sock, <span class="Type">int</span> errnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; buffer[<span class="Constant">1000</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Format the error message packet (always V2 protocol) */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(buffer, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(buffer), <span class="Constant">&quot;E</span><span class="Special">%s%s\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;could not fork new process for connection: &quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strerror(errnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set port to non-blocking.&nbsp; Don't do <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>() if this fails */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pg_set_noblock(client_sock-&gt;sock))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We'll retry after EINTR, but ignore all other failures */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a>(client_sock-&gt;sock, buffer, strlen(buffer) + <span class="Constant">1</span>, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (rc &lt; <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">EINTR</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a> -- <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do NOT call exit() directly --- always go through here!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3668">&#x200c;</a></span><span class="linkable">ExitPostmaster</span>(<span class="Type">int</span> status)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifdef HAVE_PTHREAD_IS_THREADED_NP<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is no known cause for a postmaster to become multithreaded after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup.&nbsp; Recheck to account for the possibility of unknown causes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This message uses LOG level, because an unclean shutdown at this point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would usually not look much different from a clean shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pthread_is_threaded_np() != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;postmaster became multithreaded&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Please report this to &lt;</span><span class="Special">%s</span><span class="Constant">&gt;.&quot;</span>, PACKAGE_BUGREPORT)));<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* should <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> shared memory and kill all backends */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not sure of the semantics here.&nbsp; When the Postmaster dies, should the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backends all be killed? probably not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MUST&nbsp; &nbsp; &nbsp; &nbsp; -- vadim 05-10-1999<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(status);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Handle pmsignal conditions representing requests from backends,<br/></li>
<li></span><span class="Comment"> * and check for promote and logrotate requests from pg_ctl.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3702">&#x200c;</a></span><span class="linkable">process_pm_pmsignal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L369" title="postmaster/postmaster.c:369">pending_pm_pmsignal</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;postmaster received pmsignal signal&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RECOVERY_STARTED and BEGIN_HOT_STANDBY signals are ignored in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unexpected states. If the startup process quickly starts up, completes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recovery, exits, we might process the death of the startup process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * first. We don't want to go back to recovery in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_RECOVERY_STARTED) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP &amp;&amp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> == <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WAL redo has started. We're out of reinitialization. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L271" title="postmaster/postmaster.c:271">FatalError</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L343" title="postmaster/postmaster.c:343">AbortStartTime</a> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start the archiver if we're responsible for (re-)archiving received<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (XLogArchivingAlways())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L248" title="postmaster/postmaster.c:248">PgArchPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_ARCHIVER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't planning to enter hot standby mode later, treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RECOVERY_STARTED as meaning we're out of startup, and report status<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xlog.c.html#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_STANDBY);<br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sd_notify(<span class="Constant">0</span>, <span class="Constant">&quot;READY=1&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_RECOVERY;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_BEGIN_HOT_STANDBY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY &amp;&amp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> == <a href="#L264" title="postmaster/postmaster.c:264">NoShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database system is ready to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> read-only connections&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report status */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1511" title="utils/init/miscinit.c:1511">AddToDataDirLockFile</a>(LOCK_FILE_LINE_PM_STATUS, PM_STATUS_READY);<br/></li>
<li><span class="PreProc">#ifdef USE_SYSTEMD<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sd_notify(<span class="Constant">0</span>, <span class="Constant">&quot;READY=1&quot;</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> = PM_HOT_STANDBY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L339" title="postmaster/postmaster.c:339">connsAllowed</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Some workers may be scheduled to start <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process background worker state changes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_BACKGROUND_WORKER_CHANGE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Accept new worker requests only if not stopping. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L246" title="postmaster/bgworker.c:246">BackgroundWorkerStateChange</a>(<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> &lt; PM_STOP_BACKENDS);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> || <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4409" title="postmaster/postmaster.c:4409">maybe_start_bgworkers</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tell syslogger to rotate logfile if requested */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="syslogger.c.html#L1573" title="postmaster/syslogger.c:1573">CheckLogrotateSignal</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a>, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="syslogger.c.html#L1587" title="postmaster/syslogger.c:1587">RemoveLogrotateSignalFiles</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_ROTATE_LOGFILE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L249" title="postmaster/postmaster.c:249">SysLoggerPID</a>, <span class="Constant">SIGUSR1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_LAUNCHER) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> &lt; PM_STOP_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start one iteration of the autovacuum daemon, even if autovacuuming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is nominally not enabled.&nbsp; This is so we can have an active defense<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * against transaction ID wraparound.&nbsp; We set a flag for the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do it rather than trying to do it here --- this is because the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * autovac process itself may <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the signal, and we want to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that by launching another iteration as soon as the current one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * completes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L356" title="postmaster/postmaster.c:356">start_autovac_launcher</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_START_AUTOVAC_WORKER) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> &lt; PM_STOP_BACKENDS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The autovacuum launcher wants us to start a worker process. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3960" title="postmaster/postmaster.c:3960">StartAutovacuumWorker</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_START_WALRECEIVER))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Startup Process wants us to start the walreceiver process. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start immediately if possible, else remember request for later. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L362" title="postmaster/postmaster.c:362">WalReceiverRequested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4051" title="postmaster/postmaster.c:4051">MaybeStartWalReceiver</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to advance postmaster's state machine, if a child requests it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Be careful about the order of this action relative to this function's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other actions.&nbsp; Generally, this should be after other actions, in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they have effects <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a> would need to know about.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, we should do it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../access/transam/xlogrecovery.c.html#L4463" title="access/transam/xlogrecovery.c:4463">CheckPromoteSignal</a> step, which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (immediate) effect on the state machine, but does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on what state we're in <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/pmsignal.c.html#L198" title="storage/ipc/pmsignal.c:198">CheckPostmasterSignal</a>(PMSIGNAL_ADVANCE_STATE_MACHINE))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3127" title="postmaster/postmaster.c:3127">PostmasterStateMachine</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a> != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogrecovery.c.html#L4463" title="access/transam/xlogrecovery.c:4463">CheckPromoteSignal</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell startup process to finish recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Leave the promote signal file in place and let the Startup process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do the unlink.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3421" title="postmaster/postmaster.c:3421">signal_child</a>(<a href="#L241" title="postmaster/postmaster.c:241">StartupPID</a>, <span class="Constant">SIGUSR2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Dummy signal handler<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use this for signals that we don't actually use in the postmaster,<br/></li>
<li></span><span class="Comment"> * but we do use in backends.&nbsp; If we were to SIG_IGN such signals in the<br/></li>
<li></span><span class="Comment"> * postmaster, then a newly started backend might drop a signal that arrives<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it's able to reconfigure its signal processing.&nbsp; (See notes in<br/></li>
<li></span><span class="Comment"> * tcop/postgres.c.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3860">&#x200c;</a></span><span class="linkable">dummy_handler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a random cancel key.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3868">&#x200c;</a></span><span class="linkable">RandomCancelKey</span>(int32 *cancel_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pg_strong_random(cancel_key, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Count up number of child processes of specified types (dead_end children<br/></li>
<li></span><span class="Comment"> * are always excluded).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L3878">&#x200c;</a></span><span class="linkable">CountChildren</span>(<span class="Type">int</span> target)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cnt = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bp = dlist_container(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>, elem, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;dead_end)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since target == <a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a> is the most common case, we test<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it first and avoid touching shared memory for every child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (target != <a href="#L140" title="postmaster/postmaster.c:140">BACKEND_TYPE_ALL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assign bkend_type for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recently announced WAL Sender<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * processes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;bkend_type == <a href="#L136" title="postmaster/postmaster.c:136">BACKEND_TYPE_NORMAL</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L307" title="storage/ipc/pmsignal.c:307">IsPostmasterChildWalSender</a>(bp-&gt;child_slot))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp-&gt;bkend_type = <a href="#L138" title="postmaster/postmaster.c:138">BACKEND_TYPE_WALSND</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(target &amp; bp-&gt;bkend_type))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cnt++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> cnt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a> -- start an auxiliary process for the postmaster<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;type&quot; determines what kind of child will be started.&nbsp; All child types<br/></li>
<li></span><span class="Comment"> * initially go to AuxiliaryProcessMain, which will handle common setup.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value of <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a> is subprocess' PID, or 0 if failed<br/></li>
<li></span><span class="Comment"> * to start subprocess.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pid_t<br/></li>
<li><a id="L3924">&#x200c;</a><span class="linkable">StartChildProcess</span>(BackendType type)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pid = <a href="launch_backend.c.html#L226" title="postmaster/launch_backend.c:226">postmaster_child_launch</a>(type, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pid &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in parent, fork failed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fork </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> process: %m&quot;</span>, <a href="launch_backend.c.html#L209" title="postmaster/launch_backend.c:209">PostmasterChildName</a>(type))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fork failure is fatal during startup, but there's no need to choke<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * immediately if starting other child types fails.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (type == B_STARTUP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3668" title="postmaster/postmaster.c:3668">ExitPostmaster</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in parent, successful fork<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> pid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3960" title="postmaster/postmaster.c:3960">StartAutovacuumWorker</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Start an autovac worker process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is here because it enters the resulting PID into the<br/></li>
<li></span><span class="Comment"> * postmaster's private backends list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB -- this code very roughly matches <a href="#L3544" title="postmaster/postmaster.c:3544">BackendStartup</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3960">&#x200c;</a></span><span class="linkable">StartAutovacuumWorker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If not in condition to run a process, don't try, but handle it like a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fork failure.&nbsp; This does not normally happen, since the signal is only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supposed to be sent by autovacuum launcher when it's OK to do it, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have to check to avoid race-condition problems during DB state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * changes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a>(<a href="#L137" title="postmaster/postmaster.c:137">BACKEND_TYPE_AUTOVAC</a>) == CAC_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Compute the cancel key that will be assigned to this session. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably don't need cancel keys for autovac workers, but we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * better have something random in the field to prevent unfriendly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * people from sending cancels to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3868" title="postmaster/postmaster.c:3868">RandomCancelKey</a>(&amp;<a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random cancel key&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bn = (<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *) <a href="../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>), MCXT_ALLOC_NO_OOM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bn)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;cancel_key = <a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Autovac workers are not dead_end and need a child slot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;dead_end = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;child_slot = <a href="../utils/init/globals.c.html#L51" title="utils/init/globals.c:51">MyPMChildSlot</a> = <a href="../storage/ipc/pmsignal.c.html#L247" title="storage/ipc/pmsignal.c:247">AssignPostmasterChildSlot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;bgworker_notify = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;pid = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_AUTOVAC_WORKER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bn-&gt;pid &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bn-&gt;bkend_type = <a href="#L137" title="postmaster/postmaster.c:137">BACKEND_TYPE_AUTOVAC</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dlist_push_head(&amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>, &amp;bn-&gt;elem);<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4564" title="postmaster/postmaster.c:4564">ShmemBackendArrayAdd</a>(bn);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fork failed, fall through to report -- actual error message was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logged by <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(bn-&gt;child_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(bn);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report the failure to the launcher, if it's running.&nbsp; (If it's not, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might not even be connected to shared memory, so don't try to call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="autovacuum.c.html#L1337" title="postmaster/autovacuum.c:1337">AutoVacWorkerFailed</a>.)&nbsp; Note that we also need to signal it so that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responds to the condition, but we don't do that here, instead <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> to do it.&nbsp; This way we avoid a ping-pong signaling in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * quick succession between the autovac launcher and postmaster in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * things get ugly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L247" title="postmaster/postmaster.c:247">AutoVacPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="autovacuum.c.html#L1337" title="postmaster/autovacuum.c:1337">AutoVacWorkerFailed</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L359" title="postmaster/postmaster.c:359">avlauncher_needs_signal</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4051" title="postmaster/postmaster.c:4051">MaybeStartWalReceiver</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Start the WAL receiver process, if not running and our state allows.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> is already nonzero, it might seem that we should<br/></li>
<li></span><span class="Comment"> * clear <a href="#L362" title="postmaster/postmaster.c:362">WalReceiverRequested</a>.&nbsp; However, there's a race condition if the<br/></li>
<li></span><span class="Comment"> * walreceiver terminates and the startup process immediately requests a new<br/></li>
<li></span><span class="Comment"> * one: it's quite possible to get the signal for the request <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaping<br/></li>
<li></span><span class="Comment"> * the dead walreceiver process.&nbsp; Better to risk launching an extra<br/></li>
<li></span><span class="Comment"> * walreceiver than to <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> launching one we need.&nbsp; (The walreceiver code<br/></li>
<li></span><span class="Comment"> * has logic to recognize that it should go away if not needed.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4051">&#x200c;</a></span><span class="linkable">MaybeStartWalReceiver</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_STARTUP || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RECOVERY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_WAL_RECEIVER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L245" title="postmaster/postmaster.c:245">WalReceiverPID</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L362" title="postmaster/postmaster.c:362">WalReceiverRequested</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* else leave the flag set, so we'll try again later */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4070" title="postmaster/postmaster.c:4070">MaybeStartWalSummarizer</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Start the WAL summarizer process, if not running and our state allows.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4070">&#x200c;</a></span><span class="linkable">MaybeStartWalSummarizer</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="walsummarizer.c.html#L142" title="postmaster/walsummarizer.c:142">summarize_wal</a> &amp;&amp; <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_RUN || <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L246" title="postmaster/postmaster.c:246">WalSummarizerPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_WAL_SUMMARIZER);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4089" title="postmaster/postmaster.c:4089">MaybeStartSlotSyncWorker</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Start the slot sync worker, if not running and our state allows.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We allow to start the slot sync worker when we are on a hot standby,<br/></li>
<li></span><span class="Comment"> * fast or immediate shutdown is not in progress, slot sync parameters<br/></li>
<li></span><span class="Comment"> * are configured correctly, and it is the first time of worker's launch,<br/></li>
<li></span><span class="Comment"> * or enough time has passed since the worker was launched last.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4089">&#x200c;</a></span><span class="linkable">MaybeStartSlotSyncWorker</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> == <span class="Constant">0</span> &amp;&amp; <a href="#L331" title="postmaster/postmaster.c:331">pmState</a> == PM_HOT_STANDBY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L269" title="postmaster/postmaster.c:269">Shutdown</a> &lt;= <a href="#L265" title="postmaster/postmaster.c:265">SmartShutdown</a> &amp;&amp; <a href="../replication/logical/slotsync.c.html#L109" title="replication/logical/slotsync.c:109">sync_replication_slots</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/logical/slotsync.c.html#L1039" title="replication/logical/slotsync.c:1039">ValidateSlotSyncParams</a>(LOG) &amp;&amp; <a href="../replication/logical/slotsync.c.html#L1630" title="replication/logical/slotsync.c:1630">SlotSyncWorkerCanRestart</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L250" title="postmaster/postmaster.c:250">SlotSyncWorkerPID</a> = <a href="#L3924" title="postmaster/postmaster.c:3924">StartChildProcess</a>(B_SLOTSYNC_WORKER);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create the opts file<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4101">&#x200c;</a></span><span class="linkable">CreateOptsFile</span>(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[], <span class="Type">char</span> *fullprogname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fp;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li><a id="L4106">&#x200c;</a><span class="PreProc">#define <span class="linkable">OPTS_FILE</span>&nbsp; &nbsp; </span><span class="Constant">&quot;postmaster.opts&quot;<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((fp = fopen(<a href="#L4106" title="postmaster/postmaster.c:4106">OPTS_FILE</a>, <span class="Constant">&quot;w&quot;</span>)) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, <a href="#L4106" title="postmaster/postmaster.c:4106">OPTS_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(fp, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, fullprogname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; argc; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(fp, <span class="Constant">&quot; </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>, argv[i]);<br/></li>
<li>&nbsp; &nbsp; fputs(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>, fp);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fclose(fp))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, <a href="#L4106" title="postmaster/postmaster.c:4106">OPTS_FILE</a>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4145" title="postmaster/postmaster.c:4145">MaxLivePostmasterChildren</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This reports the number of entries needed in per-child-process arrays<br/></li>
<li></span><span class="Comment"> * (the PMChildFlags array, and if EXEC_BACKEND the <a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>).<br/></li>
<li></span><span class="Comment"> * These arrays include regular backends, autovac workers, walsenders<br/></li>
<li></span><span class="Comment"> * and background workers, but not special children nor dead_end children.<br/></li>
<li></span><span class="Comment"> * This allows the arrays to have a fixed maximum size, to wit the same<br/></li>
<li></span><span class="Comment"> * too-many-children limit enforced by <a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a>().&nbsp; The exact value<br/></li>
<li></span><span class="Comment"> * isn't too critical as long as it's more than <a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L4145">&#x200c;</a></span><span class="linkable">MaxLivePostmasterChildren</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span> * (<a href="../utils/init/globals.c.html#L140" title="utils/init/globals.c:140">MaxConnections</a> + <a href="autovacuum.c.html#L117" title="postmaster/autovacuum.c:117">autovacuum_max_workers</a> + <span class="Constant">1</span> +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L121" title="replication/walsender.c:121">max_wal_senders</a> + <a href="../utils/init/globals.c.html#L141" title="utils/init/globals.c:141">max_worker_processes</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Connect background worker to a database.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4155">&#x200c;</a></span><span class="linkable">BackgroundWorkerInitializeConnection</span>(<span class="Type">const</span> <span class="Type">char</span> *dbname, <span class="Type">const</span> <span class="Type">char</span> *username, uint32 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BackgroundWorker *worker = <a href="#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>;<br/></li>
<li>&nbsp; &nbsp; bits32&nbsp; &nbsp; &nbsp; &nbsp; init_flags = <span class="Constant">0</span>; <span class="Comment">/* never honor session_preload_libraries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore datallowconn? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; BGWORKER_BYPASS_ALLOWCONN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; init_flags |= INIT_PG_OVERRIDE_ALLOW_CONNS;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore rolcanlogin? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; BGWORKER_BYPASS_ROLELOGINCHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; init_flags |= INIT_PG_OVERRIDE_ROLE_LOGIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> is this the right <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(worker-&gt;bgw_flags &amp; BGWORKER_BACKEND_DATABASE_CONNECTION))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database connection requirement not indicated during registration&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>(dbname, InvalidOid,&nbsp; &nbsp; <span class="Comment">/* database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; username, InvalidOid,&nbsp; &nbsp; <span class="Comment">/* role to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> as */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no out_dbname */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it had better not gotten out of &quot;init&quot; mode yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsInitProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid processing mode in background worker&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(NormalProcessing);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Connect background worker to a database using OIDs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4189">&#x200c;</a></span><span class="linkable">BackgroundWorkerInitializeConnectionByOid</span>(Oid dboid, Oid useroid, uint32 flags)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BackgroundWorker *worker = <a href="#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>;<br/></li>
<li>&nbsp; &nbsp; bits32&nbsp; &nbsp; &nbsp; &nbsp; init_flags = <span class="Constant">0</span>; <span class="Comment">/* never honor session_preload_libraries */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore datallowconn? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; BGWORKER_BYPASS_ALLOWCONN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; init_flags |= INIT_PG_OVERRIDE_ALLOW_CONNS;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ignore rolcanlogin? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; BGWORKER_BYPASS_ROLELOGINCHECK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; init_flags |= INIT_PG_OVERRIDE_ROLE_LOGIN;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* </span><span class="Todo">XXX</span><span class="Comment"> is this the right <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!(worker-&gt;bgw_flags &amp; BGWORKER_BACKEND_DATABASE_CONNECTION))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROGRAM_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;database connection requirement not indicated during registration&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>(<span class="Constant">NULL</span>, dboid,&nbsp; &nbsp; <span class="Comment">/* database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, useroid, <span class="Comment">/* role to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> as */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; init_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no out_dbname */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* it had better not gotten out of &quot;init&quot; mode yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsInitProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid processing mode in background worker&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(NormalProcessing);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Block/unblock signals in a background worker<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4223">&#x200c;</a></span><span class="linkable">BackgroundWorkerBlockSignals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4229">&#x200c;</a></span><span class="linkable">BackgroundWorkerUnblockSignals</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start a new bgworker.<br/></li>
<li></span><span class="Comment"> * Starting time conditions must have been checked already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true on success, false on failure.<br/></li>
<li></span><span class="Comment"> * In either case, update the RegisteredBgWorker's state appropriately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This code is heavily based on autovacuum.c, q.v.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4244">&#x200c;</a></span><span class="linkable">do_start_bgworker</span>(RegisteredBgWorker *rw)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; worker_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(rw-&gt;rw_pid == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate and assign the <a href="#L177" title="postmaster/postmaster.c:177">Backend</a> <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; Note we must do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forking, so that we can handle failures (out of memory or child-process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * slots) cleanly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Treat failure as though the worker had crashed.&nbsp; That way, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster will wait a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting to start it again; if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tried again right away, most likely we'd <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> ourselves hitting the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * same resource-exhaustion condition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4345" title="postmaster/postmaster.c:4345">assign_backendlist_entry</a>(rw))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;starting background worker process </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rw-&gt;rw_worker.bgw_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; worker_pid = <a href="launch_backend.c.html#L226" title="postmaster/launch_backend.c:226">postmaster_child_launch</a>(B_BG_WORKER, (<span class="Type">char</span> *) &amp;rw-&gt;rw_worker, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackgroundWorker), <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (worker_pid == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* in postmaster, fork failed ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fork background worker process: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* undo what <a href="#L4345" title="postmaster/postmaster.c:4345">assign_backendlist_entry</a> did */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/pmsignal.c.html#L284" title="storage/ipc/pmsignal.c:284">ReleasePostmasterChildSlot</a>(rw-&gt;rw_child_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_child_slot = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rw-&gt;rw_backend);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_backend = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark entry as crashed, so we'll try again later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* in postmaster, fork successful ... */<br/></li>
<li></span>&nbsp; &nbsp; rw-&gt;rw_pid = worker_pid;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_backend-&gt;pid = rw-&gt;rw_pid;<br/></li>
<li>&nbsp; &nbsp; <a href="bgworker.c.html#L467" title="postmaster/bgworker.c:467">ReportBackgroundWorkerPID</a>(rw);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add new worker to lists of backends */<br/></li>
<li></span>&nbsp; &nbsp; dlist_push_head(&amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>, &amp;rw-&gt;rw_backend-&gt;elem);<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4564" title="postmaster/postmaster.c:4564">ShmemBackendArrayAdd</a>(rw-&gt;rw_backend);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does the current postmaster state require starting a worker with the<br/></li>
<li></span><span class="Comment"> * specified start_time?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4303">&#x200c;</a></span><span class="linkable">bgworker_should_start_now</span>(BgWorkerStartTime start_time)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L331" title="postmaster/postmaster.c:331">pmState</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_NO_CHILDREN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_WAIT_DEAD_END:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_SHUTDOWN_2:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_SHUTDOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_WAIT_BACKENDS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_STOP_BACKENDS:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_RUN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_time == BgWorkerStart_RecoveryFinished)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_HOT_STANDBY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_time == BgWorkerStart_ConsistentState)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_RECOVERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_STARTUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PM_INIT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (start_time == BgWorkerStart_PostmasterStart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall through */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate the <a href="#L177" title="postmaster/postmaster.c:177">Backend</a> struct for a connected background worker, but don't<br/></li>
<li></span><span class="Comment"> * add it to the list of backends just yet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On failure, return false without changing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> worker state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Some info from the <a href="#L177" title="postmaster/postmaster.c:177">Backend</a> is copied into the passed rw.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4345">&#x200c;</a></span><span class="linkable">assign_backendlist_entry</span>(RegisteredBgWorker *rw)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bn;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that database state allows another connection.&nbsp; Currently the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only possible failure is CAC_TOOMANY, so we just log an error message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * based on that rather than checking the error code precisely.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a>(<a href="#L139" title="postmaster/postmaster.c:139">BACKEND_TYPE_BGWORKER</a>) != CAC_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONFIGURATION_LIMIT_EXCEEDED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no slot available for new background worker process&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute the cancel key that will be assigned to this session. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * probably don't need cancel keys for background workers, but we'd better<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have something random in the field to prevent unfriendly people from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sending cancels to them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3868" title="postmaster/postmaster.c:3868">RandomCancelKey</a>(&amp;<a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INTERNAL_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not generate random cancel key&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bn = <a href="../utils/mmgr/mcxt.c.html#L1367" title="utils/mmgr/mcxt.c:1367">palloc_extended</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>), MCXT_ALLOC_NO_OOM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bn == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bn-&gt;cancel_key = <a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>;<br/></li>
<li>&nbsp; &nbsp; bn-&gt;child_slot = <a href="../utils/init/globals.c.html#L51" title="utils/init/globals.c:51">MyPMChildSlot</a> = <a href="../storage/ipc/pmsignal.c.html#L247" title="storage/ipc/pmsignal.c:247">AssignPostmasterChildSlot</a>();<br/></li>
<li>&nbsp; &nbsp; bn-&gt;bkend_type = <a href="#L139" title="postmaster/postmaster.c:139">BACKEND_TYPE_BGWORKER</a>;<br/></li>
<li>&nbsp; &nbsp; bn-&gt;dead_end = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; bn-&gt;bgworker_notify = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_backend = bn;<br/></li>
<li>&nbsp; &nbsp; rw-&gt;rw_child_slot = bn-&gt;child_slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If the time is right, start background worker(s).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As a side effect, the bgworker control variables are set or reset<br/></li>
<li></span><span class="Comment"> * depending on whether more workers may need to be started.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We limit the number of workers started per call, to avoid consuming the<br/></li>
<li></span><span class="Comment"> * postmaster's attention for too long when many such requests are pending.<br/></li>
<li></span><span class="Comment"> * As long as <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> is true, <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> will not block and will<br/></li>
<li></span><span class="Comment"> * call this function again after dealing with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other issues.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4409">&#x200c;</a></span><span class="linkable">maybe_start_bgworkers</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><a id="L4411">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_BGWORKERS_TO_LAUNCH</span> </span><span class="Constant">100<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_launched = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TimestampTz <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; slist_mutable_iter iter;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During crash recovery, we have no need to be called until the state<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transition out of recovery.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L271" title="postmaster/postmaster.c:271">FatalError</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't need to be called again unless we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a reason for it below */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slist_foreach_modify(iter, &amp;<a href="bgworker.c.html#L40" title="postmaster/bgworker.c:40">BackgroundWorkerList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RegisteredBgWorker *rw;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rw = slist_container(RegisteredBgWorker, rw_lnode, iter.cur);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if already running */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if marked for death, clean up and remove from list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_terminate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L432" title="postmaster/bgworker.c:432">ForgetBackgroundWorker</a>(&amp;iter);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this worker has crashed previously, maybe it needs to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * restarted (unless on registration it specified it doesn't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be restarted at all).&nbsp; Check how long ago did a crash last happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the last crash is too recent, don't start it right away; let it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be restarted once enough time has passed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_crashed_at != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rw-&gt;rw_worker.bgw_restart_time == BGW_NEVER_RESTART)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notify_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notify_pid = rw-&gt;rw_worker.bgw_notify_pid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="bgworker.c.html#L432" title="postmaster/bgworker.c:432">ForgetBackgroundWorker</a>(&amp;iter);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report worker is gone <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (notify_pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kill(notify_pid, <span class="Constant">SIGUSR1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* read system time only when needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/adt/timestamp.c.html#L1790" title="utils/adt/timestamp.c:1790">TimestampDifferenceExceeds</a>(rw-&gt;rw_crashed_at, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_worker.bgw_restart_time * <span class="Constant">1000</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set flag to remember that we have workers to start later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4303" title="postmaster/postmaster.c:4303">bgworker_should_start_now</a>(rw-&gt;rw_worker.bgw_start_time))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset crash time <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to start worker */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rw-&gt;rw_crashed_at = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to start the worker.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On failure, give up processing workers for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, but set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> so we'll come back here on the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iteration<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> to try again.&nbsp; (We don't want to wait, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there might be additional ready-to-run workers.)&nbsp; We could set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L366" title="postmaster/postmaster.c:366">HaveCrashedWorker</a> as well, since this worker is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * crashed, but there's no need because the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> run of this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * function will do that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L4244" title="postmaster/postmaster.c:4244">do_start_bgworker</a>(rw))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've launched as many workers as allowed, quit, but have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L1624" title="postmaster/postmaster.c:1624">ServerLoop</a> call us again to look for additional ready-to-run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * workers.&nbsp; There might not be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, but we'll <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time we run.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++num_launched &gt;= <a href="#L4411" title="postmaster/postmaster.c:4411">MAX_BGWORKERS_TO_LAUNCH</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L365" title="postmaster/postmaster.c:365">StartWorkerNeeded</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * When a backend asks to be notified about worker state changes, we<br/></li>
<li></span><span class="Comment"> * set a flag in its backend entry.&nbsp; The background worker machinery needs<br/></li>
<li></span><span class="Comment"> * to know when such backends exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4528">&#x200c;</a></span><span class="linkable">PostmasterMarkPIDForWorkerNotify</span>(<span class="Type">int</span> pid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dlist_iter&nbsp; &nbsp; iter;<br/></li>
<li>&nbsp; &nbsp; <a href="#L177" title="postmaster/postmaster.c:177">Backend</a>&nbsp; &nbsp; *bp;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dlist_foreach(iter, &amp;<a href="#L179" title="postmaster/postmaster.c:179">BackendList</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bp = dlist_container(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>, elem, iter.cur);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bp-&gt;pid == pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp-&gt;bgworker_notify = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li>Size<br/></li>
<li><a id="L4548">&#x200c;</a><span class="linkable">ShmemBackendArraySize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<a href="#L4145" title="postmaster/postmaster.c:4145">MaxLivePostmasterChildren</a>(), <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4554">&#x200c;</a></span><span class="linkable">ShmemBackendArrayAllocation</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <a href="#L4548" title="postmaster/postmaster.c:4548">ShmemBackendArraySize</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a> = (<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *) <a href="../storage/ipc/shmem.c.html#L152" title="storage/ipc/shmem.c:152">ShmemAlloc</a>(size);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark all slots as empty */<br/></li>
<li></span>&nbsp; &nbsp; memset(<a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>, <span class="Constant">0</span>, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4564">&#x200c;</a></span><span class="linkable">ShmemBackendArrayAdd</span>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *bn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The array slot corresponding to my PMChildSlot should be free */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = bn-&gt;child_slot - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>[i].pid == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>[i] = *bn;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4574">&#x200c;</a></span><span class="linkable">ShmemBackendArrayRemove</span>(<a href="#L177" title="postmaster/postmaster.c:177">Backend</a> *bn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = bn-&gt;child_slot - <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>[i].pid == bn-&gt;pid);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark the slot as empty */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L182" title="postmaster/postmaster.c:182">ShmemBackendArray</a>[i].pid = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXEC_BACKEND */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subset implementation of <a href="#L4592" title="postmaster/postmaster.c:4592">waitpid</a>() for Windows.&nbsp; We assume pid is -1<br/></li>
<li></span><span class="Comment"> * (that is, check all child processes) and options is <a href="#L450" title="postmaster/postmaster.c:450">WNOHANG</a> (don't wait).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> pid_t<br/></li>
<li><a id="L4592">&#x200c;</a><span class="linkable">waitpid</span>(pid_t pid, <span class="Type">int</span> *exitstatus, <span class="Type">int</span> options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L462" title="postmaster/postmaster.c:462">win32_deadchild_waitinfo</a> *childinfo;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; exitcode;<br/></li>
<li>&nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; dwd;<br/></li>
<li>&nbsp; &nbsp; ULONG_PTR&nbsp; &nbsp; key;<br/></li>
<li>&nbsp; &nbsp; OVERLAPPED *ovl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Try to consume one <a href="#L462" title="postmaster/postmaster.c:462">win32_deadchild_waitinfo</a> from the queue. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!GetQueuedCompletionStatus(<a href="#L455" title="postmaster/postmaster.c:455">win32ChildQueue</a>, &amp;dwd, &amp;key, &amp;ovl, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = <span class="Constant">EAGAIN</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; childinfo = (<a href="#L462" title="postmaster/postmaster.c:462">win32_deadchild_waitinfo</a> *) key;<br/></li>
<li>&nbsp; &nbsp; pid = childinfo-&gt;procId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remove handle from wait - required even though it's set to wait only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; UnregisterWaitEx(childinfo-&gt;waitHandle, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!GetExitCodeProcess(childinfo-&gt;procHandle, &amp;exitcode))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Should never happen. Inform user and set a fixed exitcode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;could not read exit code for process</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exitcode = <span class="Constant">255</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; *exitstatus = exitcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the process handle.&nbsp; Only after this point can the PID can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * recycled by the kernel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CloseHandle(childinfo-&gt;procHandle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Free struct that was allocated <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RegisterWaitForSingleObject()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(childinfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Note! Code below executes on a thread pool! All operations must<br/></li>
<li></span><span class="Comment"> * be thread safe! Note that elog() and friends must *not* be used.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> WINAPI<br/></li>
<li><a id="L4646">&#x200c;</a><span class="linkable">pgwin32_deadchild_callback</span>(PVOID lpParameter, BOOLEAN TimerOrWaitFired)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should never happen, since we use INFINITE as timeout value. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (TimerOrWaitFired)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Post the <a href="#L462" title="postmaster/postmaster.c:462">win32_deadchild_waitinfo</a> object for <a href="#L4592" title="postmaster/postmaster.c:4592">waitpid</a>() to deal with. If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that fails, we leak the object, but we also leak a whole process and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get into an unrecoverable state, so there's not much point in worrying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about that.&nbsp; We'd like to panic, but we can't use that infrastructure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from this thread.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!PostQueuedCompletionStatus(<a href="#L455" title="postmaster/postmaster.c:455">win32ChildQueue</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ULONG_PTR) lpParameter,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;could not post child completion status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Queue SIGCHLD signal. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../port/win32/signal.c.html#L259" title="port/win32/signal.c:259">pg_queue_signal</a>(<span class="Constant">SIGCHLD</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Queue a waiter to signal when this child dies.&nbsp; The wait will be handled<br/></li>
<li></span><span class="Comment"> * automatically by an operating system thread pool.&nbsp; The memory and the<br/></li>
<li></span><span class="Comment"> * process handle will be freed by a later call to <a href="#L4592" title="postmaster/postmaster.c:4592">waitpid</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4675">&#x200c;</a></span><span class="linkable">pgwin32_register_deadchild_callback</span>(HANDLE procHandle, DWORD procId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L462" title="postmaster/postmaster.c:462">win32_deadchild_waitinfo</a> *childinfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; childinfo = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L462" title="postmaster/postmaster.c:462">win32_deadchild_waitinfo</a>));<br/></li>
<li>&nbsp; &nbsp; childinfo-&gt;procHandle = procHandle;<br/></li>
<li>&nbsp; &nbsp; childinfo-&gt;procId = procId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!RegisterWaitForSingleObject(&amp;childinfo-&gt;waitHandle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; procHandle,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L4646" title="postmaster/postmaster.c:4646">pgwin32_deadchild_callback</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; childinfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; INFINITE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not register process for wait: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError())));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize one and only handle for monitoring postmaster death.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Called once in the postmaster, so that child processes can subsequently<br/></li>
<li></span><span class="Comment"> * monitor if their parent is dead.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4703">&#x200c;</a></span><span class="linkable">InitPostmasterDeathWatchHandle</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a pipe. Postmaster holds the write end of the pipe open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (POSTMASTER_FD_OWN), and children hold the read end. Children can pass<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the read file descriptor to <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>() to wake up in case postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dies, or check for postmaster death with a (read() == 0). Children must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close the write end as soon as possible after forking, because EOF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * won't be signaled in the read end until all processes have closed the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * write fd. That is taken care of in <a href="#L1955" title="postmaster/postmaster.c:1955">ClosePostmasterPorts</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a> == <a href="../utils/init/globals.c.html#L103" title="utils/init/globals.c:103">PostmasterPid</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pipe(<a href="#L479" title="postmaster/postmaster.c:479">postmaster_alive_fds</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not create pipe to monitor postmaster death: %m&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Notify fd.c that we've eaten two FDs for the pipe. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set O_NONBLOCK to allow testing for the fd's presence with a read()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fcntl(<a href="#L479" title="postmaster/postmaster.c:479">postmaster_alive_fds</a>[POSTMASTER_FD_WATCH], F_SETFL, O_NONBLOCK) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not set postmaster death monitoring pipe to nonblocking mode: %m&quot;</span>)));<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * On Windows, we use a process handle for the same purpose.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (DuplicateHandle(GetCurrentProcess(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetCurrentProcess(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GetCurrentProcess(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L482" title="postmaster/postmaster.c:482">PostmasterHandle</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRUE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DUPLICATE_SAME_ACCESS) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;could not duplicate postmaster handle: error code </span><span class="Special">%lu</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetLastError())));<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
