<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/syslogger.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/syslogger.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L71">Log_RotationAge</a></li>
<li><a href="#L72">Log_RotationSize</a></li>
<li><a href="#L73">Log_directory</a></li>
<li><a href="#L76">Log_file_mode</a></li>
<li><a href="#L74">Log_filename</a></li>
<li><a href="#L75">Log_truncate_on_rotation</a></li>
<li><a href="#L70">Logging_collector</a></li>
<li><a href="#L112">buffer_lists</a></li>
<li><a href="#L87">csvlogFile</a></li>
<li><a href="#L89">first_syslogger_file_time</a></li>
<li><a href="#L88">jsonlogFile</a></li>
<li><a href="#L91">last_csv_file_name</a></li>
<li><a href="#L92">last_json_file_name</a></li>
<li><a href="#L90">last_sys_file_name</a></li>
<li><a href="#L83">next_rotation_time</a></li>
<li><a href="#L84">pipe_eof_seen</a></li>
<li><a href="#L85">rotation_disabled</a></li>
<li><a href="#L129">rotation_requested</a></li>
<li><a href="#L86">syslogFile</a></li>
<li><a href="#L116">syslogPipe</a></li>
<li><a href="#L118">syslogPipe</a></li>
<li><a href="#L123">sysloggerSection</a></li>
<li><a href="#L122">threadHandle</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L160">SysloggerStartupData</a></li>
<li><a href="#L109">save_buffer</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1573">CheckLogrotateSignal</a></li>
<li><a href="#L1587">RemoveLogrotateSignalFiles</a></li>
<li><a href="#L167">SysLoggerMain</a></li>
<li><a href="#L595">SysLogger_Start</a></li>
<li><a href="#L1043">flush_pipe_input</a></li>
<li><a href="#L1411">logfile_getname</a></li>
<li><a href="#L1218">logfile_open</a></li>
<li><a href="#L1362">logfile_rotate</a></li>
<li><a href="#L1263">logfile_rotate_dest</a></li>
<li><a href="#L1141">pipeThread</a></li>
<li><a href="#L880">process_pipe_input</a></li>
<li><a href="#L1441">set_next_rotation_time</a></li>
<li><a href="#L1594">sigUsr1Handler</a></li>
<li><a href="#L802">syslogger_fdget</a></li>
<li><a href="#L824">syslogger_fdopen</a></li>
<li><a href="#L1476">update_metainfo_datafile</a></li>
<li><a href="#L1094">write_syslogger_file</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L63">LOGROTATE_SIGNAL_FILE</a></li>
<li><a href="#L111">NBUFFER_LISTS</a></li>
<li><a href="#L60">READ_BUF_SIZE</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * syslogger.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The system logger (syslogger) appeared in Postgres 8.0. It catches all<br/></li>
<li></span><span class="Comment"> * stderr output from the postmaster, backends, and other subprocesses<br/></li>
<li></span><span class="Comment"> * by redirecting to a pipe, and writes it to a set of logfiles.<br/></li>
<li></span><span class="Comment"> * It's possible to have size and age limits for the logfile configured<br/></li>
<li></span><span class="Comment"> * in postgresql.conf. If these limits are reached or passed, the<br/></li>
<li></span><span class="Comment"> * current logfile is closed and a new one is created (rotated).<br/></li>
<li></span><span class="Comment"> * The logfiles are stored in a subdirectory (configurable in<br/></li>
<li></span><span class="Comment"> * postgresql.conf), using a user-selectable naming scheme.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Author: Andreas Pflug &lt;pgadmin@pse-consulting.de&gt;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2004-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/syslogger.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/file_perm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/pg_list.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgtime.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/syslogger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/dsm.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pg_shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We read() into a temp buffer twice as big as a chunk, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fragment<br/></li>
<li></span><span class="Comment"> * left after processing can be moved down to the front and we'll still have<br/></li>
<li></span><span class="Comment"> * room to read a full chunk.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">READ_BUF_SIZE</span> (</span><span class="Constant">2</span><span class="PreProc"> * PIPE_CHUNK_SIZE)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Log rotation signal file path, relative to $PGDATA */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">LOGROTATE_SIGNAL_FILE</span>&nbsp; &nbsp; </span><span class="Constant">&quot;logrotate&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC parameters.&nbsp; <a href="#L70" title="postmaster/syslogger.c:70">Logging_collector</a> cannot be changed after postmaster<br/></li>
<li></span><span class="Comment"> * start, but the rest can change at SIGHUP.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Logging_collector</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L71">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_RotationAge</span> = HOURS_PER_DAY * MINS_PER_HOUR;<br/></li>
<li><a id="L72">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_RotationSize</span> = <span class="Constant">10</span> * <span class="Constant">1024</span>;<br/></li>
<li><a id="L73">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">Log_directory</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L74">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">Log_filename</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L75">&#x200c;</a><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_truncate_on_rotation</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L76">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_file_mode</span> = S_IRUSR | S_IWUSR;<br/></li>
<li><br/></li>
<li><span class="Type">extern</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Private state<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="Type">static</span> pg_time_t <span class="linkable">next_rotation_time</span>;<br/></li>
<li><a id="L84">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">pipe_eof_seen</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L85">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">rotation_disabled</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L86">&#x200c;</a><span class="Type">static</span> <span class="Type">FILE</span> *<span class="linkable">syslogFile</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L87">&#x200c;</a><span class="Type">static</span> <span class="Type">FILE</span> *<span class="linkable">csvlogFile</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L88">&#x200c;</a><span class="Type">static</span> <span class="Type">FILE</span> *<span class="linkable">jsonlogFile</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L89">&#x200c;</a>NON_EXEC_STATIC pg_time_t <span class="linkable">first_syslogger_file_time</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L90">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">last_sys_file_name</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L91">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">last_csv_file_name</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L92">&#x200c;</a><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">last_json_file_name</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Buffers for saving partial messages from different backends.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Keep <a href="#L111" title="postmaster/syslogger.c:111">NBUFFER_LISTS</a> lists of these, with the entry for a given source pid<br/></li>
<li></span><span class="Comment"> * being in the list numbered (pid % <a href="#L111" title="postmaster/syslogger.c:111">NBUFFER_LISTS</a>), so as to cut down on<br/></li>
<li></span><span class="Comment"> * the number of entries we have to examine for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one incoming message.<br/></li>
<li></span><span class="Comment"> * There must never be more than one entry for the same source pid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An inactive buffer is not removed from its list, just held for re-use.<br/></li>
<li></span><span class="Comment"> * An inactive buffer has pid == 0 and undefined contents of data.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; pid;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PID of source process */<br/></li>
<li></span>&nbsp; &nbsp; StringInfoData data;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* accumulated data, as a StringInfo */<br/></li>
<li><a id="L109">&#x200c;</a></span>} <span class="linkable">save_buffer</span>;<br/></li>
<li><br/></li>
<li><a id="L111">&#x200c;</a><span class="PreProc">#define <span class="linkable">NBUFFER_LISTS</span> </span><span class="Constant">256<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">static</span> List *<span class="linkable">buffer_lists</span>[<a href="#L111" title="postmaster/syslogger.c:111">NBUFFER_LISTS</a>];<br/></li>
<li><br/></li>
<li><span class="Comment">/* These must be exported for EXEC_BACKEND case ... annoying */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li><a id="L116">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">syslogPipe</span>[<span class="Constant">2</span>] = {-<span class="Constant">1</span>, -<span class="Constant">1</span>};<br/></li>
<li><span class="PreProc">#else<br/></li>
<li><a id="L118">&#x200c;</a></span>HANDLE&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">syslogPipe</span>[<span class="Constant">2</span>] = {<span class="Constant">0</span>, <span class="Constant">0</span>};<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="Type">static</span> HANDLE <span class="linkable">threadHandle</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L123">&#x200c;</a><span class="Type">static</span> CRITICAL_SECTION <span class="linkable">sysloggerSection</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flags set by interrupt handlers for later service in the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L129">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">rotation_requested</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Local subroutines */<br/></li>
<li></span><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L802" title="postmaster/syslogger.c:802">syslogger_fdget</a>(<span class="Type">FILE</span> *file);<br/></li>
<li><span class="Type">static</span> <span class="Type">FILE</span> *<a href="#L824" title="postmaster/syslogger.c:824">syslogger_fdopen</a>(<span class="Type">int</span> fd);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L880" title="postmaster/syslogger.c:880">process_pipe_input</a>(<span class="Type">char</span> *logbuffer, <span class="Type">int</span> *bytes_in_logbuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1043" title="postmaster/syslogger.c:1043">flush_pipe_input</a>(<span class="Type">char</span> *logbuffer, <span class="Type">int</span> *bytes_in_logbuffer);<br/></li>
<li><span class="Type">static</span> <span class="Type">FILE</span> *<a href="#L1218" title="postmaster/syslogger.c:1218">logfile_open</a>(<span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type">const</span> <span class="Type">char</span> *mode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_errors);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> __stdcall <a href="#L1141" title="postmaster/syslogger.c:1141">pipeThread</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L1362" title="postmaster/syslogger.c:1362">logfile_rotate</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> time_based_rotation, <span class="Type">int</span> size_rotation_for);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1263" title="postmaster/syslogger.c:1263">logfile_rotate_dest</a>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> time_based_rotation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> size_rotation_for, pg_time_t fntime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> target_dest, <span class="Type">char</span> **last_file_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">FILE</span> **logFile);<br/></li>
<li><span class="Type">static</span> <span class="Type">char</span> *<a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(pg_time_t timestamp, <span class="Type">const</span> <span class="Type">char</span> *suffix);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1441" title="postmaster/syslogger.c:1441">set_next_rotation_time</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1594" title="postmaster/syslogger.c:1594">sigUsr1Handler</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1476" title="postmaster/syslogger.c:1476">update_metainfo_datafile</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>;<br/></li>
<li><a id="L160">&#x200c;</a>} <span class="linkable">SysloggerStartupData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Main entry point for syslogger process<br/></li>
<li></span><span class="Comment"> * argc/argv parameters are valid only in EXEC_BACKEND case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="linkable">SysLoggerMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; logbuffer[<a href="#L60" title="postmaster/syslogger.c:60">READ_BUF_SIZE</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes_in_logbuffer = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *currentLogDir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *currentLogFilename;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentLogRotationAge;<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> *wes;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-open the error output files that were opened by <a href="#L595" title="postmaster/syslogger.c:595">SysLogger_Start</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect this will always succeed, which is too optimistic, but if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fails there's not a lot we can do to report the problem anyway.&nbsp; As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * coded, we'll just crash on a null pointer dereference after failure...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L160" title="postmaster/syslogger.c:160">SysloggerStartupData</a> *slsdata = (<a href="#L160" title="postmaster/syslogger.c:160">SysloggerStartupData</a> *) startup_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(startup_data_len == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(*slsdata));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> = <a href="#L824" title="postmaster/syslogger.c:824">syslogger_fdopen</a>(slsdata-&gt;<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> = <a href="#L824" title="postmaster/syslogger.c:824">syslogger_fdopen</a>(slsdata-&gt;<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> = <a href="#L824" title="postmaster/syslogger.c:824">syslogger_fdopen</a>(slsdata-&gt;<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we're done reading the startup data, release postmaster's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * working memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = <a href="../utils/init/globals.c.html#L46" title="utils/init/globals.c:46">MyStartTime</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_LOGGER;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L267" title="utils/misc/ps_status.c:267">init_ps_display</a>(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we restarted, our stderr is already redirected into our own input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pipe.&nbsp; This is of course pretty useless, not to mention that it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interferes with detecting pipe EOF.&nbsp; Point stderr to /dev/null. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assumes that all interesting messages generated in the syslogger will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * come through elog.c and will be sent to <a href="#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd = open(DEVNULL, O_WRONLY, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The closes might look redundant, but they are not: we want to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * darn sure the pipe gets closed even if the open failed.&nbsp; We can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * survive running with stderr pointing nowhere, but we can't afford<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to have extra pipe input descriptors hanging around.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As we're just trying to reset these to go to DEVNULL, there's not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * much point in checking for failure from the close/dup2 calls here,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if they fail then presumably the file descriptors are closed and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> writes will go into the bitbucket anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; close(STDOUT_FILENO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(STDERR_FILENO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) dup2(fd, STDOUT_FILENO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) dup2(fd, STDERR_FILENO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Syslogger's own stderr can't be the <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>, so set it back to text<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode if we didn't just close it. (It was set to binary in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="launch_backend.c.html#L569" title="postmaster/launch_backend.c:569">SubPostmasterMain</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _setmode(STDERR_FILENO, _O_TEXT);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also close our copy of the write end of the pipe.&nbsp; This is needed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure we can detect pipe EOF correctly.&nbsp; (But note that in the restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case, the postmaster already did this.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>] &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>] = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CloseHandle(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>] = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Properly <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> or ignore signals the postmaster might <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we ignore all termination signals, and instead exit only when all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * upstream processes are gone, to ensure we don't <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dying gasps of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * broken backends...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>); <span class="Comment">/* set flag to read config<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGQUIT</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="#L1594" title="postmaster/syslogger.c:1594">sigUsr1Handler</a>);&nbsp; &nbsp; <span class="Comment">/* request log rotation */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset some signals that are accepted by postmaster but not here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Fire up separate data transfer thread */<br/></li>
<li></span>&nbsp; &nbsp; InitializeCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li>&nbsp; &nbsp; EnterCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L122" title="postmaster/syslogger.c:122">threadHandle</a> = (HANDLE) _beginthreadex(<span class="Constant">NULL</span>, <span class="Constant">0</span>, <a href="#L1141" title="postmaster/syslogger.c:1141">pipeThread</a>, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L122" title="postmaster/syslogger.c:122">threadHandle</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;could not create syslogger data transfer thread: %m&quot;</span>);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember active logfiles' name(s).&nbsp; We recompute 'em from the reference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * time because passing down just the pg_time_t is a lot cheaper than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passing a whole file path in the EXEC_BACKEND case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L90" title="postmaster/syslogger.c:90">last_sys_file_name</a> = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(<a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L91" title="postmaster/syslogger.c:91">last_csv_file_name</a> = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(<a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a>, <span class="Constant">&quot;.csv&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L92" title="postmaster/syslogger.c:92">last_json_file_name</a> = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(<a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a>, <span class="Constant">&quot;.json&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remember active logfile parameters */<br/></li>
<li></span>&nbsp; &nbsp; currentLogDir = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>);<br/></li>
<li>&nbsp; &nbsp; currentLogFilename = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L74" title="postmaster/syslogger.c:74">Log_filename</a>);<br/></li>
<li>&nbsp; &nbsp; currentLogRotationAge = <a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> planned rotation time */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1441" title="postmaster/syslogger.c:1441">set_next_rotation_time</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L1476" title="postmaster/syslogger.c:1476">update_metainfo_datafile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a>, as the postmaster will do (but hasn't yet, at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the point where we forked).&nbsp; This prevents duplicate output of messages<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * from syslogger itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up a reusable <a href="../storage/ipc/latch.c.html#L102" title="storage/ipc/latch.c:102">WaitEventSet</a> object we'll use to wait for our latch,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and (except on Windows) our <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Unlike all other postmaster child processes, we'll ignore postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * death because we want to collect final log output from all backends and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then exit last.&nbsp; We'll do that by running until we see EOF on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syslog pipe, which implies that all other backends have exited<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (including the postmaster).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; wes = <a href="../storage/ipc/latch.c.html#L751" title="storage/ipc/latch.c:751">CreateWaitEventSet</a>(<span class="Constant">NULL</span>, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(wes, WL_LATCH_SET, PGINVALID_SOCKET, <a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>, <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L963" title="storage/ipc/latch.c:963">AddWaitEventToSet</a>(wes, WL_SOCKET_READABLE, <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>], <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> worker loop */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; time_based_rotation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_rotation_for = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; cur_timeout;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; WaitEvent&nbsp; &nbsp; event;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Clear <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> already-pending wakeups */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> requests or signals received recently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if the log directory or filename pattern changed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * postgresql.conf. If so, force rotation to make sure we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * writing the logfiles in the right place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>, currentLogDir) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(currentLogDir);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentLogDir = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, create new directory if not present; ignore errors<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/file/fd.c.html#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(<a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(<a href="#L74" title="postmaster/syslogger.c:74">Log_filename</a>, currentLogFilename) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(currentLogFilename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentLogFilename = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L74" title="postmaster/syslogger.c:74">Log_filename</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force a rotation if CSVLOG output was just turned on or off and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we need to open or close <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_CSVLOG) != <span class="Constant">0</span>) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force a rotation if JSONLOG output was just turned on or off<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and we need to open or close <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> accordingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_JSONLOG) != <span class="Constant">0</span>) !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> != <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If rotation time parameter changed, reset <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> rotation time,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but don't immediately force a rotation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (currentLogRotationAge != <a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; currentLogRotationAge = <a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1441" title="postmaster/syslogger.c:1441">set_next_rotation_time</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we had a rotation-disabling failure, re-enable rotation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attempts after SIGHUP, and force one immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L85" title="postmaster/syslogger.c:85">rotation_disabled</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="postmaster/syslogger.c:85">rotation_disabled</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force rewriting last log filename when reloading configuration.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Even if <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> is false, log_destination may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * been changed and we don't want to wait the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> file rotation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1476" title="postmaster/syslogger.c:1476">update_metainfo_datafile</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a> &gt; <span class="Constant">0</span> &amp;&amp; !<a href="#L85" title="postmaster/syslogger.c:85">rotation_disabled</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do a logfile rotation if it's time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &gt;= <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = time_based_rotation = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> &amp;&amp; <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> &gt; <span class="Constant">0</span> &amp;&amp; !<a href="#L85" title="postmaster/syslogger.c:85">rotation_disabled</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do a rotation if file is too big */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ftell(<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>) &gt;= <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> * <span class="Constant">1024L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_rotation_for |= LOG_DESTINATION_STDERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftell(<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>) &gt;= <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> * <span class="Constant">1024L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_rotation_for |= LOG_DESTINATION_CSVLOG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ftell(<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>) &gt;= <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> * <span class="Constant">1024L</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_rotation_for |= LOG_DESTINATION_JSONLOG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Force rotation when both <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are zero. It means the request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * was sent by <a href="../storage/ipc/signalfuncs.c.html#L280" title="storage/ipc/signalfuncs.c:280">pg_rotate_logfile</a>() or &quot;pg_ctl logrotate&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!time_based_rotation &amp;&amp; size_rotation_for == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size_rotation_for = LOG_DESTINATION_STDERR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_DESTINATION_CSVLOG |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_DESTINATION_JSONLOG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1362" title="postmaster/syslogger.c:1362">logfile_rotate</a>(time_based_rotation, size_rotation_for);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Calculate time till <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time-based rotation, so that we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sleep longer than that.&nbsp; We assume the value of &quot;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>&quot; obtained<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * above is still close enough.&nbsp; Note we can't make this calculation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until after calling <a href="#L1362" title="postmaster/syslogger.c:1362">logfile_rotate</a>(), since it will advance<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also note that we need to beware of overflow in calculation of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeout: with large settings of <a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a>, <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could be more than INT_MAX msec in the future.&nbsp; In that case we'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wait no more than INT_MAX msec, and try again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a> &gt; <span class="Constant">0</span> &amp;&amp; !<a href="#L85" title="postmaster/syslogger.c:85">rotation_disabled</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_time_t&nbsp; &nbsp; delay;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delay = <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a> - <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delay &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delay &gt; <span class="Constant">INT_MAX</span> / <span class="Constant">1000</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; delay = <span class="Constant">INT_MAX</span> / <span class="Constant">1000</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = delay * <span class="Constant">1000L</span>;&nbsp; &nbsp; <span class="Comment">/* msec */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cur_timeout = -<span class="Constant">1L</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep until there's something to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(wes, cur_timeout, &amp;event, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_SYSLOGGER_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc == <span class="Constant">1</span> &amp;&amp; event.events == WL_SOCKET_READABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytesRead;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytesRead = read(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; logbuffer + bytes_in_logbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(logbuffer) - bytes_in_logbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bytesRead &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from logger pipe: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bytesRead &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes_in_logbuffer += bytesRead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="postmaster/syslogger.c:880">process_pipe_input</a>(logbuffer, &amp;bytes_in_logbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Zero bytes read when <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>() is saying read-ready means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * EOF on the pipe: that is, there are no longer <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> processes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with the pipe write end open.&nbsp; Therefore, the postmaster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and all backends are shut down, and we are done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="postmaster/syslogger.c:84">pipe_eof_seen</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if there's <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data left then force it out <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1043" title="postmaster/syslogger.c:1043">flush_pipe_input</a>(logbuffer, &amp;bytes_in_logbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * On Windows we leave it to a separate thread to transfer data and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect pipe EOF.&nbsp; The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> thread just wakes up to handle SIGHUP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and rotation conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Server code isn't generally thread-safe, so we ensure that only one<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the threads is active at a time by entering the critical section<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whenever we're not sleeping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; LeaveCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/ipc/latch.c.html#L1424" title="storage/ipc/latch.c:1424">WaitEventSetWait</a>(wes, cur_timeout, &amp;event, <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WAIT_EVENT_SYSLOGGER_MAIN);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EnterCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L84" title="postmaster/syslogger.c:84">pipe_eof_seen</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seeing this message on the real stderr is annoying - so we make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it DEBUG1 to suppress in normal use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;logger shutting down&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Normal exit from the syslogger is here.&nbsp; Note that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deliberately do not close <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting; this is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow for the possibility of elog messages being generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inside <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>.&nbsp; Regular exit() will take care of flushing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and closing stdio channels.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Postmaster subroutine to start a syslogger subprocess.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L595">&#x200c;</a></span><span class="linkable">SysLogger_Start</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pid_t&nbsp; &nbsp; &nbsp; &nbsp; sysloggerPid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filename;<br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L160" title="postmaster/syslogger.c:160">SysloggerStartupData</a> startup_data;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXEC_BACKEND */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L70" title="postmaster/syslogger.c:70">Logging_collector</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If first time through, create the pipe which will receive stderr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the syslogger crashes and needs to be restarted, we continue to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same pipe (indeed must do so, since extant backends will be writing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into that pipe).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This means the postmaster must continue to hold the read end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pipe open, so we can pass it down to the reincarnated syslogger. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> klugy but we have little choice.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also note that we don't bother counting the pipe FDs by calling<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reserve/<a href="../storage/file/fd.c.html#L1239" title="storage/file/fd.c:1239">ReleaseExternalFD</a>.&nbsp; There's no real need to account for them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * accurately in the postmaster or syslogger process, and both ends of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pipe will wind up closed in all other postmaster children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>] &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pipe(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create pipe for syslog: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SECURITY_ATTRIBUTES sa;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memset(&amp;sa, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SECURITY_ATTRIBUTES));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sa.nLength = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SECURITY_ATTRIBUTES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sa.bInheritHandle = TRUE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!CreatePipe(&amp;<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>], &amp;<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>], &amp;sa, <span class="Constant">32768</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not create pipe for syslog: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create log directory if not present; ignore errors<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../storage/file/fd.c.html#L3913" title="storage/file/fd.c:3913">MakePGDirectory</a>(<a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The initial logfile is created right in the postmaster, to verify that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a> is writable.&nbsp; We save the reference time so that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * syslogger child process can recompute this file name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It might look a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> strange to re-do this during a syslogger restart,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but we must do so since the postmaster closed <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> after the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * previous fork (and remembering that old file wouldn't be right anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we always append here, we won't overwrite <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing file.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is consistent with the normal rules, because by definition this is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a time-based rotation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a> = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filename = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(<a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> = <a href="#L1218" title="postmaster/syslogger.c:1218">logfile_open</a>(filename, <span class="Constant">&quot;a&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise for the initial CSV log file, if that's enabled.&nbsp; (Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we open <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> even when only CSV output is nominally enabled,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since some code paths will write to <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_CSVLOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filename = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(<a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a>, <span class="Constant">&quot;.csv&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> = <a href="#L1218" title="postmaster/syslogger.c:1218">logfile_open</a>(filename, <span class="Constant">&quot;a&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Likewise for the initial JSON log file, if that's enabled.&nbsp; (Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we open <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> even when only JSON output is nominally enabled,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since some code paths will write to <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_JSONLOG)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filename = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(<a href="#L89" title="postmaster/syslogger.c:89">first_syslogger_file_time</a>, <span class="Constant">&quot;.json&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> = <a href="#L1218" title="postmaster/syslogger.c:1218">logfile_open</a>(filename, <span class="Constant">&quot;a&quot;</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filename);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span>&nbsp; &nbsp; startup_data.<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> = <a href="#L802" title="postmaster/syslogger.c:802">syslogger_fdget</a>(<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>);<br/></li>
<li>&nbsp; &nbsp; startup_data.<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> = <a href="#L802" title="postmaster/syslogger.c:802">syslogger_fdget</a>(<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>);<br/></li>
<li>&nbsp; &nbsp; startup_data.<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> = <a href="#L802" title="postmaster/syslogger.c:802">syslogger_fdget</a>(<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>);<br/></li>
<li>&nbsp; &nbsp; sysloggerPid = <a href="launch_backend.c.html#L226" title="postmaster/launch_backend.c:226">postmaster_child_launch</a>(B_LOGGER, (<span class="Type">char</span> *) &amp;startup_data, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(startup_data), <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; sysloggerPid = <a href="launch_backend.c.html#L226" title="postmaster/launch_backend.c:226">postmaster_child_launch</a>(B_LOGGER, <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXEC_BACKEND */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sysloggerPid == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not fork system logger: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* success, in postmaster */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we redirect stderr, if not done already */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fd;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Leave a breadcrumb trail when redirecting, in case the user forgets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that redirection is active and looks only at the original stderr<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;redirecting log output to logging collector process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Future log output will appear in directory </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>)));<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dup2(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>], STDOUT_FILENO) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not redirect stdout: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stderr</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dup2(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>], STDERR_FILENO) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not redirect stderr: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we are done with the write end of the pipe. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; close(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>] = -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * open the pipe in binary mode and make sure stderr is binary after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's been dup'ed into, to avoid disturbing the pipe chunking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * protocol.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fflush(<span class="Constant">stderr</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = _open_osfhandle((<span class="Type">intptr_t</span>) <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; _O_APPEND | _O_BINARY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dup2(fd, STDERR_FILENO) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not redirect stderr: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; close(fd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; _setmode(STDERR_FILENO, _O_BINARY);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we are done with the write end of the pipe.&nbsp; CloseHandle() must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not be called because the preceding close() closes the underlying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">1</span>] = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="postmaster.c.html#L353" title="postmaster/postmaster.c:353">redirection_done</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* postmaster will never write the file(s); close 'em */<br/></li>
<li></span>&nbsp; &nbsp; fclose(<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fclose(<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fclose(<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">int</span>) sysloggerPid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L802" title="postmaster/syslogger.c:802">syslogger_fdget</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Utility wrapper to grab the file descriptor of an opened error output<br/></li>
<li></span><span class="Comment"> * file.&nbsp; Used when building the command to fork the logging collector.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">syslogger_fdget</span>(<span class="Type">FILE</span> *file)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (file != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> fileno(file);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (file != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (<span class="Type">int</span>) _get_osfhandle(_fileno(file));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L824" title="postmaster/syslogger.c:824">syslogger_fdopen</a>() -<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Utility wrapper to re-open an error output file, using the given file<br/></li>
<li></span><span class="Comment"> * descriptor.&nbsp; Used when parsing arguments in a forked logging collector.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">FILE</span> *<br/></li>
<li><a id="L824">&#x200c;</a><span class="linkable">syslogger_fdopen</span>(<span class="Type">int</span> fd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *file = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fd != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; file = fdopen(fd, <span class="Constant">&quot;a&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setvbuf(file, <span class="Constant">NULL</span>, PG_IOLBF, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (fd != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fd = _open_osfhandle(fd, _O_APPEND | _O_TEXT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fd &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; file = fdopen(fd, <span class="Constant">&quot;a&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; setvbuf(file, <span class="Constant">NULL</span>, PG_IOLBF, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> file;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* EXEC_BACKEND */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; pipe protocol handling<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process data received through the syslogger pipe.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine interprets the log pipe protocol which sends log messages as<br/></li>
<li></span><span class="Comment"> * (hopefully atomic) chunks - such chunks are detected and reassembled here.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The protocol has a header that starts with two nul bytes, then has a 16 <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment"> * length, the pid of the sending process, and a flag to indicate if it is<br/></li>
<li></span><span class="Comment"> * the last chunk in a message. Incomplete chunks are saved until we read some<br/></li>
<li></span><span class="Comment"> * more, and non-final chunks are accumulated until we get the final chunk.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * All of this is to avoid 2 problems:<br/></li>
<li></span><span class="Comment"> * . partial messages being written to logfiles (messes rotation), and<br/></li>
<li></span><span class="Comment"> * . messages from different backends being interleaved (messages garbled).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Any non-protocol messages are written out directly. These should only come<br/></li>
<li></span><span class="Comment"> * from non-PostgreSQL sources, however (e.g. third party libraries writing to<br/></li>
<li></span><span class="Comment"> * stderr).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * logbuffer is the data input buffer, and *bytes_in_logbuffer is the number<br/></li>
<li></span><span class="Comment"> * of bytes present.&nbsp; On exit, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> not-yet-eaten data is left-justified in<br/></li>
<li></span><span class="Comment"> * logbuffer, and *bytes_in_logbuffer is updated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L880">&#x200c;</a></span><span class="linkable">process_pipe_input</span>(<span class="Type">char</span> *logbuffer, <span class="Type">int</span> *bytes_in_logbuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *cursor = logbuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = *bytes_in_logbuffer;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = LOG_DESTINATION_STDERR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* While we have enough for a header, process data... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (count &gt;= (<span class="Type">int</span>) (offsetof(PipeProtoHeader, data) + <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PipeProtoHeader p;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunklen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp; &nbsp; dest_flags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do we have a valid header? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(&amp;p, cursor, offsetof(PipeProtoHeader, data));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest_flags = p.flags &amp; (PIPE_PROTO_DEST_STDERR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PIPE_PROTO_DEST_CSVLOG |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PIPE_PROTO_DEST_JSONLOG);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (p.nuls[<span class="Constant">0</span>] == <span class="Special">'\0'</span> &amp;&amp; p.nuls[<span class="Constant">1</span>] == <span class="Special">'\0'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.len &gt; <span class="Constant">0</span> &amp;&amp; p.len &lt;= PIPE_MAX_PAYLOAD &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p.pid != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_number_of_ones[dest_flags] == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *buffer_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="postmaster/syslogger.c:109">save_buffer</a> *existing_slot = <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *free_slot = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chunklen = PIPE_HEADER_SIZE + p.len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Fall out of loop if we don't have the whole chunk yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &lt; chunklen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((p.flags &amp; PIPE_PROTO_DEST_STDERR) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = LOG_DESTINATION_STDERR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((p.flags &amp; PIPE_PROTO_DEST_CSVLOG) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = LOG_DESTINATION_CSVLOG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((p.flags &amp; PIPE_PROTO_DEST_JSONLOG) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest = LOG_DESTINATION_JSONLOG;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* this should never happen as of the header validation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Locate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing buffer for this source pid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_list = <a href="#L112" title="postmaster/syslogger.c:112">buffer_lists</a>[p.pid % <a href="#L111" title="postmaster/syslogger.c:111">NBUFFER_LISTS</a>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, buffer_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="postmaster/syslogger.c:109">save_buffer</a> *buf = (<a href="#L109" title="postmaster/syslogger.c:109">save_buffer</a> *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf-&gt;pid == p.pid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_slot = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf-&gt;pid == <span class="Constant">0</span> &amp;&amp; free_slot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_slot = buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((p.flags &amp; PIPE_PROTO_IS_LAST) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Save a complete non-final chunk in a per-pid buffer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (existing_slot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add chunk to data from preceding chunks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = &amp;(existing_slot-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cursor + PIPE_HEADER_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First chunk of message, save in a new buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (free_slot == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Need a free slot, but there isn't one in the list,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so create a new one and extend the list with it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_slot = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L109" title="postmaster/syslogger.c:109">save_buffer</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buffer_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(buffer_list, free_slot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="postmaster/syslogger.c:112">buffer_lists</a>[p.pid % <a href="#L111" title="postmaster/syslogger.c:111">NBUFFER_LISTS</a>] = buffer_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; free_slot-&gt;pid = p.pid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = &amp;(free_slot-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cursor + PIPE_HEADER_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Final chunk --- add it to anything saved for that pid, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either way write the whole thing out.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (existing_slot != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; str = &amp;(existing_slot-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendBinaryStringInfo(str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cursor + PIPE_HEADER_SIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; p.len);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>(str-&gt;data, str-&gt;len, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the buffer unused, and reclaim string storage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_slot-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The whole message was one chunk, evidently. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>(cursor + PIPE_HEADER_SIZE, p.len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finished processing this chunk */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor += chunklen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count -= chunklen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process non-protocol data */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Look for the start of a protocol header.&nbsp; If found, <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * up to there and <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> the loop.&nbsp; Otherwise, <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> it all and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fall out of the loop.&nbsp; (Note: we want to <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> it all if at all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible, so as to avoid dividing non-protocol messages across<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logfiles.&nbsp; We expect that in many scenarios, a non-protocol<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message will arrive all in one read(), and we want to respect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the read() boundary if possible.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (chunklen = <span class="Constant">1</span>; chunklen &lt; count; chunklen++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cursor[chunklen] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall back on the stderr log as the destination */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>(cursor, chunklen, LOG_DESTINATION_STDERR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cursor += chunklen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count -= chunklen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't have a full chunk, so left-align what remains in the buffer */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">0</span> &amp;&amp; cursor != logbuffer)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(logbuffer, cursor, count);<br/></li>
<li>&nbsp; &nbsp; *bytes_in_logbuffer = count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Force out <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffered data<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently used only at syslogger shutdown, but could perhaps be<br/></li>
<li></span><span class="Comment"> * useful at other times, so it is careful to leave things in a clean state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1043">&#x200c;</a></span><span class="linkable">flush_pipe_input</span>(<span class="Type">char</span> *logbuffer, <span class="Type">int</span> *bytes_in_logbuffer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dump <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> incomplete protocol messages */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L111" title="postmaster/syslogger.c:111">NBUFFER_LISTS</a>; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *list = <a href="#L112" title="postmaster/syslogger.c:112">buffer_lists</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L109" title="postmaster/syslogger.c:109">save_buffer</a> *buf = (<a href="#L109" title="postmaster/syslogger.c:109">save_buffer</a> *) lfirst(cell);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (buf-&gt;pid != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; str = &amp;(buf-&gt;data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>(str-&gt;data, str-&gt;len,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOG_DESTINATION_STDERR);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the buffer unused, and reclaim string storage */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buf-&gt;pid = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str-&gt;data);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force out <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining pipe data as-is; we don't bother trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> protocol headers that may exist in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*bytes_in_logbuffer &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1094" title="postmaster/syslogger.c:1094">write_syslogger_file</a>(logbuffer, *bytes_in_logbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOG_DESTINATION_STDERR);<br/></li>
<li>&nbsp; &nbsp; *bytes_in_logbuffer = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; logfile routines<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Write text to the currently open logfile<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is exported so that elog.c can call it when <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> is B_LOGGER.<br/></li>
<li></span><span class="Comment"> * This allows the syslogger process to record elog messages of its own,<br/></li>
<li></span><span class="Comment"> * even though its stderr does not point at the syslog pipe.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1094">&#x200c;</a></span><span class="linkable">write_syslogger_file</span>(<span class="Type">const</span> <span class="Type">char</span> *buffer, <span class="Type">int</span> count, <span class="Type">int</span> destination)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *logfile;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're told to write to a structured log file, but it's not open,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> the data to <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a> (which is always open) instead.&nbsp; This can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen if structured output is enabled after postmaster start and we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been unable to open logFile.&nbsp; There are also race conditions during a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter change whereby backends might <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> us structured output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we open the logFile or after we close it.&nbsp; Writing formatted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output to the regular log file isn't great, but it beats dropping log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output on the floor.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Think not to improve this by trying to open logFile on-the-fly.&nbsp; Any<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure in that would lead to recursion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((destination &amp; LOG_DESTINATION_CSVLOG) &amp;&amp; <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logfile = <a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((destination &amp; LOG_DESTINATION_JSONLOG) &amp;&amp; <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logfile = <a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; logfile = <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rc = fwrite(buffer, <span class="Constant">1</span>, count, logfile);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to report <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure.&nbsp; We mustn't use ereport because it would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just recurse right back here, but <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a> is OK: it will write<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * either to the postmaster's original stderr, or to /dev/null, but never<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to our input pipe which would result in a different sort of looping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rc != count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L3707" title="utils/error/elog.c:3707">write_stderr</a>(<span class="Constant">&quot;could not write to log file: %m</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Worker thread to transfer data from the pipe to the current logfile.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need this because on Windows, WaitForMultipleObjects does not work on<br/></li>
<li></span><span class="Comment"> * unnamed pipes: it always reports &quot;signaled&quot;, so the blocking ReadFile won't<br/></li>
<li></span><span class="Comment"> * allow for SIGHUP; and <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> is for sockets only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> __stdcall<br/></li>
<li><a id="L1141">&#x200c;</a><span class="linkable">pipeThread</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; logbuffer[<a href="#L60" title="postmaster/syslogger.c:60">READ_BUF_SIZE</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes_in_logbuffer = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; bytesRead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BOOL&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ReadFile(<a href="#L116" title="postmaster/syslogger.c:116">syslogPipe</a>[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logbuffer + bytes_in_logbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(logbuffer) - bytes_in_logbuffer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bytesRead, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Enter critical section <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing anything that might touch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * global state shared by the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> thread. Anything that uses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>()/<a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>() in particular are not safe outside the critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * section.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; EnterCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DWORD&nbsp; &nbsp; &nbsp; &nbsp; error = GetLastError();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (error == ERROR_HANDLE_EOF ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; error == ERROR_BROKEN_PIPE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; _dosmaperr(error);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not read from logger pipe: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (bytesRead &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bytes_in_logbuffer += bytesRead;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L880" title="postmaster/syslogger.c:880">process_pipe_input</a>(logbuffer, &amp;bytes_in_logbuffer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've filled the current logfile, nudge the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> thread to do a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * log rotation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ftell(<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>) &gt;= <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> * <span class="Constant">1024L</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a> != <span class="Constant">NULL</span> &amp;&amp; ftell(<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>) &gt;= <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> * <span class="Constant">1024L</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a> != <span class="Constant">NULL</span> &amp;&amp; ftell(<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>) &gt;= <a href="#L72" title="postmaster/syslogger.c:72">Log_RotationSize</a> * <span class="Constant">1024L</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; LeaveCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We exit the above loop only upon detecting pipe EOF */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L84" title="postmaster/syslogger.c:84">pipe_eof_seen</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if there's <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> data left then force it out <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L1043" title="postmaster/syslogger.c:1043">flush_pipe_input</a>(logbuffer, &amp;bytes_in_logbuffer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set the latch to waken the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> thread, which will quit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; LeaveCriticalSection(&amp;<a href="#L123" title="postmaster/syslogger.c:123">sysloggerSection</a>);<br/></li>
<li>&nbsp; &nbsp; _endthread();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WIN32 */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Open a new logfile with proper permissions and buffering options.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If allow_errors is true, we just log <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> open failure and return NULL<br/></li>
<li></span><span class="Comment"> * (with errno still correct for the fopen failure).<br/></li>
<li></span><span class="Comment"> * Otherwise, errors are treated as fatal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">FILE</span> *<br/></li>
<li><a id="L1218">&#x200c;</a><span class="linkable">logfile_open</span>(<span class="Type">const</span> <span class="Type">char</span> *filename, <span class="Type">const</span> <span class="Type">char</span> *mode, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_errors)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fh;<br/></li>
<li>&nbsp; &nbsp; mode_t&nbsp; &nbsp; &nbsp; &nbsp; oumask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we do not let <a href="#L76" title="postmaster/syslogger.c:76">Log_file_mode</a> disable IWUSR, since we certainly want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be able to write the files ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oumask = umask((mode_t) ((~(<a href="#L76" title="postmaster/syslogger.c:76">Log_file_mode</a> | S_IWUSR)) &amp; (S_IRWXU | S_IRWXG | S_IRWXO)));<br/></li>
<li>&nbsp; &nbsp; fh = fopen(filename, mode);<br/></li>
<li>&nbsp; &nbsp; umask(oumask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setvbuf(fh, <span class="Constant">NULL</span>, PG_IOLBF, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use CRLF line endings on Windows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _setmode(_fileno(fh), _O_TEXT);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(allow_errors ? LOG : FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open log file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; errno = save_errno;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> fh;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do logfile rotation for a single destination, as specified by target_dest.<br/></li>
<li></span><span class="Comment"> * The information stored in *last_file_name and *logFile is updated on a<br/></li>
<li></span><span class="Comment"> * successful file rotation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns false if the rotation has been stopped, or true to move on to<br/></li>
<li></span><span class="Comment"> * the processing of other formats.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1263">&#x200c;</a></span><span class="linkable">logfile_rotate_dest</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> time_based_rotation, <span class="Type">int</span> size_rotation_for,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_time_t fntime, <span class="Type">int</span> target_dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> **last_file_name, <span class="Type">FILE</span> **logFile)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *logFileExt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filename;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fh;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the target destination was just turned off, close the previous file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and unregister its data.&nbsp; This cannot happen for stderr as <a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is assumed to be always opened even if stderr is disabled in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * log_destination.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; target_dest) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target_dest != LOG_DESTINATION_STDERR)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*logFile != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(*logFile);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *logFile = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*last_file_name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(*last_file_name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *last_file_name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Leave if it is not time for a rotation or if the target destination has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no need to do a rotation based on the size of its file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!time_based_rotation &amp;&amp; (size_rotation_for &amp; target_dest) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* file extension depends on the destination type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (target_dest == LOG_DESTINATION_STDERR)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logFileExt = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (target_dest == LOG_DESTINATION_CSVLOG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logFileExt = <span class="Constant">&quot;.csv&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (target_dest == LOG_DESTINATION_JSONLOG)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; logFileExt = <span class="Constant">&quot;.json&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cannot happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* build the new file name */<br/></li>
<li></span>&nbsp; &nbsp; filename = <a href="#L1411" title="postmaster/syslogger.c:1411">logfile_getname</a>(fntime, logFileExt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Decide whether to overwrite or append.&nbsp; We can overwrite if (a)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L75" title="postmaster/syslogger.c:75">Log_truncate_on_rotation</a> is set, (b) the rotation was triggered by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * elapsed time and not something else, and (c) the computed file name is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different from what we were previously logging into.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L75" title="postmaster/syslogger.c:75">Log_truncate_on_rotation</a> &amp;&amp; time_based_rotation &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *last_file_name != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strcmp(filename, *last_file_name) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fh = <a href="#L1218" title="postmaster/syslogger.c:1218">logfile_open</a>(filename, <span class="Constant">&quot;w&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fh = <a href="#L1218" title="postmaster/syslogger.c:1218">logfile_open</a>(filename, <span class="Constant">&quot;a&quot;</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!fh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ENFILE/EMFILE are not too surprising on a busy system; just keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * using the old file till we manage to get a new one.&nbsp; Otherwise,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * assume something's wrong with <a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a> and stop trying to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * create files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno != <span class="Constant">ENFILE</span> &amp;&amp; errno != <span class="Constant">EMFILE</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;disabling automatic rotation (use SIGHUP to re-enable)&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="postmaster/syslogger.c:85">rotation_disabled</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (filename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill in the new information */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*logFile != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fclose(*logFile);<br/></li>
<li>&nbsp; &nbsp; *logFile = fh;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* instead of <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>'ing filename, remember it for <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*last_file_name != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(*last_file_name);<br/></li>
<li>&nbsp; &nbsp; *last_file_name = filename;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * perform logfile rotation<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1362">&#x200c;</a></span><span class="linkable">logfile_rotate</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> time_based_rotation, <span class="Type">int</span> size_rotation_for)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; fntime;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When doing a time-based rotation, invent the new logfile name based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the planned rotation time, not current time, to avoid &quot;slippage&quot; in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * file name when we don't do the rotation immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (time_based_rotation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fntime = <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; fntime = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* file rotation for stderr */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1263" title="postmaster/syslogger.c:1263">logfile_rotate_dest</a>(time_based_rotation, size_rotation_for, fntime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOG_DESTINATION_STDERR, &amp;<a href="#L90" title="postmaster/syslogger.c:90">last_sys_file_name</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L86" title="postmaster/syslogger.c:86">syslogFile</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* file rotation for csvlog */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1263" title="postmaster/syslogger.c:1263">logfile_rotate_dest</a>(time_based_rotation, size_rotation_for, fntime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOG_DESTINATION_CSVLOG, &amp;<a href="#L91" title="postmaster/syslogger.c:91">last_csv_file_name</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L87" title="postmaster/syslogger.c:87">csvlogFile</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* file rotation for jsonlog */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L1263" title="postmaster/syslogger.c:1263">logfile_rotate_dest</a>(time_based_rotation, size_rotation_for, fntime,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LOG_DESTINATION_JSONLOG, &amp;<a href="#L92" title="postmaster/syslogger.c:92">last_json_file_name</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L88" title="postmaster/syslogger.c:88">jsonlogFile</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1476" title="postmaster/syslogger.c:1476">update_metainfo_datafile</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L1441" title="postmaster/syslogger.c:1441">set_next_rotation_time</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * construct logfile name using timestamp information<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If suffix isn't NULL, append it to the name, replacing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> &quot;.log&quot;<br/></li>
<li></span><span class="Comment"> * that may be in the pattern.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Result is <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">char</span> *<br/></li>
<li><a id="L1411">&#x200c;</a><span class="linkable">logfile_getname</span>(pg_time_t timestamp, <span class="Type">const</span> <span class="Type">char</span> *suffix)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *filename;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; filename = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(MAXPGPATH);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(filename, MAXPGPATH, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/&quot;</span>, <a href="#L73" title="postmaster/syslogger.c:73">Log_directory</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = strlen(filename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* treat <a href="#L74" title="postmaster/syslogger.c:74">Log_filename</a> as a <a href="../utils/adt/pg_locale.c.html#L774" title="utils/adt/pg_locale.c:774">strftime</a> pattern */<br/></li>
<li></span>&nbsp; &nbsp; pg_strftime(filename + len, MAXPGPATH - len, <a href="#L74" title="postmaster/syslogger.c:74">Log_filename</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_localtime(&amp;timestamp, log_timezone));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (suffix != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(filename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">4</span> &amp;&amp; (strcmp(filename + (len - <span class="Constant">4</span>), <span class="Constant">&quot;.log&quot;</span>) == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; len -= <span class="Constant">4</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strlcpy(filename + len, suffix, MAXPGPATH - len);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> filename;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> planned rotation time, and store in <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1441">&#x200c;</a></span><span class="linkable">set_next_rotation_time</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_time_t&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> pg_tm *tm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rotinterval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nothing to do if time-based rotation is disabled */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a> &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The requirements here are to choose the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time &gt; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;multiple&quot; of the log rotation interval.&nbsp; &quot;Multiple&quot; can be interpreted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fairly loosely.&nbsp; In this version we align to log_timezone rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GMT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rotinterval = <a href="#L71" title="postmaster/syslogger.c:71">Log_RotationAge</a> * SECS_PER_MINUTE;&nbsp; &nbsp; <span class="Comment">/* convert to seconds */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> = (pg_time_t) time(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; tm = pg_localtime(&amp;<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, log_timezone);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> += tm-&gt;tm_gmtoff;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> -= <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> % rotinterval;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> += rotinterval;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> -= tm-&gt;tm_gmtoff;<br/></li>
<li>&nbsp; &nbsp; <a href="#L83" title="postmaster/syslogger.c:83">next_rotation_time</a> = <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store the name of the file(s) where the log collector, when enabled, writes<br/></li>
<li></span><span class="Comment"> * log messages.&nbsp; Useful for finding the name(s) of the current log file(s)<br/></li>
<li></span><span class="Comment"> * when there is time-based logfile rotation.&nbsp; Filenames are stored in a<br/></li>
<li></span><span class="Comment"> * temporary file and which is renamed into the final destination for<br/></li>
<li></span><span class="Comment"> * atomicity.&nbsp; The file is opened with the same permissions as what gets<br/></li>
<li></span><span class="Comment"> * created in the data directory and has proper buffering options.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1476">&#x200c;</a></span><span class="linkable">update_metainfo_datafile</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">FILE</span>&nbsp; &nbsp; &nbsp;&nbsp; *fh;<br/></li>
<li>&nbsp; &nbsp; mode_t&nbsp; &nbsp; &nbsp; &nbsp; oumask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_STDERR) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_CSVLOG) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !(<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_JSONLOG))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(LOG_METAINFO_DATAFILE) &lt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not remove file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* use the same permissions as the data directory for the new file */<br/></li>
<li></span>&nbsp; &nbsp; oumask = umask(pg_mode_mask);<br/></li>
<li>&nbsp; &nbsp; fh = fopen(LOG_METAINFO_DATAFILE_TMP, <span class="Constant">&quot;w&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; umask(oumask);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fh)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; setvbuf(fh, <span class="Constant">NULL</span>, PG_IOLBF, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef WIN32<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use CRLF line endings on Windows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; _setmode(_fileno(fh), _O_TEXT);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not open file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE_TMP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="postmaster/syslogger.c:90">last_sys_file_name</a> &amp;&amp; (<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_STDERR))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fprintf(fh, <span class="Constant">&quot;stderr </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, <a href="#L90" title="postmaster/syslogger.c:90">last_sys_file_name</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE_TMP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L91" title="postmaster/syslogger.c:91">last_csv_file_name</a> &amp;&amp; (<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_CSVLOG))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fprintf(fh, <span class="Constant">&quot;csvlog </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, <a href="#L91" title="postmaster/syslogger.c:91">last_csv_file_name</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE_TMP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L92" title="postmaster/syslogger.c:92">last_json_file_name</a> &amp;&amp; (<a href="../utils/error/elog.c.html#L112" title="utils/error/elog.c:112">Log_destination</a> &amp; LOG_DESTINATION_JSONLOG))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fprintf(fh, <span class="Constant">&quot;jsonlog </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, <a href="#L92" title="postmaster/syslogger.c:92">last_json_file_name</a>) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not write file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE_TMP)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fclose(fh);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; fclose(fh);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rename(LOG_METAINFO_DATAFILE_TMP, LOG_METAINFO_DATAFILE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LOG_METAINFO_DATAFILE_TMP, LOG_METAINFO_DATAFILE)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; signal handler routines<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check to see if a log rotation request has arrived.&nbsp; Should be<br/></li>
<li></span><span class="Comment"> * called by postmaster after receiving SIGUSR1.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1573">&#x200c;</a></span><span class="linkable">CheckLogrotateSignal</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stat(<a href="#L63" title="postmaster/syslogger.c:63">LOGROTATE_SIGNAL_FILE</a>, &amp;stat_buf) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the file signaling a log rotation request.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1587">&#x200c;</a></span><span class="linkable">RemoveLogrotateSignalFiles</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; unlink(<a href="#L63" title="postmaster/syslogger.c:63">LOGROTATE_SIGNAL_FILE</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* SIGUSR1: set flag to rotate logfile */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1594">&#x200c;</a></span><span class="linkable">sigUsr1Handler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L129" title="postmaster/syslogger.c:129">rotation_requested</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
