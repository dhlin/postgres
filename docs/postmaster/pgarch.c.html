<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>postmaster/pgarch.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>postmaster/pgarch.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L104">ArchiveCallbacks</a></li>
<li><a href="#L103">PgArch</a></li>
<li><a href="#L94">XLogArchiveLibrary</a></li>
<li><a href="#L132">arch_files</a></li>
<li><a href="#L95">arch_module_check_errdetail_string</a></li>
<li><a href="#L106">archive_context</a></li>
<li><a href="#L105">archive_module_state</a></li>
<li><a href="#L102">last_sigterm_time</a></li>
<li><a href="#L137">ready_to_stop</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L84">PgArchData</a></li>
<li><a href="#L92">PgArchData</a></li>
<li><a href="#L123">arch_files_state</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L859">HandlePgArchInterrupts</a></li>
<li><a href="#L911">LoadArchiveLibrary</a></li>
<li><a href="#L197">PgArchCanRestart</a></li>
<li><a href="#L802">PgArchForceDirScan</a></li>
<li><a href="#L168">PgArchShmemInit</a></li>
<li><a href="#L157">PgArchShmemSize</a></li>
<li><a href="#L280">PgArchWakeup</a></li>
<li><a href="#L217">PgArchiverMain</a></li>
<li><a href="#L380">pgarch_ArchiverCopyLoop</a></li>
<li><a href="#L310">pgarch_MainLoop</a></li>
<li><a href="#L816">pgarch_archiveDone</a></li>
<li><a href="#L516">pgarch_archiveXlog</a></li>
<li><a href="#L953">pgarch_call_module_shutdown_cb</a></li>
<li><a href="#L845">pgarch_die</a></li>
<li><a href="#L643">pgarch_readyXlog</a></li>
<li><a href="#L297">pgarch_waken_stop</a></li>
<li><a href="#L779">ready_file_comparator</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L70">NUM_ARCHIVE_RETRIES</a></li>
<li><a href="#L81">NUM_FILES_PER_DIRECTORY_SCAN</a></li>
<li><a href="#L76">NUM_ORPHAN_CLEANUP_RETRIES</a></li>
<li><a href="#L61">PGARCH_AUTOWAKE_INTERVAL</a></li>
<li><a href="#L63">PGARCH_RESTART_INTERVAL</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pgarch.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; PostgreSQL WAL archiver<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; All <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> relating to archiver are included here<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - All <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> executed by archiver process<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; - archiver is forked from postmaster, and the two<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; processes then communicate using signals. All <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; executed by postmaster are included in this file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Initial author: Simon Riggs&nbsp; &nbsp; &nbsp; &nbsp; simon@2ndquadrant.com<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/postmaster/pgarch.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog_internal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;archive/archive_module.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;archive/shell_archive.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/binaryheap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/auxprocess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/pgarch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/condition_variable.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/latch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/shmem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/resowner.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Timer definitions.<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PGARCH_AUTOWAKE_INTERVAL</span> </span><span class="Constant">60</span><span class="PreProc"> </span><span class="Comment">/* How often to force a poll of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archive status directory; in seconds. */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PGARCH_RESTART_INTERVAL</span> </span><span class="Constant">10</span><span class="PreProc">&nbsp; &nbsp; </span><span class="Comment">/* How often to attempt to restart a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed archiver; in seconds. */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of retries allowed when attempting to archive a WAL<br/></li>
<li></span><span class="Comment"> * file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L70">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_ARCHIVE_RETRIES</span> </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of retries allowed when attempting to remove an<br/></li>
<li></span><span class="Comment"> * orphan archive status file.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L76">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_ORPHAN_CLEANUP_RETRIES</span> </span><span class="Constant">3<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of .ready files to gather per directory scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L81">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_FILES_PER_DIRECTORY_SCAN</span> </span><span class="Constant">64<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Shared memory area for archiver process */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PgArchData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pgprocno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* proc number of archiver process */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Forces a directory scan in <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_atomic_uint32 force_dir_scan;<br/></li>
<li><a id="L92">&#x200c;</a>} <span class="linkable">PgArchData</span>;<br/></li>
<li><br/></li>
<li><a id="L94">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">XLogArchiveLibrary</span> = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li><a id="L95">&#x200c;</a><span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<span class="linkable">arch_module_check_errdetail_string</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Local data<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L102">&#x200c;</a></span><span class="Type">static</span> <span class="Type">time_t</span> <span class="linkable">last_sigterm_time</span> = <span class="Constant">0</span>;<br/></li>
<li><a id="L103">&#x200c;</a><span class="Type">static</span> <a href="#L84" title="postmaster/pgarch.c:84">PgArchData</a> *<span class="linkable">PgArch</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L104">&#x200c;</a><span class="Type">static</span> <span class="Type">const</span> ArchiveModuleCallbacks *<span class="linkable">ArchiveCallbacks</span>;<br/></li>
<li><a id="L105">&#x200c;</a><span class="Type">static</span> ArchiveModuleState *<span class="linkable">archive_module_state</span>;<br/></li>
<li><a id="L106">&#x200c;</a><span class="Type">static</span> MemoryContext <span class="linkable">archive_context</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stuff for tracking multiple files to archive from each scan of<br/></li>
<li></span><span class="Comment"> * archive_status.&nbsp; Minimizing the number of directory scans when there are<br/></li>
<li></span><span class="Comment"> * many files to archive can significantly improve archival rate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * arch_heap is a max-heap that is used during the directory scan to track<br/></li>
<li></span><span class="Comment"> * the highest-priority files to archive.&nbsp; After the directory scan<br/></li>
<li></span><span class="Comment"> * completes, the file names are stored in ascending order of priority in<br/></li>
<li></span><span class="Comment"> * <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>.&nbsp; <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>() returns files from <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a> until it<br/></li>
<li></span><span class="Comment"> * is empty, at which point another directory scan must be performed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We only need this data in the archiver process, so make it a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d<br/></li>
<li></span><span class="Comment"> * struct rather than a bunch of static arrays.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">arch_files_state</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; binaryheap *arch_heap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arch_files_size;&nbsp; &nbsp; <span class="Comment">/* number of live entries in <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>[] */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>[<a href="#L81" title="postmaster/pgarch.c:81">NUM_FILES_PER_DIRECTORY_SCAN</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* buffers underlying heap, and later <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>[], entries: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; arch_filenames[<a href="#L81" title="postmaster/pgarch.c:81">NUM_FILES_PER_DIRECTORY_SCAN</a>][MAX_XFN_CHARS + <span class="Constant">1</span>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><a id="L132">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> <a href="#L123" title="postmaster/pgarch.c:123">arch_files_state</a> *<span class="linkable">arch_files</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flags set by interrupt handlers for later service in the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">ready_to_stop</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------<br/></li>
<li></span><span class="Comment"> * Local function forward declarations<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L297" title="postmaster/pgarch.c:297">pgarch_waken_stop</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L310" title="postmaster/pgarch.c:310">pgarch_MainLoop</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L380" title="postmaster/pgarch.c:380">pgarch_ArchiverCopyLoop</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L516" title="postmaster/pgarch.c:516">pgarch_archiveXlog</a>(<span class="Type">char</span> *xlog);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>(<span class="Type">char</span> *xlog);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L816" title="postmaster/pgarch.c:816">pgarch_archiveDone</a>(<span class="Type">char</span> *xlog);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L845" title="postmaster/pgarch.c:845">pgarch_die</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L859" title="postmaster/pgarch.c:859">HandlePgArchInterrupts</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L779" title="postmaster/pgarch.c:779">ready_file_comparator</a>(Datum a, Datum b, <span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L911" title="postmaster/pgarch.c:911">LoadArchiveLibrary</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L953" title="postmaster/pgarch.c:953">pgarch_call_module_shutdown_cb</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><br/></li>
<li><span class="Comment">/* Report shared memory space needed by <a href="#L168" title="postmaster/pgarch.c:168">PgArchShmemInit</a> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L157">&#x200c;</a><span class="linkable">PgArchShmemSize</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; size = <a href="../storage/ipc/shmem.c.html#L493" title="storage/ipc/shmem.c:493">add_size</a>(size, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L84" title="postmaster/pgarch.c:84">PgArchData</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> size;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Allocate and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> archiver-related shared memory */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L168">&#x200c;</a></span><span class="linkable">PgArchShmemInit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="postmaster/pgarch.c:103">PgArch</a> = (<a href="#L84" title="postmaster/pgarch.c:84">PgArchData</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/shmem.c.html#L387" title="storage/ipc/shmem.c:387">ShmemInitStruct</a>(<span class="Constant">&quot;Archiver Data&quot;</span>, <a href="#L157" title="postmaster/pgarch.c:157">PgArchShmemSize</a>(), &amp;found);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, so <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(<a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>, <span class="Constant">0</span>, <a href="#L157" title="postmaster/pgarch.c:157">PgArchShmemSize</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_atomic_init_u32(&amp;<a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;force_dir_scan, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L197" title="postmaster/pgarch.c:197">PgArchCanRestart</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return true and archiver is allowed to restart if enough time has<br/></li>
<li></span><span class="Comment"> * passed since it was launched last to reach <a href="#L63" title="postmaster/pgarch.c:63">PGARCH_RESTART_INTERVAL</a>.<br/></li>
<li></span><span class="Comment"> * Otherwise return false.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a safety valve to protect against continuous respawn attempts if the<br/></li>
<li></span><span class="Comment"> * archiver is dying immediately at launch. Note that since we will retry to<br/></li>
<li></span><span class="Comment"> * launch the archiver from the postmaster <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, we will get another<br/></li>
<li></span><span class="Comment"> * chance later.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L197">&#x200c;</a></span><span class="linkable">PgArchCanRestart</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">time_t</span> last_pgarch_start_time = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; curtime = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Return false and don't restart archiver if too soon since last archiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((<span class="Type">unsigned</span> <span class="Type">int</span>) (curtime - last_pgarch_start_time) &lt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) <a href="#L63" title="postmaster/pgarch.c:63">PGARCH_RESTART_INTERVAL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; last_pgarch_start_time = curtime;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* Main entry point for archiver process */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L217">&#x200c;</a></span><span class="linkable">PgArchiverMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_ARCHIVER;<br/></li>
<li>&nbsp; &nbsp; <a href="auxprocess.c.html#L44" title="postmaster/auxprocess.c:44">AuxiliaryProcessMainCommon</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ignore all signals usually bound to some action in the postmaster,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * except for SIGHUP, SIGTERM, SIGUSR1, SIGUSR2, and SIGQUIT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="interrupt.c.html#L105" title="postmaster/interrupt.c:105">SignalHandlerForShutdownRequest</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGALRM</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <a href="#L297" title="postmaster/pgarch.c:297">pgarch_waken_stop</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reset some signals that are accepted by postmaster but not here */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unblock signals (they were blocked when the postmaster forked us) */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We shouldn't be launched unnecessarily. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(XLogArchivingActive());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange to clean up at archiver exit */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a>(<a href="#L845" title="postmaster/pgarch.c:845">pgarch_die</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advertise our proc number so that backends can use our latch to wake us<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up while we're sleeping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;pgprocno = <a href="../utils/init/globals.c.html#L87" title="utils/init/globals.c:87">MyProcNumber</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create workspace for <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a> = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">struct</span> <a href="#L123" title="postmaster/pgarch.c:123">arch_files_state</a>));<br/></li>
<li>&nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize our max-heap for prioritizing files to archive. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap = binaryheap_allocate(<a href="#L81" title="postmaster/pgarch.c:81">NUM_FILES_PER_DIRECTORY_SCAN</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L779" title="postmaster/pgarch.c:779">ready_file_comparator</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize our memory context. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L106" title="postmaster/pgarch.c:106">archive_context</a> = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;archiver&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Load the archive_library. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L911" title="postmaster/pgarch.c:911">LoadArchiveLibrary</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L310" title="postmaster/pgarch.c:310">pgarch_MainLoop</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Wake up the archiver<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L280">&#x200c;</a></span><span class="linkable">PgArchWakeup</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arch_pgprocno = <a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;pgprocno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't acquire ProcArrayLock here.&nbsp; It's actually fine because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * procLatch isn't ever freed, so we just can potentially set the wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process' (or no process') latch.&nbsp; Even in that case the archiver will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be relaunched shortly and will start archiving.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (arch_pgprocno != INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(&amp;<a href="../storage/lmgr/proc.c.html#L78" title="storage/lmgr/proc.c:78">ProcGlobal</a>-&gt;<a href="../storage/ipc/procarray.c.html#L271" title="storage/ipc/procarray.c:271">allProcs</a>[arch_pgprocno].procLatch);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* SIGUSR2 signal handler for archiver process */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L297">&#x200c;</a></span><span class="linkable">pgarch_waken_stop</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set flag to do a final cycle and shut down afterwards */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L137" title="postmaster/pgarch.c:137">ready_to_stop</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L310" title="postmaster/pgarch.c:310">pgarch_MainLoop</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Main loop for archiver<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L310">&#x200c;</a></span><span class="linkable">pgarch_MainLoop</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; time_to_stop;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There shouldn't be anything for the archiver to do except to wait for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * signal ... however, the archiver exists to protect our data, so it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wakes up occasionally to allow itself to be proactive.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L724" title="storage/ipc/latch.c:724">ResetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* When we get SIGUSR2, we do one more archive cycle, then exit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; time_to_stop = <a href="#L137" title="postmaster/pgarch.c:137">ready_to_stop</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for barrier events and config update */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L859" title="postmaster/pgarch.c:859">HandlePgArchInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we've gotten SIGTERM, we normally just sit and do nothing until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SIGUSR2 arrives.&nbsp; However, that means a random SIGTERM would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * disable archiving indefinitely, which doesn't seem like a good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * idea.&nbsp; If more than 60 seconds pass since SIGTERM, exit anyway, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the postmaster can start a new archiver if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">time_t</span>&nbsp; &nbsp; &nbsp; &nbsp; curtime = time(<span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L102" title="postmaster/pgarch.c:102">last_sigterm_time</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L102" title="postmaster/pgarch.c:102">last_sigterm_time</a> = curtime;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((<span class="Type">unsigned</span> <span class="Type">int</span>) (curtime - <a href="#L102" title="postmaster/pgarch.c:102">last_sigterm_time</a>) &gt;=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">unsigned</span> <span class="Type">int</span>) <span class="Constant">60</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do what we're here for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L380" title="postmaster/pgarch.c:380">pgarch_ArchiverCopyLoop</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sleep until a signal is received, or until a poll is forced by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L61" title="postmaster/pgarch.c:61">PGARCH_AUTOWAKE_INTERVAL</a>, or until postmaster dies.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!time_to_stop)&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't wait during last iteration */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rc = <a href="../storage/ipc/latch.c.html#L517" title="storage/ipc/latch.c:517">WaitLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WL_LATCH_SET | WL_TIMEOUT | WL_POSTMASTER_DEATH,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L61" title="postmaster/pgarch.c:61">PGARCH_AUTOWAKE_INTERVAL</a> * <span class="Constant">1000L</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; WAIT_EVENT_ARCHIVER_MAIN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rc &amp; WL_POSTMASTER_DEATH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; time_to_stop = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The archiver quits either when the postmaster dies (not expected)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or after completing one more archiving cycle after receiving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SIGUSR2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; } <span class="Statement">while</span> (!time_to_stop);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L380" title="postmaster/pgarch.c:380">pgarch_ArchiverCopyLoop</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Archives all outstanding xlogs then returns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L380">&#x200c;</a></span><span class="linkable">pgarch_ArchiverCopyLoop</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlog[MAX_XFN_CHARS + <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* force directory scan in the first call to <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>() */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * loop through all xlogs with archive_status of .ready and archive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them...mostly we expect this to be a single file, though it is possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some backend will add files onto the list of those that need archiving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * while we are still copying earlier archives<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>(xlog))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failures = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; failures_orphan = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> stat stat_buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pathname[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not initiate <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more archive commands after receiving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SIGTERM, nor after the postmaster has died unexpectedly. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * first condition is to try to keep from having init SIGKILL the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command, and the second is to avoid conflicts with another<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * archiver spawned by a newer postmaster.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L28" title="postmaster/interrupt.c:28">ShutdownRequestPending</a> || !PostmasterIsAlive())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for barrier events and config update.&nbsp; This is so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll adopt a new setting for archive_command as soon as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible, even if there is a backlog of files to be archived.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L859" title="postmaster/pgarch.c:859">HandlePgArchInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset variables that might be set by the callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L95" title="postmaster/pgarch.c:95">arch_module_check_errdetail_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't do anything if not configured ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;check_configured_cb != <span class="Constant">NULL</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;check_configured_cb(<a href="#L105" title="postmaster/pgarch.c:105">archive_module_state</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;archive_mode enabled, yet archiving is not configured&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L95" title="postmaster/pgarch.c:95">arch_module_check_errdetail_string</a> ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="#L95" title="postmaster/pgarch.c:95">arch_module_check_errdetail_string</a>) : <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since archive status files are not removed in a durable manner,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a system crash could leave behind .ready files for WAL segments<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that have already been recycled or removed.&nbsp; In this case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * simply remove the orphan status file and move on.&nbsp; unlink() is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * used here as even on subsequent crashes the same orphan files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would get removed, so there is no need to worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * durability.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(pathname, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlog);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat(pathname, &amp;stat_buf) != <span class="Constant">0</span> &amp;&amp; errno == <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; xlogready[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StatusFilePath(xlogready, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (unlink(xlogready) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removed orphan archive status file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogready)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* leave loop and move to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> status file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++failures_orphan &gt;= <a href="#L76" title="postmaster/pgarch.c:76">NUM_ORPHAN_CLEANUP_RETRIES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;removal of orphan archive status file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> failed too many times, will try again later&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlogready)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* give up <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> of orphan status files */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* wait a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> retrying */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000000L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L516" title="postmaster/pgarch.c:516">pgarch_archiveXlog</a>(xlog))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* successful */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L816" title="postmaster/pgarch.c:816">pgarch_archiveDone</a>(xlog);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell the cumulative stats system about the WAL file that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * successfully archived<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_archiver.c.html#L28" title="utils/activity/pgstat_archiver.c:28">pgstat_report_archiver</a>(xlog, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of inner retry loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell the cumulative stats system about the WAL file that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * failed to archive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_archiver.c.html#L28" title="utils/activity/pgstat_archiver.c:28">pgstat_report_archiver</a>(xlog, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++failures &gt;= <a href="#L70" title="postmaster/pgarch.c:70">NUM_ARCHIVE_RETRIES</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;archiving write-ahead log file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> failed too many times, will try again later&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlog)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* give up archiving for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<span class="Constant">1000000L</span>);&nbsp; &nbsp; <span class="Comment">/* wait a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> retrying */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L516" title="postmaster/pgarch.c:516">pgarch_archiveXlog</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Invokes archive_file_cb to copy one archive file to wherever it should go<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L516">&#x200c;</a></span><span class="linkable">pgarch_archiveXlog</span>(<span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; pathname[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; activitymsg[MAXFNAMELEN + <span class="Constant">16</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; snprintf(pathname, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlog);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report archive activity in PS display */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;archiving </span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlog);<br/></li>
<li>&nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="#L106" title="postmaster/pgarch.c:106">archive_context</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since the archiver operates at the bottom of the exception stack,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ERRORs turn into FATALs and cause the archiver process to restart.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, using ereport(ERROR, ...) when there are problems is easy to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * code and maintain.&nbsp; Therefore, we create our own exception handler to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catch ERRORs and return false instead of restarting the archiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whenever there is a failure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We assume ERRORs from the archiving callback are the most common<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exceptions experienced by the archiver, so we opt to handle exceptions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here instead of <a href="#L217" title="postmaster/pgarch.c:217">PgArchiverMain</a>() to avoid reinitializing the archiver<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * too frequently.&nbsp; We could instead add a sigsetjmp() block to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L217" title="postmaster/pgarch.c:217">PgArchiverMain</a>() and use PG_TRY/PG_CATCH here, but the extra code to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * avoid the odd archiver restart doesn't seem worth it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the server log. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Try to clean up anything the archive module left behind.&nbsp; We try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cover anything that an archive module could conceivably have left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * behind, but it is of course possible that modules could be doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unexpected things that require additional <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>.&nbsp; Module authors<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be sure to do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> extra required <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> in a PG_CATCH block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * within the archiving callback, and they are encouraged to notify<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the pgsql-hackers mailing list so that we can add it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L751" title="utils/misc/timeout.c:751">disable_all_timeouts</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1878" title="storage/lmgr/lwlock.c:1878">LWLockReleaseAll</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/condition_variable.c.html#L230" title="storage/lmgr/condition_variable.c:230">ConditionVariableCancelSleep</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pgstat_report_wait_end();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L1002" title="utils/resowner/resowner.c:1002">ReleaseAuxProcessResources</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/file/fd.c.html#L3165" title="storage/file/fd.c:3165">AtEOXact_Files</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1869" title="utils/hash/dynahash.c:1869">AtEOXact_HashTables</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Return to the original memory context and clear <a href="../utils/mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Flush <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> leaked data */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L106" title="postmaster/pgarch.c:106">archive_context</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove our exception handler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can allow interrupts again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report failure so that the archiver retries this file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Enable our exception handler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Archive the file! */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ret = <a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;archive_file_cb(<a href="#L105" title="postmaster/pgarch.c:105">archive_module_state</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xlog, pathname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove our exception handler */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Reset our memory context and switch back to the original one */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="#L106" title="postmaster/pgarch.c:106">archive_context</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ret)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;last was </span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlog);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(activitymsg, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(activitymsg), <span class="Constant">&quot;failed on </span><span class="Special">%s</span><span class="Constant">&quot;</span>, xlog);<br/></li>
<li>&nbsp; &nbsp; set_ps_display(activitymsg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ret;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return name of the oldest xlog file that has not yet been archived.<br/></li>
<li></span><span class="Comment"> * No notification is set that file archiving is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> in progress, so<br/></li>
<li></span><span class="Comment"> * this would need to be extended if multiple concurrent archival<br/></li>
<li></span><span class="Comment"> * tasks were created. If a failure occurs, we will completely<br/></li>
<li></span><span class="Comment"> * re-copy the file at the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> available opportunity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is important that we return the oldest, so that we archive xlogs<br/></li>
<li></span><span class="Comment"> * in order that they were written, for two reasons:<br/></li>
<li></span><span class="Comment"> * 1) to maintain the sequential chain of xlogs required for recovery<br/></li>
<li></span><span class="Comment"> * 2) because the oldest ones will sooner become candidates for<br/></li>
<li></span><span class="Comment"> * recycling at time of checkpoint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the &quot;oldest&quot; comparison will consider <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> .history file to be older<br/></li>
<li></span><span class="Comment"> * than <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other file except another .history file.&nbsp; Segments on a timeline<br/></li>
<li></span><span class="Comment"> * with a smaller ID will be older than all segments on a timeline with a<br/></li>
<li></span><span class="Comment"> * larger ID; the net result being that past timelines are given higher<br/></li>
<li></span><span class="Comment"> * priority for archiving.&nbsp; This seems okay, or at least not obviously worth<br/></li>
<li></span><span class="Comment"> * changing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">pgarch_readyXlog</span>(<span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; XLogArchiveStatusDir[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">DIR</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *rldir;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> dirent *rlde;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a directory scan was requested, clear the stored file names and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pg_atomic_exchange_u32(&amp;<a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;force_dir_scan, <span class="Constant">0</span>) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we still have stored file names from the previous directory scan,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try to return one of those.&nbsp; We check to make sure the status file is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * still present, as the archive_command for a previous file may have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already marked it done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> stat st;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; status_file[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arch_file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arch_file = <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>[<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StatusFilePath(status_file, arch_file, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stat(status_file, &amp;st) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(xlog, arch_file);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (errno != <span class="Constant">ENOENT</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not stat file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>, status_file)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* arch_heap is probably empty, but let's make sure */<br/></li>
<li></span>&nbsp; &nbsp; binaryheap_reset(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the archive status directory and read through the list of files<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the .ready suffix, looking for the earliest files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snprintf(XLogArchiveStatusDir, MAXPGPATH, XLOGDIR <span class="Constant">&quot;/archive_status&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; rldir = <a href="../storage/file/fd.c.html#L2843" title="storage/file/fd.c:2843">AllocateDir</a>(XLogArchiveStatusDir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((rlde = <a href="../storage/file/fd.c.html#L2909" title="storage/file/fd.c:2909">ReadDir</a>(rldir, XLogArchiveStatusDir)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basenamelen = (<span class="Type">int</span>) strlen(rlde-&gt;d_name) - <span class="Constant">6</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; basename[MAX_XFN_CHARS + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *arch_file;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore entries with unexpected number of characters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (basenamelen &lt; MIN_XFN_CHARS ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basenamelen &gt; MAX_XFN_CHARS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore entries with unexpected characters */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strspn(rlde-&gt;d_name, VALID_XFN_CHARS) &lt; basenamelen)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore anything not suffixed with .ready */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(rlde-&gt;d_name + basenamelen, <span class="Constant">&quot;.ready&quot;</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Truncate off the .ready */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(basename, rlde-&gt;d_name, basenamelen);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; basename[basenamelen] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store the file in our max-heap if it has a high enough priority.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap-&gt;bh_size &lt; <a href="#L81" title="postmaster/pgarch.c:81">NUM_FILES_PER_DIRECTORY_SCAN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the heap isn't full yet, quickly add it. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arch_file = <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_filenames[<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap-&gt;bh_size];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(arch_file, basename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_add_unordered(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap, CStringGetDatum(arch_file));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we just filled the heap, make it a valid one. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap-&gt;bh_size == <a href="#L81" title="postmaster/pgarch.c:81">NUM_FILES_PER_DIRECTORY_SCAN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_build(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="#L779" title="postmaster/pgarch.c:779">ready_file_comparator</a>(binaryheap_first(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CStringGetDatum(basename), <span class="Constant">NULL</span>) &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the lowest priority file and add the current one to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arch_file = DatumGetCString(binaryheap_remove_first(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcpy(arch_file, basename);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; binaryheap_add(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap, CStringGetDatum(arch_file));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L2961" title="storage/file/fd.c:2961">FreeDir</a>(rldir);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If no files were found, simply return. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap-&gt;bh_size == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we didn't fill the heap, we didn't make it a valid one.&nbsp; Do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap-&gt;bh_size &lt; <a href="#L81" title="postmaster/pgarch.c:81">NUM_FILES_PER_DIRECTORY_SCAN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; binaryheap_build(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a> array with the files to archive in ascending order of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * priority.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size = <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap-&gt;bh_size;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>[i] = DatumGetCString(binaryheap_remove_first(<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_heap));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return the highest priority file. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size--;<br/></li>
<li>&nbsp; &nbsp; strcpy(xlog, <a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>[<a href="#L132" title="postmaster/pgarch.c:132">arch_files</a>-&gt;arch_files_size]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L779" title="postmaster/pgarch.c:779">ready_file_comparator</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Compares the archival priority of the given files to archive.&nbsp; If &quot;a&quot;<br/></li>
<li></span><span class="Comment"> * has a higher priority than &quot;b&quot;, a negative value will be returned.&nbsp; If<br/></li>
<li></span><span class="Comment"> * &quot;b&quot; has a higher priority than &quot;a&quot;, a positive value will be returned.<br/></li>
<li></span><span class="Comment"> * If &quot;a&quot; and &quot;b&quot; have equivalent <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, 0 will be returned.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L779">&#x200c;</a></span><span class="linkable">ready_file_comparator</span>(Datum a, Datum b, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *a_str = DatumGetCString(a);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *b_str = DatumGetCString(b);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; a_history = IsTLHistoryFileName(a_str);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; b_history = IsTLHistoryFileName(b_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Timeline history files always have the highest priority. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (a_history != b_history)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> a_history ? -<span class="Constant">1</span> : <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Priority is given to older files. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> strcmp(a_str, b_str);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L802" title="postmaster/pgarch.c:802">PgArchForceDirScan</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When called, the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> call to <a href="#L643" title="postmaster/pgarch.c:643">pgarch_readyXlog</a>() will perform a<br/></li>
<li></span><span class="Comment"> * directory scan.&nbsp; This is useful for ensuring that important files such<br/></li>
<li></span><span class="Comment"> * as timeline history files are archived as quickly as possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L802">&#x200c;</a></span><span class="linkable">PgArchForceDirScan</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; pg_atomic_write_membarrier_u32(&amp;<a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;force_dir_scan, <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L816" title="postmaster/pgarch.c:816">pgarch_archiveDone</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Emit notification that an xlog file has been successfully archived.<br/></li>
<li></span><span class="Comment"> * We do this by renaming the status file from NNN.ready to NNN.done.<br/></li>
<li></span><span class="Comment"> * Eventually, a checkpoint process will notice this and delete both the<br/></li>
<li></span><span class="Comment"> * NNN.done file and the xlog file itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L816">&#x200c;</a></span><span class="linkable">pgarch_archiveDone</span>(<span class="Type">char</span> *xlog)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; rlogready[MAXPGPATH];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; rlogdone[MAXPGPATH];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; StatusFilePath(rlogready, xlog, <span class="Constant">&quot;.ready&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; StatusFilePath(rlogdone, xlog, <span class="Constant">&quot;.done&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid extra overhead, we don't durably rename the .ready file to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * .done.&nbsp; Archive commands and libraries must gracefully handle attempts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to re-archive files (e.g., if the server crashes just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function is called), so it should be okay if the .ready file reappears<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after a crash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rename(rlogready, rlogdone) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L882" title="utils/error/elog.c:882">errcode_for_file_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not rename file </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: %m&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlogready, rlogdone)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L845" title="postmaster/pgarch.c:845">pgarch_die</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Exit-time <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> handler<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L845">&#x200c;</a></span><span class="linkable">pgarch_die</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="postmaster/pgarch.c:103">PgArch</a>-&gt;pgprocno = INVALID_PROC_NUMBER;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interrupt handler for WAL archiver process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called in the loops <a href="#L310" title="postmaster/pgarch.c:310">pgarch_MainLoop</a> and <a href="#L380" title="postmaster/pgarch.c:380">pgarch_ArchiverCopyLoop</a>.<br/></li>
<li></span><span class="Comment"> * It checks for barrier events, config update and request for logging of<br/></li>
<li></span><span class="Comment"> * memory contexts, but not shutdown request because how to handle<br/></li>
<li></span><span class="Comment"> * shutdown request is different between those loops.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L859">&#x200c;</a></span><span class="linkable">HandlePgArchInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform logging of memory contexts of this process */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *archiveLib = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="#L94" title="postmaster/pgarch.c:94">XLogArchiveLibrary</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; archiveLibChanged;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L94" title="postmaster/pgarch.c:94">XLogArchiveLibrary</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span> &amp;&amp; <a href="../access/transam/xlog.c.html#L120" title="access/transam/xlog.c:120">XLogArchiveCommand</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;both archive_command and archive_library set&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only one of archive_command, archive_library may be set.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; archiveLibChanged = strcmp(<a href="#L94" title="postmaster/pgarch.c:94">XLogArchiveLibrary</a>, archiveLib) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(archiveLib);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (archiveLibChanged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ideally, we would simply unload the previous archive module and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * load the new one, but there is presently no mechanism for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unloading a library (see the comment above<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/fmgr/dfmgr.c.html#L184" title="utils/fmgr/dfmgr.c:184">internal_load_library</a>()).&nbsp; To deal with this, we simply restart<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the archiver.&nbsp; The new archive module will be loaded when the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new archiver process starts up.&nbsp; Note that this triggers the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * module's shutdown callback, if defined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;restarting archiver process because value of &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;archive_library was changed&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L911" title="postmaster/pgarch.c:911">LoadArchiveLibrary</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Loads the archiving callbacks into our local <a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L911">&#x200c;</a></span><span class="linkable">LoadArchiveLibrary</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ArchiveModuleInit archive_init;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L94" title="postmaster/pgarch.c:94">XLogArchiveLibrary</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span> &amp;&amp; <a href="../access/transam/xlog.c.html#L120" title="access/transam/xlog.c:120">XLogArchiveCommand</a>[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;both archive_command and archive_library set&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only one of archive_command, archive_library may be set.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If shell archiving is enabled, use our special initialization function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise, load the library and call its _PG_archive_module_init().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L94" title="postmaster/pgarch.c:94">XLogArchiveLibrary</a>[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; archive_init = <a href="../archive/shell_archive.c.html#L40" title="archive/shell_archive.c:40">shell_archive_init</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; archive_init = (ArchiveModuleInit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/fmgr/dfmgr.c.html#L105" title="utils/fmgr/dfmgr.c:105">load_external_function</a>(<a href="#L94" title="postmaster/pgarch.c:94">XLogArchiveLibrary</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;_PG_archive_module_init&quot;</span>, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (archive_init == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;archive modules have to define the symbol </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;_PG_archive_module_init&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a> = (*archive_init) ();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;archive_file_cb == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;archive modules must register an archive callback&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="postmaster/pgarch.c:105">archive_module_state</a> = (ArchiveModuleState *) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ArchiveModuleState));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;startup_cb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;startup_cb(<a href="#L105" title="postmaster/pgarch.c:105">archive_module_state</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>(<a href="#L953" title="postmaster/pgarch.c:953">pgarch_call_module_shutdown_cb</a>, <span class="Constant">0</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Call the shutdown callback of the loaded archive module, if defined.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L953">&#x200c;</a></span><span class="linkable">pgarch_call_module_shutdown_cb</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;shutdown_cb != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L104" title="postmaster/pgarch.c:104">ArchiveCallbacks</a>-&gt;shutdown_cb(<a href="#L105" title="postmaster/pgarch.c:105">archive_module_state</a>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
