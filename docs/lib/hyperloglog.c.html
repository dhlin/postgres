<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lib/hyperloglog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>lib/hyperloglog.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L167">addHyperLogLog</a></li>
<li><a href="#L186">estimateHyperLogLog</a></li>
<li><a href="#L151">freeHyperLogLog</a></li>
<li><a href="#L66">initHyperLogLog</a></li>
<li><a href="#L128">initHyperLogLogError</a></li>
<li><a href="#L242">rho</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L55">NEG_POW_2_32</a></li>
<li><a href="#L54">POW_2_32</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hyperloglog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; HyperLogLog cardinality estimator<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 2014-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Based on Hideaki Ohno's C++ implementation.&nbsp; This is probably not ideally<br/></li>
<li></span><span class="Comment"> * suited to estimating the cardinality of very large sets;&nbsp; in particular, we<br/></li>
<li></span><span class="Comment"> * have not attempted to further <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> the implementation as described in<br/></li>
<li></span><span class="Comment"> * the Heule, Nunkesser and Hall paper &quot;HyperLogLog in Practice: Algorithmic<br/></li>
<li></span><span class="Comment"> * Engineering of a State of The Art Cardinality Estimation Algorithm&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A sparse representation of HyperLogLog state is used, with fixed space<br/></li>
<li></span><span class="Comment"> * overhead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The copyright terms of Ohno's original version (the MIT license) follow.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/lib/hyperloglog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2013 Hideaki Ohno &lt;hide.o.j55{at}gmail.com&gt;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Permission is hereby granted, free of <a href="../utils/adt/char.c.html#L172" title="utils/adt/char.c:172">charge</a>, to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> person obtaining a copy<br/></li>
<li></span><span class="Comment"> * of this software and associated documentation files (the 'Software'), to<br/></li>
<li></span><span class="Comment"> * deal in the Software without restriction, including without limitation the<br/></li>
<li></span><span class="Comment"> * rights to use, copy, modify, <a href="pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>, publish, distribute, sublicense, and/or<br/></li>
<li></span><span class="Comment"> * sell copies of the Software, and to permit persons to whom the Software is<br/></li>
<li></span><span class="Comment"> * furnished to do so, subject to the following conditions:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The above copyright notice and this permission notice shall be included in<br/></li>
<li></span><span class="Comment"> * all copies or substantial portions of the Software.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br/></li>
<li></span><span class="Comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br/></li>
<li></span><span class="Comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br/></li>
<li></span><span class="Comment"> * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br/></li>
<li></span><span class="Comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING<br/></li>
<li></span><span class="Comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS<br/></li>
<li></span><span class="Comment"> * IN THE SOFTWARE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lib/hyperloglog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L54">&#x200c;</a><span class="PreProc">#define <span class="linkable">POW_2_32</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Constant">4294967296.0</span><span class="PreProc">)<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NEG_POW_2_32</span>&nbsp; &nbsp; &nbsp; &nbsp; (-</span><span class="Constant">4294967296.0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint8 <a href="#L242" title="lib/hyperloglog.c:242">rho</a>(uint32 x, uint8 b);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize HyperLogLog track state, by <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> width<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bwidth is <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> width (so register size will be 2 to the power of bwidth).<br/></li>
<li></span><span class="Comment"> * Must be between 4 and 16 inclusive.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L66">&#x200c;</a></span><span class="linkable">initHyperLogLog</span>(hyperLogLogState *cState, uint8 bwidth)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; alpha;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bwidth &lt; <span class="Constant">4</span> || bwidth &gt; <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> width must be between 4 and 16 inclusive&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cState-&gt;registerWidth = bwidth;<br/></li>
<li>&nbsp; &nbsp; cState-&gt;nRegisters = (Size) <span class="Constant">1</span> &lt;&lt; bwidth;<br/></li>
<li>&nbsp; &nbsp; cState-&gt;arrSize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint8) * cState-&gt;nRegisters + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize hashes array to zero, not negative infinity, per discussion<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of the coupon collector problem in the HyperLogLog paper<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cState-&gt;hashesArr = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(cState-&gt;arrSize);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;alpha&quot; is a value that for each possible number of registers (m) is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used to correct a systematic multiplicative bias present in m ^ 2 Z (Z<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is &quot;the indicator function&quot; through which we finally compute E,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimated cardinality).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (cState-&gt;nRegisters)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">16</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alpha = <span class="Constant">0.673</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">32</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alpha = <span class="Constant">0.697</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">64</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alpha = <span class="Constant">0.709</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alpha = <span class="Constant">0.7213</span> / (<span class="Constant">1.0</span> + <span class="Constant">1.079</span> / cState-&gt;nRegisters);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Precalculate alpha m ^ 2, later used to generate &quot;raw&quot; HyperLogLog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * estimate E<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cState-&gt;alphaMM = alpha * cState-&gt;nRegisters * cState-&gt;nRegisters;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Initialize HyperLogLog track state, by error rate<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Instead of specifying bwidth (number of bits used for addressing the<br/></li>
<li></span><span class="Comment"> * register), this method allows sizing the counter for particular error<br/></li>
<li></span><span class="Comment"> * rate using a simple formula from the paper:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; e = 1.04 / sqrt(m)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * where 'm' is the number of registers, i.e. (2^bwidth). The method<br/></li>
<li></span><span class="Comment"> * finds the lowest bwidth with 'e' below the requested error rate, and<br/></li>
<li></span><span class="Comment"> * then uses it to <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the counter.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As bwidth has to be between 4 and 16, the worst possible error rate<br/></li>
<li></span><span class="Comment"> * is between ~25% (bwidth=4) and 0.4% (bwidth=16).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L128">&#x200c;</a></span><span class="linkable">initHyperLogLogError</span>(hyperLogLogState *cState, <span class="Type">double</span> error)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; bwidth = <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (bwidth &lt; <span class="Constant">16</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; m = (Size) <span class="Constant">1</span> &lt;&lt; bwidth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<span class="Constant">1.04</span> / sqrt(m) &lt; error)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bwidth++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L66" title="lib/hyperloglog.c:66">initHyperLogLog</a>(cState, bwidth);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free HyperLogLog track state<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Releases allocated resources, but not the state itself (in case it's not<br/></li>
<li></span><span class="Comment"> * allocated by <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L151">&#x200c;</a></span><span class="linkable">freeHyperLogLog</span>(hyperLogLogState *cState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(cState-&gt;hashesArr != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(cState-&gt;hashesArr);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Adds <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to the estimator, from caller-supplied <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * It is critical that the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value passed be an actual <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value, typically<br/></li>
<li></span><span class="Comment"> * generated using hash_any().&nbsp; The algorithm relies on a specific <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>-pattern<br/></li>
<li></span><span class="Comment"> * observable in conjunction with stochastic averaging.&nbsp; There must be a<br/></li>
<li></span><span class="Comment"> * uniform distribution of bits in <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for each distinct original value<br/></li>
<li></span><span class="Comment"> * observed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L167">&#x200c;</a></span><span class="linkable">addHyperLogLog</span>(hyperLogLogState *cState, uint32 <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use the first &quot;k&quot; (registerWidth) bits as a zero based index */<br/></li>
<li></span>&nbsp; &nbsp; index = <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &gt;&gt; (BITS_PER_BYTE * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) - cState-&gt;registerWidth);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Compute the rank of the remaining 32 - &quot;k&quot; (registerWidth) bits */<br/></li>
<li></span>&nbsp; &nbsp; count = <a href="#L242" title="lib/hyperloglog.c:242">rho</a>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &lt;&lt; cState-&gt;registerWidth,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BITS_PER_BYTE * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint32) - cState-&gt;registerWidth);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cState-&gt;hashesArr[index] = Max(count, cState-&gt;hashesArr[index]);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Estimates cardinality, based on elements added so far<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L186">&#x200c;</a></span><span class="linkable">estimateHyperLogLog</span>(hyperLogLogState *cState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">double</span>&nbsp; &nbsp; &nbsp; &nbsp; sum = <span class="Constant">0.0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cState-&gt;nRegisters; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sum += <span class="Constant">1.0</span> / pow(<span class="Constant">2.0</span>, cState-&gt;hashesArr[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* result set to &quot;raw&quot; HyperLogLog estimate (E in the HyperLogLog paper) */<br/></li>
<li></span>&nbsp; &nbsp; result = cState-&gt;alphaMM / sum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (result &lt;= (<span class="Constant">5.0</span> / <span class="Constant">2.0</span>) * cState-&gt;nRegisters)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Small <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> correction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero_count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; cState-&gt;nRegisters; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cState-&gt;hashesArr[i] == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (zero_count != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = cState-&gt;nRegisters * log((<span class="Type">double</span>) cState-&gt;nRegisters /<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; zero_count);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (result &gt; (<span class="Constant">1.0</span> / <span class="Constant">30.0</span>) * <a href="#L54" title="lib/hyperloglog.c:54">POW_2_32</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Large <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> correction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L55" title="lib/hyperloglog.c:55">NEG_POW_2_32</a> * log(<span class="Constant">1.0</span> - (result / <a href="#L54" title="lib/hyperloglog.c:54">POW_2_32</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Worker for <a href="#L167" title="lib/hyperloglog.c:167">addHyperLogLog</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calculates the position of the first set <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> in first b bits of x argument<br/></li>
<li></span><span class="Comment"> * starting from the first, reading from most significant to least significant<br/></li>
<li></span><span class="Comment"> * bits.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Example (when considering fist 10 bits of x):<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="lib/hyperloglog.c:242">rho</a>(x = 0b1000000000)&nbsp;&nbsp; returns 1<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="lib/hyperloglog.c:242">rho</a>(x = 0b0010000000)&nbsp;&nbsp; returns 3<br/></li>
<li></span><span class="Comment"> * <a href="#L242" title="lib/hyperloglog.c:242">rho</a>(x = 0b0000000000)&nbsp;&nbsp; returns b + 1<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;The binary address determined by the first b bits of x&quot;<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return value &quot;j&quot; used to index <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> pattern to watch.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint8<br/></li>
<li><a id="L242">&#x200c;</a><span class="linkable">rho</span>(uint32 x, uint8 b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; j = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; j = <span class="Constant">32</span> - pg_leftmost_one_pos32(x);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (j &gt; b)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> b + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> j;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
