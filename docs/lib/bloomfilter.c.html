<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lib/bloomfilter.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>lib/bloomfilter.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L44">bloom_filter</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L135">bloom_add_element</a></li>
<li><a href="#L87">bloom_create</a></li>
<li><a href="#L126">bloom_free</a></li>
<li><a href="#L157">bloom_lacks_element</a></li>
<li><a href="#L187">bloom_prop_bits_set</a></li>
<li><a href="#L250">k_hashes</a></li>
<li><a href="#L288">mod_m</a></li>
<li><a href="#L210">my_bloom_power</a></li>
<li><a href="#L229">optimal_k</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L42">MAX_HASH_FUNCS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bloomfilter.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Space-efficient set membership testing<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A Bloom filter is a probabilistic data structure that is used to test an<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>'s membership of a set.&nbsp; False positives are possible, but false<br/></li>
<li></span><span class="Comment"> * negatives are not; a test of membership of the set returns either &quot;possibly<br/></li>
<li></span><span class="Comment"> * in set&quot; or &quot;definitely not in set&quot;.&nbsp; This is typically very space efficient,<br/></li>
<li></span><span class="Comment"> * which can be a decisive advantage.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Elements can be added to the set, but not removed.&nbsp; The more elements that<br/></li>
<li></span><span class="Comment"> * are added, the larger the probability of false positives.&nbsp; Caller must hint<br/></li>
<li></span><span class="Comment"> * an estimated total size of the set when the Bloom filter is initialized.<br/></li>
<li></span><span class="Comment"> * This is used to balance the use of memory against the final false positive<br/></li>
<li></span><span class="Comment"> * rate.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The implementation is well suited to data synchronization problems between<br/></li>
<li></span><span class="Comment"> * unordered sets, especially where predictable performance is important and<br/></li>
<li></span><span class="Comment"> * some false positives are acceptable.&nbsp; It's also well suited to cache<br/></li>
<li></span><span class="Comment"> * filtering problems where a relatively small and/or low cardinality set is<br/></li>
<li></span><span class="Comment"> * fingerprinted, especially when many subsequent membership tests end up<br/></li>
<li></span><span class="Comment"> * indicating that <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> of interest are not present.&nbsp; That should save the<br/></li>
<li></span><span class="Comment"> * caller many authoritative lookups, such as expensive probes of a much larger<br/></li>
<li></span><span class="Comment"> * on-disk structure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Copyright (c) 2018-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/lib/bloomfilter.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/bloomfilter.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><br/></li>
<li><a id="L42">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_HASH_FUNCS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">10<br/></li>
<li></span><br/></li>
<li><a id="L44">&#x200c;</a><span class="Type">struct</span> <span class="linkable">bloom_filter</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* K <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are used, seeded by caller's seed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k_hash_funcs;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; seed;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* m is bitset size, in bits.&nbsp; Must be a power of two &lt;= 2^32.&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; m;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">char</span> bitset[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L210" title="lib/bloomfilter.c:210">my_bloom_power</a>(uint64 target_bitset_bits);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L229" title="lib/bloomfilter.c:229">optimal_k</a>(uint64 bitset_bits, int64 total_elems);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L250" title="lib/bloomfilter.c:250">k_hashes</a>(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter, uint32 *hashes, <span class="Type">unsigned</span> <span class="Type">char</span> *elem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">size_t</span> len);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> uint32 <a href="#L288" title="lib/bloomfilter.c:288">mod_m</a>(uint32 val, uint64 m);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create Bloom filter in caller's memory context.&nbsp; We aim for a false positive<br/></li>
<li></span><span class="Comment"> * rate of between 1% and 2% when bitset size is not constrained by memory<br/></li>
<li></span><span class="Comment"> * availability.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * total_elems is an estimate of the final size of the set.&nbsp; It should be<br/></li>
<li></span><span class="Comment"> * approximately correct, but the implementation can cope well with it being<br/></li>
<li></span><span class="Comment"> * off by perhaps a factor of five or more.&nbsp; See &quot;Bloom Filters in<br/></li>
<li></span><span class="Comment"> * Probabilistic Verification&quot; (Dillinger &amp; Manolios, 2004) for details of why<br/></li>
<li></span><span class="Comment"> * this is the case.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * bloom_work_mem is sized in KB, in line with the general <a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a> convention.<br/></li>
<li></span><span class="Comment"> * This determines the size of the underlying bitset (trivial bookkeeping space<br/></li>
<li></span><span class="Comment"> * isn't counted).&nbsp; The bitset is always sized as a power of two number of<br/></li>
<li></span><span class="Comment"> * bits, and the largest possible bitset is 512MB (2^32 bits).&nbsp; The<br/></li>
<li></span><span class="Comment"> * implementation allocates only enough memory to target its standard false<br/></li>
<li></span><span class="Comment"> * positive rate, using a simple formula with caller's total_elems estimate as<br/></li>
<li></span><span class="Comment"> * an input.&nbsp; The bitset might be as small as 1MB, even when bloom_work_mem is<br/></li>
<li></span><span class="Comment"> * much higher.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The Bloom filter is seeded using a value provided by the caller.&nbsp; Using a<br/></li>
<li></span><span class="Comment"> * distinct seed value on every call makes it unlikely that the same false<br/></li>
<li></span><span class="Comment"> * positives will reoccur when the same set is fingerprinted a second time.<br/></li>
<li></span><span class="Comment"> * Callers that don't care about this pass a constant as their seed, typically<br/></li>
<li></span><span class="Comment"> * 0.&nbsp; Callers can also use a pseudo-random seed, eg from pg_prng_uint64().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *<br/></li>
<li><a id="L87">&#x200c;</a><span class="linkable">bloom_create</span>(int64 total_elems, <span class="Type">int</span> bloom_work_mem, uint64 seed)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bloom_power;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; bitset_bytes;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; bitset_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Aim for two bytes per <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>; this is sufficient to get a false<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * positive rate below 1%, independent of the size of the bitset or total<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * number of elements.&nbsp; Also, if rounding down the size of the bitset to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> lowest power of two turns out to be a significant drop, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * false positive rate still won't exceed 2% in almost all cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bitset_bytes = <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(bloom_work_mem * UINT64CONST(<span class="Constant">1024</span>), total_elems * <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; bitset_bytes = Max(<span class="Constant">1024</span> * <span class="Constant">1024</span>, bitset_bytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Size in bits should be the highest power of two &lt;= target.&nbsp; bitset_bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is uint64 because PG_UINT32_MAX is 2^32 - 1, not 2^32<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; bloom_power = <a href="#L210" title="lib/bloomfilter.c:210">my_bloom_power</a>(bitset_bytes * BITS_PER_BYTE);<br/></li>
<li>&nbsp; &nbsp; bitset_bits = UINT64CONST(<span class="Constant">1</span>) &lt;&lt; bloom_power;<br/></li>
<li>&nbsp; &nbsp; bitset_bytes = bitset_bits / BITS_PER_BYTE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate bloom filter with unset bitset */<br/></li>
<li></span>&nbsp; &nbsp; filter = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(offsetof(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a>, bitset) +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<span class="Type">unsigned</span> <span class="Type">char</span>) * bitset_bytes);<br/></li>
<li>&nbsp; &nbsp; filter-&gt;k_hash_funcs = <a href="#L229" title="lib/bloomfilter.c:229">optimal_k</a>(bitset_bits, total_elems);<br/></li>
<li>&nbsp; &nbsp; filter-&gt;seed = seed;<br/></li>
<li>&nbsp; &nbsp; filter-&gt;m = bitset_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> filter;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Free Bloom filter<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L126">&#x200c;</a></span><span class="linkable">bloom_free</span>(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(filter);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> to Bloom filter<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="linkable">bloom_add_element</span>(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter, <span class="Type">unsigned</span> <span class="Type">char</span> *elem, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashes[<a href="#L42" title="lib/bloomfilter.c:42">MAX_HASH_FUNCS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L250" title="lib/bloomfilter.c:250">k_hashes</a>(filter, hashes, elem, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>-wise address to a byte-wise address + <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> offset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; filter-&gt;k_hash_funcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; filter-&gt;bitset[hashes[i] &gt;&gt; <span class="Constant">3</span>] |= <span class="Constant">1</span> &lt;&lt; (hashes[i] &amp; <span class="Constant">7</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Test if Bloom filter definitely lacks <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is definitely not in the set of elements<br/></li>
<li></span><span class="Comment"> * observed by <a href="#L135" title="lib/bloomfilter.c:135">bloom_add_element</a>().&nbsp; Otherwise, returns false, indicating that<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> is probably present in set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L157">&#x200c;</a></span><span class="linkable">bloom_lacks_element</span>(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter, <span class="Type">unsigned</span> <span class="Type">char</span> *elem, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; hashes[<a href="#L42" title="lib/bloomfilter.c:42">MAX_HASH_FUNCS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L250" title="lib/bloomfilter.c:250">k_hashes</a>(filter, hashes, elem, len);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Map a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>-wise address to a byte-wise address + <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> offset */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; filter-&gt;k_hash_funcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(filter-&gt;bitset[hashes[i] &gt;&gt; <span class="Constant">3</span>] &amp; (<span class="Constant">1</span> &lt;&lt; (hashes[i] &amp; <span class="Constant">7</span>))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * What proportion of bits are currently set?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns proportion, expressed as a multiplier of filter size.&nbsp; That should<br/></li>
<li></span><span class="Comment"> * generally be close to 0.5, even when we have more than enough memory to<br/></li>
<li></span><span class="Comment"> * ensure a false positive rate within target 1% to 2% band, since more <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are used as more memory is available per <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is the only instrumentation that is low overhead enough to appear in<br/></li>
<li></span><span class="Comment"> * debug traces.&nbsp; When debugging Bloom filter code, it's likely to be far more<br/></li>
<li></span><span class="Comment"> * interesting to directly test the false positive rate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">double<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="linkable">bloom_prop_bits_set</span>(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitset_bytes = filter-&gt;m / BITS_PER_BYTE;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; bits_set = pg_popcount((<span class="Type">char</span> *) filter-&gt;bitset, bitset_bytes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bits_set / (<span class="Type">double</span>) filter-&gt;m;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Which <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the sequence of powers of two is less than or <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to<br/></li>
<li></span><span class="Comment"> * target_bitset_bits?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Value returned here must be generally safe as the basis for actual bitset<br/></li>
<li></span><span class="Comment"> * size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Bitset is never allowed to exceed 2 ^ 32 bits (512MB).&nbsp; This is sufficient<br/></li>
<li></span><span class="Comment"> * for the needs of all current callers, and allows us to use 32-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&nbsp; It also makes it easy to stay under the MaxAllocSize restriction<br/></li>
<li></span><span class="Comment"> * (caller needs to leave room for non-bitset fields that appear <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * flexible array member, so a 1GB bitset would use an allocation that just<br/></li>
<li></span><span class="Comment"> * exceeds MaxAllocSize).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L210">&#x200c;</a></span><span class="linkable">my_bloom_power</span>(uint64 target_bitset_bits)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bloom_power = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (target_bitset_bits &gt; <span class="Constant">0</span> &amp;&amp; bloom_power &lt; <span class="Constant">32</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bloom_power++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; target_bitset_bits &gt;&gt;= <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> bloom_power;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Determine optimal number of <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> based on size of filter in bits,<br/></li>
<li></span><span class="Comment"> * and projected total number of elements.&nbsp; The optimal number is the number<br/></li>
<li></span><span class="Comment"> * that minimizes the false positive rate.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L229">&#x200c;</a></span><span class="linkable">optimal_k</span>(uint64 bitset_bits, int64 total_elems)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; k = rint(log(<span class="Constant">2.0</span>) * bitset_bits / total_elems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> Max(<span class="Constant">1</span>, <a href="../jit/llvm/llvmjit_inline.cpp.html#L46" title="jit/llvm/llvmjit_inline.cpp:46">Min</a>(k, <a href="#L42" title="lib/bloomfilter.c:42">MAX_HASH_FUNCS</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate k <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller passes array, which is filled-in with k <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> determined by hashing<br/></li>
<li></span><span class="Comment"> * caller's <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only 2 real independent <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are actually used to support an<br/></li>
<li></span><span class="Comment"> * interface of up to <a href="#L42" title="lib/bloomfilter.c:42">MAX_HASH_FUNCS</a> <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>; enhanced double hashing is<br/></li>
<li></span><span class="Comment"> * used to make this work.&nbsp; The <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> reason we prefer enhanced double hashing<br/></li>
<li></span><span class="Comment"> * to classic double hashing is that the latter has an issue with collisions<br/></li>
<li></span><span class="Comment"> * when using power of two sized bitsets.&nbsp; See Dillinger &amp; Manolios for full<br/></li>
<li></span><span class="Comment"> * details.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L250">&#x200c;</a></span><span class="linkable">k_hashes</span>(<a href="#L44" title="lib/bloomfilter.c:44">bloom_filter</a> *filter, uint32 *hashes, <span class="Type">unsigned</span> <span class="Type">char</span> *elem, <span class="Type">size_t</span> len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; y;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; m;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Use 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> hashing to get two independent 32-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> hashes */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = DatumGetUInt64(hash_any_extended(elem, len, filter-&gt;seed));<br/></li>
<li>&nbsp; &nbsp; x = (uint32) <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; y = (uint32) (<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &gt;&gt; <span class="Constant">32</span>);<br/></li>
<li>&nbsp; &nbsp; m = filter-&gt;m;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; x = <a href="#L288" title="lib/bloomfilter.c:288">mod_m</a>(x, m);<br/></li>
<li>&nbsp; &nbsp; y = <a href="#L288" title="lib/bloomfilter.c:288">mod_m</a>(y, m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Accumulate hashes */<br/></li>
<li></span>&nbsp; &nbsp; hashes[<span class="Constant">0</span>] = x;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; filter-&gt;k_hash_funcs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; x = <a href="#L288" title="lib/bloomfilter.c:288">mod_m</a>(x + y, m);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; y = <a href="#L288" title="lib/bloomfilter.c:288">mod_m</a>(y + i, m);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashes[i] = x;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Calculate &quot;val <a href="../utils/hash/dynahash.c.html#L255" title="utils/hash/dynahash.c:255">MOD</a> m&quot; inexpensively.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Assumes that m (which is bitset size) is a power of two.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Using a power of two number of bits for bitset size allows us to use bitwise<br/></li>
<li></span><span class="Comment"> * AND operations to calculate the modulo of a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value.&nbsp; It's also a simple<br/></li>
<li></span><span class="Comment"> * way of avoiding the modulo bias effect.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> uint32<br/></li>
<li><a id="L288">&#x200c;</a><span class="linkable">mod_m</span>(uint32 val, uint64 m)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(m &lt;= PG_UINT32_MAX + UINT64CONST(<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(((m - <span class="Constant">1</span>) &amp; m) == <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val &amp; (m - <span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
