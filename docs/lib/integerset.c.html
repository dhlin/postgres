<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lib/integerset.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>lib/integerset.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L825">simple8b_modes</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L197">IntegerSet</a></li>
<li><a href="#L136">intset_internal_node</a></li>
<li><a href="#L146">intset_internal_node</a></li>
<li><a href="#L135">intset_leaf_node</a></li>
<li><a href="#L169">intset_leaf_node</a></li>
<li><a href="#L134">intset_node</a></li>
<li><a href="#L139">intset_node</a></li>
<li><a href="#L165">leaf_item</a></li>
<li><a href="#L821">simple8b_mode</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L370">intset_add_member</a></li>
<li><a href="#L624">intset_begin_iterate</a></li>
<li><a href="#L747">intset_binsrch_leaf</a></li>
<li><a href="#L714">intset_binsrch_uint64</a></li>
<li><a href="#L284">intset_create</a></li>
<li><a href="#L396">intset_flush_buffered_values</a></li>
<li><a href="#L554">intset_is_member</a></li>
<li><a href="#L643">intset_iterate_next</a></li>
<li><a href="#L359">intset_memory_usage</a></li>
<li><a href="#L316">intset_new_internal_node</a></li>
<li><a href="#L331">intset_new_leaf_node</a></li>
<li><a href="#L350">intset_num_entries</a></li>
<li><a href="#L481">intset_update_upper</a></li>
<li><a href="#L1004">simple8b_contains</a></li>
<li><a href="#L975">simple8b_decode</a></li>
<li><a href="#L873">simple8b_encode</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L857">EMPTY_CODEWORD</a></li>
<li><a href="#L187">MAX_BUFFERED_VALUES</a></li>
<li><a href="#L95">MAX_INTERNAL_ITEMS</a></li>
<li><a href="#L96">MAX_LEAF_ITEMS</a></li>
<li><a href="#L110">MAX_TREE_LEVELS</a></li>
<li><a href="#L167">MAX_VALUES_PER_LEAF_ITEM</a></li>
<li><a href="#L84">SIMPLE8B_MAX_VALUES_PER_CODEWORD</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * integerset.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Data structure to hold a large set of 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers efficiently<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L197" title="lib/integerset.c:197">IntegerSet</a> provides an in-memory data structure to hold a set of<br/></li>
<li></span><span class="Comment"> * arbitrary 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers.&nbsp; Internally, the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are stored in a<br/></li>
<li></span><span class="Comment"> * B-tree, with a special packed representation at the leaf level using<br/></li>
<li></span><span class="Comment"> * the Simple-8b algorithm, which can pack clusters of nearby <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a><br/></li>
<li></span><span class="Comment"> * very tightly.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Memory consumption depends on the number of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> stored, but also<br/></li>
<li></span><span class="Comment"> * on how far the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are from each other.&nbsp; In the best case, with<br/></li>
<li></span><span class="Comment"> * long runs of consecutive integers, memory consumption can be as low as<br/></li>
<li></span><span class="Comment"> * 0.1 bytes per integer.&nbsp; In the worst case, if integers are more than<br/></li>
<li></span><span class="Comment"> * 2^32 apart, it uses about 8 bytes per integer.&nbsp; In typical use, the<br/></li>
<li></span><span class="Comment"> * consumption per integer is somewhere between those extremes, depending<br/></li>
<li></span><span class="Comment"> * on the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of integers stored, and how &quot;clustered&quot; they are.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Interface<br/></li>
<li></span><span class="Comment"> * ---------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L284" title="lib/integerset.c:284">intset_create</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Create a new, empty set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L370" title="lib/integerset.c:370">intset_add_member</a>&nbsp; &nbsp; &nbsp; &nbsp; - Add an integer to the set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L554" title="lib/integerset.c:554">intset_is_member</a>&nbsp; &nbsp; &nbsp; &nbsp; - Test if an integer is in the set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L624" title="lib/integerset.c:624">intset_begin_iterate</a>&nbsp; &nbsp; - Begin iterating through all integers in set<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L643" title="lib/integerset.c:643">intset_iterate_next</a>&nbsp; &nbsp; &nbsp; &nbsp; - Return <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> set member, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L284" title="lib/integerset.c:284">intset_create</a>() creates the set in the current memory context.&nbsp; Subsequent<br/></li>
<li></span><span class="Comment"> * operations that add to the data structure will continue to allocate from<br/></li>
<li></span><span class="Comment"> * that same context, even if it's not current anymore.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that there is no function to free an integer set.&nbsp; If you need to do<br/></li>
<li></span><span class="Comment"> * that, create a dedicated memory context to hold it, and destroy the memory<br/></li>
<li></span><span class="Comment"> * context instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Limitations<br/></li>
<li></span><span class="Comment"> * -----------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Values must be added in order.&nbsp; (Random insertions would require<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; splitting nodes, which hasn't been implemented.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - Values cannot be added while iteration is in progress.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * - No support for removing <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * None of these limitations are fundamental to the data structure, so they<br/></li>
<li></span><span class="Comment"> * could be lifted if needed, by writing some new code.&nbsp; But the current<br/></li>
<li></span><span class="Comment"> * users of this facility don't need them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * References<br/></li>
<li></span><span class="Comment"> * ----------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simple-8b encoding is based on:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Vo Ngoc Anh, Alistair Moffat, Index compression using 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> words,<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; Software - Practice &amp; Experience, v.40 n.2, p.131-147, February 2010<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; (https://doi.org/10.1002/spe.948)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/lib/integerset.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;lib/integerset.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum number of integers that can be encoded in a single Simple-8b<br/></li>
<li></span><span class="Comment"> * codeword. (Defined here <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything else, so that we can size arrays<br/></li>
<li></span><span class="Comment"> * using this.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L84">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">SIMPLE8B_MAX_VALUES_PER_CODEWORD</span> </span><span class="Constant">240<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parameters for shape of the in-memory B-tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * These set the size of each <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> and leaf node.&nbsp; They don't necessarily<br/></li>
<li></span><span class="Comment"> * need to be the same, because the tree is just an in-memory structure.<br/></li>
<li></span><span class="Comment"> * With the default 64, each node is about 1 kb.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If you change these, you must recalculate <a href="#L110" title="lib/integerset.c:110">MAX_TREE_LEVELS</a>, too!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L95">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_INTERNAL_ITEMS</span>&nbsp; &nbsp; </span><span class="Constant">64<br/></li>
<li><a id="L96">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_LEAF_ITEMS</span>&nbsp; &nbsp; </span><span class="Constant">64<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Maximum height of the tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * MAX_TREE_ITEMS is calculated from the &quot;fan-out&quot; of the B-tree.&nbsp; The<br/></li>
<li></span><span class="Comment"> * theoretical maximum number of items that we can store in a set is 2^64,<br/></li>
<li></span><span class="Comment"> * so <a href="#L110" title="lib/integerset.c:110">MAX_TREE_LEVELS</a> should be set so that:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp;&nbsp; <a href="#L96" title="lib/integerset.c:96">MAX_LEAF_ITEMS</a> * <a href="#L95" title="lib/integerset.c:95">MAX_INTERNAL_ITEMS</a> ^ (<a href="#L110" title="lib/integerset.c:110">MAX_TREE_LEVELS</a> - 1) &gt;= 2^64.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In practice, we'll need far fewer levels, because you will run out of<br/></li>
<li></span><span class="Comment"> * memory long <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reaching that number, but let's be conservative.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L110">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_TREE_LEVELS</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">11<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Node structures, for the in-memory B-tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * An <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node holds a number of downlink pointers to leaf nodes, or<br/></li>
<li></span><span class="Comment"> * to <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> nodes on a <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level.&nbsp; For each downlink, the key value<br/></li>
<li></span><span class="Comment"> * corresponding to the <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> level node is stored in a sorted array.&nbsp; The<br/></li>
<li></span><span class="Comment"> * stored key <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are low keys.&nbsp; In other words, if the downlink has value<br/></li>
<li></span><span class="Comment"> * X, then all items stored on that child are &gt;= X.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each leaf node holds a number of &quot;items&quot;, with a varying number of<br/></li>
<li></span><span class="Comment"> * integers packed into each item.&nbsp; Each item consists of two 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> words:<br/></li>
<li></span><span class="Comment"> * The first <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> holds the first integer stored in the item, in plain format.<br/></li>
<li></span><span class="Comment"> * The second <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> contains between 0 and 240 more integers, packed using<br/></li>
<li></span><span class="Comment"> * Simple-8b encoding.&nbsp; By storing the first integer in plain, unpacked,<br/></li>
<li></span><span class="Comment"> * format, we can use binary search to quickly <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an item that holds (or<br/></li>
<li></span><span class="Comment"> * would hold) a particular integer.&nbsp; And by storing the rest in packed form,<br/></li>
<li></span><span class="Comment"> * we still get pretty good memory density, if there are clusters of integers<br/></li>
<li></span><span class="Comment"> * with similar <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Each leaf node also has a pointer to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> leaf node, so that the leaf<br/></li>
<li></span><span class="Comment"> * nodes can be easily walked from beginning to end when iterating.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L134">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">intset_node</span> <span class="linkable">intset_node</span>;<br/></li>
<li><a id="L135">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">intset_leaf_node</span> <span class="linkable">intset_leaf_node</span>;<br/></li>
<li><a id="L136">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">intset_internal_node</span> <span class="linkable">intset_internal_node</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Common structure of both leaf and <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> nodes. */<br/></li>
<li><a id="L139">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">intset_node</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; level;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tree level of this node */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; num_items;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of items in this node */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Internal node */<br/></li>
<li><a id="L146">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">intset_internal_node</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* common header, must match <a href="#L139" title="lib/integerset.c:139">intset_node</a> */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; level;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &gt;= 1 on <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> nodes */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; num_items;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * '<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>' is an array of key <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and 'downlinks' are pointers to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>-level nodes, corresponding to the key <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<a href="#L95" title="lib/integerset.c:95">MAX_INTERNAL_ITEMS</a>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L139" title="lib/integerset.c:139">intset_node</a> *downlinks[<a href="#L95" title="lib/integerset.c:95">MAX_INTERNAL_ITEMS</a>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Leaf node */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; first;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* first integer in this item */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; codeword;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* simple8b encoded differences from 'first' */<br/></li>
<li><a id="L165">&#x200c;</a></span>} <span class="linkable">leaf_item</span>;<br/></li>
<li><br/></li>
<li><a id="L167">&#x200c;</a><span class="PreProc">#define <span class="linkable">MAX_VALUES_PER_LEAF_ITEM</span>&nbsp; &nbsp; (</span><span class="Constant">1</span><span class="PreProc"> + <a href="#L84" title="lib/integerset.c:84">SIMPLE8B_MAX_VALUES_PER_CODEWORD</a>)<br/></li>
<li></span><br/></li>
<li><a id="L169">&#x200c;</a><span class="Type">struct</span> <span class="linkable">intset_leaf_node</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* common header, must match <a href="#L139" title="lib/integerset.c:139">intset_node</a> */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; level;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* 0 on leafs */<br/></li>
<li></span>&nbsp; &nbsp; uint16&nbsp; &nbsp; &nbsp; &nbsp; num_items;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* right sibling, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="lib/integerset.c:165">leaf_item</a>&nbsp; &nbsp; items[<a href="#L96" title="lib/integerset.c:96">MAX_LEAF_ITEMS</a>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We buffer insertions in a simple array, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> packing and inserting them<br/></li>
<li></span><span class="Comment"> * into the B-tree.&nbsp; <a href="#L187" title="lib/integerset.c:187">MAX_BUFFERED_VALUES</a> sets the size of the buffer.&nbsp; The<br/></li>
<li></span><span class="Comment"> * encoder assumes that it is large enough that we can always fill a leaf<br/></li>
<li></span><span class="Comment"> * item with buffered new items.&nbsp; In other words, <a href="#L187" title="lib/integerset.c:187">MAX_BUFFERED_VALUES</a> must be<br/></li>
<li></span><span class="Comment"> * larger than <a href="#L167" title="lib/integerset.c:167">MAX_VALUES_PER_LEAF_ITEM</a>.&nbsp; For efficiency, make it much larger.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L187">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_BUFFERED_VALUES</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="#L167" title="lib/integerset.c:167">MAX_VALUES_PER_LEAF_ITEM</a> * </span><span class="Constant">2</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L197" title="lib/integerset.c:197">IntegerSet</a> is the top-level object representing the set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The integers are stored in an in-memory B-tree structure, plus an array<br/></li>
<li></span><span class="Comment"> * for newly-added integers.&nbsp; <a href="#L197" title="lib/integerset.c:197">IntegerSet</a> also tracks information about memory<br/></li>
<li></span><span class="Comment"> * usage, as well as the current position when iterating the set with<br/></li>
<li></span><span class="Comment"> * <a href="#L624" title="lib/integerset.c:624">intset_begin_iterate</a> / <a href="#L643" title="lib/integerset.c:643">intset_iterate_next</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L197">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">IntegerSet</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'context' is the memory context holding this integer set and all its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tree nodes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'mem_used' tracks the amount of memory used.&nbsp; We don't do anything with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it in integerset.c itself, but the callers can ask for it with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L359" title="lib/integerset.c:359">intset_memory_usage</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContext context;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; mem_used;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; num_entries;&nbsp; &nbsp; <span class="Comment">/* total # of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the set */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; highest_value;&nbsp; &nbsp; <span class="Comment">/* highest value stored in this set */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * B-tree to hold the packed <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'rightmost_nodes' hold pointers to the rightmost node on each level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rightmost_parent[0] is rightmost leaf, rightmost_parent[1] is its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent, and so forth, all the way up to the root. These are needed when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * adding new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. (Currently, we require that new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are added at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the end.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_levels;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* height of the tree */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L139" title="lib/integerset.c:139">intset_node</a> *root;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* root node */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L139" title="lib/integerset.c:139">intset_node</a> *rightmost_nodes[<a href="#L110" title="lib/integerset.c:110">MAX_TREE_LEVELS</a>];<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *leftmost_leaf;&nbsp; &nbsp; <span class="Comment">/* leftmost leaf node */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Holding area for new items that haven't been inserted to the tree yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; buffered_values[<a href="#L187" title="lib/integerset.c:187">MAX_BUFFERED_VALUES</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_buffered_values;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Iterator support.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'iter_values' is an array of integers ready to be returned to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller; 'iter_num_values' is the length of that array, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'iter_valueno' is the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index.&nbsp; 'iter_node' and 'iter_itemno' point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the leaf node, and item within the leaf node, to get the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> batch<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normally, 'iter_values' points to 'iter_values_buf', which holds items<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * decoded from a leaf item.&nbsp; But after we have scanned the whole B-tree,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we iterate through all the unbuffered <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, too, by pointing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * iter_values to 'buffered_values'.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; iter_active;&nbsp; &nbsp; <span class="Comment">/* is iteration in progress? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> uint64 *iter_values;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter_num_values;&nbsp; &nbsp; <span class="Comment">/* number of elements in 'iter_values' */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter_valueno;&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> index into 'iter_values' */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *iter_node;&nbsp; &nbsp; <span class="Comment">/* current leaf node */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iter_itemno;&nbsp; &nbsp; <span class="Comment">/* <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item in 'iter_node' to decode */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; iter_values_buf[<a href="#L167" title="lib/integerset.c:167">MAX_VALUES_PER_LEAF_ITEM</a>];<br/></li>
<li>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prototypes for <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void</span> <a href="#L481" title="lib/integerset.c:481">intset_update_upper</a>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset, <span class="Type">int</span> level,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="lib/integerset.c:139">intset_node</a> *child, uint64 child_key);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L396" title="lib/integerset.c:396">intset_flush_buffered_values</a>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L714" title="lib/integerset.c:714">intset_binsrch_uint64</a>(uint64 item, uint64 *arr, <span class="Type">int</span> arr_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nextkey);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L747" title="lib/integerset.c:747">intset_binsrch_leaf</a>(uint64 item, <a href="#L165" title="lib/integerset.c:165">leaf_item</a> *arr, <span class="Type">int</span> arr_elems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nextkey);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> uint64 <a href="#L873" title="lib/integerset.c:873">simple8b_encode</a>(<span class="Type">const</span> uint64 *ints, <span class="Type">int</span> *num_encoded, uint64 base);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L975" title="lib/integerset.c:975">simple8b_decode</a>(uint64 codeword, uint64 *decoded, uint64 base);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1004" title="lib/integerset.c:1004">simple8b_contains</a>(uint64 codeword, uint64 key, uint64 base);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new, initially empty, integer set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The integer set is created in the current memory context.<br/></li>
<li></span><span class="Comment"> * We will do all subsequent allocations in the same context, too, regardless<br/></li>
<li></span><span class="Comment"> * of which memory context is current when new integers are added to the set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *<br/></li>
<li><a id="L284">&#x200c;</a><span class="linkable">intset_create</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; intset = (<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a>));<br/></li>
<li>&nbsp; &nbsp; intset-&gt;context = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;mem_used = <a href="../utils/mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(intset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; intset-&gt;num_entries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;highest_value = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; intset-&gt;num_levels = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;root = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; memset(intset-&gt;rightmost_nodes, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(intset-&gt;rightmost_nodes));<br/></li>
<li>&nbsp; &nbsp; intset-&gt;leftmost_leaf = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; intset-&gt;num_buffered_values = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_active = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_node = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_itemno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_valueno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_num_values = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_values = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> intset;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate a new node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *<br/></li>
<li><a id="L316">&#x200c;</a><span class="linkable">intset_new_internal_node</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = (<a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *) <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(intset-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L146" title="lib/integerset.c:146">intset_internal_node</a>));<br/></li>
<li>&nbsp; &nbsp; intset-&gt;mem_used += <a href="../utils/mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;level = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* caller must set */<br/></li>
<li></span>&nbsp; &nbsp; n-&gt;num_items = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *<br/></li>
<li><a id="L331">&#x200c;</a><span class="linkable">intset_new_leaf_node</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n = (<a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *) <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(intset-&gt;context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a>));<br/></li>
<li>&nbsp; &nbsp; intset-&gt;mem_used += <a href="../utils/mmgr/mcxt.c.html#L721" title="utils/mmgr/mcxt.c:721">GetMemoryChunkSpace</a>(n);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; n-&gt;level = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;num_items = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; n-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> n;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the number of entries in the integer set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint64<br/></li>
<li><a id="L350">&#x200c;</a><span class="linkable">intset_num_entries</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> intset-&gt;num_entries;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Return the amount of memory used by the integer set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint64<br/></li>
<li><a id="L359">&#x200c;</a><span class="linkable">intset_memory_usage</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> intset-&gt;mem_used;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Add a value to the set.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Values must be added in order.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L370">&#x200c;</a></span><span class="linkable">intset_add_member</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset, uint64 x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;iter_active)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot add new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to integer set while iteration is in progress&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (x &lt;= intset-&gt;highest_value &amp;&amp; intset-&gt;num_entries &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot add value to integer set out of order&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;num_buffered_values &gt;= <a href="#L187" title="lib/integerset.c:187">MAX_BUFFERED_VALUES</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Time to flush our buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L396" title="lib/integerset.c:396">intset_flush_buffered_values</a>(intset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(intset-&gt;num_buffered_values &lt; <a href="#L187" title="lib/integerset.c:187">MAX_BUFFERED_VALUES</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add it to the buffer of newly-added <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> */<br/></li>
<li></span>&nbsp; &nbsp; intset-&gt;buffered_values[intset-&gt;num_buffered_values] = x;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;num_buffered_values++;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;num_entries++;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;highest_value = x;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Take a batch of buffered <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, and pack them into the B-tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L396">&#x200c;</a></span><span class="linkable">intset_flush_buffered_values</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> = intset-&gt;buffered_values;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; num_values = intset-&gt;num_buffered_values;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_packed = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *leaf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; leaf = (<a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *) intset-&gt;rightmost_nodes[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the tree is completely empty, create the first leaf page, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also the root.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (leaf == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is the very first item in the set.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Allocate root node. It's also a leaf.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leaf = <a href="#L331" title="lib/integerset.c:331">intset_new_leaf_node</a>(intset);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;root = (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) leaf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;leftmost_leaf = leaf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;rightmost_nodes[<span class="Constant">0</span>] = (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) leaf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;num_levels = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are less than <a href="#L167" title="lib/integerset.c:167">MAX_VALUES_PER_LEAF_ITEM</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the buffer,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stop.&nbsp; In most cases, we cannot encode that many <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * value, but this way, the encoder doesn't have to worry about running<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * out of input.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (num_values - num_packed &gt;= <a href="#L167" title="lib/integerset.c:167">MAX_VALUES_PER_LEAF_ITEM</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="lib/integerset.c:165">leaf_item</a>&nbsp; &nbsp; item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_encoded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> leaf item, packing as many buffered <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; item.first = <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[num_packed];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item.codeword = <a href="#L873" title="lib/integerset.c:873">simple8b_encode</a>(&amp;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[num_packed + <span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;num_encoded,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item.first);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the item to the node, allocating a new node if the old one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * full.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (leaf-&gt;num_items &gt;= <a href="#L96" title="lib/integerset.c:96">MAX_LEAF_ITEMS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Allocate new leaf and link it to the tree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *old_leaf = leaf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leaf = <a href="#L331" title="lib/integerset.c:331">intset_new_leaf_node</a>(intset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; old_leaf-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = leaf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;rightmost_nodes[<span class="Constant">0</span>] = (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) leaf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L481" title="lib/integerset.c:481">intset_update_upper</a>(intset, <span class="Constant">1</span>, (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) leaf, item.first);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leaf-&gt;items[leaf-&gt;num_items++] = item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; num_packed += <span class="Constant">1</span> + num_encoded;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> remaining buffered <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the beginning of the array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (num_packed &lt; intset-&gt;num_buffered_values)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memmove(&amp;intset-&gt;buffered_values[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;intset-&gt;buffered_values[num_packed],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (intset-&gt;num_buffered_values - num_packed) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint64));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; intset-&gt;num_buffered_values -= num_packed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a downlink into parent node, after creating a new node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Recurses if the parent node is full, too.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L481">&#x200c;</a></span><span class="linkable">intset_update_upper</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset, <span class="Type">int</span> level, <a href="#L139" title="lib/integerset.c:139">intset_node</a> *child,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64 child_key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(level &gt; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a new root node, if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (level &gt;= intset-&gt;num_levels)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L139" title="lib/integerset.c:139">intset_node</a> *oldroot = intset-&gt;root;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; downlink_key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L110" title="lib/integerset.c:110">MAX_TREE_LEVELS</a> should be more than enough, this shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;num_levels == <a href="#L110" title="lib/integerset.c:110">MAX_TREE_LEVELS</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not expand integer set, maximum number of levels reached&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;num_levels++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the first value on the old root page, to be used as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * downlink.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;root-&gt;level == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlink_key = ((<a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *) oldroot)-&gt;items[<span class="Constant">0</span>].first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; downlink_key = ((<a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *) oldroot)-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="#L316" title="lib/integerset.c:316">intset_new_internal_node</a>(intset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;level = level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = downlink_key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;downlinks[<span class="Constant">0</span>] = oldroot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;num_items = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;root = (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) parent;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;rightmost_nodes[level] = (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) parent;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Place the downlink on the parent page.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parent = (<a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *) intset-&gt;rightmost_nodes[level];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;num_items &lt; <a href="#L95" title="lib/integerset.c:95">MAX_INTERNAL_ITEMS</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[parent-&gt;num_items] = child_key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;downlinks[parent-&gt;num_items] = child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;num_items++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doesn't fit.&nbsp; Allocate new parent, with the downlink as the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * item on it, and recursively insert the downlink to the new parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to the grandparent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; parent = <a href="#L316" title="lib/integerset.c:316">intset_new_internal_node</a>(intset);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;level = level;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] = child_key;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;downlinks[<span class="Constant">0</span>] = child;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent-&gt;num_items = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;rightmost_nodes[level] = (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) parent;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L481" title="lib/integerset.c:481">intset_update_upper</a>(intset, level + <span class="Constant">1</span>, (<a href="#L139" title="lib/integerset.c:139">intset_node</a> *) parent, child_key);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Does the set contain the given value?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L554">&#x200c;</a></span><span class="linkable">intset_is_member</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset, uint64 x)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L139" title="lib/integerset.c:139">intset_node</a> *node;<br/></li>
<li>&nbsp; &nbsp; <a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *leaf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; level;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; itemno;<br/></li>
<li>&nbsp; &nbsp; <a href="#L165" title="lib/integerset.c:165">leaf_item</a>&nbsp; *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The value might be in the buffer of newly-added <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;num_buffered_values &gt; <span class="Constant">0</span> &amp;&amp; x &gt;= intset-&gt;buffered_values[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemno = <a href="#L714" title="lib/integerset.c:714">intset_binsrch_uint64</a>(x,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; intset-&gt;buffered_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; intset-&gt;num_buffered_values,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemno &gt;= intset-&gt;num_buffered_values)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (intset-&gt;buffered_values[itemno] == x);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start from the root, and walk down the B-tree to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the right leaf<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!intset-&gt;root)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; node = intset-&gt;root;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (level = intset-&gt;num_levels - <span class="Constant">1</span>; level &gt; <span class="Constant">0</span>; level--)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *n = (<a href="#L146" title="lib/integerset.c:146">intset_internal_node</a> *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(node-&gt;level == level);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; itemno = <a href="#L714" title="lib/integerset.c:714">intset_binsrch_uint64</a>(x, n-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, n-&gt;num_items, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (itemno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = n-&gt;downlinks[itemno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(node-&gt;level == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; leaf = (<a href="#L169" title="lib/integerset.c:169">intset_leaf_node</a> *) node;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Binary search to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the right item on the leaf page<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; itemno = <a href="#L747" title="lib/integerset.c:747">intset_binsrch_leaf</a>(x, leaf-&gt;items, leaf-&gt;num_items, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (itemno == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; item = &amp;leaf-&gt;items[itemno - <span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is this a match to the first value on the item? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (item-&gt;first == x)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; Assert(x &gt; item-&gt;first);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is it in the packed codeword? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1004" title="lib/integerset.c:1004">simple8b_contains</a>(item-&gt;codeword, x, item-&gt;first))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Begin in-order scan through all the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * While the iteration is in-progress, you cannot add new <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to the set.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L624">&#x200c;</a></span><span class="linkable">intset_begin_iterate</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note that we allow an iteration to be abandoned midway */<br/></li>
<li></span>&nbsp; &nbsp; intset-&gt;iter_active = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_node = intset-&gt;leftmost_leaf;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_itemno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_valueno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_num_values = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; intset-&gt;iter_values = intset-&gt;iter_values_buf;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> integer, when iterating.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L624" title="lib/integerset.c:624">intset_begin_iterate</a>() must be called first.&nbsp; <a href="#L643" title="lib/integerset.c:643">intset_iterate_next</a>() returns<br/></li>
<li></span><span class="Comment"> * the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> value in the set.&nbsp; Returns true, if there was another value, and<br/></li>
<li></span><span class="Comment"> * stores the value in *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>.&nbsp; Otherwise, returns false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L643">&#x200c;</a></span><span class="linkable">intset_iterate_next</span>(<a href="#L197" title="lib/integerset.c:197">IntegerSet</a> *intset, uint64 *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(intset-&gt;iter_active);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Return <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> iter_values[] entry if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;iter_valueno &lt; intset-&gt;iter_num_values)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = intset-&gt;iter_values[intset-&gt;iter_valueno++];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Decode <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item in current leaf node, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;iter_node &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_itemno &lt; intset-&gt;iter_node-&gt;num_items)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L165" title="lib/integerset.c:165">leaf_item</a>&nbsp; *item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_decoded;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = &amp;intset-&gt;iter_node-&gt;items[intset-&gt;iter_itemno++];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_values_buf[<span class="Constant">0</span>] = item-&gt;first;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; num_decoded = <a href="#L975" title="lib/integerset.c:975">simple8b_decode</a>(item-&gt;codeword,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;intset-&gt;iter_values_buf[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item-&gt;first);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_num_values = num_decoded + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_valueno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No more items on this leaf, step to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;iter_node)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_node = intset-&gt;iter_node-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_itemno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have reached the end of the B-tree.&nbsp; But we might still have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * some integers in the buffer of newly-added <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (intset-&gt;iter_values == (<span class="Type">const</span> uint64 *) intset-&gt;iter_values_buf)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_values = intset-&gt;buffered_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_num_values = intset-&gt;num_buffered_values;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; intset-&gt;iter_valueno = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No more results. */<br/></li>
<li></span>&nbsp; &nbsp; intset-&gt;iter_active = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prevent uninitialized-variable warnings */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L714" title="lib/integerset.c:714">intset_binsrch_uint64</a>() -- search a sorted array of uint64s<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the first position with key <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> or less than the given key.<br/></li>
<li></span><span class="Comment"> * The returned position would be the &quot;insert&quot; location for the given key,<br/></li>
<li></span><span class="Comment"> * that is, the position where the new key should be inserted to.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * 'nextkey' affects the behavior on <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> keys.&nbsp; If true, and there is an<br/></li>
<li></span><span class="Comment"> * <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> key in the array, this returns the position immediately after the<br/></li>
<li></span><span class="Comment"> * <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> key.&nbsp; If false, this returns the position of the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> key itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L714">&#x200c;</a></span><span class="linkable">intset_binsrch_uint64</span>(uint64 item, uint64 *arr, <span class="Type">int</span> arr_elems, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nextkey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; high = arr_elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid = low + (high - low) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item &gt;= arr[mid])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item &gt; arr[mid])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* same, but for an array of leaf items */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L747">&#x200c;</a></span><span class="linkable">intset_binsrch_leaf</span>(uint64 item, <a href="#L165" title="lib/integerset.c:165">leaf_item</a> *arr, <span class="Type">int</span> arr_elems, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nextkey)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; low = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; high = arr_elems;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (high &gt; low)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mid = low + (high - low) / <span class="Constant">2</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nextkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item &gt;= arr[mid].first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (item &gt; arr[mid].first)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low = mid + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; high = mid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> low;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Simple-8b encoding.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The simple-8b algorithm packs between 1 and 240 integers into 64-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> words,<br/></li>
<li></span><span class="Comment"> * called &quot;codewords&quot;.&nbsp; The number of integers packed into a single codeword<br/></li>
<li></span><span class="Comment"> * depends on the integers being packed; small integers are encoded using<br/></li>
<li></span><span class="Comment"> * fewer bits than large integers.&nbsp; A single codeword can store a single<br/></li>
<li></span><span class="Comment"> * 60-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer, or two 30-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers, for example.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since we're storing a unique, sorted, set of integers, we actually encode<br/></li>
<li></span><span class="Comment"> * the *differences* between consecutive integers.&nbsp; That way, clusters of<br/></li>
<li></span><span class="Comment"> * integers that are close to each other are packed efficiently, regardless<br/></li>
<li></span><span class="Comment"> * of their absolute <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In Simple-8b, each codeword consists of a 4-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> selector, which indicates<br/></li>
<li></span><span class="Comment"> * how many integers are encoded in the codeword, and the encoded integers are<br/></li>
<li></span><span class="Comment"> * packed into the remaining 60 bits.&nbsp; The selector allows for 16 different<br/></li>
<li></span><span class="Comment"> * ways of using the remaining 60 bits, called &quot;modes&quot;.&nbsp; The number of integers<br/></li>
<li></span><span class="Comment"> * packed into a single codeword in each mode is listed in the <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a><br/></li>
<li></span><span class="Comment"> * table below.&nbsp; For example, consider the following codeword:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; 20-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer&nbsp; &nbsp; &nbsp;&nbsp; 20-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer&nbsp; &nbsp; &nbsp;&nbsp; 20-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer<br/></li>
<li></span><span class="Comment"> * 1101 00000000000000010010 01111010000100100000 00000000000000010100<br/></li>
<li></span><span class="Comment"> * ^<br/></li>
<li></span><span class="Comment"> * selector<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The selector 1101 is 13 in decimal.&nbsp; From the modes table below, we see<br/></li>
<li></span><span class="Comment"> * that it means that the codeword encodes three 20-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers.&nbsp; In decimal,<br/></li>
<li></span><span class="Comment"> * those integers are 18, 500000 and 20.&nbsp; Because we encode deltas rather than<br/></li>
<li></span><span class="Comment"> * absolute <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, the actual <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> that they represent are 18, 500018 and<br/></li>
<li></span><span class="Comment"> * 500038.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Modes 0 and 1 are a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> special; they encode a run of 240 or 120 zeroes<br/></li>
<li></span><span class="Comment"> * (which means 240 or 120 consecutive integers, since we're encoding the<br/></li>
<li></span><span class="Comment"> * deltas between integers), without using the rest of the codeword bits<br/></li>
<li></span><span class="Comment"> * for anything.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Simple-8b cannot encode integers larger than 60 bits.&nbsp; Values larger than<br/></li>
<li></span><span class="Comment"> * that are always stored in the 'first' field of a leaf item, never in the<br/></li>
<li></span><span class="Comment"> * packed codeword.&nbsp; If there is a sequence of integers that are more than<br/></li>
<li></span><span class="Comment"> * 2^60 apart, the codeword will go unused on those items.&nbsp; To represent that,<br/></li>
<li></span><span class="Comment"> * we use a magic <a href="#L857" title="lib/integerset.c:857">EMPTY_CODEWORD</a> codeword value.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L821">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">struct</span> <span class="linkable">simple8b_mode</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; bits_per_int;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; num_ints;<br/></li>
<li><a id="L825">&#x200c;</a>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">simple8b_modes</span>[<span class="Constant">17</span>] =<br/></li>
<li><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">0</span>, <span class="Constant">240</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 0: 240 zeroes */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">0</span>, <span class="Constant">120</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 1: 120 zeroes */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">1</span>, <span class="Constant">60</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 2: sixty 1-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">2</span>, <span class="Constant">30</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 3: thirty 2-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">3</span>, <span class="Constant">20</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 4: twenty 3-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">4</span>, <span class="Constant">15</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 5: fifteen 4-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">5</span>, <span class="Constant">12</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 6: twelve 5-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">6</span>, <span class="Constant">10</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 7: ten 6-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">7</span>, <span class="Constant">8</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 8: eight 7-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers (four bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are wasted) */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">8</span>, <span class="Constant">7</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode&nbsp; 9: seven 8-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers (four bits<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are wasted) */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">10</span>, <span class="Constant">6</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode 10: six 10-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">12</span>, <span class="Constant">5</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode 11: five 12-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">15</span>, <span class="Constant">4</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode 12: four 15-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">20</span>, <span class="Constant">3</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode 13: three 20-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">30</span>, <span class="Constant">2</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode 14: two 30-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integers */<br/></li>
<li></span>&nbsp; &nbsp; {<span class="Constant">60</span>, <span class="Constant">1</span>},&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mode 15: one 60-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> integer */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; {<span class="Constant">0</span>, <span class="Constant">0</span>}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="rbtree.c.html#L63" title="lib/rbtree.c:63">sentinel</a> value */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L857" title="lib/integerset.c:857">EMPTY_CODEWORD</a> is a special value, used to indicate &quot;no <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&quot;.<br/></li>
<li></span><span class="Comment"> * It is used if the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> value is too large to be encoded with Simple-8b.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This value looks like a mode-0 codeword, but we can distinguish it<br/></li>
<li></span><span class="Comment"> * because a regular mode-0 codeword would have zeroes in the unused bits.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L857">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">EMPTY_CODEWORD</span>&nbsp; &nbsp; &nbsp; &nbsp; UINT64CONST(</span><span class="Constant">0x0FFFFFFFFFFFFFFF</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Encode a number of integers into a Simple-8b codeword.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (What we actually encode are deltas between successive integers.<br/></li>
<li></span><span class="Comment"> * &quot;base&quot; is the value <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> ints[0].)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The input array must contain at least <a href="#L84" title="lib/integerset.c:84">SIMPLE8B_MAX_VALUES_PER_CODEWORD</a><br/></li>
<li></span><span class="Comment"> * elements, ensuring that we can produce a full codeword.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the encoded codeword, and sets *num_encoded to the number of<br/></li>
<li></span><span class="Comment"> * input integers that were encoded.&nbsp; That can be zero, if the first delta<br/></li>
<li></span><span class="Comment"> * is too large to be encoded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L873">&#x200c;</a><span class="linkable">simple8b_encode</span>(<span class="Type">const</span> uint64 *ints, <span class="Type">int</span> *num_encoded, uint64 base)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selector;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nints;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; diff;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; last_val;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; codeword;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ints[<span class="Constant">0</span>] &gt; base);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Select the &quot;mode&quot; to use for this codeword.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In each iteration, check if the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> value can be represented in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current mode we're considering.&nbsp; If it's too large, then step up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode to a wider one, and <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a>.&nbsp; If it fits, move on to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integer.&nbsp; Repeat until the codeword is full, given the current mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> way to represent unused slots in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * codeword, so we require each codeword to be &quot;full&quot;.&nbsp; It is always<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible to produce a full codeword unless the very first delta is too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * large to be encoded.&nbsp; For example, if the first delta is small but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * second is too large to be encoded, we'll end up using the last &quot;mode&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * which has nints == 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; selector = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; nints = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[<span class="Constant">0</span>].num_ints;<br/></li>
<li>&nbsp; &nbsp; bits = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[<span class="Constant">0</span>].bits_per_int;<br/></li>
<li>&nbsp; &nbsp; diff = ints[<span class="Constant">0</span>] - base - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; last_val = ints[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; i = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* number of deltas we have accepted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (diff &gt;= (UINT64CONST(<span class="Constant">1</span>) &lt;&lt; bits))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* too large, step up to <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selector++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nints = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[selector].num_ints;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[selector].bits_per_int;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we might already have accepted enough deltas for this mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= nints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> this delta; then done if codeword is full */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= nints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* examine <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> delta */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(ints[i] &gt; last_val);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff = ints[i] - last_val - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; last_val = ints[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nints == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The first delta is too large to be encoded with Simple-8b.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there is at least one not-too-large integer in the input, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will encode it using mode 15 (or a more <a href="../regex/regc_nfa.c.html#L3479" title="regex/regc_nfa.c:3479">compact</a> mode).&nbsp; Hence, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can only get here if the *first* delta is &gt;= 2^60.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(i == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *num_encoded = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L857" title="lib/integerset.c:857">EMPTY_CODEWORD</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Encode the integers using the selected mode.&nbsp; Note that we shift them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into the codeword in reverse order, so that they will come out in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * correct order in the decoder.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; codeword = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = nints - <span class="Constant">1</span>; i &gt; <span class="Constant">0</span>; i--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; diff = ints[i] - ints[i - <span class="Constant">1</span>] - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; codeword |= diff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; codeword &lt;&lt;= bits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; diff = ints[<span class="Constant">0</span>] - base - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; codeword |= diff;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add selector to the codeword, and return */<br/></li>
<li></span>&nbsp; &nbsp; codeword |= (uint64) selector &lt;&lt; <span class="Constant">60</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *num_encoded = nints;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> codeword;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Decode a codeword into an array of integers.<br/></li>
<li></span><span class="Comment"> * Returns the number of integers decoded.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L975">&#x200c;</a></span><span class="linkable">simple8b_decode</span>(uint64 codeword, uint64 *decoded, uint64 base)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selector = (codeword &gt;&gt; <span class="Constant">60</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nints = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[selector].num_ints;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[selector].bits_per_int;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; mask = (UINT64CONST(<span class="Constant">1</span>) &lt;&lt; bits) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; curr_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (codeword == <a href="#L857" title="lib/integerset.c:857">EMPTY_CODEWORD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; curr_value = base;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nints; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; diff = codeword &amp; mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr_value += <span class="Constant">1</span> + diff;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; decoded[i] = curr_value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; codeword &gt;&gt;= bits;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nints;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * This is very similar to <a href="#L975" title="lib/integerset.c:975">simple8b_decode</a>(), but instead of decoding all<br/></li>
<li></span><span class="Comment"> * the <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to an array, it just checks if the given &quot;key&quot; is part of<br/></li>
<li></span><span class="Comment"> * the codeword.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1004">&#x200c;</a></span><span class="linkable">simple8b_contains</span>(uint64 codeword, uint64 key, uint64 base)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selector = (codeword &gt;&gt; <span class="Constant">60</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nints = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[selector].num_ints;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits = <a href="#L825" title="lib/integerset.c:825">simple8b_modes</a>[selector].bits_per_int;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (codeword == <a href="#L857" title="lib/integerset.c:857">EMPTY_CODEWORD</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (bits == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Special handling for 0-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> cases. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (key - base) &lt;= nints;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; mask = (UINT64CONST(<span class="Constant">1</span>) &lt;&lt; bits) - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; curr_value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; curr_value = base;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nints; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; diff = codeword &amp; mask;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; curr_value += <span class="Constant">1</span> + diff;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr_value &gt;= key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (curr_value == key)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; codeword &gt;&gt;= bits;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
