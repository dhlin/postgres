<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>lib/dshash.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>lib/dshash.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L73">dshash_partition</a></li>
<li><a href="#L77">dshash_partition</a></li>
<li><a href="#L103">dshash_table</a></li>
<li><a href="#L83">dshash_table_control</a></li>
<li><a href="#L98">dshash_table_control</a></li>
<li><a href="#L44">dshash_table_item</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1083">copy_key</a></li>
<li><a href="#L832">delete_item</a></li>
<li><a href="#L1033">delete_item_from_bucket</a></li>
<li><a href="#L1004">delete_key_from_bucket</a></li>
<li><a href="#L270">dshash_attach</a></li>
<li><a href="#L206">dshash_create</a></li>
<li><a href="#L757">dshash_delete_current</a></li>
<li><a href="#L541">dshash_delete_entry</a></li>
<li><a href="#L503">dshash_delete_key</a></li>
<li><a href="#L323">dshash_destroy</a></li>
<li><a href="#L307">dshash_detach</a></li>
<li><a href="#L778">dshash_dump</a></li>
<li><a href="#L390">dshash_find</a></li>
<li><a href="#L433">dshash_find_or_insert</a></li>
<li><a href="#L367">dshash_get_hash_table_handle</a></li>
<li><a href="#L572">dshash_memcmp</a></li>
<li><a href="#L590">dshash_memcpy</a></li>
<li><a href="#L581">dshash_memhash</a></li>
<li><a href="#L558">dshash_release_lock</a></li>
<li><a href="#L638">dshash_seq_init</a></li>
<li><a href="#L657">dshash_seq_next</a></li>
<li><a href="#L747">dshash_seq_term</a></li>
<li><a href="#L599">dshash_strcmp</a></li>
<li><a href="#L622">dshash_strcpy</a></li>
<li><a href="#L611">dshash_strhash</a></li>
<li><a href="#L935">ensure_valid_bucket_pointers</a></li>
<li><a href="#L1072">equal_keys</a></li>
<li><a href="#L949">find_in_bucket</a></li>
<li><a href="#L1061">hash_key</a></li>
<li><a href="#L984">insert_into_bucket</a></li>
<li><a href="#L968">insert_item_into_bucket</a></li>
<li><a href="#L858">resize</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a></li>
<li><a href="#L131">BUCKETS_PER_PARTITION</a></li>
<li><a href="#L161">BUCKET_FOR_HASH</a></li>
<li><a href="#L149">BUCKET_INDEX_FOR_HASH_AND_SIZE</a></li>
<li><a href="#L153">BUCKET_INDEX_FOR_PARTITION</a></li>
<li><a href="#L63">DSHASH_MAGIC</a></li>
<li><a href="#L60">DSHASH_NUM_PARTITIONS</a></li>
<li><a href="#L59">DSHASH_NUM_PARTITIONS_LOG2</a></li>
<li><a href="#L114">ENTRY_FROM_ITEM</a></li>
<li><a href="#L118">ITEM_FROM_ENTRY</a></li>
<li><a href="#L135">MAX_COUNT_PER_PARTITION</a></li>
<li><a href="#L127">NUM_BUCKETS</a></li>
<li><a href="#L123">NUM_SPLITS</a></li>
<li><a href="#L157">PARTITION_FOR_BUCKET_INDEX</a></li>
<li><a href="#L140">PARTITION_FOR_HASH</a></li>
<li><a href="#L192">PARTITION_LOCK</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dshash.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Concurrent <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables backed by dynamic shared memory areas.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is an open hashing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, with a linked list at each table<br/></li>
<li></span><span class="Comment"> * entry.&nbsp; It supports dynamic resizing, as required to prevent the linked<br/></li>
<li></span><span class="Comment"> * lists from growing too long on average.&nbsp; Currently, only growing is<br/></li>
<li></span><span class="Comment"> * supported: the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table never becomes smaller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To deal with concurrency, it has a fixed size set of partitions, each of<br/></li>
<li></span><span class="Comment"> * which is independently locked.&nbsp; Each bucket <a href="../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> to a partition; so insert,<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and iterate operations normally only acquire one lock.&nbsp; Therefore,<br/></li>
<li></span><span class="Comment"> * good concurrency is achieved whenever such operations don't collide at the<br/></li>
<li></span><span class="Comment"> * lock partition level.&nbsp; However, when a <a href="#L858" title="lib/dshash.c:858">resize</a> operation begins, all<br/></li>
<li></span><span class="Comment"> * partition locks must be acquired simultaneously for a brief period.&nbsp; This<br/></li>
<li></span><span class="Comment"> * is only expected to happen a small number of times until a stable size is<br/></li>
<li></span><span class="Comment"> * found, since growth is geometric.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Future versions may support iterators and incremental resizing; for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a><br/></li>
<li></span><span class="Comment"> * the implementation is minimalist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/lib/dshash.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/hashfn.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/dshash.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lwlock.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/dsa.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * An item in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; This wraps the user's entry object in an<br/></li>
<li></span><span class="Comment"> * envelop that holds a pointer back to the bucket and a pointer to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * item in the bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L44">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">dshash_table_item</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item in the same bucket. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The hashed key, to avoid having to recompute it. */<br/></li>
<li></span>&nbsp; &nbsp; dshash_hash <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The user's entry object follows here.&nbsp; See <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(item). */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The number of partitions for locking purposes.&nbsp; This is set to match<br/></li>
<li></span><span class="Comment"> * NUM_BUFFER_PARTITIONS for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, on the basis that whatever's good enough for<br/></li>
<li></span><span class="Comment"> * the buffer pool must be good enough for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other purpose.&nbsp; This could<br/></li>
<li></span><span class="Comment"> * become a runtime parameter in future.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L59">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSHASH_NUM_PARTITIONS_LOG2</span> </span><span class="Constant">7<br/></li>
<li><a id="L60">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSHASH_NUM_PARTITIONS</span> (</span><span class="Constant">1</span><span class="PreProc"> &lt;&lt; <a href="#L59" title="lib/dshash.c:59">DSHASH_NUM_PARTITIONS_LOG2</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* A magic value used to identify our <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> tables. */<br/></li>
<li><a id="L63">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">DSHASH_MAGIC</span> </span><span class="Constant">0x75ff6a20<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tracking information for each lock partition.&nbsp; Initially, each partition<br/></li>
<li></span><span class="Comment"> * corresponds to one bucket, but each time the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table grows, the buckets<br/></li>
<li></span><span class="Comment"> * covered by each partition split so the number of buckets covered doubles.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We might want to add padding here so that each partition is on a different<br/></li>
<li></span><span class="Comment"> * cache line, but doing so would bloat this structure considerably.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L73">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">dshash_partition</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; LWLock&nbsp; &nbsp; &nbsp; &nbsp; lock;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Protects all buckets in this partition. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; count;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* # of items in this partition's buckets */<br/></li>
<li><a id="L77">&#x200c;</a></span>} <span class="linkable">dshash_partition</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The head object for a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; This will be stored in dynamic shared<br/></li>
<li></span><span class="Comment"> * memory.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L83">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">dshash_table_control</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_table_handle handle;<br/></li>
<li>&nbsp; &nbsp; uint32&nbsp; &nbsp; &nbsp; &nbsp; magic;<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="lib/dshash.c:73">dshash_partition</a> partitions[<a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lwlock_tranche_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The following members are written to only when ALL partitions locks are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * held.&nbsp; They can be read when <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> one partition lock is held.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Number of buckets expressed as power of 2 (8 = 256 buckets). */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size_log2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log2(number of buckets) */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer buckets;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* current bucket array */<br/></li>
<li><a id="L98">&#x200c;</a></span>} <span class="linkable">dshash_table_control</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Per-backend state for a dynamic <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L103">&#x200c;</a></span><span class="Type">struct</span> <span class="linkable">dshash_table</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a>&nbsp;&nbsp; *area;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Backing dynamic shared memory area. */<br/></li>
<li></span>&nbsp; &nbsp; dshash_parameters params;&nbsp; &nbsp; <span class="Comment">/* Parameters. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">void</span>&nbsp; &nbsp; &nbsp;&nbsp; *arg;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* User-supplied data pointer. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L83" title="lib/dshash.c:83">dshash_table_control</a> *control;&nbsp; &nbsp; <span class="Comment">/* Control object in DSM. */<br/></li>
<li></span>&nbsp; &nbsp; dsa_pointer *buckets;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Current bucket pointers in DSM. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size_log2;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* log2(number of buckets) */<br/></li>
<li></span>};<br/></li>
<li><br/></li>
<li><span class="Comment">/* Given a pointer to an item, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the entry (user data) it holds. */<br/></li>
<li><a id="L114">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ENTRY_FROM_ITEM</span>(item) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((</span><span class="Type">char</span><span class="PreProc"> *)(item) + MAXALIGN(</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L44" title="lib/dshash.c:44">dshash_table_item</a>)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Given a pointer to an entry, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the item that holds it. */<br/></li>
<li><a id="L118">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">ITEM_FROM_ENTRY</span>(entry)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((<a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *)((</span><span class="Type">char</span><span class="PreProc"> *)(entry) -&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; MAXALIGN(</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L44" title="lib/dshash.c:44">dshash_table_item</a>))))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* How many <a href="#L858" title="lib/dshash.c:858">resize</a> operations (bucket splits) have there been? */<br/></li>
<li><a id="L123">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_SPLITS</span>(size_log2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (size_log2 - <a href="#L59" title="lib/dshash.c:59">DSHASH_NUM_PARTITIONS_LOG2</a>)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* How many buckets are there in a given size? */<br/></li>
<li><a id="L127">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">NUM_BUCKETS</span>(size_log2)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((</span><span class="Type">size_t</span><span class="PreProc">) </span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; (size_log2))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* How many buckets are there in each partition at a given size? */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUCKETS_PER_PARTITION</span>(size_log2)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (((</span><span class="Type">size_t</span><span class="PreProc">) </span><span class="Constant">1</span><span class="PreProc">) &lt;&lt; <a href="#L123" title="lib/dshash.c:123">NUM_SPLITS</a>(size_log2))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Max entries <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we need to grow.&nbsp; Half + quarter = 75% load factor. */<br/></li>
<li><a id="L135">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_COUNT_PER_PARTITION</span>(hash_table)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="#L131" title="lib/dshash.c:131">BUCKETS_PER_PARTITION</a>(hash_table-&gt;size_log2) / </span><span class="Constant">2</span><span class="PreProc"> + \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; <a href="#L131" title="lib/dshash.c:131">BUCKETS_PER_PARTITION</a>(hash_table-&gt;size_log2) / </span><span class="Constant">4</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Choose partition based on the highest order bits of the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>. */<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARTITION_FOR_HASH</span>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &gt;&gt; ((</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(dshash_hash) * </span><span class="Constant">CHAR_BIT</span><span class="PreProc">) - <a href="#L59" title="lib/dshash.c:59">DSHASH_NUM_PARTITIONS_LOG2</a>))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Find the bucket index for a given <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> and table size.&nbsp; Each time the table<br/></li>
<li></span><span class="Comment"> * doubles in size, the appropriate bucket for a given <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value doubles and<br/></li>
<li></span><span class="Comment"> * possibly adds one, depending on the newly revealed <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>, so that all buckets<br/></li>
<li></span><span class="Comment"> * are split.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L149">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUCKET_INDEX_FOR_HASH_AND_SIZE</span>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, size_log2)&nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> &gt;&gt; ((</span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(dshash_hash) * </span><span class="Constant">CHAR_BIT</span><span class="PreProc">) - (size_log2)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The index of the first bucket in a given partition. */<br/></li>
<li><a id="L153">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUCKET_INDEX_FOR_PARTITION</span>(partition, size_log2)&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((partition) &lt;&lt; <a href="#L123" title="lib/dshash.c:123">NUM_SPLITS</a>(size_log2))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Choose partition based on bucket index. */<br/></li>
<li><a id="L157">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">PARTITION_FOR_BUCKET_INDEX</span>(bucket_idx, size_log2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((bucket_idx) &gt;&gt; <a href="#L123" title="lib/dshash.c:123">NUM_SPLITS</a>(size_log2))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The head of the active bucket for a given <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value (lvalue). */<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">BUCKET_FOR_HASH</span>(hash_table, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (hash_table-&gt;buckets[&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L149" title="lib/dshash.c:149">BUCKET_INDEX_FOR_HASH_AND_SIZE</a>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash_table-&gt;size_log2)])<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L832" title="lib/dshash.c:832">delete_item</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L858" title="lib/dshash.c:858">resize</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">size_t</span> new_size_log2);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *<a href="#L949" title="lib/dshash.c:949">find_in_bucket</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer item_pointer);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L968" title="lib/dshash.c:968">insert_item_into_bucket</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer item_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer *bucket);<br/></li>
<li><span class="Type">static</span> <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *<a href="#L984" title="lib/dshash.c:984">insert_into_bucket</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer *bucket);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1004" title="lib/dshash.c:1004">delete_key_from_bucket</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer *bucket_head);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1033" title="lib/dshash.c:1033">delete_item_from_bucket</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer *bucket_head);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> dshash_hash <a href="#L1061" title="lib/dshash.c:1061">hash_key</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">const</span> <span class="Type">void</span> *key);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L1072" title="lib/dshash.c:1072">equal_keys</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b);<br/></li>
<li><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void</span> <a href="#L1083" title="lib/dshash.c:1083">copy_key</a>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">void</span> *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *src);<br/></li>
<li><br/></li>
<li><a id="L192">&#x200c;</a><span class="PreProc">#define <span class="linkable">PARTITION_LOCK</span>(hash_table, i)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; (&amp;(hash_table)-&gt;control-&gt;partitions[(i)].lock)<br/></li>
<li></span><br/></li>
<li><a id="L195">&#x200c;</a><span class="PreProc">#define <span class="linkable">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</span>(hash_table) \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; Assert(!<a href="../storage/lmgr/lwlock.c.html#L1913" title="storage/lmgr/lwlock.c:1913">LWLockAnyHeldByMe</a>(&amp;(hash_table)-&gt;control-&gt;partitions[</span><span class="Constant">0</span><span class="PreProc">].lock, \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>, </span><span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span><span class="PreProc">(<a href="#L73" title="lib/dshash.c:73">dshash_partition</a>)))<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a new <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table backed by the given dynamic shared area, with the<br/></li>
<li></span><span class="Comment"> * given parameters.&nbsp; The returned object is allocated in backend-local memory<br/></li>
<li></span><span class="Comment"> * using the current MemoryContext.&nbsp; 'arg' will be passed through to the<br/></li>
<li></span><span class="Comment"> * <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a>, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>, and copy <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L103" title="lib/dshash.c:103">dshash_table</a> *<br/></li>
<li><a id="L206">&#x200c;</a><span class="linkable">dshash_create</span>(<a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">const</span> dshash_parameters *params, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer control;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the backend-local object representing the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; hash_table = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the control object in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; control = dsa_allocate(area, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L83" title="lib/dshash.c:83">dshash_table_control</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the local and shared <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table structs. */<br/></li>
<li></span>&nbsp; &nbsp; hash_table-&gt;area = area;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;params = *params;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, control);<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control-&gt;handle = control;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control-&gt;magic = <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control-&gt;lwlock_tranche_id = params-&gt;tranche_id;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the array of lock partitions. */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="lib/dshash.c:73">dshash_partition</a> *partitions = hash_table-&gt;control-&gt;partitions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tranche_id = hash_table-&gt;control-&gt;lwlock_tranche_id;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L709" title="storage/lmgr/lwlock.c:709">LWLockInitialize</a>(&amp;partitions[i].lock, tranche_id);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partitions[i].count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the initial array of buckets.&nbsp; Our initial size is the same as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the number of partitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_table-&gt;control-&gt;size_log2 = <a href="#L59" title="lib/dshash.c:59">DSHASH_NUM_PARTITIONS_LOG2</a>;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control-&gt;buckets =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L671" title="utils/mmgr/dsa.c:671">dsa_allocate_extended</a>(area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer) * <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DSA_ALLOC_NO_OOM | DSA_ALLOC_ZERO);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!DsaPointerIsValid(hash_table-&gt;control-&gt;buckets))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(area, control);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OUT_OF_MEMORY),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;out of memory&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Failed on DSA request of size </span><span class="Special">%zu</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer) * <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;buckets = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;control-&gt;buckets);<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;size_log2 = hash_table-&gt;control-&gt;size_log2;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_table;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Attach to an existing <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table using a handle.&nbsp; The returned object is<br/></li>
<li></span><span class="Comment"> * allocated in backend-local memory using the current MemoryContext.&nbsp; 'arg'<br/></li>
<li></span><span class="Comment"> * will be passed through to the <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> and <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><a href="#L103" title="lib/dshash.c:103">dshash_table</a> *<br/></li>
<li><a id="L270">&#x200c;</a><span class="linkable">dshash_attach</span>(<a href="../utils/mmgr/dsa.c.html#L347" title="utils/mmgr/dsa.c:347">dsa_area</a> *area, <span class="Type">const</span> dshash_parameters *params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dshash_table_handle handle, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer control;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the backend-local object representing the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table. */<br/></li>
<li></span>&nbsp; &nbsp; hash_table = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the control object in shared memory. */<br/></li>
<li></span>&nbsp; &nbsp; control = handle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up the local <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table struct. */<br/></li>
<li></span>&nbsp; &nbsp; hash_table-&gt;area = area;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;params = *params;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;arg = arg;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(area, control);<br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * These will later be set to the correct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(), at which time we'll be holding a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition lock for interlocking against concurrent resizing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_table-&gt;buckets = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;size_log2 = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_table;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Detach from a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; This frees backend-local resources associated<br/></li>
<li></span><span class="Comment"> * with the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, but the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table will continue to exist until it is<br/></li>
<li></span><span class="Comment"> * either explicitly destroyed (by a backend that is still attached to it), or<br/></li>
<li></span><span class="Comment"> * the area that backs it is returned to the operating system.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L307">&#x200c;</a></span><span class="linkable">dshash_detach</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="lib/dshash.c:195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table may have been destroyed.&nbsp; Just free local memory. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hash_table);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Destroy a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, returning all memory to the area.&nbsp; The caller must be<br/></li>
<li></span><span class="Comment"> * certain that no other backend will attempt to access the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * calling this function.&nbsp; Other backend must explicitly call <a href="#L307" title="lib/dshash.c:307">dshash_detach</a> to<br/></li>
<li></span><span class="Comment"> * free up backend-local memory associated with the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; The backend<br/></li>
<li></span><span class="Comment"> * that calls <a href="#L323" title="lib/dshash.c:323">dshash_destroy</a> must not call <a href="#L307" title="lib/dshash.c:307">dshash_detach</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L323">&#x200c;</a></span><span class="linkable">dshash_destroy</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free all the entries. */<br/></li>
<li></span>&nbsp; &nbsp; size = <a href="#L127" title="lib/dshash.c:127">NUM_BUCKETS</a>(hash_table-&gt;size_log2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; size; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer item_pointer = hash_table-&gt;buckets[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(item_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer next_item_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, item_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_item_pointer = item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(hash_table-&gt;area, item_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_pointer = next_item_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Vandalize the control block to <a href="../main/main.c.html#L320" title="main/main.c:320">help</a> catch programming errors where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * other backends access the memory formerly occupied by this <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; hash_table-&gt;control-&gt;magic = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Free the active table and control object. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(hash_table-&gt;area, hash_table-&gt;control-&gt;buckets);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(hash_table-&gt;area, hash_table-&gt;control-&gt;handle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(hash_table);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get a handle that can be used by other processes to attach to this <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * table.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dshash_table_handle<br/></li>
<li><a id="L367">&#x200c;</a><span class="linkable">dshash_get_hash_table_handle</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_table-&gt;control-&gt;handle;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Look up an entry, given a key.&nbsp; Returns a pointer to an entry if one can be<br/></li>
<li></span><span class="Comment"> * found with the given key.&nbsp; Returns NULL if the key is not found.&nbsp; If a<br/></li>
<li></span><span class="Comment"> * non-NULL value is returned, the entry is locked and must be released by<br/></li>
<li></span><span class="Comment"> * calling <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a>.&nbsp; If an error is raised <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a> is called, the lock will be released automatically, but<br/></li>
<li></span><span class="Comment"> * the caller must take care to ensure that the entry is not left corrupted.<br/></li>
<li></span><span class="Comment"> * The lock mode is either shared or exclusive depending on 'exclusive'.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller must not hold a lock already.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the lock held is in fact an LWLock, so interrupts will be held on<br/></li>
<li></span><span class="Comment"> * return from this function, and not resumed until <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a> is<br/></li>
<li></span><span class="Comment"> * called.&nbsp; It is a very good idea for the caller to release the lock quickly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L390">&#x200c;</a><span class="linkable">dshash_find</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">const</span> <span class="Type">void</span> *key, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exclusive)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_hash <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L1061" title="lib/dshash.c:1061">hash_key</a>(hash_table, key);<br/></li>
<li>&nbsp; &nbsp; partition = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="lib/dshash.c:195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exclusive ? LW_EXCLUSIVE : LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search the active bucket. */<br/></li>
<li></span>&nbsp; &nbsp; item = <a href="#L949" title="lib/dshash.c:949">find_in_bucket</a>(hash_table, key, <a href="#L161" title="lib/dshash.c:161">BUCKET_FOR_HASH</a>(hash_table, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!item)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not found. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The caller will free the lock by calling <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(item);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns a pointer to an exclusively locked item which must be released with<br/></li>
<li></span><span class="Comment"> * <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a>.&nbsp; If the key is found in the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, 'found' is set<br/></li>
<li></span><span class="Comment"> * to true and a pointer to the existing entry is returned.&nbsp; If the key is not<br/></li>
<li></span><span class="Comment"> * found, 'found' is set to false, and a pointer to a newly created entry is<br/></li>
<li></span><span class="Comment"> * returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notes above <a href="#L390" title="lib/dshash.c:390">dshash_find</a>() regarding locking and error handling equally<br/></li>
<li></span><span class="Comment"> * apply here.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L433">&#x200c;</a><span class="linkable">dshash_find_or_insert</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *found)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_hash <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition_index;<br/></li>
<li>&nbsp; &nbsp; <a href="#L73" title="lib/dshash.c:73">dshash_partition</a> *partition;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L1061" title="lib/dshash.c:1061">hash_key</a>(hash_table, key);<br/></li>
<li>&nbsp; &nbsp; partition_index = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li>&nbsp; &nbsp; partition = &amp;hash_table-&gt;control-&gt;partitions[partition_index];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="lib/dshash.c:195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a>(hash_table);<br/></li>
<li><br/></li>
<li><span class="Statement">restart</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition_index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Search the active bucket. */<br/></li>
<li></span>&nbsp; &nbsp; item = <a href="#L949" title="lib/dshash.c:949">find_in_bucket</a>(hash_table, key, <a href="#L161" title="lib/dshash.c:161">BUCKET_FOR_HASH</a>(hash_table, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (item)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if we are getting too full. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partition-&gt;count &gt; <a href="#L135" title="lib/dshash.c:135">MAX_COUNT_PER_PARTITION</a>(hash_table))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The load factor (= keys / buckets) for all buckets protected by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this partition is &gt; 0.75.&nbsp; Presumably the same applies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generally across the whole <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table (though we don't attempt<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to track that directly to avoid contention on some kind of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * central counter; we just assume that this partition is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * representative).&nbsp; This is a good time to <a href="#L858" title="lib/dshash.c:858">resize</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Give up our existing lock first, because resizing needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reacquire all the locks in the right order to avoid deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition_index));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L858" title="lib/dshash.c:858">resize</a>(hash_table, hash_table-&gt;size_log2 + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> restart;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finally we can try to insert the new item. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; item = <a href="#L984" title="lib/dshash.c:984">insert_into_bucket</a>(hash_table, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L161" title="lib/dshash.c:161">BUCKET_FOR_HASH</a>(hash_table, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust per-lock-partition counter for load factor knowledge. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ++partition-&gt;count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The caller must release the lock with <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(item);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove an entry by key.&nbsp; Returns true if the key was found and the<br/></li>
<li></span><span class="Comment"> * corresponding entry was removed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To delete an entry that you already have a pointer to, see<br/></li>
<li></span><span class="Comment"> * <a href="#L541" title="lib/dshash.c:541">dshash_delete_entry</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L503">&#x200c;</a></span><span class="linkable">dshash_delete_key</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">const</span> <span class="Type">void</span> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dshash_hash <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="lib/dshash.c:195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = <a href="#L1061" title="lib/dshash.c:1061">hash_key</a>(hash_table, key);<br/></li>
<li>&nbsp; &nbsp; partition = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1004" title="lib/dshash.c:1004">delete_key_from_bucket</a>(hash_table, key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;<a href="#L161" title="lib/dshash.c:161">BUCKET_FOR_HASH</a>(hash_table, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;partitions[partition].count &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --hash_table-&gt;control-&gt;partitions[partition].count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> found;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove an entry.&nbsp; The entry must already be exclusively locked, and must<br/></li>
<li></span><span class="Comment"> * have been obtained by <a href="#L390" title="lib/dshash.c:390">dshash_find</a> or <a href="#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>.&nbsp; Note that this<br/></li>
<li></span><span class="Comment"> * function releases the lock just like <a href="#L558" title="lib/dshash.c:558">dshash_release_lock</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To delete an entry by key, see <a href="#L503" title="lib/dshash.c:503">dshash_delete_key</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L541">&#x200c;</a></span><span class="linkable">dshash_delete_entry</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">void</span> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item = <a href="#L118" title="lib/dshash.c:118">ITEM_FROM_ENTRY</a>(entry);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(item-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L832" title="lib/dshash.c:832">delete_item</a>(hash_table, item);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Unlock an entry which was locked by <a href="#L390" title="lib/dshash.c:390">dshash_find</a> or <a href="#L433" title="lib/dshash.c:433">dshash_find_or_insert</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L558">&#x200c;</a></span><span class="linkable">dshash_release_lock</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">void</span> *entry)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item = <a href="#L118" title="lib/dshash.c:118">ITEM_FROM_ENTRY</a>(entry);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition_index = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(item-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition_index));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> function that forwards to memcmp.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L572">&#x200c;</a></span><span class="linkable">dshash_memcmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> memcmp(a, b, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function that forwards to tag_hash.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dshash_hash<br/></li>
<li><a id="L581">&#x200c;</a><span class="linkable">dshash_memhash</span>(<span class="Type">const</span> <span class="Type">void</span> *v, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tag_hash(v, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A copy function that forwards to memcpy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L590">&#x200c;</a></span><span class="linkable">dshash_memcpy</span>(<span class="Type">void</span> *dest, <span class="Type">const</span> <span class="Type">void</span> *src, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) memcpy(dest, src, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> function that forwards to strcmp.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L599">&#x200c;</a></span><span class="linkable">dshash_strcmp</span>(<span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(strlen((<span class="Type">const</span> <span class="Type">char</span> *) a) &lt; size);<br/></li>
<li>&nbsp; &nbsp; Assert(strlen((<span class="Type">const</span> <span class="Type">char</span> *) b) &lt; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> strcmp((<span class="Type">const</span> <span class="Type">char</span> *) a, (<span class="Type">const</span> <span class="Type">char</span> *) b);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> function that forwards to string_hash.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>dshash_hash<br/></li>
<li><a id="L611">&#x200c;</a><span class="linkable">dshash_strhash</span>(<span class="Type">const</span> <span class="Type">void</span> *v, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(strlen((<span class="Type">const</span> <span class="Type">char</span> *) v) &lt; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> string_hash((<span class="Type">const</span> <span class="Type">char</span> *) v, size);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * A copy function that forwards to strcpy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L622">&#x200c;</a></span><span class="linkable">dshash_strcpy</span>(<span class="Type">void</span> *dest, <span class="Type">const</span> <span class="Type">void</span> *src, <span class="Type">size_t</span> size, <span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(strlen((<span class="Type">const</span> <span class="Type">char</span> *) src) &lt; size);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; (<span class="Type">void</span>) strcpy((<span class="Type">char</span> *) dest, (<span class="Type">const</span> <span class="Type">char</span> *) src);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sequentially scan through dshash table and return all the elements one by<br/></li>
<li></span><span class="Comment"> * one, return NULL when all elements have been returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L747" title="lib/dshash.c:747">dshash_seq_term</a> needs to be called when a scan finished.&nbsp; The caller may<br/></li>
<li></span><span class="Comment"> * delete returned elements midst of a scan by using <a href="#L757" title="lib/dshash.c:757">dshash_delete_current</a>()<br/></li>
<li></span><span class="Comment"> * if exclusive = true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L638">&#x200c;</a></span><span class="linkable">dshash_seq_init</span>(dshash_seq_status *status, <a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> exclusive)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; status-&gt;hash_table = hash_table;<br/></li>
<li>&nbsp; &nbsp; status-&gt;curbucket = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; status-&gt;nbuckets = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; status-&gt;curitem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; status-&gt;pnextitem = InvalidDsaPointer;<br/></li>
<li>&nbsp; &nbsp; status-&gt;curpartition = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; status-&gt;exclusive = exclusive;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Returns the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returned elements are locked and the caller may not release the lock. It is<br/></li>
<li></span><span class="Comment"> * released by future calls to <a href="#L657" title="lib/dshash.c:657">dshash_seq_next</a>() or <a href="#L747" title="lib/dshash.c:747">dshash_seq_term</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void</span> *<br/></li>
<li><a id="L657">&#x200c;</a><span class="linkable">dshash_seq_next</span>(dshash_seq_status *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer next_item_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Not yet holding <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition locks. Need to determine the size of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table, it could have been resized since we were looking last.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since we iterate in partition order, we can start by unconditionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock partition 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we hold the lock, no resizing can happen until the scan ends. So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't need to repeatedly call <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;curpartition == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(status-&gt;curbucket == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L195" title="lib/dshash.c:195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a>(status-&gt;hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;curpartition = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(status-&gt;hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status-&gt;curpartition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;exclusive ? LW_EXCLUSIVE : LW_SHARED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(status-&gt;hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status-&gt;nbuckets =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L127" title="lib/dshash.c:127">NUM_BUCKETS</a>(status-&gt;hash_table-&gt;control-&gt;size_log2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_item_pointer = status-&gt;hash_table-&gt;buckets[status-&gt;curbucket];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; next_item_pointer = status-&gt;pnextitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(status-&gt;hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status-&gt;curpartition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;exclusive ? LW_EXCLUSIVE : LW_SHARED));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Move to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> bucket if we finished the current bucket */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (!DsaPointerIsValid(next_item_pointer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_partition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++status-&gt;curbucket &gt;= status-&gt;nbuckets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all buckets have been scanned. finish. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check if move to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> partition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; next_partition =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L157" title="lib/dshash.c:157">PARTITION_FOR_BUCKET_INDEX</a>(status-&gt;curbucket,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status-&gt;hash_table-&gt;size_log2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;curpartition != next_partition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Move to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> partition. Lock the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> partition then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * release the current, not in the reverse order to avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * concurrent resizing.&nbsp; Avoid dead lock by taking lock in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same order with <a href="#L858" title="lib/dshash.c:858">resize</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(status-&gt;hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; next_partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;exclusive ? LW_EXCLUSIVE : LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(status-&gt;hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; status-&gt;curpartition));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status-&gt;curpartition = next_partition;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; next_item_pointer = status-&gt;hash_table-&gt;buckets[status-&gt;curbucket];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; status-&gt;curitem =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(status-&gt;hash_table-&gt;area, next_item_pointer);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The caller may delete the item. Store the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> item in case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; status-&gt;pnextitem = status-&gt;curitem-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(status-&gt;curitem);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Terminates the seqscan and release all locks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Needs to be called after finishing or when exiting a seqscan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L747">&#x200c;</a></span><span class="linkable">dshash_seq_term</span>(dshash_seq_status *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (status-&gt;curpartition &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(status-&gt;hash_table, status-&gt;curpartition));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Remove the current entry of the seq scan.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L757">&#x200c;</a></span><span class="linkable">dshash_delete_current</span>(dshash_seq_status *status)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table = status-&gt;hash_table;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item = status-&gt;curitem;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition <a href="../storage/lmgr/lock.c.html#L185" title="storage/lmgr/lock.c:185">PG_USED_FOR_ASSERTS_ONLY</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partition = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(item-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(status-&gt;exclusive);<br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1939" title="storage/lmgr/lwlock.c:1939">LWLockHeldByMeInMode</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; LW_EXCLUSIVE));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L832" title="lib/dshash.c:832">delete_item</a>(hash_table, item);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Print debugging information about the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state of the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table to<br/></li>
<li></span><span class="Comment"> * stderr.&nbsp; The caller must hold no partition locks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L778">&#x200c;</a></span><span class="linkable">dshash_dump</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;magic == <a href="#L63" title="lib/dshash.c:63">DSHASH_MAGIC</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="lib/dshash.c:195">ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, i)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, i), LW_SHARED);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L935" title="lib/dshash.c:935">ensure_valid_bucket_pointers</a>(hash_table);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table size = </span><span class="Special">%zu\n</span><span class="Constant">&quot;</span>, (<span class="Type">size_t</span>) <span class="Constant">1</span> &lt;&lt; hash_table-&gt;size_log2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L73" title="lib/dshash.c:73">dshash_partition</a> *partition = &amp;hash_table-&gt;control-&gt;partitions[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; begin = <a href="#L153" title="lib/dshash.c:153">BUCKET_INDEX_FOR_PARTITION</a>(i, hash_table-&gt;size_log2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; end = <a href="#L153" title="lib/dshash.c:153">BUCKET_INDEX_FOR_PARTITION</a>(i + <span class="Constant">1</span>, hash_table-&gt;size_log2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; partition </span><span class="Special">%zu\n</span><span class="Constant">&quot;</span>, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;&nbsp; &nbsp; active buckets (key count = </span><span class="Special">%zu</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>, partition-&gt;count);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (j = begin; j &lt; end; ++j)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer bucket = hash_table-&gt;buckets[j];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(bucket))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, bucket);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bucket = item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;&nbsp; &nbsp; &nbsp; bucket </span><span class="Special">%zu</span><span class="Constant"> (key count = </span><span class="Special">%zu</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>, j, count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, i));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> a locked item to which we have a pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L832">&#x200c;</a></span><span class="linkable">delete_item</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> = item-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; partition = <a href="#L140" title="lib/dshash.c:140">PARTITION_FOR_HASH</a>(<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, partition)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1033" title="lib/dshash.c:1033">delete_item_from_bucket</a>(hash_table, item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="#L161" title="lib/dshash.c:161">BUCKET_FOR_HASH</a>(hash_table, <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(hash_table-&gt;control-&gt;partitions[partition].count &gt; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; --hash_table-&gt;control-&gt;partitions[partition].count;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Grow the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table if necessary to the requested number of buckets.&nbsp; The<br/></li>
<li></span><span class="Comment"> * requested size must be double some previously observed size.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> partition lock held.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L858">&#x200c;</a></span><span class="linkable">resize</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">size_t</span> new_size_log2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer old_buckets;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer new_buckets_shared;<br/></li>
<li>&nbsp; &nbsp; dsa_pointer *new_buckets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; size;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; new_size = ((<span class="Type">size_t</span>) <span class="Constant">1</span>) &lt;&lt; new_size_log2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Acquire the locks for all lock partitions.&nbsp; This is expensive, but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't have to do it many times.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="../storage/lmgr/lwlock.c.html#L1895" title="storage/lmgr/lwlock.c:1895">LWLockHeldByMe</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, i)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1170" title="storage/lmgr/lwlock.c:1170">LWLockAcquire</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, i), LW_EXCLUSIVE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i == <span class="Constant">0</span> &amp;&amp; hash_table-&gt;control-&gt;size_log2 &gt;= new_size_log2)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Another backend has already increased the size; we can avoid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * obtaining all the locks and return early.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(new_size_log2 == hash_table-&gt;control-&gt;size_log2 + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate the space for the new table. */<br/></li>
<li></span>&nbsp; &nbsp; new_buckets_shared = dsa_allocate0(hash_table-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(dsa_pointer) * new_size);<br/></li>
<li>&nbsp; &nbsp; new_buckets = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, new_buckets_shared);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We've allocated the new bucket array; all that remains to do <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reinsert all items, which amounts to adjusting all the pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; size = ((<span class="Type">size_t</span>) <span class="Constant">1</span>) &lt;&lt; hash_table-&gt;control-&gt;size_log2;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; size; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer item_pointer = hash_table-&gt;buckets[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(item_pointer))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer next_item_pointer;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, item_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_item_pointer = item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L968" title="lib/dshash.c:968">insert_item_into_bucket</a>(hash_table, item_pointer, item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;new_buckets[<a href="#L149" title="lib/dshash.c:149">BUCKET_INDEX_FOR_HASH_AND_SIZE</a>(item-&gt;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_size_log2)]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; item_pointer = next_item_pointer;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Swap the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table into place and free the old one. */<br/></li>
<li></span>&nbsp; &nbsp; old_buckets = hash_table-&gt;control-&gt;buckets;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control-&gt;buckets = new_buckets_shared;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;control-&gt;size_log2 = new_size_log2;<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;buckets = new_buckets;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(hash_table-&gt;area, old_buckets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Release all the locks. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; <a href="#L60" title="lib/dshash.c:60">DSHASH_NUM_PARTITIONS</a>; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lwlock.c.html#L1783" title="storage/lmgr/lwlock.c:1783">LWLockRelease</a>(<a href="#L192" title="lib/dshash.c:192">PARTITION_LOCK</a>(hash_table, i));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make sure that our backend-local bucket pointers are up to date.&nbsp; The<br/></li>
<li></span><span class="Comment"> * caller must have locked one lock partition, which prevents <a href="#L858" title="lib/dshash.c:858">resize</a>() from<br/></li>
<li></span><span class="Comment"> * running concurrently.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L935">&#x200c;</a></span><span class="linkable">ensure_valid_bucket_pointers</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (hash_table-&gt;size_log2 != hash_table-&gt;control-&gt;size_log2)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;buckets = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;control-&gt;buckets);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;size_log2 = hash_table-&gt;control-&gt;size_log2;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Scan a locked bucket for a match, using the provided <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *<br/></li>
<li><a id="L949">&#x200c;</a><span class="linkable">find_in_bucket</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer item_pointer)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(item_pointer))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, item_pointer);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1072" title="lib/dshash.c:1072">equal_keys</a>(hash_table, key, <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(item)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> item;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item_pointer = item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> an already-allocated item into a bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L968">&#x200c;</a></span><span class="linkable">insert_item_into_bucket</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer item_pointer,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer *bucket)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(item == <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, item_pointer));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = *bucket;<br/></li>
<li>&nbsp; &nbsp; *bucket = item_pointer;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Allocate space for an entry with the given key and insert it into the<br/></li>
<li></span><span class="Comment"> * provided bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *<br/></li>
<li><a id="L984">&#x200c;</a><span class="linkable">insert_into_bucket</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer *bucket)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; dsa_pointer item_pointer;<br/></li>
<li>&nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; item_pointer = dsa_allocate(hash_table-&gt;area,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;params.entry_size +<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MAXALIGN(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L44" title="lib/dshash.c:44">dshash_table_item</a>)));<br/></li>
<li>&nbsp; &nbsp; item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, item_pointer);<br/></li>
<li>&nbsp; &nbsp; <a href="#L1083" title="lib/dshash.c:1083">copy_key</a>(hash_table, <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(item), key);<br/></li>
<li>&nbsp; &nbsp; <a href="#L968" title="lib/dshash.c:968">insert_item_into_bucket</a>(hash_table, item_pointer, item, bucket);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> item;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Search a bucket for a matching key and delete it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1004">&#x200c;</a></span><span class="linkable">delete_key_from_bucket</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">void</span> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dsa_pointer *bucket_head)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(*bucket_head))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, *bucket_head);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1072" title="lib/dshash.c:1072">equal_keys</a>(hash_table, key, <a href="#L114" title="lib/dshash.c:114">ENTRY_FROM_ITEM</a>(item)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(hash_table-&gt;area, *bucket_head);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bucket_head = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_head = &amp;item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the specified item from the bucket.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1033">&#x200c;</a></span><span class="linkable">delete_item_from_bucket</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *item,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer *bucket_head)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (DsaPointerIsValid(*bucket_head))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L44" title="lib/dshash.c:44">dshash_table_item</a> *bucket_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_item = <a href="../utils/mmgr/dsa.c.html#L942" title="utils/mmgr/dsa.c:942">dsa_get_address</a>(hash_table-&gt;area, *bucket_head);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bucket_item == item)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dsa_pointer <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/dsa.c.html#L826" title="utils/mmgr/dsa.c:826">dsa_free</a>(hash_table-&gt;area, *bucket_head);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *bucket_head = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bucket_head = &amp;bucket_item-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Compute the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> value for a key.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> dshash_hash<br/></li>
<li><a id="L1061">&#x200c;</a><span class="linkable">hash_key</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">const</span> <span class="Type">void</span> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_table-&gt;params.hash_function(key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;params.key_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash_table-&gt;arg);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether two keys <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1072">&#x200c;</a></span><span class="linkable">equal_keys</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">const</span> <span class="Type">void</span> *a, <span class="Type">const</span> <span class="Type">void</span> *b)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> hash_table-&gt;params.compare_function(a, b,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash_table-&gt;params.key_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash_table-&gt;arg) == <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy a key.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">inline</span> <span class="Type">void<br/></li>
<li><a id="L1083">&#x200c;</a></span><span class="linkable">copy_key</span>(<a href="#L103" title="lib/dshash.c:103">dshash_table</a> *hash_table, <span class="Type">void</span> *dest, <span class="Type">const</span> <span class="Type">void</span> *src)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; hash_table-&gt;params.copy_function(dest, src,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash_table-&gt;params.key_size,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; hash_table-&gt;arg);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
