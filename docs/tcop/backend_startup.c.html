<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>tcop/backend_startup.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>tcop/backend_startup.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L41">Trace_connection_negotiation</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L122">BackendInitialize</a></li>
<li><a href="#L57">BackendMain</a></li>
<li><a href="#L362">ProcessSSLStartup</a></li>
<li><a href="#L453">ProcessStartupPacket</a></li>
<li><a href="#L846">SendNegotiateProtocolVersion</a></li>
<li><a href="#L886">StartupPacketTimeoutHandler</a></li>
<li><a href="#L876">process_startup_packet_die</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * backend_startup.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a> startup code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2023, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/tcop/backend_startup.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/ip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/string.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq-be.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/fd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/backend_startup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUCs */<br/></li>
<li><a id="L41">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Trace_connection_negotiation</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L122" title="tcop/backend_startup.c:122">BackendInitialize</a>(ClientSocket *client_sock, CAC_state cac);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L362" title="tcop/backend_startup.c:362">ProcessSSLStartup</a>(Port *port);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L453" title="tcop/backend_startup.c:453">ProcessStartupPacket</a>(Port *port, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ssl_done, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> gss_done);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L846" title="tcop/backend_startup.c:846">SendNegotiateProtocolVersion</a>(List *unrecognized_protocol_options);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L876" title="tcop/backend_startup.c:876">process_startup_packet_die</a>(SIGNAL_ARGS);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L886" title="tcop/backend_startup.c:886">StartupPacketTimeoutHandler</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Entry point for a new backend process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Initialize the connection, read the startup packet, authenticate the<br/></li>
<li></span><span class="Comment"> * client, and start the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> processing loop.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L57">&#x200c;</a></span><span class="linkable">BackendMain</span>(<span class="Type">char</span> *startup_data, <span class="Type">size_t</span> startup_data_len)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; BackendStartupData *bsdata = (BackendStartupData *) startup_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(startup_data_len == <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(BackendStartupData));<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L48" title="utils/init/globals.c:48">MyClientSocket</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef EXEC_BACKEND<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need to reinitialize the SSL library in the backend, since the context<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structures contain function pointers and cannot be passed through the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parameter file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If for some reason reload fails (maybe the user installed broken key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * files), soldier on without SSL; that's better than all connections<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * becoming impossible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should we do this in all child processes?&nbsp; For the moment it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enough to do it in backend children.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L225" title="postmaster/postmaster.c:225">EnableSSL</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/be-secure.c.html#L73" title="libpq/be-secure.c:73">secure_initialize</a>(<span class="Constant">false</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/postmaster.c.html#L381" title="postmaster/postmaster.c:381">LoadedSSL</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SSL configuration could not be loaded in child process&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform additional initialization and collect startup packet */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L122" title="tcop/backend_startup.c:122">BackendInitialize</a>(<a href="../utils/init/globals.c.html#L48" title="utils/init/globals.c:48">MyClientSocket</a>, bsdata-&gt;<a href="../postmaster/postmaster.c.html#L1895" title="postmaster/postmaster.c:1895">canAcceptConnections</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a per-backend PGPROC struct in shared memory.&nbsp; We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can use LWLocks or access <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure we aren't in <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> anymore.&nbsp; (We can't delete it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just yet, though, because <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> will need the HBA data.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a>(<a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;database_name, <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>-&gt;user_name);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L122" title="tcop/backend_startup.c:122">BackendInitialize</a> -- <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> an interactive (postmaster-child)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backend process, and collect the client's startup packet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * returns: nothing.&nbsp; Will not return at all if there's <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> failure.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this code does not depend on having <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> access to shared memory.<br/></li>
<li></span><span class="Comment"> * Indeed, our approach to SIGTERM/timeout handling *requires* that<br/></li>
<li></span><span class="Comment"> * shared memory not have been touched yet; see comments within.<br/></li>
<li></span><span class="Comment"> * In the EXEC_BACKEND case, we are physically attached to shared memory<br/></li>
<li></span><span class="Comment"> * but have not yet set up most of our local pointers to shmem structures.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L122">&#x200c;</a></span><span class="linkable">BackendInitialize</span>(ClientSocket *client_sock, CAC_state cac)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; status;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ret;<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; remote_host[NI_MAXHOST];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; remote_port[NI_MAXSERV];<br/></li>
<li>&nbsp; &nbsp; StringInfoData ps_data;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Tell fd.c about the long-lived FD associated with the client_sock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/file/fd.c.html#L1221" title="storage/file/fd.c:1221">ReserveExternalFD</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../postmaster/postmaster.c.html#L227" title="postmaster/postmaster.c:227">PreAuthDelay</a> is a debugging aid for investigating problems in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication cycle: it can be set in postgresql.conf to allow time to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attach to the newly-forked backend with a debugger.&nbsp; (See also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="postgres.c.html#L101" title="tcop/postgres.c:101">PostAuthDelay</a>, which we allow clients to pass through PGOPTIONS, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not honored until after authentication.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L227" title="postmaster/postmaster.c:227">PreAuthDelay</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../port/win32/signal.c.html#L53" title="port/win32/signal.c:53">pg_usleep</a>(<a href="../postmaster/postmaster.c.html#L227" title="postmaster/postmaster.c:227">PreAuthDelay</a> * <span class="Constant">1000000L</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This flag will remain set until <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> finishes authentication */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a> = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* limit visibility of log messages */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Initialize libpq and enable reporting of ereport errors to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must do this <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because authentication uses libpq to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The Port structure and all data structures attached to it are allocated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, so that they survive into <a href="postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a> execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need not worry about leaking this storage on failure, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * aren't in the postmaster process anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; port = <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> = <a href="../libpq/pqcomm.c.html#L173" title="libpq/pqcomm.c:173">pq_init</a>(client_sock);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="postgres.c.html#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestRemote; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> safe to ereport to client */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set these to empty in case they are needed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we set them up */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;remote_host = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; port-&gt;remote_port = <span class="Constant">&quot;&quot;</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We arrange to do _exit(1) if we receive SIGTERM or timeout while trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to collect the startup packet; while SIGQUIT results in _exit(2).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Otherwise the postmaster cannot shutdown the database FAST or IMMED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleanly if a buggy client fails to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the packet promptly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exiting with _exit(1) is only possible because we have not yet touched<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory; therefore no outside-the-process state needs to get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cleaned up.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="#L876" title="tcop/backend_startup.c:876">process_startup_packet_die</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* SIGQUIT handler was already set up by <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* establishes SIGALRM handler */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L24" title="libpq/pqsignal.c:24">StartupBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the remote host name and port for logging and status display.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; remote_host[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; remote_port[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((ret = pg_getnameinfo_all(&amp;port-&gt;raddr.addr, port-&gt;raddr.salen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_host, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remote_host),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_port, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(remote_port),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../postmaster/postmaster.c.html#L230" title="postmaster/postmaster.c:230">log_hostname</a> ? <span class="Constant">0</span> : NI_NUMERICHOST) | NI_NUMERICSERV)) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;pg_getnameinfo_all() failed: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; gai_strerror(ret))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Save remote_host and remote_port in port structure (after this, they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will appear in <a href="../utils/error/elog.c.html#L2773" title="utils/error/elog.c:2773">log_line_prefix</a> data for log messages).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; port-&gt;remote_host = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remote_host);<br/></li>
<li>&nbsp; &nbsp; port-&gt;remote_port = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remote_port);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can issue the <a href="../postmaster/postmaster.c.html#L231" title="postmaster/postmaster.c:231">Log_connections</a> message, if wanted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L231" title="postmaster/postmaster.c:231">Log_connections</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (remote_port[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;connection received: host=</span><span class="Special">%s</span><span class="Constant"> port=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_host,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_port)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;connection received: host=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; remote_host)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we did a reverse lookup to name, we might as well save the results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than possibly repeating the lookup during authentication.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we don't want to specify NI_NAMEREQD above, because then we'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * get nothing useful for a client without an rDNS entry.&nbsp; Therefore, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must check whether we got a <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> IPv4 or IPv6 address, and not save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it into remote_hostname if so.&nbsp; (This test is conservative and might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sometimes classify a hostname as <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>, but an error in that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * direction is safe; it only results in a possible extra lookup.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L230" title="postmaster/postmaster.c:230">log_hostname</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ret == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strspn(remote_host, <span class="Constant">&quot;0123456789.&quot;</span>) &lt; strlen(remote_host) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; strspn(remote_host, <span class="Constant">&quot;0123456789ABCDEFabcdef:&quot;</span>) &lt; strlen(remote_host))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_hostname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(remote_host);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ready to begin client interaction.&nbsp; We will give up and _exit(1) after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a time delay, so that a broken client can't hog a connection<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indefinitely.&nbsp; <a href="../postmaster/postmaster.c.html#L227" title="postmaster/postmaster.c:227">PreAuthDelay</a> and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> DNS interactions above don't count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * against the time limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: <a href="../postmaster/postmaster.c.html#L228" title="postmaster/postmaster.c:228">AuthenticationTimeout</a> is applied here while <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * startup packet, and then again in <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> for the duration of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication operations.&nbsp; So a hostile client could tie up the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process for nearly twice <a href="../postmaster/postmaster.c.html#L228" title="postmaster/postmaster.c:228">AuthenticationTimeout</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we kick him off.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: because <a href="postgres.c.html#L4152" title="tcop/postgres.c:4152">PostgresMain</a> will call <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a> again, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * registration of STARTUP_PACKET_TIMEOUT will be lost.&nbsp; This is okay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since we never use it again after this function.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L505" title="utils/misc/timeout.c:505">RegisterTimeout</a>(STARTUP_PACKET_TIMEOUT, <a href="#L886" title="tcop/backend_startup.c:886">StartupPacketTimeoutHandler</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(STARTUP_PACKET_TIMEOUT, <a href="../postmaster/postmaster.c.html#L228" title="postmaster/postmaster.c:228">AuthenticationTimeout</a> * <span class="Constant">1000</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle direct SSL handshake */<br/></li>
<li></span>&nbsp; &nbsp; status = <a href="#L362" title="tcop/backend_startup.c:362">ProcessSSLStartup</a>(port);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Receive the startup packet (which might turn out to be a cancel request<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * packet).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; status = <a href="#L453" title="tcop/backend_startup.c:453">ProcessStartupPacket</a>(port, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're going to reject the connection due to database state, say so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> instead of wasting cycles on an authentication exchange. (This also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows a pg_ping utility to be written.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status == STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cac)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CAC_STARTUP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CANNOT_CONNECT_NOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the database system is starting up&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CAC_NOTCONSISTENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xlog.c.html#L121" title="access/transam/xlog.c:121">EnableHotStandby</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CANNOT_CONNECT_NOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the database system is not yet accepting connections&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Consistent recovery state has not been yet reached.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CANNOT_CONNECT_NOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the database system is not accepting connections&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Hot standby mode is disabled.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CAC_SHUTDOWN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CANNOT_CONNECT_NOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the database system is shutting down&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CAC_RECOVERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CANNOT_CONNECT_NOW),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;the database system is in recovery mode&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CAC_TOOMANY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_CONNECTIONS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;sorry, too many clients already&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CAC_OK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Disable the timeout, and prevent SIGTERM again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(STARTUP_PACKET_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a safety check that nothing in startup has yet performed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared-memory modifications that would need to be undone if we had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exited through SIGTERM or timeout above, check that no <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handlers have been registered yet.&nbsp; (This isn't terribly bulletproof,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * since someone might misuse an <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> handler for shmem <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but it's a cheap and helpful check.&nbsp; We cannot disallow <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handlers unfortunately, since <a href="../libpq/pqcomm.c.html#L173" title="libpq/pqcomm.c:173">pq_init</a>() already registered one.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L432" title="storage/ipc/ipc.c:432">check_on_shmem_exit_lists_are_empty</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Stop here if it was bad or a cancel packet.&nbsp; <a href="#L453" title="tcop/backend_startup.c:453">ProcessStartupPacket</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already did <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> appropriate error reporting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (status != STATUS_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that we have the user and database name, we can set the process<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * title for ps.&nbsp; It's good to do this as early as possible in startup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;ps_data);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;ps_data, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> &quot;</span>, <a href="../utils/init/miscinit.c.html#L263" title="utils/init/miscinit.c:263">GetBackendTypeDesc</a>(B_WAL_SENDER));<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;ps_data, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> &quot;</span>, port-&gt;user_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;database_name[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;ps_data, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> &quot;</span>, port-&gt;database_name);<br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;ps_data, port-&gt;remote_host);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;remote_port[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;ps_data, <span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant">)&quot;</span>, port-&gt;remote_port);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L267" title="utils/misc/ps_status.c:267">init_ps_display</a>(ps_data.data);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ps_data.data);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;initializing&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check for a direct SSL connection.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This happens <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the startup packet so we are careful not to actually<br/></li>
<li></span><span class="Comment"> * read <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> bytes from the stream if it's not a direct SSL connection.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L362">&#x200c;</a></span><span class="linkable">ProcessSSLStartup</span>(Port *port)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstbyte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!port-&gt;ssl_in_use);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; firstbyte = <a href="../libpq/pqcomm.c.html#L982" title="libpq/pqcomm.c:982">pq_peekbyte</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1164" title="libpq/pqcomm.c:1164">pq_endmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (firstbyte == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Like in <a href="#L453" title="tcop/backend_startup.c:453">ProcessStartupPacket</a>, if we get no data at all, don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clutter the log with a complaint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (firstbyte != <span class="Constant">0x16</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not an SSL handshake message */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First byte indicates standard SSL handshake message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (It can't be a Postgres startup length because in network byte order<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that would be a startup packet hundreds of megabytes long)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../postmaster/postmaster.c.html#L381" title="postmaster/postmaster.c:381">LoadedSSL</a> || port-&gt;laddr.addr.ss_family == AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* SSL not supported */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> reject;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/be-secure.c.html#L110" title="libpq/be-secure.c:110">secure_open_server</a>(port) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we assume <a href="../libpq/be-secure.c.html#L110" title="libpq/be-secure.c:110">secure_open_server</a>() sent an appropriate TLS alert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> reject;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; Assert(port-&gt;ssl_in_use);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!port-&gt;alpn_used)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received direct SSL connection request without ALPN protocol negotiation extension&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> reject;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L41" title="tcop/backend_startup.c:41">Trace_connection_negotiation</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;direct SSL connection accepted&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* SSL not supported by this build */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">goto</span> reject;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="Statement">reject</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L41" title="tcop/backend_startup.c:41">Trace_connection_negotiation</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;direct SSL connection rejected&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Read a client's startup packet and do something according to it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns STATUS_OK or STATUS_ERROR, or might call ereport(FATAL) and<br/></li>
<li></span><span class="Comment"> * not return at all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * (Note that ereport(FATAL) stuff is sent to the client, so only use it<br/></li>
<li></span><span class="Comment"> * if that's what you want.&nbsp; Return STATUS_ERROR if you don't want to<br/></li>
<li></span><span class="Comment"> * <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> anything to the client, which would typically be appropriate<br/></li>
<li></span><span class="Comment"> * if we detect a communications failure.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set ssl_done and/or gss_done when negotiation of an encrypted layer<br/></li>
<li></span><span class="Comment"> * (currently, TLS or GSSAPI) is completed. A successful negotiation of either<br/></li>
<li></span><span class="Comment"> * encryption layer sets both flags, but a rejected negotiation sets only the<br/></li>
<li></span><span class="Comment"> * flag for that layer, since the client may wish to try the other one. We<br/></li>
<li></span><span class="Comment"> * should make no assumption here about the order in which the client may make<br/></li>
<li></span><span class="Comment"> * requests.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L453">&#x200c;</a></span><span class="linkable">ProcessStartupPacket</span>(Port *port, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> ssl_done, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> gss_done)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; len;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *buf;<br/></li>
<li>&nbsp; &nbsp; ProtocolVersion proto;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Grab the first byte of the length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> separately, so that we can tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * whether we have no data at all or an incomplete packet.&nbsp; (This might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sound inefficient, but it's not really, because of buffering in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pqcomm.c.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>((<span class="Type">char</span> *) &amp;len, <span class="Constant">1</span>) == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we get no data at all, don't clutter the log with a complaint;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such cases often occur for legitimate reasons.&nbsp; An example is that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we might be here after responding to NEGOTIATE_SSL_CODE, and if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * client didn't like our response, it'll probably just drop the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connection.&nbsp; Service-monitoring software also often just opens and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * closes a connection without sending anything.&nbsp; (So do port<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scanners, which may be less benign, but it's not really our job to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notice those.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>(((<span class="Type">char</span> *) &amp;len) + <span class="Constant">1</span>, <span class="Constant">3</span>) == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Got a partial length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>, so bleat about that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ssl_done &amp;&amp; !gss_done)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incomplete startup packet&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; len = pg_ntoh32(len);<br/></li>
<li>&nbsp; &nbsp; len -= <span class="Constant">4</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (len &lt; (int32) <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ProtocolVersion) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; len &gt; MAX_STARTUP_PACKET_LENGTH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid length of startup packet&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate space to hold the startup packet, plus one extra byte that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * initialized to be zero.&nbsp; This ensures we will have null termination of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all strings inside the packet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; buf = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(len + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; buf[len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1062" title="libpq/pqcomm.c:1062">pq_getbytes</a>(buf, len) == <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incomplete startup packet&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1164" title="libpq/pqcomm.c:1164">pq_endmsgread</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The first field is either a protocol version number or a special<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * request code.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; port-&gt;proto = proto = pg_ntoh32(*((ProtocolVersion *) buf));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proto == CANCEL_REQUEST_CODE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CancelRequestPacket *canc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backendPID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; cancelAuthCode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (len != <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(CancelRequestPacket))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid length of startup packet&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; canc = (CancelRequestPacket *) buf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; backendPID = (<span class="Type">int</span>) pg_ntoh32(canc-&gt;backendPID);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cancelAuthCode = (int32) pg_ntoh32(canc-&gt;cancelAuthCode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/postmaster.c.html#L1835" title="postmaster/postmaster.c:1835">processCancelRequest</a>(backendPID, cancelAuthCode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not really an error, but we don't want to proceed further */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (proto == NEGOTIATE_SSL_CODE &amp;&amp; !ssl_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; SSLok;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No SSL when disabled or on Unix sockets.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also no SSL negotiation if we already have a direct SSL connection<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../postmaster/postmaster.c.html#L381" title="postmaster/postmaster.c:381">LoadedSSL</a> || port-&gt;laddr.addr.ss_family == AF_UNIX || port-&gt;ssl_in_use)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSLok = <span class="Constant">'N'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSLok = <span class="Constant">'S'</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Support for SSL */<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SSLok = <span class="Constant">'N'</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No support for SSL */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L41" title="tcop/backend_startup.c:41">Trace_connection_negotiation</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SSLok == <span class="Constant">'S'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SSLRequest accepted&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SSLRequest rejected&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../libpq/be-secure.c.html#L301" title="libpq/be-secure.c:301">secure_write</a>(port, &amp;SSLok, <span class="Constant">1</span>) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if interrupted, just retry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;failed to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> SSL negotiation response: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;&nbsp; &nbsp; <span class="Comment">/* close the connection */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef USE_SSL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (SSLok == <span class="Constant">'S'</span> &amp;&amp; <a href="../libpq/be-secure.c.html#L110" title="libpq/be-secure.c:110">secure_open_server</a>(port) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we should have no data already buffered.&nbsp; If we do,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it was received <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we performed the SSL handshake, so it wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * encrypted and indeed may have been injected by a man-in-the-middle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We report this case to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1126" title="libpq/pqcomm.c:1126">pq_buffer_remaining_data</a>() &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received unencrypted data after SSL request&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regular startup packet, cancel, etc packet should follow, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another SSL negotiation request, and a GSS request should only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * follow if SSL was rejected (client may negotiate in either order)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L453" title="tcop/backend_startup.c:453">ProcessStartupPacket</a>(port, <span class="Constant">true</span>, SSLok == <span class="Constant">'S'</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (proto == NEGOTIATE_GSS_CODE &amp;&amp; !gss_done)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; GSSok = <span class="Constant">'N'</span>;<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No GSSAPI encryption when on Unix <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;laddr.addr.ss_family != AF_UNIX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; GSSok = <span class="Constant">'G'</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L41" title="tcop/backend_startup.c:41">Trace_connection_negotiation</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GSSok == <span class="Constant">'G'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;GSSENCRequest accepted&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;GSSENCRequest rejected&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (<a href="../libpq/be-secure.c.html#L301" title="libpq/be-secure.c:301">secure_write</a>(port, &amp;GSSok, <span class="Constant">1</span>) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errno == <span class="Constant">EINTR</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L955" title="utils/error/elog.c:955">errcode_for_socket_access</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;failed to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> GSSAPI negotiation response: %m&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;&nbsp; &nbsp; <span class="Comment">/* close the connection */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef ENABLE_GSS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (GSSok == <span class="Constant">'G'</span> &amp;&amp; <a href="../libpq/be-secure-gssapi.c.html#L495" title="libpq/be-secure-gssapi.c:495">secure_open_gssapi</a>(port) == -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> STATUS_ERROR;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point we should have no data already buffered.&nbsp; If we do,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it was received <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we performed the GSS handshake, so it wasn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * encrypted and indeed may have been injected by a man-in-the-middle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We report this case to the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1126" title="libpq/pqcomm.c:1126">pq_buffer_remaining_data</a>() &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;received unencrypted data after GSSAPI encryption request&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;This could be either a client-software bug or evidence of an attempted man-in-the-middle attack.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * regular startup packet, cancel, etc packet should follow, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * another GSS negotiation request, and an SSL request should only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * follow if GSS was rejected (client may negotiate in either order)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L453" title="tcop/backend_startup.c:453">ProcessStartupPacket</a>(port, GSSok == <span class="Constant">'G'</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Could add additional special packet types here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set <a href="../utils/init/globals.c.html#L28" title="utils/init/globals.c:28">FrontendProtocol</a> <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so that ereport() knows what format to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we fail during startup.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L28" title="utils/init/globals.c:28">FrontendProtocol</a> = proto;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check that the major protocol version is in <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (PG_PROTOCOL_MAJOR(proto) &lt; PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_PROTOCOL_MAJOR(proto) &gt; PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported frontend protocol </span><span class="Special">%u</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">: server supports </span><span class="Special">%u</span><span class="Constant">.0 to </span><span class="Special">%u</span><span class="Constant">.</span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_PROTOCOL_MAJOR(proto), PG_PROTOCOL_MINOR(proto),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_PROTOCOL_MAJOR(PG_PROTOCOL_EARLIEST),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_PROTOCOL_MAJOR(PG_PROTOCOL_LATEST),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now fetch parameters out of startup packet and save them into the Port<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * structure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle protocol version 3 startup packet */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; offset = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ProtocolVersion);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *unrecognized_protocol_options = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Scan packet body for name/option pairs.&nbsp; We can assume <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * beginning within the packet body is null-terminated, thanks to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * zeroing extra byte above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;guc_options = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (offset &lt; len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nameptr = buf + offset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; valoffset;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *valptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (*nameptr == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* found packet terminator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valoffset = offset + strlen(nameptr) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (valoffset &gt;= len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* missing value, will complain below */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valptr = buf + valoffset;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(nameptr, <span class="Constant">&quot;database&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;database_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(valptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(nameptr, <span class="Constant">&quot;user&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(valptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(nameptr, <span class="Constant">&quot;options&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;cmdline_options = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(valptr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(nameptr, <span class="Constant">&quot;replication&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Due to backward compatibility concerns the replication<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameter is a hybrid beast which allows the value to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either boolean or the string 'database'. The latter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connects to a specific database which is e.g. required for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logical decoding while.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(valptr, <span class="Constant">&quot;database&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L118" title="replication/walsender.c:118">am_db_walsender</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!<a href="../utils/adt/bool.c.html#L30" title="utils/adt/bool.c:30">parse_bool</a>(valptr, &amp;<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid value for parameter </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">: </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;replication&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valptr),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Valid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> are: </span><span class="Special">\&quot;</span><span class="Constant">false</span><span class="Special">\&quot;</span><span class="Constant">, 0, </span><span class="Special">\&quot;</span><span class="Constant">true</span><span class="Special">\&quot;</span><span class="Constant">, 1, </span><span class="Special">\&quot;</span><span class="Constant">database</span><span class="Special">\&quot;</span><span class="Constant">.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strncmp(nameptr, <span class="Constant">&quot;_pq_.&quot;</span>, <span class="Constant">5</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Any option beginning with _pq_. is reserved for use as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * protocol-level option, but at present no such options are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unrecognized_protocol_options =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(unrecognized_protocol_options, <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(nameptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume it's a generic GUC option */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;guc_options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(port-&gt;guc_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(nameptr));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;guc_options = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(port-&gt;guc_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(valptr));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a> to port if we come across it.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is done so we can log the <a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a> in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connection authorization message.&nbsp; Note that the GUC would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be used but we haven't gone through GUC setup yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(nameptr, <span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a>&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;<a href="../utils/misc/guc_tables.c.html#L546" title="utils/misc/guc_tables.c:546">application_name</a> = pg_clean_ascii(valptr, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; offset = valoffset + strlen(valptr) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a packet terminator exactly at the end of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * given packet length, complain.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (offset != len - <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid startup packet layout: expected terminator as last byte&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the client requested a newer protocol version or if the client<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requested <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> protocol options we didn't recognize, let them know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the newest minor protocol version we do support and the names of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unrecognized options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PG_PROTOCOL_MINOR(proto) &gt; PG_PROTOCOL_MINOR(PG_PROTOCOL_LATEST) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; unrecognized_protocol_options != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L846" title="tcop/backend_startup.c:846">SendNegotiateProtocolVersion</a>(unrecognized_protocol_options);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check a user name was given. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;user_name == <span class="Constant">NULL</span> || port-&gt;user_name[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;no PostgreSQL user name specified in startup packet&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The database defaults to the user name. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (port-&gt;database_name == <span class="Constant">NULL</span> || port-&gt;database_name[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;database_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(port-&gt;user_name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_WAL_SENDER;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L63" title="utils/init/miscinit.c:63">MyBackendType</a> = B_BACKEND;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Normal walsender backends, e.g. for streaming replication, are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * connected to a particular database. But walsenders used for logical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication need to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to a specific database. We allow streaming<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * replication commands to be issued even if connected to a database as it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can make sense to first make a basebackup and then stream changes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * starting from that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a> &amp;&amp; !<a href="../replication/walsender.c.html#L118" title="replication/walsender.c:118">am_db_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; port-&gt;database_name[<span class="Constant">0</span>] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done filling the Port structure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> STATUS_OK;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Send a NegotiateProtocolVersion to the client.&nbsp; This lets the client know<br/></li>
<li></span><span class="Comment"> * that they have requested a newer minor protocol version than we are able<br/></li>
<li></span><span class="Comment"> * to speak.&nbsp; We'll speak the highest version we know about; the client can,<br/></li>
<li></span><span class="Comment"> * of course, abandon the connection if that's a problem.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also include in the response a list of protocol options we didn't<br/></li>
<li></span><span class="Comment"> * understand.&nbsp; This allows clients to include optional parameters that might<br/></li>
<li></span><span class="Comment"> * be present either in newer protocol versions or third-party protocol<br/></li>
<li></span><span class="Comment"> * extensions without fear of having to reconnect if those options are not<br/></li>
<li></span><span class="Comment"> * understood, while at the same time making certain that the client is aware<br/></li>
<li></span><span class="Comment"> * of which options were actually accepted.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L846">&#x200c;</a></span><span class="linkable">SendNegotiateProtocolVersion</span>(List *unrecognized_protocol_options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_NegotiateProtocolVersion);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, PG_PROTOCOL_LATEST);<br/></li>
<li>&nbsp; &nbsp; pq_sendint32(&amp;buf, list_length(unrecognized_protocol_options));<br/></li>
<li>&nbsp; &nbsp; foreach(lc, unrecognized_protocol_options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L195" title="libpq/pqformat.c:195">pq_sendstring</a>(&amp;buf, lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no need to flush, some other message will follow */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SIGTERM while processing startup packet.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Running <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() from a signal handler would be quite unsafe.<br/></li>
<li></span><span class="Comment"> * However, since we have not yet touched shared memory, we can just<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> the plug and exit without running <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> atexit handlers.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One might be tempted to try to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a message, or log one, indicating<br/></li>
<li></span><span class="Comment"> * why we are disconnecting.&nbsp; However, that would be quite unsafe in itself.<br/></li>
<li></span><span class="Comment"> * Also, it seems undesirable to provide clues about the database's state<br/></li>
<li></span><span class="Comment"> * to a client that has not yet completed authentication, or even sent us<br/></li>
<li></span><span class="Comment"> * a startup packet.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L876">&#x200c;</a></span><span class="linkable">process_startup_packet_die</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; _exit(<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Timeout while processing startup packet.<br/></li>
<li></span><span class="Comment"> * As for <a href="#L876" title="tcop/backend_startup.c:876">process_startup_packet_die</a>(), we exit via _exit(1).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L886">&#x200c;</a></span><span class="linkable">StartupPacketTimeoutHandler</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; _exit(<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
