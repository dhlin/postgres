<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>tcop/pquery.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>tcop/pquery.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L35">ActivePortal</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L209">ChoosePortalStrategy</a></li>
<li><a href="#L67">CreateQueryDesc</a></li>
<li><a href="#L1686">DoPortalRewind</a></li>
<li><a href="#L1492">DoPortalRunFetch</a></li>
<li><a href="#L1780">EnsurePortalSnapshotExists</a></li>
<li><a href="#L326">FetchPortalTargetList</a></li>
<li><a href="#L348">FetchStatementTargetList</a></li>
<li><a href="#L1000">FillPortalStore</a></li>
<li><a href="#L105">FreeQueryDesc</a></li>
<li><a href="#L1732">PlannedStmtRequiresSnapshot</a></li>
<li><a href="#L684">PortalRun</a></li>
<li><a href="#L1391">PortalRunFetch</a></li>
<li><a href="#L1190">PortalRunMulti</a></li>
<li><a href="#L867">PortalRunSelect</a></li>
<li><a href="#L1127">PortalRunUtility</a></li>
<li><a href="#L623">PortalSetResultFormat</a></li>
<li><a href="#L433">PortalStart</a></li>
<li><a href="#L136">ProcessQuery</a></li>
<li><a href="#L1061">RunFromStore</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pquery.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES process query command code<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/tcop/pquery.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/prepare.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/tstoreReceiver.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/pquery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> is the currently executing Portal (the most closely nested,<br/></li>
<li></span><span class="Comment"> * if there are several).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L35">&#x200c;</a></span>Portal&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">ActivePortal</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L136" title="tcop/pquery.c:136">ProcessQuery</a>(PlannedStmt *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QueryCompletion *qc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1000" title="tcop/pquery.c:1000">FillPortalStore</a>(Portal portal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L1061" title="tcop/pquery.c:1061">RunFromStore</a>(Portal portal, ScanDirection direction, uint64 count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(Portal portal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward, <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a>(Portal portal, PlannedStmt *pstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setHoldSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest, QueryCompletion *qc);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1190" title="tcop/pquery.c:1190">PortalRunMulti</a>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setHoldSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest, DestReceiver *altdest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QueryCompletion *qc);<br/></li>
<li><span class="Type">static</span> uint64 <a href="#L1492" title="tcop/pquery.c:1492">DoPortalRunFetch</a>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FetchDirection fdirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1686" title="tcop/pquery.c:1686">DoPortalRewind</a>(Portal portal);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L67" title="tcop/pquery.c:67">CreateQueryDesc</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>QueryDesc *<br/></li>
<li><a id="L67">&#x200c;</a><span class="linkable">CreateQueryDesc</span>(PlannedStmt *plannedstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot crosscheck_snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> instrument_options)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *qd = (QueryDesc *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(QueryDesc));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qd-&gt;operation = plannedstmt-&gt;commandType;&nbsp; &nbsp; <span class="Comment">/* operation */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;plannedstmt = plannedstmt;&nbsp; &nbsp; <span class="Comment">/* plan */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;sourceText = sourceText;&nbsp; &nbsp; <span class="Comment">/* query text */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(snapshot);&nbsp; &nbsp; <span class="Comment">/* snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* RI check snapshot */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;crosscheck_snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(crosscheck_snapshot);<br/></li>
<li>&nbsp; &nbsp; qd-&gt;dest = dest;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* output dest */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;params = params;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> passed into query */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;queryEnv = queryEnv;<br/></li>
<li>&nbsp; &nbsp; qd-&gt;instrument_options = instrument_options;&nbsp; &nbsp; <span class="Comment">/* instrumentation wanted? */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* null these fields until set by <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a> */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;tupDesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; qd-&gt;estate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; qd-&gt;planstate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; qd-&gt;totaltime = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not yet executed */<br/></li>
<li></span>&nbsp; &nbsp; qd-&gt;already_executed = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qd;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L105" title="tcop/pquery.c:105">FreeQueryDesc</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L105">&#x200c;</a></span><span class="linkable">FreeQueryDesc</span>(QueryDesc *qdesc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't be a live query */<br/></li>
<li></span>&nbsp; &nbsp; Assert(qdesc-&gt;estate == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* forget our snapshots */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(qdesc-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(qdesc-&gt;crosscheck_snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only the QueryDesc itself need be freed */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(qdesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L136" title="tcop/pquery.c:136">ProcessQuery</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Execute a single plannable query within a PORTAL_MULTI_QUERY,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PORTAL_ONE_RETURNING, or PORTAL_ONE_MOD_WITH portal<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; plan: the plan tree for the query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; sourceText: the source text of the query<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; params: <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameters needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; dest: where to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> results<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; qc: where to store the command completion status data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * qc may be NULL if caller doesn't want a status string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must be called in a memory context that will be reset or deleted on<br/></li>
<li></span><span class="Comment"> * error; otherwise the executor's memory usage will be leaked.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L136">&#x200c;</a></span><span class="linkable">ProcessQuery</span>(PlannedStmt *plan,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the QueryDesc object<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc = <a href="#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(plan, sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>(), InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dest, params, queryEnv, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a> to prepare the plan for execution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>(queryDesc, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run the plan to completion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc, ForwardScanDirection, <span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build command completion status data, if caller wants one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (queryDesc-&gt;operation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_SELECT, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_INSERT, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_UPDATE, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_DELETE, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_MERGE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_MERGE, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetQueryCompletion(qc, CMDTAG_UNKNOWN, queryDesc-&gt;estate-&gt;es_processed);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now, we close down all the scans and free allocated resources.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L407" title="executor/execMain.c:407">ExecutorFinish</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execMain.c.html#L467" title="executor/execMain.c:467">ExecutorEnd</a>(queryDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L105" title="tcop/pquery.c:105">FreeQueryDesc</a>(queryDesc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L209" title="tcop/pquery.c:209">ChoosePortalStrategy</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Select portal execution strategy given the intended statement list.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The list elements can be Querys or PlannedStmts.<br/></li>
<li></span><span class="Comment"> * That's more general than portals need, but plancache.c uses this too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * See the comments in portal.h.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PortalStrategy<br/></li>
<li><a id="L209">&#x200c;</a><span class="linkable">ChoosePortalStrategy</span>(List *stmts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nSetTag;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PORTAL_ONE_SELECT and PORTAL_UTIL_SELECT need only consider the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single-statement case, since there are no rewrite rules that can add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * auxiliary queries to a SELECT or a utility command. PORTAL_ONE_MOD_WITH<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likewise allows only one top-level statement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(stmts) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = (Node *) linitial(stmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, Query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_ONE_MOD_WITH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_ONE_SELECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="utility.c.html#L2025" title="tcop/utility.c:2025">UtilityReturnsTuples</a>(query-&gt;utilityStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_UTIL_SELECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it can't be ONE_RETURNING, so give up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt, PlannedStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = (PlannedStmt *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_ONE_MOD_WITH;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_ONE_SELECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="utility.c.html#L2025" title="tcop/utility.c:2025">UtilityReturnsTuples</a>(pstmt-&gt;utilityStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_UTIL_SELECT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* it can't be ONE_RETURNING, so give up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) nodeTag(stmt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PORTAL_ONE_RETURNING has to allow auxiliary queries added by rewrite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Choose PORTAL_ONE_RETURNING if there is exactly one canSetTag query and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it has a RETURNING list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nSetTag = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, stmts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, Query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++nSetTag &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;&nbsp; &nbsp; <span class="Comment">/* no need to look further */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query-&gt;returningList == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;&nbsp; &nbsp; <span class="Comment">/* no need to look further */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(stmt, PlannedStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = (PlannedStmt *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (++nSetTag &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;&nbsp; &nbsp; <span class="Comment">/* no need to look further */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_UTILITY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !pstmt-&gt;hasReturning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;&nbsp; &nbsp; <span class="Comment">/* no need to look further */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) nodeTag(stmt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nSetTag == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> PORTAL_ONE_RETURNING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else, it's the general case... */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> PORTAL_MULTI_QUERY;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L326" title="tcop/pquery.c:326">FetchPortalTargetList</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a portal that returns tuples, extract the query targetlist.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns NIL if the portal doesn't have a determinable targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: do not modify the result.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L326">&#x200c;</a><span class="linkable">FetchPortalTargetList</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no point in looking if we determined it doesn't return tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;strategy == PORTAL_MULTI_QUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* get the primary statement and <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out what it returns */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L348" title="tcop/pquery.c:348">FetchStatementTargetList</a>((Node *) <a href="../utils/mmgr/portalmem.c.html#L151" title="utils/mmgr/portalmem.c:151">PortalGetPrimaryStmt</a>(portal));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L348" title="tcop/pquery.c:348">FetchStatementTargetList</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a statement that returns tuples, extract the query targetlist.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns NIL if the statement doesn't have a determinable targetlist.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be applied to a Query or a PlannedStmt.<br/></li>
<li></span><span class="Comment"> * That's more general than portals need, but plancache.c uses this too.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: do not modify the result.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> be careful to keep this in sync with <a href="utility.c.html#L2025" title="tcop/utility.c:2025">UtilityReturnsTuples</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L348">&#x200c;</a><span class="linkable">FetchStatementTargetList</span>(Node *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, Query))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = (Query *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transfer attention to utility statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = query-&gt;utilityStmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> query-&gt;targetList;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> query-&gt;returningList;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, PlannedStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = (PlannedStmt *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transfer attention to utility statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = pstmt-&gt;utilityStmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pstmt-&gt;planTree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;hasReturning)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> pstmt-&gt;planTree-&gt;targetlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, FetchStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FetchStmt&nbsp; *fstmt = (FetchStmt *) stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; subportal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!fstmt-&gt;ismove);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; subportal = <a href="../utils/mmgr/portalmem.c.html#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(fstmt-&gt;portalname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(PortalIsValid(subportal));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L326" title="tcop/pquery.c:326">FetchPortalTargetList</a>(subportal);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, ExecuteStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExecuteStmt *estmt = (ExecuteStmt *) stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *entry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; entry = <a href="../commands/prepare.c.html#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(estmt-&gt;name, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../commands/prepare.c.html#L486" title="commands/prepare.c:486">FetchPreparedStatementTargetList</a>(entry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L433" title="tcop/pquery.c:433">PortalStart</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Prepare a portal for execution.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must already have created the portal, done <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>(),<br/></li>
<li></span><span class="Comment"> * and adjusted portal options if needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If parameters are needed by the query, they must be passed in &quot;params&quot;<br/></li>
<li></span><span class="Comment"> * (caller is responsible for giving them appropriate lifetime).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller can also provide an initial set of &quot;eflags&quot; to be passed to<br/></li>
<li></span><span class="Comment"> * <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a> (but note these can be modified internally, and they are<br/></li>
<li></span><span class="Comment"> * currently only honored for PORTAL_ONE_SELECT portals).&nbsp; Most callers<br/></li>
<li></span><span class="Comment"> * should simply pass zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller can optionally pass a snapshot to be used; pass InvalidSnapshot<br/></li>
<li></span><span class="Comment"> * for the normal behavior of setting a new snapshot.&nbsp; This parameter is<br/></li>
<li></span><span class="Comment"> * presently ignored for non-PORTAL_ONE_SELECT portals (it's only intended<br/></li>
<li></span><span class="Comment"> * to be used for cursors).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On return, portal is ready to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> <a href="#L684" title="tcop/pquery.c:684">PortalRun</a>() calls, and the result<br/></li>
<li></span><span class="Comment"> * tupdesc (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is known.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L433">&#x200c;</a></span><span class="linkable">PortalStart</span>(Portal portal, ParamListInfo params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> eflags, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; MemoryContext savePortalContext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myeflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PortalIsValid(portal));<br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;status == PORTAL_DEFINED);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up global portal context pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; saveActivePortal = <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a>;<br/></li>
<li>&nbsp; &nbsp; saveResourceOwner = <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; savePortalContext = <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>;<br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = portal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = portal-&gt;resowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = portal-&gt;portalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must remember portal param list, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalParams = params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Determine the portal execution strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;strategy = <a href="#L209" title="tcop/pquery.c:209">ChoosePortalStrategy</a>(portal-&gt;stmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fire her up according to the strategy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (portal-&gt;strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_SELECT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must set snapshot <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> starting executor. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could remember the snapshot in portal-&gt;portalSnapshot,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but presently there seems no need to, as this code path<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot be used for non-atomic execution.&nbsp; Hence there can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> commit/abort that might destroy the snapshot.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we don't do that, there's also no need to force a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-default nesting level for the snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create QueryDesc in portal's context; for the moment, set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the destination to DestNone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryDesc = <a href="#L67" title="tcop/pquery.c:67">CreateQueryDesc</a>(linitial_node(PlannedStmt, portal-&gt;stmts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a scrollable cursor, executor needs to support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * REWIND and backwards scan, as well as whatever the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might've asked for.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;cursorOptions &amp; CURSOR_OPT_SCROLL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myeflags = eflags | EXEC_FLAG_REWIND | EXEC_FLAG_BACKWARD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myeflags = eflags;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Call <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a> to prepare the plan for execution<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>(queryDesc, myeflags);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This tells <a href="../commands/portalcmds.c.html#L263" title="commands/portalcmds.c:263">PortalCleanup</a> to shut down the executor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;queryDesc = queryDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remember tuple descriptor (computed by <a href="../executor/execMain.c.html#L124" title="executor/execMain.c:124">ExecutorStart</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;tupDesc = queryDesc-&gt;tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset cursor position data to &quot;start of query&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* allow fetches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_MOD_WITH:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't start the executor until we are told to run the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * portal.&nbsp; We do need to set up the result tupdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstmt = <a href="../utils/mmgr/portalmem.c.html#L151" title="utils/mmgr/portalmem.c:151">PortalGetPrimaryStmt</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;tupDesc =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execTuples.c.html#L2037" title="executor/execTuples.c:2037">ExecCleanTypeFromTL</a>(pstmt-&gt;planTree-&gt;targetlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset cursor position data to &quot;start of query&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* allow fetches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_UTIL_SELECT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't set snapshot here, because <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * take care of it if needed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = <a href="../utils/mmgr/portalmem.c.html#L151" title="utils/mmgr/portalmem.c:151">PortalGetPrimaryStmt</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(pstmt-&gt;commandType == CMD_UTILITY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;tupDesc = <a href="utility.c.html#L2081" title="tcop/utility.c:2081">UtilityTupleDescriptor</a>(pstmt-&gt;utilityStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset cursor position data to &quot;start of query&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* allow fetches */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_MULTI_QUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need do nothing <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;tupDesc = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Uncaught error while executing portal: mark it dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore global <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and propagate error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = savePortalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = savePortalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal-&gt;status = PORTAL_READY;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L623" title="tcop/pquery.c:623">PortalSetResultFormat</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Select the format codes for a portal's output.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This must be run after <a href="#L433" title="tcop/pquery.c:433">PortalStart</a> for a portal that will be read by<br/></li>
<li></span><span class="Comment"> * a DestRemote or DestRemoteExecute destination.&nbsp; It is not presently needed<br/></li>
<li></span><span class="Comment"> * for other destination types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * formats[] is the client format request, as per Bind message conventions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L623">&#x200c;</a></span><span class="linkable">PortalSetResultFormat</span>(Portal portal, <span class="Type">int</span> nFormats, int16 *formats)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do nothing if portal won't return tuples */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;tupDesc == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; natts = portal-&gt;tupDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;formats = (int16 *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(portal-&gt;portalContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nFormats &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* format specified for each column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nFormats != natts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> message has </span><span class="Special">%d</span><span class="Constant"> result formats but query has </span><span class="Special">%d</span><span class="Constant"> columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nFormats, natts)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; memcpy(portal-&gt;formats, formats, natts * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int16));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (nFormats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* single format specified, use for all columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; format1 = formats[<span class="Constant">0</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;formats[i] = format1;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* use default format for all columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;formats[i] = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L684" title="tcop/pquery.c:684">PortalRun</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Run a portal's query or queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * count &lt;= 0 is interpreted as a no-op: the destination gets started up<br/></li>
<li></span><span class="Comment"> * and shut down, but nothing else happens.&nbsp; Also, count == FETCH_ALL is<br/></li>
<li></span><span class="Comment"> * interpreted as &quot;all rows&quot;.&nbsp; Note that count is ignored in multi-query<br/></li>
<li></span><span class="Comment"> * situations, where we always run the portal to completion.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isTopLevel: true if query is being executed at backend &quot;top level&quot;<br/></li>
<li></span><span class="Comment"> * (that is, directly from a client command message)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dest: where to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> output of primary (canSetTag) query<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * altdest: where to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> output of non-primary queries<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * qc: where to store command completion status data.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; May be NULL if caller doesn't want status data.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if the portal's execution is complete, false if it was<br/></li>
<li></span><span class="Comment"> * suspended due to exhaustion of the count parameter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">PortalRun</span>(Portal portal, <span class="Type">long</span> count, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> run_once,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest, DestReceiver *altdest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; nprocessed;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner saveTopTransactionResourceOwner;<br/></li>
<li>&nbsp; &nbsp; MemoryContext saveTopTransactionContext;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; MemoryContext savePortalContext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext saveMemoryContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PortalIsValid(portal));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_EXECUTE_START();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize empty completion data */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="cmdtag.c.html#L40" title="tcop/cmdtag.c:40">InitializeQueryCompletion</a>(qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a> &amp;&amp; portal-&gt;strategy != PORTAL_MULTI_QUERY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(DEBUG3, <span class="Constant">&quot;<a href="#L684" title="tcop/pquery.c:684">PortalRun</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PORTAL_MULTI_QUERY logs its own stats per query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for improper portal use, and mark portal active.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L395" title="utils/mmgr/portalmem.c:395">MarkPortalActive</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set run_once flag.&nbsp; Shouldn't be clear if previously set. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!portal-&gt;run_once || run_once);<br/></li>
<li>&nbsp; &nbsp; portal-&gt;run_once = run_once;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up global portal context pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to play a special game here to support utility commands like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VACUUM and CLUSTER, which internally start and commit transactions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When we are called to execute such a command, <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be pointing to the <a href="../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a> --- which will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * destroyed and replaced in the course of the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> commit and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restart.&nbsp; So we need to be prepared to restore it as pointing to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exit-time <a href="../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>.&nbsp; (Ain't that ugly?&nbsp; This idea of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * internally starting whole new transactions is not good.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a> has a similar problem, but the other pointers we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * save here will be NULL or pointing to longer-lived objects.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; saveTopTransactionResourceOwner = <a href="../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; saveTopTransactionContext = <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>;<br/></li>
<li>&nbsp; &nbsp; saveActivePortal = <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a>;<br/></li>
<li>&nbsp; &nbsp; saveResourceOwner = <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; savePortalContext = <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>;<br/></li>
<li>&nbsp; &nbsp; saveMemoryContext = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = portal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = portal-&gt;resowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = portal-&gt;portalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (portal-&gt;strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_MOD_WITH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_UTIL_SELECT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have not yet run the command, do so, storing its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results in the portal's tuplestore.&nbsp; But we don't do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for the PORTAL_ONE_SELECT case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;strategy != PORTAL_ONE_SELECT &amp;&amp; !portal-&gt;holdStore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1000" title="tcop/pquery.c:1000">FillPortalStore</a>(portal, isTopLevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now fetch desired portion of results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocessed = <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, count, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the portal result contains a command tag and the caller<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * gave us a pointer to store it, copy it and update the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rowcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (qc &amp;&amp; portal-&gt;qc.commandTag != CMDTAG_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CopyQueryCompletion(qc, &amp;portal-&gt;qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qc-&gt;nprocessed = nprocessed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark portal not active */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;status = PORTAL_READY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since it's a forward fetch, say DONE iff atEnd is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = portal-&gt;atEnd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_MULTI_QUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1190" title="tcop/pquery.c:1190">PortalRunMulti</a>(portal, isTopLevel, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dest, altdest, qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent portal's commands from being re-executed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L414" title="utils/mmgr/portalmem.c:414">MarkPortalDone</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Always complete at end of RunMulti */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized portal strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) portal-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Uncaught error while executing portal: mark it dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore global <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and propagate error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saveMemoryContext == saveTopTransactionContext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(saveMemoryContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saveResourceOwner == saveTopTransactionResourceOwner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = savePortalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (saveMemoryContext == saveTopTransactionContext)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(saveMemoryContext);<br/></li>
<li>&nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (saveResourceOwner == saveTopTransactionResourceOwner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = <a href="../utils/resowner/resowner.c.html#L167" title="utils/resowner/resowner.c:167">TopTransactionResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = savePortalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a> &amp;&amp; portal-&gt;strategy != PORTAL_MULTI_QUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;EXECUTOR STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_EXECUTE_DONE();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Execute a portal's query in PORTAL_ONE_SELECT mode, and also<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; when fetching from a completed holdStore in PORTAL_ONE_RETURNING,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; PORTAL_ONE_MOD_WITH, and PORTAL_UTIL_SELECT cases.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This handles simple N-rows-forward-or-backward cases.&nbsp; For more complex<br/></li>
<li></span><span class="Comment"> * nonsequential access to a portal, see <a href="#L1391" title="tcop/pquery.c:1391">PortalRunFetch</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * count &lt;= 0 is interpreted as a no-op: the destination gets started up<br/></li>
<li></span><span class="Comment"> * and shut down, but nothing else happens.&nbsp; Also, count == FETCH_ALL is<br/></li>
<li></span><span class="Comment"> * interpreted as &quot;all rows&quot;.&nbsp; (cf FetchStmt.howMany)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must already have validated the Portal and done appropriate<br/></li>
<li></span><span class="Comment"> * setup (cf. <a href="#L684" title="tcop/pquery.c:684">PortalRun</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of rows processed (suitable for use in result tag)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L867">&#x200c;</a><span class="linkable">PortalRunSelect</span>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forward,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li>&nbsp; &nbsp; ScanDirection direction;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; nprocessed;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: queryDesc will be NULL if we are fetching from a held cursor or a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completed utility query; can't use it in that path.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc = portal-&gt;queryDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller messed up if we have neither a ready query nor held data. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(queryDesc || portal-&gt;holdStore);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Force the queryDesc destination to the right thing.&nbsp; This supports<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * MOVE, for example, which will pass in dest = DestNone.&nbsp; This is okay to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change as long as we do it on every fetch.&nbsp; (The Executor must not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assume that dest never changes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; queryDesc-&gt;dest = dest;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which direction to go in, and check to see if we're already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at the end of the available tuples in that direction.&nbsp; If so, set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * direction to NoMovement to avoid trying to fetch <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples.&nbsp; (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check exists because not all plan node types are robust about being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called again if they've already returned NULL once.)&nbsp; Then call the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * executor (we must not <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this, because the destination needs to see a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setup and shutdown even if no tuples are available).&nbsp; Finally, update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the portal position state depending on the number of tuples that were<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * retrieved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (forward)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;atEnd || count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction = NoMovementScanDirection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't pass negative count to executor */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction = ForwardScanDirection;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In the executor, zero count processes all rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == FETCH_ALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdStore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocessed = <a href="#L1061" title="tcop/pquery.c:1061">RunFromStore</a>(portal, direction, (uint64) count, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(queryDesc-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc, direction, (uint64) count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;run_once);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocessed = queryDesc-&gt;estate-&gt;es_processed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ScanDirectionIsNoMovement(direction))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nprocessed &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* OK to go backward <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span> || nprocessed &lt; (uint64) count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* we retrieved 'em all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos += nprocessed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;cursorOptions &amp; CURSOR_OPT_NO_SCROLL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cursor can only scan forward&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Declare it with SCROLL option to enable backward scan.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;atStart || count &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction = NoMovementScanDirection;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't pass negative count to executor */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; direction = BackwardScanDirection;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* In the executor, zero count processes all rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == FETCH_ALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdStore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocessed = <a href="#L1061" title="tcop/pquery.c:1061">RunFromStore</a>(portal, direction, (uint64) count, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(queryDesc-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>(queryDesc, direction, (uint64) count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;run_once);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nprocessed = queryDesc-&gt;estate-&gt;es_processed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ScanDirectionIsNoMovement(direction))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nprocessed &gt; <span class="Constant">0</span> &amp;&amp; portal-&gt;atEnd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* OK to go forward <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos++;&nbsp; &nbsp; <span class="Comment">/* adjust for endpoint case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span> || nprocessed &lt; (uint64) count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">true</span>; <span class="Comment">/* we retrieved 'em all */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos -= nprocessed;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nprocessed;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1000" title="tcop/pquery.c:1000">FillPortalStore</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Run the query and load result tuples into the portal's tuple store.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used for PORTAL_ONE_RETURNING, PORTAL_ONE_MOD_WITH, and<br/></li>
<li></span><span class="Comment"> * PORTAL_UTIL_SELECT cases only.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1000">&#x200c;</a></span><span class="linkable">FillPortalStore</span>(Portal portal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; DestReceiver *treceiver;<br/></li>
<li>&nbsp; &nbsp; QueryCompletion qc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="cmdtag.c.html#L40" title="tcop/cmdtag.c:40">InitializeQueryCompletion</a>(&amp;qc);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L331" title="utils/mmgr/portalmem.c:331">PortalCreateHoldStore</a>(portal);<br/></li>
<li>&nbsp; &nbsp; treceiver = <a href="dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(DestTuplestore);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/tstoreReceiver.c.html#L266" title="executor/tstoreReceiver.c:266">SetTuplestoreDestReceiverParams</a>(treceiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdStore,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdContext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (portal-&gt;strategy)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_MOD_WITH:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Run the portal to completion just as for the default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PORTAL_MULTI_QUERY case, but <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the primary query's output to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the tuplestore.&nbsp; Auxiliary query outputs are discarded. Set the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * portal's holdSnapshot to the snapshot used (or a copy of it).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1190" title="tcop/pquery.c:1190">PortalRunMulti</a>(portal, isTopLevel, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; treceiver, <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>, &amp;qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_UTIL_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a>(portal, linitial_node(PlannedStmt, portal-&gt;stmts),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isTopLevel, <span class="Constant">true</span>, treceiver, &amp;qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported portal strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) portal-&gt;strategy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Override portal completion data with actual command results */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qc.commandTag != CMDTAG_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CopyQueryCompletion(&amp;portal-&gt;qc, &amp;qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; treceiver-&gt;rDestroy(treceiver);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1061" title="tcop/pquery.c:1061">RunFromStore</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fetch tuples from the portal's tuple store.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Calling conventions are similar to <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a>, except that we<br/></li>
<li></span><span class="Comment"> * do not depend on having a queryDesc or estate.&nbsp; Therefore we return the<br/></li>
<li></span><span class="Comment"> * number of tuples processed as the result, not in estate-&gt;es_processed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * One difference from <a href="../executor/execMain.c.html#L297" title="executor/execMain.c:297">ExecutorRun</a> is that the destination receiver <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a><br/></li>
<li></span><span class="Comment"> * are run in the caller's memory context (since we have no estate).&nbsp; Watch<br/></li>
<li></span><span class="Comment"> * out for memory leaks.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L1061">&#x200c;</a><span class="linkable">RunFromStore</span>(Portal portal, ScanDirection direction, uint64 count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; current_tuple_count = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; slot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(portal-&gt;tupDesc, &amp;<a href="../executor/execTuples.c.html#L86" title="executor/execTuples.c:86">TTSOpsMinimalTuple</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest-&gt;rStartup(dest, CMD_SELECT, portal-&gt;tupDesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ScanDirectionIsNoMovement(direction))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do nothing except start/stop the destination */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; forward = ScanDirectionIsForward(direction);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ok;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(portal-&gt;holdContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ok = <a href="../utils/sort/tuplestore.c.html#L1078" title="utils/sort/tuplestore.c:1078">tuplestore_gettupleslot</a>(portal-&gt;holdStore, forward, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not able to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the tuple, we assume the destination<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * has closed and no more tuples can be sent. If that's the case,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * end the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!dest-&gt;receiveSlot(slot, dest))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecClearTuple(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * check our tuple count.. if we've processed the proper number<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then quit, else loop again and process more tuples. Zero count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means no limit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; current_tuple_count++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &amp;&amp; count == current_tuple_count)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; dest-&gt;rShutdown(dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> current_tuple_count;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Execute a utility statement inside a portal.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1127">&#x200c;</a></span><span class="linkable">PortalRunUtility</span>(Portal portal, PlannedStmt *pstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setHoldSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest, QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set snapshot if utility stmt needs one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L1732" title="tcop/pquery.c:1732">PlannedStmtRequiresSnapshot</a>(pstmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If told to, register the snapshot we're using and save in portal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setHoldSnapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdSnapshot = snapshot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, make the snapshot active and remember it in portal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Because the portal <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> references the snapshot, we must tell<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapmgr.c that the snapshot belongs to the portal's transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * level, else we risk portalSnapshot becoming a dangling pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L662" title="utils/time/snapmgr.c:662">PushActiveSnapshotWithLevel</a>(snapshot, portal-&gt;createLevel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../utils/time/snapmgr.c.html#L662" title="utils/time/snapmgr.c:662">PushActiveSnapshotWithLevel</a> might have copied the snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalSnapshot = <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="utility.c.html#L499" title="tcop/utility.c:499">ProcessUtility</a>(pstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (portal-&gt;cplan != <span class="Constant">NULL</span>), <span class="Comment">/* protect tree if in plancache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isTopLevel ? PROCESS_UTILITY_TOPLEVEL : PROCESS_UTILITY_QUERY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;portalParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Some utility statements may change context on us */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(portal-&gt;portalContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Some utility commands (e.g., VACUUM) pop the <a href="../utils/time/snapmgr.c.html#L120" title="utils/time/snapmgr.c:120">ActiveSnapshot</a> stack from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * under us, so don't complain if it's <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> empty.&nbsp; Otherwise, our snapshot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should be the top one; pop it.&nbsp; Note that this could be a different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot from the one we made above; see <a href="#L1780" title="tcop/pquery.c:1780">EnsurePortalSnapshotExists</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;portalSnapshot != <span class="Constant">NULL</span> &amp;&amp; <a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(portal-&gt;portalSnapshot == <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; portal-&gt;portalSnapshot = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1190" title="tcop/pquery.c:1190">PortalRunMulti</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Execute a portal's queries in the general case (multi queries<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or non-SELECT-like queries)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1190">&#x200c;</a></span><span class="linkable">PortalRunMulti</span>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> setHoldSnapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest, DestReceiver *altdest,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; QueryCompletion *qc)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; active_snapshot_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *stmtlist_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the destination is DestRemoteExecute, change to DestNone.&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reason is that the client won't be expecting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples, and indeed has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no way to know what they are, since there is no provision for Describe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> a RowDescription message when this portal execution strategy is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in effect.&nbsp; This presently will only affect SELECT commands added to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-SELECT queries by rewrite rules: such commands will be executed,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * but the results will be discarded unless you use &quot;simple Query&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * protocol.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;mydest == DestRemoteExecute)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest = <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (altdest-&gt;mydest == DestRemoteExecute)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; altdest = <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Loop to handle the individual queries generated from a single parsetree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by analysis and rewrite.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(stmtlist_item, portal-&gt;stmts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = lfirst_node(PlannedStmt, stmtlist_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we got a cancel signal in prior command, quit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;utilityStmt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process a plannable query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_EXECUTE_START();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="postgres.c.html#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Must always have a snapshot for plannable queries.&nbsp; First time<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * through, take a new snapshot; for subsequent queries in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same portal, just update the snapshot's copy of the command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!active_snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If told to, register the snapshot and save in portal */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (setHoldSnapshot)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;holdSnapshot = snapshot;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't have the holdSnapshot also be the active one,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because <a href="../utils/time/snapmgr.c.html#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a> would complain.&nbsp; So<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * force an extra snapshot copy.&nbsp; Plain <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would have copied the transaction snapshot anyway, so this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only adds a copy step when setHoldSnapshot is true.&nbsp; (It's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * okay for the command ID of the active snapshot to diverge<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from what holdSnapshot has.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L700" title="utils/time/snapmgr.c:700">PushCopiedSnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * As for PORTAL_ONE_SELECT portals, it does not seem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * necessary to maintain portal-&gt;portalSnapshot here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; active_snapshot_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L712" title="utils/time/snapmgr.c:712">UpdateActiveSnapshotCommandId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* statement can set tag string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L136" title="tcop/pquery.c:136">ProcessQuery</a>(pstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;portalParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dest, qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stmt added by rewrite cannot set tag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L136" title="tcop/pquery.c:136">ProcessQuery</a>(pstmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;portalParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;queryEnv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; altdest, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="postgres.c.html#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;EXECUTOR STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_EXECUTE_DONE();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * process utility <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> (create, destroy, etc..)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must not set a snapshot here for utility commands (if one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed, <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a> will do it).&nbsp; If a utility command is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alone in a portal then everything's fine.&nbsp; The only case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a utility command can be part of a longer list is that rules<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are allowed to include NotifyStmt.&nbsp; NotifyStmt doesn't care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether it has a snapshot or not, so we just leave the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * snapshot alone if we have one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;canSetTag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!active_snapshot_set);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* statement can set tag string */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a>(portal, pstmt, isTopLevel, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; dest, qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(IsA(pstmt-&gt;utilityStmt, NotifyStmt));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stmt added by rewrite cannot set tag */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1127" title="tcop/pquery.c:1127">PortalRunUtility</a>(portal, pstmt, isTopLevel, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; altdest, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear subsidiary contexts to recover temporary memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(portal-&gt;portalContext == <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L539" title="utils/mmgr/mcxt.c:539">MemoryContextDeleteChildren</a>(portal-&gt;portalContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Avoid crashing if portal-&gt;stmts has been reset.&nbsp; This can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * occur if a CALL or DO utility statement executed an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * COMMIT/ROLLBACK (cf <a href="../utils/mmgr/portalmem.c.html#L310" title="utils/mmgr/portalmem.c:310">PortalReleaseCachedPlan</a>).&nbsp; The CALL or DO must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have been the only statement in the portal, so there's nothing left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for us to do; but we don't want to dereference a <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-dangling list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;stmts == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Increment command counter between queries, but not after the last<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(portal-&gt;stmts, stmtlist_item) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the snapshot if we pushed one. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (active_snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a query completion data was supplied, use it.&nbsp; Otherwise use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portal's query completion data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Exception: Clients expect INSERT/UPDATE/DELETE tags to have counts, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fake them with zeros.&nbsp; This can happen with DO INSTEAD rules if there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is no replacement query of the same type as the original.&nbsp; We <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> &quot;0<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 0&quot; here because technically there is no query of the matching tag type,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and printing a non-zero count for a different query type seems wrong,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * e.g.&nbsp; an INSERT that does an UPDATE instead should not <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> &quot;0 1&quot; if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one row was updated.&nbsp; See <a href="../rewrite/rewriteHandler.c.html#L4371" title="rewrite/rewriteHandler.c:4371">QueryRewrite</a>(), step 3, for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (qc &amp;&amp; qc-&gt;commandTag == CMDTAG_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;qc.commandTag != CMDTAG_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CopyQueryCompletion(qc, &amp;portal-&gt;qc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the caller supplied a qc, we should have set it by <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(qc-&gt;commandTag != CMDTAG_UNKNOWN);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1391" title="tcop/pquery.c:1391">PortalRunFetch</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Variant form of <a href="#L684" title="tcop/pquery.c:684">PortalRun</a> that supports SQL FETCH directions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we presently assume that no callers of this want isTopLevel = true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * count &lt;= 0 is interpreted as a no-op: the destination gets started up<br/></li>
<li></span><span class="Comment"> * and shut down, but nothing else happens.&nbsp; Also, count == FETCH_ALL is<br/></li>
<li></span><span class="Comment"> * interpreted as &quot;all rows&quot;.&nbsp; (cf FetchStmt.howMany)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of rows processed (suitable for use in result tag)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>uint64<br/></li>
<li><a id="L1391">&#x200c;</a><span class="linkable">PortalRunFetch</span>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FetchDirection fdirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; ResourceOwner saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; MemoryContext savePortalContext;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(PortalIsValid(portal));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for improper portal use, and mark portal active.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L395" title="utils/mmgr/portalmem.c:395">MarkPortalActive</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If supporting FETCH, portal can't be run-once. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!portal-&gt;run_once);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up global portal context pointers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; saveActivePortal = <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a>;<br/></li>
<li>&nbsp; &nbsp; saveResourceOwner = <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a>;<br/></li>
<li>&nbsp; &nbsp; savePortalContext = <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>;<br/></li>
<li>&nbsp; &nbsp; PG_TRY();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = portal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;resowner)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = portal-&gt;resowner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = portal-&gt;portalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldContext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (portal-&gt;strategy)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1492" title="tcop/pquery.c:1492">DoPortalRunFetch</a>(portal, fdirection, count, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_RETURNING:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_ONE_MOD_WITH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PORTAL_UTIL_SELECT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we have not yet run the command, do so, storing its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results in the portal's tuplestore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!portal-&gt;holdStore)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1000" title="tcop/pquery.c:1000">FillPortalStore</a>(portal, <span class="Constant">false</span> <span class="Comment">/* isTopLevel */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now fetch desired portion of results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1492" title="tcop/pquery.c:1492">DoPortalRunFetch</a>(portal, fdirection, count, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unsupported portal strategy&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_CATCH();<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Uncaught error while executing portal: mark it dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L442" title="utils/mmgr/portalmem.c:442">MarkPortalFailed</a>(portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore global <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and propagate error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = savePortalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PG_RE_THROW();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; PG_END_TRY();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark portal not active */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;status = PORTAL_READY;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a> = saveActivePortal;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/resowner/resowner.c.html#L165" title="utils/resowner/resowner.c:165">CurrentResourceOwner</a> = saveResourceOwner;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L158" title="utils/mmgr/mcxt.c:158">PortalContext</a> = savePortalContext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1492" title="tcop/pquery.c:1492">DoPortalRunFetch</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Guts of <a href="#L1391" title="tcop/pquery.c:1391">PortalRunFetch</a> --- the portal context is already set up<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Here, count &lt; 0 typically reverses the direction.&nbsp; Also, count == FETCH_ALL<br/></li>
<li></span><span class="Comment"> * is interpreted as &quot;all rows&quot;.&nbsp; (cf FetchStmt.howMany)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns number of rows processed (suitable for use in result tag)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> uint64<br/></li>
<li><a id="L1492">&#x200c;</a><span class="linkable">DoPortalRunFetch</span>(Portal portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FetchDirection fdirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">long</span> count,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DestReceiver *dest)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; forward;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;strategy == PORTAL_ONE_SELECT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;strategy == PORTAL_ONE_RETURNING ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;strategy == PORTAL_ONE_MOD_WITH ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; portal-&gt;strategy == PORTAL_UTIL_SELECT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we disallow backwards fetch (including re-fetch of current row)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for NO SCROLL cursors, but we interpret that very loosely: you can use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the FetchDirection options, so long as the end result is to move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forwards by at least one row.&nbsp; Currently it's sufficient to check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NO SCROLL in <a href="#L1686" title="tcop/pquery.c:1686">DoPortalRewind</a>() and in the forward == false path in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(); but someday we might prefer to account for that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * restriction explicitly here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (fdirection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FETCH_FORWARD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdirection = FETCH_BACKWARD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = -count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall out of switch to share code with FETCH_BACKWARD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FETCH_BACKWARD:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdirection = FETCH_FORWARD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = -count;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fall out of switch to share code with FETCH_FORWARD */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FETCH_ABSOLUTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Definition: Rewind to start, advance count-1 rows, return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In practice, if the goal is less than halfway back to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start, it's better to scan from where we are.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if current portalPos is outside the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of &quot;long&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do it the hard way to avoid possible overflow of the count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * argument to <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>.&nbsp; We must exclude exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * LONG_MAX, as well, lest the count look like FETCH_ALL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> case, we arrange to fetch the target row going<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((uint64) (count - <span class="Constant">1</span>) &lt;= portal-&gt;portalPos / <span class="Constant">2</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;portalPos &gt;= (uint64) <span class="Constant">LONG_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1686" title="tcop/pquery.c:1686">DoPortalRewind</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, count - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; pos = (<span class="Type">long</span>) portal-&gt;portalPos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;atEnd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos++;&nbsp; &nbsp; <span class="Comment">/* need one extra fetch if off end */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &lt;= pos)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">false</span>, pos - count + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (count &gt; pos + <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, count - pos - <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, <span class="Constant">1L</span>, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (count &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Definition: Advance to end, back up abs(count)-1 rows,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return prior row (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; We could <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a> this if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * knew in advance where the end was, but typically we won't.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Is it worth considering case where count &gt; half of size of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query?&nbsp; We could rewind once we know the size ...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, FETCH_ALL, <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &lt; -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">false</span>, -count - <span class="Constant">1</span>, <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">false</span>, <span class="Constant">1L</span>, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count == 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Rewind to start, return zero rows */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1686" title="tcop/pquery.c:1686">DoPortalRewind</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, <span class="Constant">0L</span>, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> FETCH_RELATIVE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Definition: advance count-1 rows, return <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> row (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, count - <span class="Constant">1</span>, <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">true</span>, <span class="Constant">1L</span>, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (count &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Definition: back up abs(count)-1 rows, return prior row (if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (count &lt; -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">false</span>, -count - <span class="Constant">1</span>, <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">false</span>, <span class="Constant">1L</span>, dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* count == 0 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Same as FETCH FORWARD 0, so fall out of switch */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdirection = FETCH_FORWARD;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;bogus direction&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get here with fdirection == FETCH_FORWARD or FETCH_BACKWARD, and count<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &gt;= 0.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; forward = (fdirection == FETCH_FORWARD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zero count means to re-fetch the current row, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> (per SQL)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (count == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; on_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Are we sitting on a row? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; on_row = (!portal-&gt;atStart &amp;&amp; !portal-&gt;atEnd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dest-&gt;mydest == DestNone)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* MOVE 0 returns 0/1 based on if FETCH 0 would return a row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> on_row ? <span class="Constant">1</span> : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are sitting on a row, back up one so we can re-fetch it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are not sitting on a row, we still have to start up and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * shut down the executor so that the destination is initialized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and shut down correctly; so keep going.&nbsp; To <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * count == 0 means we will retrieve no row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (on_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, <span class="Constant">false</span>, <span class="Constant">1L</span>, <a href="dest.c.html#L96" title="tcop/dest.c:96">None_Receiver</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set up to fetch one row forward */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forward = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Optimize MOVE BACKWARD ALL into a Rewind.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!forward &amp;&amp; count == FETCH_ALL &amp;&amp; dest-&gt;mydest == DestNone)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; result = portal-&gt;portalPos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result &gt; <span class="Constant">0</span> &amp;&amp; !portal-&gt;atEnd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1686" title="tcop/pquery.c:1686">DoPortalRewind</a>(portal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L867" title="tcop/pquery.c:867">PortalRunSelect</a>(portal, forward, count, dest);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1686" title="tcop/pquery.c:1686">DoPortalRewind</a> - rewind a Portal to starting point<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1686">&#x200c;</a></span><span class="linkable">DoPortalRewind</span>(Portal portal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; QueryDesc&nbsp; *queryDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No work is needed if we've not advanced nor attempted to advance the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cursor (and we don't want to throw a NO SCROLL error in this case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;atStart &amp;&amp; !portal-&gt;atEnd)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, cursor must allow scrolling */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;cursorOptions &amp; CURSOR_OPT_NO_SCROLL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cursor can only scan forward&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Declare it with SCROLL option to enable backward scan.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rewind holdStore, if we have one */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;holdStore)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(portal-&gt;holdContext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/sort/tuplestore.c.html#L1233" title="utils/sort/tuplestore.c:1233">tuplestore_rescan</a>(portal-&gt;holdStore);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Rewind executor, if active */<br/></li>
<li></span>&nbsp; &nbsp; queryDesc = portal-&gt;queryDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (queryDesc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(queryDesc-&gt;snapshot);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execMain.c.html#L533" title="executor/execMain.c:533">ExecutorRewind</a>(queryDesc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal-&gt;atStart = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;atEnd = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; portal-&gt;portalPos = <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1732" title="tcop/pquery.c:1732">PlannedStmtRequiresSnapshot</a> - what it says on the tin<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L1732">&#x200c;</a></span><span class="linkable">PlannedStmtRequiresSnapshot</span>(PlannedStmt *pstmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *utilityStmt = pstmt-&gt;utilityStmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's not a utility statement, it definitely needs a snapshot */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (utilityStmt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Most utility statements need a snapshot, and the default presumption<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about new ones should be that they do too.&nbsp; Hence, enumerate those that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * do not need one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transaction control, LOCK, and <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> must *not* set a snapshot, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they need to be executable at the start of a transaction-snapshot-mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction without freezing a snapshot.&nbsp; By extension we allow SHOW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not to set a snapshot.&nbsp; The other stmts listed are just efficiency<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hacks.&nbsp; Beware of listing anything that can modify the database --- if,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * say, it has to update an index with expressions that invoke<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user-defined <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, then it had better have a snapshot.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(utilityStmt, TransactionStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, LockStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, VariableSetStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, VariableShowStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, ConstraintsSetStmt) ||<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* efficiency hacks from here down */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, FetchStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, ListenStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, NotifyStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, UnlistenStmt) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsA(utilityStmt, CheckPointStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1780" title="tcop/pquery.c:1780">EnsurePortalSnapshotExists</a> - recreate Portal-level snapshot, if needed<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Generally, we will have an active snapshot whenever we are executing<br/></li>
<li></span><span class="Comment"> * inside a Portal, unless the Portal's query is one of the utility<br/></li>
<li></span><span class="Comment"> * statements exempted from that rule (see <a href="#L1732" title="tcop/pquery.c:1732">PlannedStmtRequiresSnapshot</a>).<br/></li>
<li></span><span class="Comment"> * However, procedures and DO blocks can commit or abort the transaction,<br/></li>
<li></span><span class="Comment"> * and thereby destroy all snapshots.&nbsp; This function can be called to<br/></li>
<li></span><span class="Comment"> * re-establish the Portal-level snapshot when <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> exists.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1780">&#x200c;</a></span><span class="linkable">EnsurePortalSnapshotExists</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Nothing to do if a snapshot is set.&nbsp; (We take it on faith that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outermost active snapshot belongs to some Portal; or if there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Portal, it's somebody else's responsibility to manage things.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Otherwise, we'd better have an active Portal */<br/></li>
<li></span>&nbsp; &nbsp; portal = <a href="#L35" title="tcop/pquery.c:35">ActivePortal</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(portal == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot execute SQL without an outer snapshot or portal&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(portal-&gt;portalSnapshot == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a new snapshot, make it active, and remember it in portal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because the portal <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> references the snapshot, we must tell snapmgr.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that the snapshot belongs to the portal's transaction level, else we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * risk portalSnapshot becoming a dangling pointer.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L662" title="utils/time/snapmgr.c:662">PushActiveSnapshotWithLevel</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>(), portal-&gt;createLevel);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/time/snapmgr.c.html#L662" title="utils/time/snapmgr.c:662">PushActiveSnapshotWithLevel</a> might have copied the snapshot */<br/></li>
<li></span>&nbsp; &nbsp; portal-&gt;portalSnapshot = <a href="../utils/time/snapmgr.c.html#L770" title="utils/time/snapmgr.c:770">GetActiveSnapshot</a>();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
