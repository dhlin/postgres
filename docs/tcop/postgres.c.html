<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>tcop/postgres.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>tcop/postgres.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L144">DoingCommandRead</a></li>
<li><a href="#L162">EchoQuery</a></li>
<li><a href="#L93">Log_disconnections</a></li>
<li><a href="#L101">PostAuthDelay</a></li>
<li><a href="#L166">RecoveryConflictPending</a></li>
<li><a href="#L167">RecoveryConflictPendingReasons</a></li>
<li><a href="#L4989">Save_r</a></li>
<li><a href="#L4990">Save_t</a></li>
<li><a href="#L163">UseSemiNewlineNewline</a></li>
<li><a href="#L104">client_connection_check_interval</a></li>
<li><a href="#L87">debug_query_string</a></li>
<li><a href="#L150">doing_extended_query_message</a></li>
<li><a href="#L151">ignore_till_sync</a></li>
<li><a href="#L95">log_statement</a></li>
<li><a href="#L98">max_stack_depth</a></li>
<li><a href="#L125">max_stack_depth_bytes</a></li>
<li><a href="#L204">old_valgrind_error_count</a></li>
<li><a href="#L171">row_description_buf</a></li>
<li><a href="#L170">row_description_context</a></li>
<li><a href="#L131">stack_base_ptr</a></li>
<li><a href="#L158">unnamed_stmt_psrc</a></li>
<li><a href="#L161">userDoption</a></li>
<li><a href="#L90">whereToSendOutput</a></li>
<li><a href="#L137">xact_started</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L112">BindParamCbData</a></li>
<li><a href="#L117">BindParamCbData</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L3019">FloatExceptionHandler</a></li>
<li><a href="#L3035">HandleRecoveryConflictInterrupt</a></li>
<li><a href="#L244">InteractiveBackend</a></li>
<li><a href="#L2803">IsTransactionExitStmt</a></li>
<li><a href="#L2820">IsTransactionExitStmtList</a></li>
<li><a href="#L2835">IsTransactionStmtList</a></li>
<li><a href="#L4152">PostgresMain</a></li>
<li><a href="#L4042">PostgresSingleUserMain</a></li>
<li><a href="#L509">ProcessClientReadInterrupt</a></li>
<li><a href="#L555">ProcessClientWriteInterrupt</a></li>
<li><a href="#L3244">ProcessInterrupts</a></li>
<li><a href="#L3047">ProcessRecoveryConflictInterrupt</a></li>
<li><a href="#L3205">ProcessRecoveryConflictInterrupts</a></li>
<li><a href="#L488">ReadCommand</a></li>
<li><a href="#L4993">ResetUsage</a></li>
<li><a href="#L5000">ShowUsage</a></li>
<li><a href="#L360">SocketBackend</a></li>
<li><a href="#L3002">StatementCancelHandler</a></li>
<li><a href="#L3595">assign_max_stack_depth</a></li>
<li><a href="#L3656">assign_transaction_timeout</a></li>
<li><a href="#L2548">bind_param_error_callback</a></li>
<li><a href="#L3606">check_client_connection_check_interval</a></li>
<li><a href="#L2379">check_log_duration</a></li>
<li><a href="#L2340">check_log_statement</a></li>
<li><a href="#L3641">check_log_stats</a></li>
<li><a href="#L3578">check_max_stack_depth</a></li>
<li><a href="#L3531">check_stack_depth</a></li>
<li><a href="#L3627">check_stage_log_stats</a></li>
<li><a href="#L2972">die</a></li>
<li><a href="#L5167">disable_statement_timeout</a></li>
<li><a href="#L2850">drop_unnamed_stmt</a></li>
<li><a href="#L5145">enable_statement_timeout</a></li>
<li><a href="#L2495">errdetail_abort</a></li>
<li><a href="#L2442">errdetail_execute</a></li>
<li><a href="#L2475">errdetail_params</a></li>
<li><a href="#L2509">errdetail_recovery_conflict</a></li>
<li><a href="#L1626">exec_bind_message</a></li>
<li><a href="#L2691">exec_describe_portal_message</a></li>
<li><a href="#L2597">exec_describe_statement_message</a></li>
<li><a href="#L2085">exec_execute_message</a></li>
<li><a href="#L1391">exec_parse_message</a></li>
<li><a href="#L1013">exec_simple_query</a></li>
<li><a href="#L2771">finish_xact_command</a></li>
<li><a href="#L4939">forbidden_in_wal_sender</a></li>
<li><a href="#L4961">get_stack_depth_rlimit</a></li>
<li><a href="#L3750">get_stats_option_name</a></li>
<li><a href="#L332">interactive_getc</a></li>
<li><a href="#L5109">log_disconnections</a></li>
<li><a href="#L671">pg_analyze_and_rewrite_fixedparams</a></li>
<li><a href="#L710">pg_analyze_and_rewrite_varparams</a></li>
<li><a href="#L764">pg_analyze_and_rewrite_withcb</a></li>
<li><a href="#L611">pg_parse_query</a></li>
<li><a href="#L972">pg_plan_queries</a></li>
<li><a href="#L886">pg_plan_query</a></li>
<li><a href="#L804">pg_rewrite_query</a></li>
<li><a href="#L3790">process_postgres_switches</a></li>
<li><a href="#L2875">quickdie</a></li>
<li><a href="#L3514">restore_stack_base</a></li>
<li><a href="#L3679">set_debug_options</a></li>
<li><a href="#L3708">set_plan_disabling_options</a></li>
<li><a href="#L3481">set_stack_base</a></li>
<li><a href="#L3545">stack_is_too_deep</a></li>
<li><a href="#L2743">start_xact_command</a></li>
<li><a href="#L212">valgrind_report_error_query</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L224">valgrind_report_error_query</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * postgres.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; POSTGRES C <a href="../postmaster/postmaster.c.html#L177" title="postmaster/postmaster.c:177">Backend</a> Interface<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/tcop/postgres.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; this is the &quot;<a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>&quot; module of the postgres backend and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; hence the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> module of the &quot;traffic cop&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/resource.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/<a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;valgrind/valgrind.h&gt;<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/parallel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/<a href="../access/common/printtup.c.html#L303" title="access/common/printtup.c:303">printtup</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/async.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L367" title="utils/adt/pseudotypes.c:367">event_trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/prepare.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;common/pg_prng.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;jit/jit.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/libpq.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqformat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;libpq/pqsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/stringinfo_mb.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/<a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_getopt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pg_trace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/autovacuum.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/interrupt.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postmaster/postmaster.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicallauncher.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/logicalworker.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/slot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;replication/walsender.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteHandler.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/ipc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/pmsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/procsignal.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/sinval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/fastpath.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/pquery.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/tcopprot.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;tcop/utility.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc_hooks.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/injection_point.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ps_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timeout.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/timestamp.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; global variables<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L87">&#x200c;</a></span><span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">debug_query_string</span>; <span class="Comment">/* client-supplied query string */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Note: <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> is initialized for the bootstrap/standalone case */<br/></li>
<li><a id="L90">&#x200c;</a></span>CommandDest <span class="linkable">whereToSendOutput</span> = DestDebug;<br/></li>
<li><br/></li>
<li><span class="Comment">/* flag for logging end of session */<br/></li>
<li><a id="L93">&#x200c;</a></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">Log_disconnections</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><a id="L95">&#x200c;</a><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">log_statement</span> = LOGSTMT_NONE;<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC variable for maximum stack depth (measured in kilobytes) */<br/></li>
<li><a id="L98">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">max_stack_depth</span> = <span class="Constant">100</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* wait N seconds to allow attach from a debugger */<br/></li>
<li><a id="L101">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">PostAuthDelay</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* Time between checks that the client is still connected. */<br/></li>
<li><a id="L104">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">client_connection_check_interval</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; private typedefs etc<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* type of argument for <a href="#L2548" title="tcop/postgres.c:2548">bind_param_error_callback</a> */<br/></li>
<li><a id="L112">&#x200c;</a></span><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">BindParamCbData</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *portalName;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramno;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* zero-based param number, or -1 initially */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *paramval;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* textual input string, if available */<br/></li>
<li><a id="L117">&#x200c;</a></span>} <span class="linkable">BindParamCbData</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; private variables<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="#L98" title="tcop/postgres.c:98">max_stack_depth</a> converted to bytes for speed of checking */<br/></li>
<li><a id="L125">&#x200c;</a></span><span class="Type">static</span> <span class="Type">long</span> <span class="linkable">max_stack_depth_bytes</span> = <span class="Constant">100</span> * <span class="Constant">1024L</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Stack base pointer -- initialized by <a href="../postmaster/postmaster.c.html#L489" title="postmaster/postmaster.c:489">PostmasterMain</a> and inherited by<br/></li>
<li></span><span class="Comment"> * subprocesses (but see also <a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L131">&#x200c;</a></span><span class="Type">static</span> <span class="Type">char</span> *<span class="linkable">stack_base_ptr</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag to keep track of whether we have started a transaction.<br/></li>
<li></span><span class="Comment"> * For extended query protocol this has to be remembered across messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L137">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">xact_started</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flag to indicate that we are doing the outer loop's read-from-client,<br/></li>
<li></span><span class="Comment"> * as opposed to <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> random read from client that might happen within<br/></li>
<li></span><span class="Comment"> * commands like COPY FROM STDIN.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L144">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">DoingCommandRead</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Flags to implement <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>-till-Sync-after-error behavior for messages of<br/></li>
<li></span><span class="Comment"> * the extended query protocol.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L150">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">doing_extended_query_message</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L151">&#x200c;</a><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">ignore_till_sync</span> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If an unnamed prepared statement exists, it's stored here.<br/></li>
<li></span><span class="Comment"> * We keep it separate from the hashtable kept by commands/prepare.c<br/></li>
<li></span><span class="Comment"> * in order to reduce overhead for short-lived queries.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L158">&#x200c;</a></span><span class="Type">static</span> CachedPlanSource *<span class="linkable">unnamed_stmt_psrc</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* assorted command-line switches */<br/></li>
<li><a id="L161">&#x200c;</a></span><span class="Type">static</span> <span class="Type">const</span> <span class="Type">char</span> *<span class="linkable">userDoption</span> = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* -D switch */<br/></li>
<li><a id="L162">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">EchoQuery</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* -E switch */<br/></li>
<li><a id="L163">&#x200c;</a></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <span class="linkable">UseSemiNewlineNewline</span> = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* -j switch */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* whether or not, and why, we were canceled by conflict with recovery */<br/></li>
<li><a id="L166">&#x200c;</a></span><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">RecoveryConflictPending</span> = <span class="Constant">false</span>;<br/></li>
<li><a id="L167">&#x200c;</a><span class="Type">static</span> <span class="Type">volatile</span> <span class="Type">sig_atomic_t</span> <span class="linkable">RecoveryConflictPendingReasons</span>[NUM_PROCSIGNALS];<br/></li>
<li><br/></li>
<li><span class="Comment">/* reused buffer to pass to <a href="../access/common/printtup.c.html#L165" title="access/common/printtup.c:165">SendRowDescriptionMessage</a>() */<br/></li>
<li><a id="L170">&#x200c;</a></span><span class="Type">static</span> MemoryContext <span class="linkable">row_description_context</span> = <span class="Constant">NULL</span>;<br/></li>
<li><a id="L171">&#x200c;</a><span class="Type">static</span> StringInfoData <span class="linkable">row_description_buf</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; decls for routines only used in this file<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L244" title="tcop/postgres.c:244">InteractiveBackend</a>(StringInfo inBuf);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L332" title="tcop/postgres.c:332">interactive_getc</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L360" title="tcop/postgres.c:360">SocketBackend</a>(StringInfo inBuf);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L488" title="tcop/postgres.c:488">ReadCommand</a>(StringInfo inBuf);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(<span class="Type">char</span> firstchar);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2340" title="tcop/postgres.c:2340">check_log_statement</a>(List *stmt_list);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2442" title="tcop/postgres.c:2442">errdetail_execute</a>(List *raw_parsetree_list);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2475" title="tcop/postgres.c:2475">errdetail_params</a>(ParamListInfo params);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2548" title="tcop/postgres.c:2548">bind_param_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2803" title="tcop/postgres.c:2803">IsTransactionExitStmt</a>(Node *parsetree);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2820" title="tcop/postgres.c:2820">IsTransactionExitStmtList</a>(List *pstmts);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L2835" title="tcop/postgres.c:2835">IsTransactionStmtList</a>(List *pstmts);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2850" title="tcop/postgres.c:2850">drop_unnamed_stmt</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5109" title="tcop/postgres.c:5109">log_disconnections</a>(<span class="Type">int</span> code, Datum arg);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5145" title="tcop/postgres.c:5145">enable_statement_timeout</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L5167" title="tcop/postgres.c:5167">disable_statement_timeout</a>(<span class="Type">void</span>);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; infrastructure for valgrind debugging<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span><span class="Comment">/* This variable should be set at the top of the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop. */<br/></li>
<li><a id="L204">&#x200c;</a></span><span class="Type">static</span> <span class="Type">unsigned</span> <span class="Type">int</span> <span class="linkable">old_valgrind_error_count</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * If Valgrind detected <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors since <a href="#L204" title="tcop/postgres.c:204">old_valgrind_error_count</a> was updated,<br/></li>
<li></span><span class="Comment"> * report the current query as the cause.&nbsp; This should be called at the end<br/></li>
<li></span><span class="Comment"> * of message processing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L212">&#x200c;</a></span><span class="linkable">valgrind_report_error_query</span>(<span class="Type">const</span> <span class="Type">char</span> *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">unsigned</span> <span class="Type">int</span> valgrind_error_count = VALGRIND_COUNT_ERRORS;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (unlikely(valgrind_error_count != <a href="#L204" title="tcop/postgres.c:204">old_valgrind_error_count</a>) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; VALGRIND_PRINTF(<span class="Constant">&quot;Valgrind detected </span><span class="Special">%u</span><span class="Constant"> error(s) during execution of </span><span class="Special">\&quot;%s\&quot;\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valgrind_error_count - <a href="#L204" title="tcop/postgres.c:204">old_valgrind_error_count</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !USE_VALGRIND */<br/></li>
<li><a id="L224">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">valgrind_report_error_query</span>(query) ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_VALGRIND */<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; routines to obtain user input<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L244" title="tcop/postgres.c:244">InteractiveBackend</a>() is called for user interactive connections<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; the string entered by the user is placed in its parameter inBuf,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; and we act like a Q message was received.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; EOF is returned if end-of-file input is seen; time to shut down.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L244">&#x200c;</a></span><span class="linkable">InteractiveBackend</span>(StringInfo inBuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* character read from getc() */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * display a prompt and obtain input from the user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; printf(<span class="Constant">&quot;backend&gt; &quot;</span>);<br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resetStringInfo(inBuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Read characters until EOF or the appropriate delimiter is seen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((c = <a href="#L332" title="tcop/postgres.c:332">interactive_getc</a>()) != <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (c == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L163" title="tcop/postgres.c:163">UseSemiNewlineNewline</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In -j mode, semicolon followed by two newlines ends the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command; otherwise treat <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> as regular character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inBuf-&gt;len &gt; <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inBuf-&gt;data[inBuf-&gt;len - <span class="Constant">1</span>] == <span class="Special">'\n'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inBuf-&gt;data[inBuf-&gt;len - <span class="Constant">2</span>] == <span class="Constant">';'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* might as well drop the second <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In plain mode, <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> ends the command unless preceded by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backslash.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inBuf-&gt;len &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inBuf-&gt;data[inBuf-&gt;len - <span class="Constant">1</span>] == <span class="Special">'\\'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* discard backslash from inBuf */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inBuf-&gt;data[--inBuf-&gt;len] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* discard <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep the <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> character, but end the command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(inBuf, <span class="Special">'\n'</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>, or <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> treated as regular character */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfoChar(inBuf, (<span class="Type">char</span>) c);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No input <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> EOF signal means time to quit. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (c == <span class="Constant">EOF</span> &amp;&amp; inBuf-&gt;len == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise we have a user query so process it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add '\0' to make it look the same as message case. */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfoChar(inBuf, (<span class="Type">char</span>) <span class="Special">'\0'</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the query echo flag was given, <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the query..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L162" title="tcop/postgres.c:162">EchoQuery</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;statement: </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, inBuf-&gt;data);<br/></li>
<li>&nbsp; &nbsp; fflush(<span class="Constant">stdout</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">'Q'</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L332" title="tcop/postgres.c:332">interactive_getc</a> -- collect one character from stdin<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Even though we are not reading from a &quot;client&quot; process, we still want to<br/></li>
<li></span><span class="Comment"> * respond to signals, particularly SIGTERM/SIGQUIT.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L332">&#x200c;</a></span><span class="linkable">interactive_getc</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This will not process catchup interrupts or notifications while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reading. But those can't really be relevant for a standalone backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway. To properly handle SIGTERM there's a hack in <a href="#L2972" title="tcop/postgres.c:2972">die</a>() that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * directly processes interrupts at this stage...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; c = getc(<span class="Constant">stdin</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L509" title="tcop/postgres.c:509">ProcessClientReadInterrupt</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> c;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L360" title="tcop/postgres.c:360">SocketBackend</a>()&nbsp; &nbsp; &nbsp; &nbsp; Is called for frontend-backend connections<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Returns the message type code, and loads message body data into inBuf.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; EOF is returned if the connection is lost.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L360">&#x200c;</a></span><span class="linkable">SocketBackend</span>(StringInfo inBuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qtype;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get message type code from the frontend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_CANCEL_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqcomm.c.html#L1140" title="libpq/pqcomm.c:1140">pq_startmsgread</a>();<br/></li>
<li>&nbsp; &nbsp; qtype = <a href="../libpq/pqcomm.c.html#L963" title="libpq/pqcomm.c:963">pq_getbyte</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qtype == <span class="Constant">EOF</span>)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* frontend disconnected */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(COMMERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unexpected EOF on client connection with an open transaction&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Can't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> DEBUG log messages to client at this point. Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're disconnecting right away, we don't need to restore<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_DOES_NOT_EXIST),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;unexpected EOF on client connection&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> qtype;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validate message type code <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying to read body; if we have lost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sync, better to say &quot;command unknown&quot; than to run out of memory because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we used garbage as a length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a>.&nbsp; We can also <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a type-dependent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * limit on what a sane length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> could be.&nbsp; (The limit could be chosen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more granularly, but it's not clear it's worth fussing over.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This also gives us a place to set the <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> flag<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as soon as possible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (qtype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Query:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_LARGE_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_FunctionCall:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_LARGE_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Terminate:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_SMALL_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="tcop/postgres.c:151">ignore_till_sync</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Bind:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Parse:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_LARGE_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Close:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Describe:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Execute:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Flush:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_SMALL_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Sync:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_SMALL_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* stop <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>-till-Sync */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="tcop/postgres.c:151">ignore_till_sync</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mark not-extended, so that a new error doesn't begin <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyData:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_LARGE_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyDone:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyFail:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = PQ_SMALL_MESSAGE_LIMIT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise we got garbage from the frontend.&nbsp; We treat this as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * fatal because we have probably lost message boundary sync, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no good way to recover.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid frontend message type </span><span class="Special">%d</span><span class="Constant">&quot;</span>, qtype)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxmsglen = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In protocol version 3, all frontend messages have a length <a href="../regex/regcomp.c.html#L1474" title="regex/regcomp.c:1474">word</a> <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * after the type code; we can read the message contents independently of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1202" title="libpq/pqcomm.c:1202">pq_getmessage</a>(inBuf, maxmsglen))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">EOF</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* suitable message already logged */<br/></li>
<li></span>&nbsp; &nbsp; RESUME_CANCEL_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qtype;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L488" title="tcop/postgres.c:488">ReadCommand</a> reads a command from either the frontend or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; standard input, places it in inBuf, and returns the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; message type code (first byte of the message).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; EOF is returned if end of file.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L488">&#x200c;</a></span><span class="linkable">ReadCommand</span>(StringInfo inBuf)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L360" title="tcop/postgres.c:360">SocketBackend</a>(inBuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L244" title="tcop/postgres.c:244">InteractiveBackend</a>(inBuf);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L509" title="tcop/postgres.c:509">ProcessClientReadInterrupt</a>() - Process interrupts specific to client reads<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after low-level reads.<br/></li>
<li></span><span class="Comment"> * 'blocked' is true if no data was available to read and we plan to retry,<br/></li>
<li></span><span class="Comment"> * false if about to read or done reading.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must preserve errno!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L509">&#x200c;</a></span><span class="linkable">ProcessClientReadInterrupt</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> blocked)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for general interrupts that arrived <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a>/while reading */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process sinval catchup interrupts, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/ipc/sinval.c.html#L39" title="storage/ipc/sinval.c:39">catchupInterruptPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/sinval.c.html#L174" title="storage/ipc/sinval.c:174">ProcessCatchupInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process notify interrupts, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../commands/async.c.html#L413" title="commands/async.c:413">notifyInterruptPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/async.c.html#L1834" title="commands/async.c:1834">ProcessNotifyInterrupt</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're dying.&nbsp; If there is no data available to read, then it's safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (and sane) to handle that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; If we haven't tried to read yet,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure the process latch is set, so that if there is no data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we'll come back here and <a href="#L2972" title="tcop/postgres.c:2972">die</a>.&nbsp; If we're done reading, also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure the process latch is set, as we might've undesirably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleared it while reading.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L555" title="tcop/postgres.c:555">ProcessClientWriteInterrupt</a>() - Process interrupts specific to client writes<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after low-level writes.<br/></li>
<li></span><span class="Comment"> * 'blocked' is true if no data could be written and we plan to retry,<br/></li>
<li></span><span class="Comment"> * false if about to write or done writing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Must preserve errno!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L555">&#x200c;</a></span><span class="linkable">ProcessClientWriteInterrupt</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> blocked)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_errno = errno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We're dying.&nbsp; If it's not possible to write, then we should handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that immediately, else a stuck client could indefinitely delay our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * response to the signal.&nbsp; If we haven't tried to write yet, make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sure the process latch is set, so that if the write would block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * then we'll come back here and <a href="#L2972" title="tcop/postgres.c:2972">die</a>.&nbsp; If we're done writing, also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * make sure the process latch is set, as we might've undesirably<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleared it while writing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (blocked)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Don't mess with <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> if <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a> wouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * service <a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> == <span class="Constant">0</span> &amp;&amp; <a href="../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't want to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the client the error message, as a)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that would possibly block again, and b) it would likely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lead to loss of protocol sync because we may have already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sent a partial protocol message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; errno = save_errno;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do raw parsing (only).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A list of parsetrees (RawStmt nodes) is returned, since there might be<br/></li>
<li></span><span class="Comment"> * multiple commands in the given string.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: for interactive queries, it is important to keep this routine<br/></li>
<li></span><span class="Comment"> * separate from the analysis &amp; rewrite stages.&nbsp; Analysis and rewriting<br/></li>
<li></span><span class="Comment"> * cannot be done in an aborted transaction, since they require access to<br/></li>
<li></span><span class="Comment"> * database tables.&nbsp; So, we rely on the raw parser to determine whether<br/></li>
<li></span><span class="Comment"> * we've seen a COMMIT or ABORT command; when we are in abort state, other<br/></li>
<li></span><span class="Comment"> * commands are not processed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further than the raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> stage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L611">&#x200c;</a><span class="linkable">pg_parse_query</span>(<span class="Type">const</span> <span class="Type">char</span> *query_string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *raw_parsetree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_PARSE_START(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; raw_parsetree_list = <a href="../parser/parser.c.html#L42" title="parser/parser.c:42">raw_parser</a>(query_string, RAW_PARSE_DEFAULT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;PARSER STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef COPY_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Optional debugging check: pass raw parsetrees through copyObject() */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a> = copyObject(raw_parsetree_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This checks both copyObject() and the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() routines... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>, raw_parsetree_list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;copyObject() failed to produce an <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raw_parsetree_list = <a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Optional debugging check: pass raw parsetrees through<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * outfuncs/readfuncs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = <a href="../nodes/outfuncs.c.html#L797" title="nodes/outfuncs.c:797">nodeToStringWithLocations</a>(raw_parsetree_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a> = <a href="../nodes/read.c.html#L98" title="nodes/read.c:98">stringToNodeWithLocations</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This checks both outfuncs/readfuncs and the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() routines... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>, raw_parsetree_list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;outfuncs/readfuncs failed to produce an <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; raw_parsetree_list = <a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_PARSE_DONE(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> raw_parsetree_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a raw parsetree (gram.y output), and optionally information about<br/></li>
<li></span><span class="Comment"> * types of parameter symbols ($n), perform <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rule rewriting.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A list of Query nodes is returned, since either the analyzer or the<br/></li>
<li></span><span class="Comment"> * rewriter might expand one query to several.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: for reasons mentioned above, this must be separate from raw parsing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L671">&#x200c;</a><span class="linkable">pg_analyze_and_rewrite_fixedparams</span>(RawStmt *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *paramTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (1) Perform <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="../parser/analyze.c.html#L104" title="parser/analyze.c:104">parse_analyze_fixedparams</a>(parsetree, query_string, paramTypes, numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;PARSE ANALYSIS STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (2) Rewrite the queries, as necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; querytree_list = <a href="#L804" title="tcop/postgres.c:804">pg_rewrite_query</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> querytree_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rewriting.&nbsp; This is the same as<br/></li>
<li></span><span class="Comment"> * <a href="#L671" title="tcop/postgres.c:671">pg_analyze_and_rewrite_fixedparams</a> except that it's okay to deduce<br/></li>
<li></span><span class="Comment"> * information about $n symbol datatypes from context.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L710">&#x200c;</a><span class="linkable">pg_analyze_and_rewrite_varparams</span>(RawStmt *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid **paramTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> *numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (1) Perform <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="../parser/analyze.c.html#L144" title="parser/analyze.c:144">parse_analyze_varparams</a>(parsetree, query_string, paramTypes, numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check all parameter types got determined.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; *numParams; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = (*paramTypes)[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ptype == InvalidOid || ptype == UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INDETERMINATE_DATATYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not determine data type of parameter $</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;PARSE ANALYSIS STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (2) Rewrite the queries, as necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; querytree_list = <a href="#L804" title="tcop/postgres.c:804">pg_rewrite_query</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> querytree_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and rewriting.&nbsp; This is the same as<br/></li>
<li></span><span class="Comment"> * <a href="#L671" title="tcop/postgres.c:671">pg_analyze_and_rewrite_fixedparams</a> except that, instead of a fixed list of<br/></li>
<li></span><span class="Comment"> * parameter datatypes, a parser callback is supplied that can do<br/></li>
<li></span><span class="Comment"> * external-parameter resolution and possibly other things.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L764">&#x200c;</a><span class="linkable">pg_analyze_and_rewrite_withcb</span>(RawStmt *parsetree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParserSetupHook parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">void</span> *parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_REWRITE_START(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (1) Perform <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="../parser/analyze.c.html#L185" title="parser/analyze.c:185">parse_analyze_withcb</a>(parsetree, query_string, parserSetup, parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; queryEnv);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;PARSE ANALYSIS STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (2) Rewrite the queries, as necessary<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; querytree_list = <a href="#L804" title="tcop/postgres.c:804">pg_rewrite_query</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_REWRITE_DONE(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> querytree_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform rewriting of a query produced by <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: query must just have come from the parser, because we do not do<br/></li>
<li></span><span class="Comment"> * <a href="../rewrite/rewriteHandler.c.html#L140" title="rewrite/rewriteHandler.c:140">AcquireRewriteLocks</a>() on it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L804">&#x200c;</a><span class="linkable">pg_rewrite_query</span>(Query *query)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L501" title="utils/misc/guc_tables.c:501">Debug_print_parse</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/print.c.html#L72" title="nodes/print.c:72">elog_node_display</a>(LOG, <span class="Constant">&quot;<a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree&quot;</span>, query,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L503" title="utils/misc/guc_tables.c:503">Debug_pretty_print</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't rewrite utilities, just <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> 'em into result list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querytree_list = list_make1(query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rewrite regular queries */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../rewrite/rewriteHandler.c.html#L4371" title="rewrite/rewriteHandler.c:4371">QueryRewrite</a>(query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;REWRITER STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef COPY_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Optional debugging check: pass querytree through copyObject() */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a> = copyObject(querytree_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This checks both copyObject() and the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() routines... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>, querytree_list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;copyObject() failed to produce an <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> rewritten <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Optional debugging check: pass querytree through outfuncs/readfuncs */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a> = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, querytree_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *curr_query = lfirst_node(Query, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str = <a href="../nodes/outfuncs.c.html#L797" title="nodes/outfuncs.c:797">nodeToStringWithLocations</a>(curr_query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *new_query = <a href="../nodes/read.c.html#L98" title="nodes/read.c:98">stringToNodeWithLocations</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * queryId is not saved in stored rules, but we must preserve it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here to avoid breaking pg_stat_statements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new_query-&gt;queryId = curr_query-&gt;queryId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a> = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>, new_query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This checks both outfuncs/readfuncs and the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() routines... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(<a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>, querytree_list))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;outfuncs/readfuncs failed to produce an <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> rewritten <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="../nodes/list.c.html#L91" title="nodes/list.c:91">new_list</a>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L502" title="utils/misc/guc_tables.c:502">Debug_print_rewritten</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/print.c.html#L72" title="nodes/print.c:72">elog_node_display</a>(LOG, <span class="Constant">&quot;rewritten <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree&quot;</span>, querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L503" title="utils/misc/guc_tables.c:503">Debug_pretty_print</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> querytree_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a plan for a single already-rewritten query.<br/></li>
<li></span><span class="Comment"> * This is a thin wrapper around <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>() and takes the same parameters.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PlannedStmt *<br/></li>
<li><a id="L886">&#x200c;</a><span class="linkable">pg_plan_query</span>(Query *querytree, <span class="Type">const</span> <span class="Type">char</span> *query_string, <span class="Type">int</span> cursorOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamListInfo boundParams)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PlannedStmt *plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Utility commands have no plans. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (querytree-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Planner must have a snapshot in case it calls user-defined <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_PLAN_START();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L506" title="utils/misc/guc_tables.c:506">log_planner_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* call the optimizer */<br/></li>
<li></span>&nbsp; &nbsp; plan = <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>(querytree, query_string, cursorOptions, boundParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L506" title="utils/misc/guc_tables.c:506">log_planner_stats</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;PLANNER STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef COPY_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Optional debugging check: pass plan tree through copyObject() */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *new_plan = copyObject(plan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() currently does not have routines to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> Plan nodes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't try to test equality here.&nbsp; Perhaps fix someday?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This checks both copyObject() and the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() routines... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(new_plan, plan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;copyObject() failed to produce an <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> plan tree&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = new_plan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef WRITE_READ_PARSE_PLAN_TREES<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Optional debugging check: pass plan tree through outfuncs/readfuncs */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *new_plan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../nodes/outfuncs.c.html#L797" title="nodes/outfuncs.c:797">nodeToStringWithLocations</a>(plan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; new_plan = <a href="../nodes/read.c.html#L98" title="nodes/read.c:98">stringToNodeWithLocations</a>(str);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() currently does not have routines to <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> Plan nodes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't try to test equality here.&nbsp; Perhaps fix someday?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef NOT_USED<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* This checks both outfuncs/readfuncs and the <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>() routines... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(new_plan, plan))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(WARNING, <span class="Constant">&quot;outfuncs/readfuncs failed to produce an <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> plan tree&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plan = new_plan;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Print plan if debugging.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L500" title="utils/misc/guc_tables.c:500">Debug_print_plan</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/print.c.html#L72" title="nodes/print.c:72">elog_node_display</a>(LOG, <span class="Constant">&quot;plan&quot;</span>, plan, <a href="../utils/misc/guc_tables.c.html#L503" title="utils/misc/guc_tables.c:503">Debug_pretty_print</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_PLAN_DONE();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> plan;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate plans for a list of already-rewritten queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For normal optimizable statements, invoke the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.&nbsp; For utility<br/></li>
<li></span><span class="Comment"> * statements, just make a wrapper PlannedStmt node.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a list of PlannedStmt nodes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L972">&#x200c;</a><span class="linkable">pg_plan_queries</span>(List *querytrees, <span class="Type">const</span> <span class="Type">char</span> *query_string, <span class="Type">int</span> cursorOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParamListInfo boundParams)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stmt_list = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *query_list;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(query_list, querytrees)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query = lfirst_node(Query, query_list);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;commandType == CMD_UTILITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Utility commands require no planning. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = makeNode(PlannedStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;canSetTag = query-&gt;canSetTag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;utilityStmt = query-&gt;utilityStmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;stmt_location = query-&gt;stmt_location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;stmt_len = query-&gt;stmt_len;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;queryId = query-&gt;queryId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = <a href="#L886" title="tcop/postgres.c:886">pg_plan_query</a>(query, query_string, cursorOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; boundParams);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt_list = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stmt_list, stmt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stmt_list;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1013" title="tcop/postgres.c:1013">exec_simple_query</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Execute a &quot;simple Query&quot; protocol message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1013">&#x200c;</a></span><span class="linkable">exec_simple_query</span>(<span class="Type">const</span> <span class="Type">char</span> *query_string)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandDest dest = <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *parsetree_list;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *parsetree_item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_log_statement_stats = <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; was_logged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_implicit_block;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msec_str[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report query to various monitoring facilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = query_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_START(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We use save_log_statement_stats so <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a> doesn't report incorrect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * results because <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a> wasn't called.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start up a transaction command.&nbsp; All queries generated by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query_string will be in this same command block, *unless* we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * BEGIN/COMMIT/ABORT statement; we have to force a new xact command after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one of those, else bad things will happen in xact.c. (Note that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will normally change current memory context.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Zap <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing unnamed statement.&nbsp; (While not strictly necessary,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it seems best to define simple-Query mode as if it used the unnamed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statement and portal; this ensures we recover <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> storage used by prior<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unnamed operations.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2850" title="tcop/postgres.c:2850">drop_unnamed_stmt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to appropriate context for constructing parsetrees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do basic parsing of the query or queries (this should be safe even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are in aborted transaction state!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parsetree_list = <a href="#L611" title="tcop/postgres.c:611">pg_parse_query</a>(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Log immediately if dictated by <a href="#L95" title="tcop/postgres.c:95">log_statement</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2340" title="tcop/postgres.c:2340">check_log_statement</a>(parsetree_list))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;statement: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, query_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2442" title="tcop/postgres.c:2442">errdetail_execute</a>(parsetree_list)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; was_logged = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch back to transaction context to enter the loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For historical reasons, if multiple SQL statements are given in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * single &quot;simple Query&quot; message, we execute them as a single transaction,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unless explicit transaction control commands are included to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * portions of the list be separate transactions.&nbsp; To represent this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behavior properly in the transaction machinery, we use an &quot;implicit&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; use_implicit_block = (list_length(parsetree_list) &gt; <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run through the raw parsetree(s) and process each one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(parsetree_item, parsetree_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RawStmt&nbsp; &nbsp; *parsetree = lfirst_node(RawStmt, parsetree_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CommandTag&nbsp; &nbsp; commandTag;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; QueryCompletion qc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContext per_parsetree_context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *plantree_list;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DestReceiver *receiver;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; format;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cmdtagname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; cmdtaglen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L613" title="utils/activity/backend_status.c:613">pgstat_report_query_id</a>(<span class="Constant">0</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Get the command name for use in status display (it also becomes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * default completion tag, down inside <a href="pquery.c.html#L684" title="tcop/pquery.c:684">PortalRun</a>).&nbsp; Set ps_status and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> special start-of-SQL-command processing needed by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * destination.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; commandTag = <a href="utility.c.html#L2359" title="tcop/utility.c:2359">CreateCommandTag</a>(parsetree-&gt;stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmdtagname = <a href="cmdtag.c.html#L53" title="tcop/cmdtag.c:53">GetCommandTagNameAndLen</a>(commandTag, &amp;cmdtaglen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L451" title="utils/misc/ps_status.c:451">set_ps_display_with_len</a>(cmdtagname, cmdtaglen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L103" title="tcop/dest.c:103">BeginCommand</a>(commandTag, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in an aborted transaction, reject all commands except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * COMMIT/ABORT.&nbsp; It is important that this test occur <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, rewrite, or planning, since all those phases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * try to do database accesses, which may fail in abort state. (It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might be safe to allow some additional utility commands in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state, but not many...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2803" title="tcop/postgres.c:2803">IsTransactionExitStmt</a>(parsetree-&gt;stmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we are in a transaction command */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If using an implicit transaction block, and we're not already in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction block, start an implicit block to force this statement<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to be grouped together with <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> following ones.&nbsp; (We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each time through the loop; otherwise, a COMMIT/ROLLBACK in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list would cause later statements to not be grouped.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_implicit_block)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L4275" title="access/transam/xact.c:4275">BeginImplicitTransactionBlock</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we got a cancel signal in parsing or prior command, quit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up a snapshot if <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis/planning will need one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../parser/analyze.c.html#L485" title="parser/analyze.c:485">analyze_requires_snapshot</a>(parsetree))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OK to <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>, rewrite, and plan this query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch to appropriate context for constructing query and plan trees<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (these can't be in the transaction context, as that will get reset<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * when the command is COMMIT/ROLLBACK).&nbsp; If we have multiple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parsetrees, we use a separate context for each one, so that we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * free that memory <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> moving on to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one.&nbsp; But for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last (or only) parsetree, just use <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>, which will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset shortly after completion anyway.&nbsp; In event of an error, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * per_parsetree_context will be deleted when <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> is reset.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(parsetree_list, parsetree_item) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; per_parsetree_context =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;per-parsetree message context&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(per_parsetree_context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="#L671" title="tcop/postgres.c:671">pg_analyze_and_rewrite_fixedparams</a>(parsetree, query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; plantree_list = <a href="#L972" title="tcop/postgres.c:972">pg_plan_queries</a>(querytree_list, query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CURSOR_OPT_PARALLEL_OK, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Done with the snapshot used for parsing/planning.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While it looks promising to reuse the same snapshot for query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execution (at least for simple protocol), unfortunately it causes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * execution to use a snapshot that has been acquired <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the tables mentioned in the query.&nbsp; This creates user-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * visible anomalies, so refrain.&nbsp; Refer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * https://postgr.es/m/flat/5075D8DF.6050500@fuzzy.cz for details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we got a cancel signal in analysis or planning, quit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create unnamed portal to run the query or queries in. If there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already is one, silently drop it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L175" title="utils/mmgr/portalmem.c:175">CreatePortal</a>(<span class="Constant">&quot;&quot;</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't display the portal in pg_cursors */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;visible = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We don't have to copy anything into the portal, because everything<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we are passing here is in <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> or the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * per_parsetree_context, and so will outlive the portal anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commandTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plantree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Start the portal.&nbsp; No parameters here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pquery.c.html#L433" title="tcop/pquery.c:433">PortalStart</a>(portal, <span class="Constant">NULL</span>, <span class="Constant">0</span>, InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select the appropriate output format: text unless we are doing a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FETCH from a binary cursor.&nbsp; (Pretty grotty to have to do this here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * --- but it avoids grottiness in other places.&nbsp; Ah, the joys of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backward compatibility...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; format = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* TEXT is default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(parsetree-&gt;stmt, FetchStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FetchStmt&nbsp; *stmt = (FetchStmt *) parsetree-&gt;stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!stmt-&gt;ismove)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; fportal = <a href="../utils/mmgr/portalmem.c.html#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(stmt-&gt;portalname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PortalIsValid(fportal) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (fportal-&gt;cursorOptions &amp; CURSOR_OPT_BINARY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; format = <span class="Constant">1</span>; <span class="Comment">/* BINARY */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pquery.c.html#L623" title="tcop/pquery.c:623">PortalSetResultFormat</a>(portal, <span class="Constant">1</span>, &amp;format);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we can create the destination receiver object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; receiver = <a href="dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dest == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/printtup.c.html#L99" title="access/common/printtup.c:99">SetRemoteDestReceiverParams</a>(receiver, portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Switch back to transaction context for execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Run the portal to completion, and then drop it (and the receiver).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="pquery.c.html#L684" title="tcop/pquery.c:684">PortalRun</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FETCH_ALL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* always top level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; receiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; receiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; receiver-&gt;rDestroy(receiver);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lnext(parsetree_list, parsetree_item) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the last parsetree of the query string, close down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction statement <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> reporting command-complete.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> end-of-transaction errors are reported <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the command-complete message is issued, to avoid confusing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * clients who will expect either a command-complete message or an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error, not one and then the other.&nbsp; Also, if we're using an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * implicit transaction block, we must close that out first.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (use_implicit_block)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L4300" title="access/transam/xact.c:4300">EndImplicitTransactionBlock</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(parsetree-&gt;stmt, TransactionStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this was a transaction control statement, commit it. We will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * start a new xact command for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We had better not see XACT_FLAGS_NEEDIMMEDIATECOMMIT set if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we're not calling <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>().&nbsp; (The implicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction block should have prevented it from getting set.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(<a href="../access/transam/xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> &amp; XACT_FLAGS_NEEDIMMEDIATECOMMIT));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> after every query, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those that start or end a transaction block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable statement timeout between queries of a multi-query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * string, so that the timeout applies separately to each query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (Our <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> loop iteration will start a fresh timeout.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5167" title="tcop/postgres.c:5167">disable_statement_timeout</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Tell client that we're done with this query.&nbsp; Note we emit exactly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one <a href="dest.c.html#L169" title="tcop/dest.c:169">EndCommand</a> report for each raw parsetree, thus one for each SQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * command the client sent, regardless of rewriting. (But a command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aborted by error will not <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> an <a href="dest.c.html#L169" title="tcop/dest.c:169">EndCommand</a> report at all.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L169" title="tcop/dest.c:169">EndCommand</a>(&amp;qc, dest, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we may drop the per-parsetree context, if one was created. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (per_parsetree_context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(per_parsetree_context);<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end loop over parsetrees */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close down transaction statement, if one is open.&nbsp; (This will only do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * something if the parsetree list was empty; otherwise the last loop<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * iteration already did it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there were no parsetrees, return EmptyQueryResponse message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!parsetree_list)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L218" title="tcop/dest.c:218">NullCommand</a>(dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit duration logging if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2379" title="tcop/postgres.c:2379">check_log_duration</a>(msec_str, was_logged))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&quot;</span>, msec_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&nbsp; statement: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msec_str, query_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2442" title="tcop/postgres.c:2442">errdetail_execute</a>(parsetree_list)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;QUERY STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; TRACE_POSTGRESQL_QUERY_DONE(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1391" title="tcop/postgres.c:1391">exec_parse_message</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Execute a &quot;Parse&quot; protocol message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1391">&#x200c;</a></span><span class="linkable">exec_parse_message</span>(<span class="Type">const</span> <span class="Type">char</span> *query_string,&nbsp; &nbsp; <span class="Comment">/* string to execute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *stmt_name,&nbsp; &nbsp; <span class="Comment">/* name for prepared stmt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *paramTypes, <span class="Comment">/* parameter types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> numParams)&nbsp; &nbsp; <span class="Comment">/* number of parameters */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; MemoryContext unnamed_stmt_context = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *parsetree_list;<br/></li>
<li>&nbsp; &nbsp; RawStmt&nbsp; &nbsp; *raw_parse_tree;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *querytree_list;<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *psrc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_named;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_log_statement_stats = <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msec_str[<span class="Constant">32</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report query to various monitoring facilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = query_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;PARSE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;<a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *stmt_name ? stmt_name : <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; query_string)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start up a transaction command so we can run <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis etc. (Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that this will normally change current memory context.) Nothing happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if we are already in one.&nbsp; This also arms the statement timeout if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to appropriate context for constructing parsetrees.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have two strategies depending on whether the prepared statement is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * named or not.&nbsp; For a named prepared statement, we do parsing in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> and copy the finished trees into the prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statement's plancache entry; then the reset of <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> releases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * temporary space used by parsing and rewriting. For an unnamed prepared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statement, we assume the statement isn't going to hang around long, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * getting rid of temp space quickly is probably not worth the costs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copying <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> trees.&nbsp; So in this case, we create the plancache entry's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * query_context here, and do all the parsing work therein.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; is_named = (stmt_name[<span class="Constant">0</span>] != <span class="Special">'\0'</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_named)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Named prepared statement --- <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> in <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Unnamed prepared statement --- release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> prior unnamed stmt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2850" title="tcop/postgres.c:2850">drop_unnamed_stmt</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create context for parsing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; unnamed_stmt_context =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;unnamed prepared statement&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(unnamed_stmt_context);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Do basic parsing of the query or queries (this should be safe even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are in aborted transaction state!)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; parsetree_list = <a href="#L611" title="tcop/postgres.c:611">pg_parse_query</a>(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We only allow a single user statement in a prepared statement. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mainly to keep the protocol simple --- otherwise we'd need to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about multiple result tupdescs and things like that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(parsetree_list) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot insert multiple commands into a prepared statement&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree_list != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; raw_parse_tree = linitial_node(RawStmt, parsetree_list);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in an aborted transaction, reject all commands except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * COMMIT/ROLLBACK.&nbsp; It is important that this test occur <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * try to do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, rewrite, or planning, since all those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * phases try to do database accesses, which may fail in abort state.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (It might be safe to allow some additional utility commands in this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state, but not many...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2803" title="tcop/postgres.c:2803">IsTransactionExitStmt</a>(raw_parse_tree-&gt;stmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create the CachedPlanSource <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis, since it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needs to see the unmodified raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; psrc = <a href="../utils/cache/plancache.c.html#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a>(raw_parse_tree, query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="utility.c.html#L2359" title="tcop/utility.c:2359">CreateCommandTag</a>(raw_parse_tree-&gt;stmt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up a snapshot if <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis will need one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../parser/analyze.c.html#L485" title="parser/analyze.c:485">analyze_requires_snapshot</a>(raw_parse_tree))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Analyze and rewrite the query.&nbsp; Note that the originally specified<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parameter set is not required to be complete, so we have to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L710" title="tcop/postgres.c:710">pg_analyze_and_rewrite_varparams</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; querytree_list = <a href="#L710" title="tcop/postgres.c:710">pg_analyze_and_rewrite_varparams</a>(raw_parse_tree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;paramTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Done with the snapshot used for parsing */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Empty input string.&nbsp; This is legal. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; raw_parse_tree = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; psrc = <a href="../utils/cache/plancache.c.html#L192" title="utils/cache/plancache.c:192">CreateCachedPlan</a>(raw_parse_tree, query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CMDTAG_UNKNOWN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; querytree_list = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CachedPlanSource must be a direct child of <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reparent unnamed_stmt_context under it, else we have a disconnected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * circular subgraph.&nbsp; Klugy, but less so than flipping contexts even more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (unnamed_stmt_context)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L637" title="utils/mmgr/mcxt.c:637">MemoryContextSetParent</a>(psrc-&gt;context, <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finish filling in the CachedPlanSource */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L366" title="utils/cache/plancache.c:366">CompleteCachedPlan</a>(psrc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; querytree_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; unnamed_stmt_context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paramTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CURSOR_OPT_PARALLEL_OK,&nbsp; &nbsp; <span class="Comment">/* allow parallel mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);&nbsp; &nbsp; <span class="Comment">/* fixed result */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we got a cancel signal during analysis, quit */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (is_named)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Store the query as a prepared statement.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/prepare.c.html#L389" title="commands/prepare.c:389">StorePreparedStatement</a>(stmt_name, psrc, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We just save the CachedPlanSource into <a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L482" title="utils/cache/plancache.c:482">SaveCachedPlan</a>(psrc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a> = psrc;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do NOT close the open transaction command here; that only happens<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * when the client sends Sync.&nbsp; Instead, do <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in case something happened during <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>/plan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send ParseComplete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L388" title="libpq/pqformat.c:388">pq_putemptymessage</a>(PqMsg_ParseComplete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit duration logging if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2379" title="tcop/postgres.c:2379">check_log_duration</a>(msec_str, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&quot;</span>, msec_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&nbsp; <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> </span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msec_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *stmt_name ? stmt_name : <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;PARSE MESSAGE STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1626" title="tcop/postgres.c:1626">exec_bind_message</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process a &quot;Bind&quot; message to create a portal from a prepared statement<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1626">&#x200c;</a></span><span class="linkable">exec_bind_message</span>(StringInfo input_message)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *portal_name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stmt_name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPFormats;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *pformats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numParams;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numRFormats;<br/></li>
<li>&nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp;&nbsp; *rformats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *psrc;<br/></li>
<li>&nbsp; &nbsp; CachedPlan *cplan;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *query_string;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *saved_stmt_name;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo params;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldContext;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_log_statement_stats = <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msec_str[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; ParamsErrorCbData params_data;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback params_errcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the fixed part of the message */<br/></li>
<li></span>&nbsp; &nbsp; portal_name = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(input_message);<br/></li>
<li>&nbsp; &nbsp; stmt_name = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;<a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *portal_name ? portal_name : <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *stmt_name ? stmt_name : <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find prepared statement */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt_name[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *pstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstmt = <a href="../commands/prepare.c.html#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(stmt_name, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; psrc = pstmt-&gt;plansource;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special-case the unnamed statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; psrc = <a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!psrc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_PSTATEMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unnamed prepared statement does not exist&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report query to various monitoring facilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = psrc-&gt;query_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, psrc-&gt;query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;BIND&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start up a transaction command so we can call <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> etc. (Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this will normally change current memory context.) Nothing happens if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we are already in one.&nbsp; This also arms the statement timeout if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch back to message context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the parameter format codes */<br/></li>
<li></span>&nbsp; &nbsp; numPFormats = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(input_message, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numPFormats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pformats = palloc_array(int16, numPFormats);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numPFormats; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pformats[i] = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(input_message, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the parameter value count */<br/></li>
<li></span>&nbsp; &nbsp; numParams = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(input_message, <span class="Constant">2</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numPFormats &gt; <span class="Constant">1</span> &amp;&amp; numPFormats != numParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> message has </span><span class="Special">%d</span><span class="Constant"> parameter formats but </span><span class="Special">%d</span><span class="Constant"> parameters&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPFormats, numParams)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numParams != psrc-&gt;num_params)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> message supplies </span><span class="Special">%d</span><span class="Constant"> parameters, but prepared statement </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> requires </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numParams, stmt_name, psrc-&gt;num_params)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in aborted transaction state, the only portals we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually run are those containing COMMIT or ROLLBACK commands. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * disallow binding anything else to avoid problems with infrastructure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that expects to run inside a valid transaction.&nbsp; We also disallow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * binding <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameters, since we can't risk calling user-defined I/O<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (!(psrc-&gt;raw_parse_tree &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2803" title="tcop/postgres.c:2803">IsTransactionExitStmt</a>(psrc-&gt;raw_parse_tree-&gt;stmt)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numParams != <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the portal.&nbsp; Allow silent replacement of an existing portal only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if the unnamed portal is specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal_name[<span class="Constant">0</span>] == <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L175" title="utils/mmgr/portalmem.c:175">CreatePortal</a>(portal_name, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L175" title="utils/mmgr/portalmem.c:175">CreatePortal</a>(portal_name, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare to copy stuff into the portal's memory context.&nbsp; We do all this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * copying first, because it could possibly fail (out-of-memory) and we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want a failure to occur between <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>; that would result in leaking our plancache refcount.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldContext = MemoryContextSwitchTo(portal-&gt;portalContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy the plan's query string into the portal */<br/></li>
<li></span>&nbsp; &nbsp; query_string = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(psrc-&gt;query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Likewise make a copy of the statement name, unless it's unnamed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt_name[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; saved_stmt_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(stmt_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; saved_stmt_name = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set a snapshot if we have parameters to fetch (since the input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> might need it) or the query isn't a utility command (and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hence could require redoing <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis and planning).&nbsp; We keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * snapshot active till we're done, so that plancache.c doesn't have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * take new ones.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numParams &gt; <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (psrc-&gt;raw_parse_tree &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../parser/analyze.c.html#L485" title="parser/analyze.c:485">analyze_requires_snapshot</a>(psrc-&gt;raw_parse_tree)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L648" title="utils/time/snapmgr.c:648">PushActiveSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L216" title="utils/time/snapmgr.c:216">GetTransactionSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snapshot_set = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch parameters, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and store in the portal's memory context.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (numParams &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; **knownTextValues = <span class="Constant">NULL</span>; <span class="Comment">/* allocate on first use */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L112" title="tcop/postgres.c:112">BindParamCbData</a> one_param_data;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up an error callback so that if there's an error in this phase,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we can report the specific parameter causing the problem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; one_param_data.portalName = portal-&gt;name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; one_param_data.paramno = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; one_param_data.paramval = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params_errcxt.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params_errcxt.callback = <a href="#L2548" title="tcop/postgres.c:2548">bind_param_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params_errcxt.arg = (<span class="Type">void</span> *) &amp;one_param_data;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;params_errcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; params = <a href="../nodes/params.c.html#L44" title="nodes/params.c:44">makeParamList</a>(numParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> paramno = <span class="Constant">0</span>; paramno &lt; numParams; paramno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = psrc-&gt;param_types[paramno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; plength;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; pval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfoData pbuf;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; csave;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; pformat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one_param_data.paramno = paramno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one_param_data.paramval = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plength = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(input_message, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isNull = (plength == -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pvalue;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Rather than copying data around, we just <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * StringInfo pointing to the correct portion of the message<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * buffer.&nbsp; We assume we can scribble on the message buffer to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * add a trailing NUL which is required for the input function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pvalue = unconstify(<span class="Type">char</span> *, <a href="../libpq/pqformat.c.html#L508" title="libpq/pqformat.c:508">pq_getmsgbytes</a>(input_message, plength));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; csave = pvalue[plength];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pvalue[plength] = <span class="Special">'\0'</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; initReadOnlyStringInfo(&amp;pbuf, pvalue, plength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pbuf.data = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; csave = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numPFormats &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pformat = pformats[paramno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (numPFormats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pformat = pformats[<span class="Constant">0</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pformat = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* default = text */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pformat == <span class="Constant">0</span>)&nbsp; &nbsp; <span class="Comment">/* text mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typinput;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pstring;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2874" title="utils/cache/lsyscache.c:2874">getTypeInputInfo</a>(ptype, &amp;typinput, &amp;typioparam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to do encoding conversion <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> calling the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typinput routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstring = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstring = <a href="../utils/mb/mbutils.c.html#L660" title="utils/mb/mbutils.c:660">pg_client_to_server</a>(pbuf.data, plength);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can log the input string in case of error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one_param_data.paramval = pstring;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pval = <a href="../utils/fmgr/fmgr.c.html#L1754" title="utils/fmgr/fmgr.c:1754">OidInputFunctionCall</a>(typinput, pstring, typioparam, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; one_param_data.paramval = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we might need to log parameters later, save a copy of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the converted string in <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>; then free the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result of encoding conversion, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> was done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstring)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContext oldcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldcxt = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (knownTextValues == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; knownTextValues = palloc0_array(<span class="Type">char</span> *, numParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a> &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; knownTextValues[paramno] = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(pstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can trim the saved string, knowing that we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> all of it.&nbsp; But we must copy at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * least two more full characters than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../nodes/params.c.html#L335" title="nodes/params.c:335">BuildParamLogString</a> wants to use; otherwise it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * might fail to include the trailing ellipsis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; knownTextValues[paramno] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1706" title="utils/mmgr/mcxt.c:1706">pnstrdup</a>(pstring,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; + <span class="Constant">2</span> * MAX_MULTIBYTE_CHAR_LEN);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(oldcxt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstring != pbuf.data)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pstring);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (pformat == <span class="Constant">1</span>)&nbsp; &nbsp; <span class="Comment">/* binary mode */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typreceive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typioparam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StringInfo&nbsp; &nbsp; bufptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Call the parameter type's binary input converter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L2940" title="utils/cache/lsyscache.c:2940">getTypeBinaryInputInfo</a>(ptype, &amp;typreceive, &amp;typioparam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bufptr = &amp;pbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pval = <a href="../utils/fmgr/fmgr.c.html#L1772" title="utils/fmgr/fmgr.c:1772">OidReceiveFunctionCall</a>(typreceive, bufptr, typioparam, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Trouble if it didn't eat the whole buffer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull &amp;&amp; pbuf.cursor != pbuf.len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_BINARY_REPRESENTATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;incorrect binary data format in <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> parameter </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramno + <span class="Constant">1</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unsupported format code: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pformat)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pval = <span class="Constant">0</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore message buffer contents */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pbuf.data[plength] = csave;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;params[paramno].value = pval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;params[paramno].isnull = isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We mark the params as CONST.&nbsp; This ensures that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> custom plan<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * makes full use of the parameter <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;params[paramno].pflags = PARAM_FLAG_CONST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;params[paramno].ptype = ptype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Pop the per-parameter error callback */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>-&gt;previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Once all parameters have been received, prepare for printing them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in future errors, if configured to do so.&nbsp; (This is saved in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * portal, so that they'll appear when the query is executed later.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; params-&gt;paramValuesStr =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/params.c.html#L335" title="nodes/params.c:335">BuildParamLogString</a>(params,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; knownTextValues,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; params = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done storing stuff in portal's context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(oldContext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up another error callback so that all the parameters are logged if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we get an error during the rest of the BIND processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; params_data.portalName = portal-&gt;name;<br/></li>
<li>&nbsp; &nbsp; params_data.params = params;<br/></li>
<li>&nbsp; &nbsp; params_errcxt.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; params_errcxt.callback = <a href="../nodes/params.c.html#L407" title="nodes/params.c:407">ParamsErrorCallback</a>;<br/></li>
<li>&nbsp; &nbsp; params_errcxt.arg = (<span class="Type">void</span> *) &amp;params_data;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;params_errcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the result format codes */<br/></li>
<li></span>&nbsp; &nbsp; numRFormats = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(input_message, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numRFormats &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rformats = palloc_array(int16, numRFormats);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numRFormats; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rformats[i] = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(input_message, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain a plan from the CachedPlanSource.&nbsp; Any cruft from (re)planning<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will be generated in <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>.&nbsp; The plan refcount will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assigned to the Portal, so it will be released at portal destruction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cplan = <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a>(psrc, params, <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we can define the portal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * DO NOT put <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> code that could possibly throw an error between the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above <a href="../utils/cache/plancache.c.html#L1168" title="utils/cache/plancache.c:1168">GetCachedPlan</a> call and here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L282" title="utils/mmgr/portalmem.c:282">PortalDefineQuery</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saved_stmt_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; psrc-&gt;commandTag,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cplan-&gt;stmt_list,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cplan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with the snapshot used for parameter I/O and parsing/planning */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (snapshot_set)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * And we're ready to start portal execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pquery.c.html#L433" title="tcop/pquery.c:433">PortalStart</a>(portal, params, <span class="Constant">0</span>, InvalidSnapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Apply the result format requests to the portal.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pquery.c.html#L623" title="tcop/pquery.c:623">PortalSetResultFormat</a>(portal, numRFormats, rformats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Done binding; remove the parameters error callback.&nbsp; Entries emitted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * later determine independently whether to log the parameters or not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>-&gt;previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send BindComplete.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L388" title="libpq/pqformat.c:388">pq_putemptymessage</a>(PqMsg_BindComplete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit duration logging if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2379" title="tcop/postgres.c:2379">check_log_duration</a>(msec_str, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&quot;</span>, msec_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&nbsp; <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> </span><span class="Special">%s%s%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msec_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *stmt_name ? stmt_name : <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *portal_name ? <span class="Constant">&quot;/&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *portal_name ? portal_name : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; psrc-&gt;query_string),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2475" title="tcop/postgres.c:2475">errdetail_params</a>(params)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;BIND MESSAGE STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<a href="#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2085" title="tcop/postgres.c:2085">exec_execute_message</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process an &quot;Execute&quot; message for a portal<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2085">&#x200c;</a></span><span class="linkable">exec_execute_message</span>(<span class="Type">const</span> <span class="Type">char</span> *portal_name, <span class="Type">long</span> max_rows)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CommandDest dest;<br/></li>
<li>&nbsp; &nbsp; DestReceiver *receiver;<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; completed;<br/></li>
<li>&nbsp; &nbsp; QueryCompletion qc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *sourceText;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *prepStmtName;<br/></li>
<li>&nbsp; &nbsp; ParamListInfo portalParams;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; save_log_statement_stats = <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_xact_command;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; execute_is_fetch;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; was_logged = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; msec_str[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; ParamsErrorCbData params_data;<br/></li>
<li>&nbsp; &nbsp; ErrorContextCallback params_errcxt;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *cmdtagname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; cmdtaglen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Adjust destination to tell <a href="../access/common/printtup.c.html#L303" title="access/common/printtup.c:303">printtup</a>.c what to do */<br/></li>
<li></span>&nbsp; &nbsp; dest = <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dest = DestRemoteExecute;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(portal_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PortalIsValid(portal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_CURSOR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, portal_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the original query was a null string, just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EmptyQueryResponse.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;commandTag == CMDTAG_UNKNOWN)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(portal-&gt;stmts == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L218" title="tcop/dest.c:218">NullCommand</a>(dest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Does the portal contain a transaction command? */<br/></li>
<li></span>&nbsp; &nbsp; is_xact_command = <a href="#L2835" title="tcop/postgres.c:2835">IsTransactionStmtList</a>(portal-&gt;stmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must copy the sourceText and prepStmtName into <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case the portal is destroyed during <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>.&nbsp; We do not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make a copy of the portalParams though, preferring to just not <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sourceText = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(portal-&gt;sourceText);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;prepStmtName)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prepStmtName = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(portal-&gt;prepStmtName);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; prepStmtName = <span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; portalParams = portal-&gt;portalParams;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Report query to various monitoring facilities.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = sourceText;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_RUNNING, sourceText);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cmdtagname = <a href="cmdtag.c.html#L53" title="tcop/cmdtag.c:53">GetCommandTagNameAndLen</a>(portal-&gt;commandTag, &amp;cmdtaglen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/ps_status.c.html#L451" title="utils/misc/ps_status.c:451">set_ps_display_with_len</a>(cmdtagname, cmdtaglen);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4993" title="tcop/postgres.c:4993">ResetUsage</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="dest.c.html#L103" title="tcop/dest.c:103">BeginCommand</a>(portal-&gt;commandTag, dest);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create dest receiver in <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> (we don't want it in transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context, because that may get deleted if portal contains VACUUM).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; receiver = <a href="dest.c.html#L113" title="tcop/dest.c:113">CreateDestReceiver</a>(dest);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (dest == DestRemoteExecute)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/printtup.c.html#L99" title="access/common/printtup.c:99">SetRemoteDestReceiverParams</a>(receiver, portal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ensure we are in a transaction command (this should normally be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * case already due to prior BIND).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we re-issue an Execute protocol request against an existing portal,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then we are only fetching more rows rather than completely re-executing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the query from the start. atStart is never reset for a v3 portal, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are safe to use this check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; execute_is_fetch = !portal-&gt;atStart;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Log immediately if dictated by <a href="#L95" title="tcop/postgres.c:95">log_statement</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L2340" title="tcop/postgres.c:2340">check_log_statement</a>(portal-&gt;stmts))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s%s%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; execute_is_fetch ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;execute fetch from&quot;</span>) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;execute&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prepStmtName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *portal_name ? <span class="Constant">&quot;/&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *portal_name ? portal_name : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sourceText),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2475" title="tcop/postgres.c:2475">errdetail_params</a>(portalParams)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; was_logged = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in aborted transaction state, the only portals we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actually run are those containing COMMIT or ROLLBACK commands.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="#L2820" title="tcop/postgres.c:2820">IsTransactionExitStmtList</a>(portal-&gt;stmts))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for cancel signal <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we start execution */<br/></li>
<li></span>&nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Okay to run the portal.&nbsp; Set the error callback so that parameters are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * logged.&nbsp; The parameters must have been saved during the <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a> phase.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; params_data.portalName = portal-&gt;name;<br/></li>
<li>&nbsp; &nbsp; params_data.params = portalParams;<br/></li>
<li>&nbsp; &nbsp; params_errcxt.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; params_errcxt.callback = <a href="../nodes/params.c.html#L407" title="nodes/params.c:407">ParamsErrorCallback</a>;<br/></li>
<li>&nbsp; &nbsp; params_errcxt.arg = (<span class="Type">void</span> *) &amp;params_data;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;params_errcxt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (max_rows &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; max_rows = FETCH_ALL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; completed = <a href="pquery.c.html#L684" title="tcop/pquery.c:684">PortalRun</a>(portal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_rows,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Comment">/* always top level */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !execute_is_fetch &amp;&amp; max_rows == FETCH_ALL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; receiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; receiver,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; receiver-&gt;rDestroy(receiver);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done executing; remove the params error callback */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>-&gt;previous;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (completed)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_xact_command || (<a href="../access/transam/xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> &amp; XACT_FLAGS_NEEDIMMEDIATECOMMIT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this was a transaction control statement, commit it.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will start a new xact command for the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> command (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise if the statement required immediate commit.&nbsp; Without<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this provision, we wouldn't force commit until Sync is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * received, which creates a hazard if the client tries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pipeline immediate-commit statements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * These commands typically don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> parameters, and even if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one did we couldn't <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> them <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because the storage went<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * away during <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>.&nbsp; So pretend there were <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portalParams = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need a <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> after every query, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those that start or end a transaction block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set XACT_FLAGS_PIPELINING whenever we complete an Execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message without immediately committing the transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> |= XACT_FLAGS_PIPELINING;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disable statement timeout whenever we complete an Execute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message.&nbsp; The <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> protocol message will start a fresh timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5167" title="tcop/postgres.c:5167">disable_statement_timeout</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Send appropriate CommandComplete to client */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L169" title="tcop/dest.c:169">EndCommand</a>(&amp;qc, dest, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Portal run not complete, so <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> PortalSuspended */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L388" title="libpq/pqformat.c:388">pq_putemptymessage</a>(PqMsg_PortalSuspended);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set XACT_FLAGS_PIPELINING whenever we suspend an Execute message,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L134" title="access/transam/xact.c:134">MyXactFlags</a> |= XACT_FLAGS_PIPELINING;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Emit duration logging if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="#L2379" title="tcop/postgres.c:2379">check_log_duration</a>(msec_str, was_logged))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">1</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&quot;</span>, msec_str),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">2</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;duration: </span><span class="Special">%s</span><span class="Constant"> ms&nbsp; </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s%s%s</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msec_str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; execute_is_fetch ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;execute fetch from&quot;</span>) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(<span class="Constant">&quot;execute&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prepStmtName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *portal_name ? <span class="Constant">&quot;/&quot;</span> : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *portal_name ? portal_name : <span class="Constant">&quot;&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sourceText),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1413" title="utils/error/elog.c:1413">errhidestmt</a>(<span class="Constant">true</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2475" title="tcop/postgres.c:2475">errdetail_params</a>(portalParams)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (save_log_statement_stats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L5000" title="tcop/postgres.c:5000">ShowUsage</a>(<span class="Constant">&quot;EXECUTE MESSAGE STATISTICS&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<a href="#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2340" title="tcop/postgres.c:2340">check_log_statement</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine whether command should be logged because of <a href="#L95" title="tcop/postgres.c:95">log_statement</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * stmt_list can be either raw grammar output or a list of planned<br/></li>
<li></span><span class="Comment"> * statements<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2340">&#x200c;</a></span><span class="linkable">check_log_statement</span>(List *stmt_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *stmt_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L95" title="tcop/postgres.c:95">log_statement</a> == LOGSTMT_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L95" title="tcop/postgres.c:95">log_statement</a> == LOGSTMT_ALL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Else we have to inspect the statement(s) to see whether to log */<br/></li>
<li></span>&nbsp; &nbsp; foreach(stmt_item, stmt_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *stmt = (Node *) lfirst(stmt_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="utility.c.html#L3246" title="tcop/utility.c:3246">GetCommandLogLevel</a>(stmt) &lt;= <a href="#L95" title="tcop/postgres.c:95">log_statement</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2379" title="tcop/postgres.c:2379">check_log_duration</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Determine whether current command's duration should be logged<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We also check if this statement in this transaction must be logged<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (regardless of its duration).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 0 if no logging is needed<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 1 if just the duration should be logged<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; 2 if duration and query details should be logged<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If logging is needed, the duration in msec is formatted into msec_str[],<br/></li>
<li></span><span class="Comment"> * which must be a 32-byte buffer.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * was_logged should be true if caller already logged query details (this<br/></li>
<li></span><span class="Comment"> * essentially prevents 2 from being returned).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L2379">&#x200c;</a></span><span class="linkable">check_log_duration</span>(<span class="Type">char</span> *msec_str, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> was_logged)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc_tables.c.html#L499" title="utils/misc/guc_tables.c:499">log_duration</a> || <a href="../utils/misc/guc_tables.c.html#L526" title="utils/misc/guc_tables.c:526">log_min_duration_sample</a> &gt;= <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc_tables.c.html#L527" title="utils/misc/guc_tables.c:527">log_min_duration_statement</a> &gt;= <span class="Constant">0</span> || <a href="../access/transam/xact.c.html#L293" title="access/transam/xact.c:293">xact_is_sampled</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msecs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exceeded_duration;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; exceeded_sample_duration;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; in_sample = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(<a href="../access/transam/xact.c.html#L876" title="access/transam/xact.c:876">GetCurrentStatementStartTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;secs, &amp;usecs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; msecs = usecs / <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This odd-looking test for log_min_duration_* being exceeded is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * designed to avoid integer overflow with very long durations: don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * compute secs * 1000 until we've verified it will fit in int.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exceeded_duration = (<a href="../utils/misc/guc_tables.c.html#L527" title="utils/misc/guc_tables.c:527">log_min_duration_statement</a> == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<a href="../utils/misc/guc_tables.c.html#L527" title="utils/misc/guc_tables.c:527">log_min_duration_statement</a> &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (secs &gt; <a href="../utils/misc/guc_tables.c.html#L527" title="utils/misc/guc_tables.c:527">log_min_duration_statement</a> / <span class="Constant">1000</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; secs * <span class="Constant">1000</span> + msecs &gt;= <a href="../utils/misc/guc_tables.c.html#L527" title="utils/misc/guc_tables.c:527">log_min_duration_statement</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exceeded_sample_duration = (<a href="../utils/misc/guc_tables.c.html#L526" title="utils/misc/guc_tables.c:526">log_min_duration_sample</a> == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/misc/guc_tables.c.html#L526" title="utils/misc/guc_tables.c:526">log_min_duration_sample</a> &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (secs &gt; <a href="../utils/misc/guc_tables.c.html#L526" title="utils/misc/guc_tables.c:526">log_min_duration_sample</a> / <span class="Constant">1000</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; secs * <span class="Constant">1000</span> + msecs &gt;= <a href="../utils/misc/guc_tables.c.html#L526" title="utils/misc/guc_tables.c:526">log_min_duration_sample</a>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do not log if <a href="../utils/misc/guc_tables.c.html#L531" title="utils/misc/guc_tables.c:531">log_statement_sample_rate</a> = 0. Log a sample if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/misc/guc_tables.c.html#L531" title="utils/misc/guc_tables.c:531">log_statement_sample_rate</a> &lt;= 1 and avoid unnecessary PRNG call if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/misc/guc_tables.c.html#L531" title="utils/misc/guc_tables.c:531">log_statement_sample_rate</a> = 1.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exceeded_sample_duration)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; in_sample = <a href="../utils/misc/guc_tables.c.html#L531" title="utils/misc/guc_tables.c:531">log_statement_sample_rate</a> != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/misc/guc_tables.c.html#L531" title="utils/misc/guc_tables.c:531">log_statement_sample_rate</a> == <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pg_prng_double(&amp;pg_global_prng_state) &lt;= <a href="../utils/misc/guc_tables.c.html#L531" title="utils/misc/guc_tables.c:531">log_statement_sample_rate</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (exceeded_duration || in_sample || <a href="../utils/misc/guc_tables.c.html#L499" title="utils/misc/guc_tables.c:499">log_duration</a> || <a href="../access/transam/xact.c.html#L293" title="access/transam/xact.c:293">xact_is_sampled</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snprintf(msec_str, <span class="Constant">32</span>, <span class="Constant">&quot;</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; secs * <span class="Constant">1000</span> + msecs, usecs % <span class="Constant">1000</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((exceeded_duration || in_sample || <a href="../access/transam/xact.c.html#L293" title="access/transam/xact.c:293">xact_is_sampled</a>) &amp;&amp; !was_logged)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2442" title="tcop/postgres.c:2442">errdetail_execute</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add an <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>() line showing the query referenced by an EXECUTE, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> * The argument is the raw parsetree list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2442">&#x200c;</a></span><span class="linkable">errdetail_execute</span>(List *raw_parsetree_list)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *parsetree_item;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(parsetree_item, raw_parsetree_list)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RawStmt&nbsp; &nbsp; *parsetree = lfirst_node(RawStmt, parsetree_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(parsetree-&gt;stmt, ExecuteStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ExecuteStmt *stmt = (ExecuteStmt *) parsetree-&gt;stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *pstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pstmt = <a href="../commands/prepare.c.html#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(stmt-&gt;name, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;prepare: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, pstmt-&gt;plansource-&gt;query_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2475" title="tcop/postgres.c:2475">errdetail_params</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add an <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>() line showing <a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>-parameter data, if available.<br/></li>
<li></span><span class="Comment"> * Note that this is only used for statement logging, so it is controlled<br/></li>
<li></span><span class="Comment"> * by <a href="../utils/misc/guc_tables.c.html#L528" title="utils/misc/guc_tables.c:528">log_parameter_max_length</a> not <a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2475">&#x200c;</a></span><span class="linkable">errdetail_params</span>(ParamListInfo params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (params &amp;&amp; params-&gt;numParams &gt; <span class="Constant">0</span> &amp;&amp; <a href="../utils/misc/guc_tables.c.html#L528" title="utils/misc/guc_tables.c:528">log_parameter_max_length</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *str;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str = <a href="../nodes/params.c.html#L335" title="nodes/params.c:335">BuildParamLogString</a>(params, <span class="Constant">NULL</span>, <a href="../utils/misc/guc_tables.c.html#L528" title="utils/misc/guc_tables.c:528">log_parameter_max_length</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (str &amp;&amp; str[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Parameters: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, str);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add an <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>() line showing abort reason, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2495">&#x200c;</a></span><span class="linkable">errdetail_abort</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;recoveryConflictPending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Abort reason: recovery conflict&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2509" title="tcop/postgres.c:2509">errdetail_recovery_conflict</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Add an <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>() line showing conflict source.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L2509">&#x200c;</a></span><span class="linkable">errdetail_recovery_conflict</span>(ProcSignalReason reason)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (reason)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User was holding shared buffer pin for too long.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_LOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User was holding a relation lock for too long.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_TABLESPACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User was or might have been using tablespace that must be dropped.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User query might have needed to see row versions that must be removed.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User was using a logical replication slot that must be invalidated.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User transaction caused buffer deadlock with recovery.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_DATABASE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;User was connected to a database that must be dropped.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a> */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2548" title="tcop/postgres.c:2548">bind_param_error_callback</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Error context callback used while parsing parameters in a Bind message<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2548">&#x200c;</a></span><span class="linkable">bind_param_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="tcop/postgres.c:112">BindParamCbData</a> *data = (<a href="#L112" title="tcop/postgres.c:112">BindParamCbData</a> *) arg;<br/></li>
<li>&nbsp; &nbsp; StringInfoData buf;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *quotedval;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;paramno &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we have a textual value, quote it, and trim if necessary */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;paramval)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mb/stringinfo_mb.c.html#L34" title="utils/mb/stringinfo_mb.c:34">appendStringInfoStringQuoted</a>(&amp;buf, data-&gt;paramval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/guc_tables.c.html#L529" title="utils/misc/guc_tables.c:529">log_parameter_max_length_on_error</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; quotedval = buf.data;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; quotedval = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (data-&gt;portalName &amp;&amp; data-&gt;portalName[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (quotedval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> parameter $</span><span class="Special">%d</span><span class="Constant"> = </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;portalName, data-&gt;paramno + <span class="Constant">1</span>, quotedval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> parameter $</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;portalName, data-&gt;paramno + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (quotedval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;unnamed portal parameter $</span><span class="Special">%d</span><span class="Constant"> = </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;paramno + <span class="Constant">1</span>, quotedval);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errcontext(<span class="Constant">&quot;unnamed portal parameter $</span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; data-&gt;paramno + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (quotedval)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(quotedval);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2597" title="tcop/postgres.c:2597">exec_describe_statement_message</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process a &quot;Describe&quot; message for a prepared statement<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2597">&#x200c;</a></span><span class="linkable">exec_describe_statement_message</span>(<span class="Type">const</span> <span class="Type">char</span> *stmt_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CachedPlanSource *psrc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start up a transaction command. (Note that this will normally change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current memory context.) Nothing happens if we are already in one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch back to message context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find prepared statement */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt_name[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PreparedStatement *pstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstmt = <a href="../commands/prepare.c.html#L431" title="commands/prepare.c:431">FetchPreparedStatement</a>(stmt_name, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; psrc = pstmt-&gt;plansource;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special-case the unnamed statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; psrc = <a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!psrc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_PSTATEMENT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unnamed prepared statement does not exist&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepared statements shouldn't have changeable result descs */<br/></li>
<li></span>&nbsp; &nbsp; Assert(psrc-&gt;fixed_result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in aborted transaction state, we can't run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/common/printtup.c.html#L165" title="access/common/printtup.c:165">SendRowDescriptionMessage</a>(), because that needs catalog accesses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hence, refuse to Describe statements that return data.&nbsp; (We shouldn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * just refuse all Describes, since that might break the ability of some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clients to issue COMMIT or ROLLBACK commands, if they use code that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blindly Describes whatever it does.)&nbsp; We can Describe parameters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * without doing anything dangerous, so we don't restrict that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; psrc-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> != DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't actually do anything... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First describe the parameters...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L109" title="libpq/pqformat.c:109">pq_beginmessage_reuse</a>(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>, <span class="Constant">'t'</span>);&nbsp; &nbsp; <span class="Comment">/* parameter description<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message type */<br/></li>
<li></span>&nbsp; &nbsp; pq_sendint16(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>, psrc-&gt;num_params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; psrc-&gt;num_params; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptype = psrc-&gt;param_types[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>, (<span class="Type">int</span>) ptype);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L314" title="libpq/pqformat.c:314">pq_endmessage_reuse</a>(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Next <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> RowDescription or NoData to describe the result...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (psrc-&gt;resultDesc)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the plan's primary targetlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tlist = <a href="../utils/cache/plancache.c.html#L1640" title="utils/cache/plancache.c:1640">CachedPlanGetTargetList</a>(psrc, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/printtup.c.html#L165" title="access/common/printtup.c:165">SendRowDescriptionMessage</a>(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; psrc-&gt;resultDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L388" title="libpq/pqformat.c:388">pq_putemptymessage</a>(PqMsg_NoData);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2691" title="tcop/postgres.c:2691">exec_describe_portal_message</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process a &quot;Describe&quot; message for a portal<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2691">&#x200c;</a></span><span class="linkable">exec_describe_portal_message</span>(<span class="Type">const</span> <span class="Type">char</span> *portal_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start up a transaction command. (Note that this will normally change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current memory context.) Nothing happens if we are already in one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Switch back to message context */<br/></li>
<li></span>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(portal_name);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!PortalIsValid(portal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_CURSOR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;portal </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, portal_name)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are in aborted transaction state, we can't run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/common/printtup.c.html#L165" title="access/common/printtup.c:165">SendRowDescriptionMessage</a>(), because that needs catalog accesses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Hence, refuse to Describe portals that return data.&nbsp; (We shouldn't just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * refuse all Describes, since that might break the ability of some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clients to issue COMMIT or ROLLBACK commands, if they use code that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blindly Describes whatever it does.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;tupDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IN_FAILED_SQL_TRANSACTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;current transaction is aborted, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;commands ignored until end of transaction block&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2495" title="tcop/postgres.c:2495">errdetail_abort</a>()));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> != DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* can't actually do anything... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (portal-&gt;tupDesc)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/printtup.c.html#L165" title="access/common/printtup.c:165">SendRowDescriptionMessage</a>(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;tupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pquery.c.html#L326" title="tcop/pquery.c:326">FetchPortalTargetList</a>(portal),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal-&gt;formats);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L388" title="libpq/pqformat.c:388">pq_putemptymessage</a>(PqMsg_NoData);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience routines for starting/committing a single command.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2743">&#x200c;</a></span><span class="linkable">start_xact_command</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L137" title="tcop/postgres.c:137">xact_started</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="tcop/postgres.c:137">xact_started</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Start statement timeout if necessary.&nbsp; Note that this'll intentionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not reset the clock on an already started timeout, to avoid the timing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overhead when <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>() is invoked repeatedly, without an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interceding <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>() (e.g. <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>/<a href="../port/win32/socket.c.html#L32" title="port/win32/socket.c:32">bind</a>/execute).&nbsp; If that's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not desired, the timeout has to be disabled explicitly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5145" title="tcop/postgres.c:5145">enable_statement_timeout</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Start timeout for checking if the client has gone away if necessary. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L104" title="tcop/postgres.c:104">client_connection_check_interval</a> &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(CLIENT_CONNECTION_CHECK_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(CLIENT_CONNECTION_CHECK_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L104" title="tcop/postgres.c:104">client_connection_check_interval</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2771">&#x200c;</a></span><span class="linkable">finish_xact_command</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* cancel active statement timeout after each command */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L5167" title="tcop/postgres.c:5167">disable_statement_timeout</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L137" title="tcop/postgres.c:137">xact_started</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef MEMORY_CONTEXT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check all memory contexts that weren't freed during commit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* (those that were, were checked <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> being deleted) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1052" title="utils/mmgr/mcxt.c:1052">MemoryContextCheck</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#ifdef SHOW_MEMORY_STATS<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Print mem stats after each commit for leak tracking */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L814" title="utils/mmgr/mcxt.c:814">MemoryContextStats</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="tcop/postgres.c:137">xact_started</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Convenience routines for checking whether a statement is one of the<br/></li>
<li></span><span class="Comment"> * ones that we allow in transaction-aborted state.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Test a bare parsetree */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2803">&#x200c;</a></span><span class="linkable">IsTransactionExitStmt</span>(Node *parsetree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parsetree &amp;&amp; IsA(parsetree, TransactionStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TransactionStmt *stmt = (TransactionStmt *) parsetree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;kind == TRANS_STMT_COMMIT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;kind == TRANS_STMT_PREPARE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;kind == TRANS_STMT_ROLLBACK ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;kind == TRANS_STMT_ROLLBACK_TO)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Test a list that contains PlannedStmt nodes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2820">&#x200c;</a></span><span class="linkable">IsTransactionExitStmtList</span>(List *pstmts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pstmts) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = linitial_node(PlannedStmt, pstmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_UTILITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2803" title="tcop/postgres.c:2803">IsTransactionExitStmt</a>(pstmt-&gt;utilityStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Test a list that contains PlannedStmt nodes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2835">&#x200c;</a></span><span class="linkable">IsTransactionStmtList</span>(List *pstmts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pstmts) == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PlannedStmt *pstmt = linitial_node(PlannedStmt, pstmts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstmt-&gt;commandType == CMD_UTILITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(pstmt-&gt;utilityStmt, TransactionStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* Release <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing unnamed prepared statement */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2850">&#x200c;</a></span><span class="linkable">drop_unnamed_stmt</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* paranoia to avoid a dangling pointer in case of error */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CachedPlanSource *psrc = <a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L158" title="tcop/postgres.c:158">unnamed_stmt_psrc</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/plancache.c.html#L526" title="utils/cache/plancache.c:526">DropCachedPlan</a>(psrc);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* --------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; signal handler routines used in <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a>()<br/></li>
<li></span><span class="Comment"> * --------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2875" title="tcop/postgres.c:2875">quickdie</a>() occurs when signaled SIGQUIT by the postmaster.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Either some backend has bought the farm, or we've been told to shut down<br/></li>
<li></span><span class="Comment"> * &quot;immediately&quot;; so we need to stop what we're doing and exit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2875">&#x200c;</a></span><span class="linkable">quickdie</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigaddset(&amp;<a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">SIGQUIT</span>);&nbsp; &nbsp; <span class="Comment">/* prevent nested calls */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prevent interrupts while exiting; though we just blocked signals that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would queue new interrupts, one may have been pending.&nbsp; We don't want a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2875" title="tcop/postgres.c:2875">quickdie</a>() downgraded to a mere query cancel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're aborting out of client auth, don't risk trying to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anything to the client; we will likely violate the protocol, not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mention that we may have interrupted the guts of OpenSSL or some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * authentication library.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a> &amp;&amp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Notify the client <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> exiting, to give a clue on what happened.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It's dubious to call ereport() from a signal handler.&nbsp; It is certainly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not async-signal safe.&nbsp; But it seems better to try, than to disconnect<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * abruptly and leave the client wondering what happened.&nbsp; It's remotely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possible that we crash or hang while trying to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the message, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * receiving a SIGQUIT is a sign that something has already gone badly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * wrong, so there's not much to lose.&nbsp; Assuming the postmaster is still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * running, it will SIGKILL us soon if we get stuck for some reason.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * One thing we can do to make this a tad safer is to clear the error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * context stack, so that context callbacks are not called.&nbsp; That's a lot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * less code that could be reached here, and the context info is unlikely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be very relevant to a SIGQUIT report anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * When responding to a postmaster-issued signal, we <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> the message only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the client; sending to the server log just creates log spam, plus<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's more code that we need to hope will work in a signal handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ideally these should be ereport(FATAL), but then we'd not get control<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * back to force the correct type of process exit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (<a href="../storage/ipc/pmsignal.c.html#L229" title="storage/ipc/pmsignal.c:229">GetQuitSignalReason</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PMQUIT_NOT_SENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Hmm, SIGQUIT arrived out of the blue */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection because of unexpected SIGQUIT signal&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PMQUIT_FOR_CRASH:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* A crash-and-restart cycle is in progress */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING_CLIENT_ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CRASH_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection because of crash of another server process&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;The postmaster has commanded this server process to roll back&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; the current transaction and exit, because another&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; server process exited abnormally and possibly corrupted&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; shared memory.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;In a moment you should be able to reconnect to the&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; database and <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> your command.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PMQUIT_FOR_STOP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Immediate-mode stop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING_CLIENT_ONLY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection due to immediate shutdown command&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We DO NOT want to run <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>() or atexit() callbacks -- we're here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because shared memory may be corrupted, so we don't want to try to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clean up our transaction.&nbsp; Just nail the windows shut and get out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * town.&nbsp; The callbacks wouldn't be safe to run from a signal handler,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we do _exit(2) not _exit(0).&nbsp; This is to force the postmaster into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a system reset cycle if someone sends a manual SIGQUIT to a random<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * backend.&nbsp; This is necessary precisely because we don't clean up our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory state.&nbsp; (The &quot;dead man switch&quot; mechanism in pmsignal.c<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should ensure the postmaster sees this as a crash, too, but no harm in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being doubly sure.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; _exit(<span class="Constant">2</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../postmaster/postmaster.c.html#L269" title="postmaster/postmaster.c:269">Shutdown</a> signal from postmaster: abort transaction and exit<br/></li>
<li></span><span class="Comment"> * at soonest convenient time<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2972">&#x200c;</a></span><span class="linkable">die</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Don't joggle the elbow of <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/ipc/ipc.c.html#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* for the cumulative stats system */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/activity/pgstat_database.c.html#L32" title="utils/activity/pgstat_database.c:32">pgStatSessionEndCause</a> = DISCONNECT_KILLED;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're still here, waken anything <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on the process latch */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're in single user mode, we want to quit immediately - we can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rely on latches as they wouldn't work when stdin/stdout is a file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Rather ugly, but it's unlikely to be worthwhile to invest much more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * effort just for the benefit of single user mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> &amp;&amp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> != DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Query-cancel signal from postmaster: abort current transaction<br/></li>
<li></span><span class="Comment"> * at soonest convenient time<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3002">&#x200c;</a></span><span class="linkable">StatementCancelHandler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't joggle the elbow of <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/ipc/ipc.c.html#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If we're still here, waken anything <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> on the process latch */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/latch.c.html#L632" title="storage/ipc/latch.c:632">SetLatch</a>(<a href="../utils/init/globals.c.html#L60" title="utils/init/globals.c:60">MyLatch</a>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* signal handler for floating point exception */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3019">&#x200c;</a></span><span class="linkable">FloatExceptionHandler</span>(SIGNAL_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're not returning, so no need to save errno */<br/></li>
<li></span>&nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FLOATING_POINT_EXCEPTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;floating-point exception&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;An invalid floating-point operation was signaled. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;This probably means an out-of-<a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> result or an &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;invalid operation, such as division by zero.&quot;</span>)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Tell the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> CHECK_FOR_INTERRUPTS() to check for a particular type of<br/></li>
<li></span><span class="Comment"> * recovery conflict.&nbsp; Runs in a SIGUSR1 handler.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3035">&#x200c;</a></span><span class="linkable">HandleRecoveryConflictInterrupt</span>(ProcSignalReason reason)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L167" title="tcop/postgres.c:167">RecoveryConflictPendingReasons</a>[reason] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="tcop/postgres.c:166">RecoveryConflictPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* latch will be set by <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a> */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check one individual conflict reason.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3047">&#x200c;</a></span><span class="linkable">ProcessRecoveryConflictInterrupt</span>(ProcSignalReason reason)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (reason)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for a lock we can never deadlock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/lmgr/proc.c.html#L713" title="storage/lmgr/proc.c:713">IsWaitingForLock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Intentional fall through to check wait for pin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_BUFFERPIN:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If PROCSIG_RECOVERY_CONFLICT_BUFFERPIN is requested but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't blocking the Startup process there is nothing more to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK is requested,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we're <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for locks and the startup process is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for buffer pin (i.e., also <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for locks), we set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the flag so that <a href="../storage/lmgr/proc.c.html#L1066" title="storage/lmgr/proc.c:1066">ProcSleep</a>() will check for deadlocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/buffer/bufmgr.c.html#L5300" title="storage/buffer/bufmgr.c:5300">HoldingBufferPinThatDelaysRecovery</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reason == PROCSIG_RECOVERY_CONFLICT_STARTUP_DEADLOCK &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L671" title="storage/lmgr/proc.c:671">GetStartupBufferPinWaitBufId</a>() &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L1840" title="storage/lmgr/proc.c:1840">CheckDeadLockAlert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;recoveryConflictPending = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Intentional fall through to error handling */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_LOCK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_TABLESPACE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_SNAPSHOT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we aren't in a transaction <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> longer then ignore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we're not in a subtransaction then we are OK to throw an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ERROR to resolve the conflict.&nbsp; Otherwise drop through to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FATAL case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT is a special case that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * always throws an ERROR (ie never promotes to FATAL), though it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * still has to respect <a href="../utils/init/globals.c.html#L42" title="utils/init/globals.c:42">QueryCancelHoldoffCount</a>, so it shares this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * code path.&nbsp; Logical decoding slots are only acquired while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performing logical decoding.&nbsp; During logical decoding no user<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * controlled code is run.&nbsp; During [sub]transaction abort, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slot is released.&nbsp; Therefore user controlled code cannot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * intercept an error <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the replication slot is released.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> other times that we can throw just an ERROR *may* be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCSIG_RECOVERY_CONFLICT_LOCK if no locks are held in parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCSIG_RECOVERY_CONFLICT_SNAPSHOT if no snapshots are held by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent transactions and the transaction is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction-snapshot mode<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * PROCSIG_RECOVERY_CONFLICT_TABLESPACE if no temp files or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cursors open in parent transactions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (reason == PROCSIG_RECOVERY_CONFLICT_LOGICALSLOT ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../access/transam/xact.c.html#L4988" title="access/transam/xact.c:4988">IsSubTransaction</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we already aborted then we no longer need to cancel.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * do this here since we do not wish to ignore aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subtransactions, which must cause FATAL, currently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a recovery conflict happens while we are <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * input from the client, the client is presumably just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sitting idle in a transaction, preventing recovery from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * making progress.&nbsp; We'll drop through to the FATAL case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below to dislodge it, in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Avoid losing sync in the FE/BE protocol. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L42" title="utils/init/globals.c:42">QueryCancelHoldoffCount</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-arm and defer this interrupt until later.&nbsp; See<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * similar code in <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="tcop/postgres.c:167">RecoveryConflictPendingReasons</a>[reason] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L166" title="tcop/postgres.c:166">RecoveryConflictPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We are cleared to throw an ERROR.&nbsp; Either it's the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logical slot case, or we have a top-level transaction<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we can abort and a conflict that isn't inherently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-retryable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_database.c.html#L81" title="utils/activity/pgstat_database.c:81">pgstat_report_recovery_conflict</a>(reason);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling statement due to conflict with recovery&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2509" title="tcop/postgres.c:2509">errdetail_recovery_conflict</a>(reason)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Intentional fall through to session cancel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROCSIG_RECOVERY_CONFLICT_DATABASE:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Retrying is not possible because the database is dropped, or we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decided above that we couldn't resolve the conflict with an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ERROR and fell through.&nbsp; Terminate the session.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_database.c.html#L81" title="utils/activity/pgstat_database.c:81">pgstat_report_recovery_conflict</a>(reason);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(reason == PROCSIG_RECOVERY_CONFLICT_DATABASE ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ERRCODE_DATABASE_DROPPED :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ERRCODE_T_R_SERIALIZATION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection due to conflict with recovery&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L2509" title="tcop/postgres.c:2509">errdetail_recovery_conflict</a>(reason),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;In a moment you should be able to reconnect to the&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot; database and <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> your command.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(FATAL, <span class="Constant">&quot;unrecognized conflict mode: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) reason);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check each possible recovery conflict reason.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3205">&#x200c;</a></span><span class="linkable">ProcessRecoveryConflictInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need to worry about joggling the elbow of <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/ipc.c.html#L165" title="storage/ipc/ipc.c:165">proc_exit_prepare</a>() holds interrupts, so <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>() won't call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../storage/ipc/ipc.c.html#L40" title="storage/ipc/ipc.c:40">proc_exit_inprogress</a>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L166" title="tcop/postgres.c:166">RecoveryConflictPending</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L166" title="tcop/postgres.c:166">RecoveryConflictPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (ProcSignalReason reason = PROCSIG_RECOVERY_CONFLICT_FIRST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reason &lt;= PROCSIG_RECOVERY_CONFLICT_LAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reason++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L167" title="tcop/postgres.c:167">RecoveryConflictPendingReasons</a>[reason])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L167" title="tcop/postgres.c:167">RecoveryConflictPendingReasons</a>[reason] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3047" title="tcop/postgres.c:3047">ProcessRecoveryConflictInterrupt</a>(reason);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>: out-of-line portion of CHECK_FOR_INTERRUPTS() macro<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an interrupt condition is pending, and it's safe to service it,<br/></li>
<li></span><span class="Comment"> * then clear the flag and <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the interrupt.&nbsp; Called only when<br/></li>
<li></span><span class="Comment"> * <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> is true.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: if INTERRUPTS_CAN_BE_PROCESSED() is true, then <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a><br/></li>
<li></span><span class="Comment"> * is guaranteed to clear the <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> flag <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> returning.<br/></li>
<li></span><span class="Comment"> * (This is not the same as guaranteeing that it's still clear when we<br/></li>
<li></span><span class="Comment"> * return; another interrupt could have arrived.&nbsp; But we promise that<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pre-existing one will have been serviced.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3244">&#x200c;</a></span><span class="linkable">ProcessInterrupts</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* OK to <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> interrupts <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>? */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L41" title="utils/init/globals.c:41">InterruptHoldoffCount</a> != <span class="Constant">0</span> || <a href="../utils/init/globals.c.html#L43" title="utils/init/globals.c:43">CritSectionCount</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L32" title="utils/init/globals.c:32">ProcDiePending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>; <span class="Comment">/* ProcDie trumps QueryCancel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As in <a href="#L2875" title="tcop/postgres.c:2875">quickdie</a>, don't risk sending to client during auth */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a> &amp;&amp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/postmaster.c.html#L350" title="postmaster/postmaster.c:350">ClientAuthInProgress</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_QUERY_CANCELED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling authentication due to timeout&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating autovacuum process due to administrator command&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../replication/logical/worker.c.html#L4744" title="replication/logical/worker.c:4744">IsLogicalWorker</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating logical replication worker due to administrator command&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../replication/logical/launcher.c.html#L1243" title="replication/logical/launcher.c:1243">IsLogicalLauncher</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;logical replication launcher shutting down&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The logical replication launcher can be stopped at <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Use exit status 1 so the background worker is restarted.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (AmBackgroundWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating background worker </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> due to administrator command&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/postmaster.c.html#L185" title="postmaster/postmaster.c:185">MyBgworkerEntry</a>-&gt;bgw_type)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_ADMIN_SHUTDOWN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection due to administrator command&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L33" title="utils/init/globals.c:33">CheckClientConnectionPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L33" title="utils/init/globals.c:33">CheckClientConnectionPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for lost connection and re-arm, if still configured, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if we've arrived back at <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> state.&nbsp; We don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wake up idle sessions, and they already know how to detect lost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connections.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> &amp;&amp; <a href="#L104" title="tcop/postgres.c:104">client_connection_check_interval</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../libpq/pqcomm.c.html#L2053" title="libpq/pqcomm.c:2053">pq_check_connection</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L34" title="utils/init/globals.c:34">ClientConnectionLost</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(CLIENT_CONNECTION_CHECK_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L104" title="tcop/postgres.c:104">client_connection_check_interval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L34" title="utils/init/globals.c:34">ClientConnectionLost</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>; <span class="Comment">/* lost connection trumps QueryCancel */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> to client, we already know the connection to be dead. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_CONNECTION_FAILURE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;connection to client lost&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow query cancel interrupts while reading input from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client, because we might lose sync in the FE/BE protocol.&nbsp; (Die<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * interrupts are OK, because we won't read <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> further messages from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * client in that case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See similar logic in <a href="#L3205" title="tcop/postgres.c:3205">ProcessRecoveryConflictInterrupts</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> &amp;&amp; <a href="../utils/init/globals.c.html#L42" title="utils/init/globals.c:42">QueryCancelHoldoffCount</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-arm <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> so that we process the cancel request as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * soon as we're done reading the message.&nbsp; (</span><span class="Todo">XXX</span><span class="Comment"> this is seriously<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ugly: it complicates INTERRUPTS_CAN_BE_PROCESSED(), and it means we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't use that macro directly as the initial test in this function,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * meaning that this code also creates opportunities for other bugs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appear.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L30" title="utils/init/globals.c:30">InterruptPending</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lock_timeout_occurred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; stmt_timeout_occurred;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If LOCK_TIMEOUT and STATEMENT_TIMEOUT indicators are both set, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to clear both, so always fetch both.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; lock_timeout_occurred = <a href="../utils/misc/timeout.c.html#L793" title="utils/misc/timeout.c:793">get_timeout_indicator</a>(LOCK_TIMEOUT, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt_timeout_occurred = <a href="../utils/misc/timeout.c.html#L793" title="utils/misc/timeout.c:793">get_timeout_indicator</a>(STATEMENT_TIMEOUT, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If both were set, we want to report whichever timeout completed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * earlier; this ensures consistent behavior if the machine is slow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enough that the second timeout triggers <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get here.&nbsp; A tie<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is arbitrarily broken in favor of reporting a lock timeout.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock_timeout_occurred &amp;&amp; stmt_timeout_occurred &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L827" title="utils/misc/timeout.c:827">get_timeout_finish_time</a>(STATEMENT_TIMEOUT) &lt; <a href="../utils/misc/timeout.c.html#L827" title="utils/misc/timeout.c:827">get_timeout_finish_time</a>(LOCK_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock_timeout_occurred = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* report stmt timeout */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lock_timeout_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_LOCK_NOT_AVAILABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling statement due to lock timeout&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt_timeout_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_QUERY_CANCELED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling statement due to statement timeout&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AmAutoVacuumWorkerProcess())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_QUERY_CANCELED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling autovacuum task&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are reading a command from the client, just ignore the cancel<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * request --- sending an extra error message won't accomplish<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anything.&nbsp; Otherwise, go ahead and throw the error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L730" title="storage/lmgr/proc.c:730">LockErrorCleanup</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_QUERY_CANCELED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;canceling statement due to user request&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L166" title="tcop/postgres.c:166">RecoveryConflictPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3205" title="tcop/postgres.c:3205">ProcessRecoveryConflictInterrupts</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L35" title="utils/init/globals.c:35">IdleInTransactionSessionTimeoutPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the GUC has been reset to zero, ignore the signal.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important because the GUC update itself won't disable <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupt.&nbsp; We need to unset the flag <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the injection point,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we could loop in interrupts checking.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L35" title="utils/init/globals.c:35">IdleInTransactionSessionTimeoutPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INJECTION_POINT(<span class="Constant">&quot;idle-in-transaction-session-timeout&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IDLE_IN_TRANSACTION_SESSION_TIMEOUT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection due to idle-in-transaction timeout&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L36" title="utils/init/globals.c:36">TransactionTimeoutPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, ignore the signal if the GUC has been reset to zero. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L36" title="utils/init/globals.c:36">TransactionTimeoutPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INJECTION_POINT(<span class="Constant">&quot;transaction-timeout&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TRANSACTION_TIMEOUT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection due to transaction timeout&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L37" title="utils/init/globals.c:37">IdleSessionTimeoutPending</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, ignore the signal if the GUC has been reset to zero. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L37" title="utils/init/globals.c:37">IdleSessionTimeoutPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L62" title="storage/lmgr/proc.c:62">IdleSessionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INJECTION_POINT(<span class="Constant">&quot;idle-session-timeout&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_IDLE_SESSION_TIMEOUT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection due to idle-session timeout&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If there are pending stats updates and we currently are truly idle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (matching the conditions in <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a>(), report stats <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L40" title="utils/init/globals.c:40">IdleStatsUpdateTimeoutPending</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> &amp;&amp; !<a href="../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L40" title="utils/init/globals.c:40">IdleStatsUpdateTimeoutPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L38" title="utils/init/globals.c:38">ProcSignalBarrierPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/procsignal.c.html#L464" title="storage/ipc/procsignal.c:464">ProcessProcSignalBarrier</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/parallel.c.html#L115" title="access/transam/parallel.c:115">ParallelMessagePending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/parallel.c.html#L1027" title="access/transam/parallel.c:1027">HandleParallelMessages</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L39" title="utils/init/globals.c:39">LogMemoryContextPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1288" title="utils/mmgr/mcxt.c:1288">ProcessLogMemoryContextInterrupt</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/logical/applyparallelworker.c.html#L245" title="replication/logical/applyparallelworker.c:245">ParallelApplyMessagePending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/logical/applyparallelworker.c.html#L1063" title="replication/logical/applyparallelworker.c:1063">HandleParallelApplyMessages</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3481" title="tcop/postgres.c:3481">set_stack_base</a>: set up reference point for stack depth checking<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the old reference point, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>pg_stack_base_t<br/></li>
<li><a id="L3481">&#x200c;</a><span class="linkable">set_stack_base</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#ifndef HAVE__BUILTIN_FRAME_ADDRESS<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; stack_base;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; pg_stack_base_t old;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; old = <a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up reference point for stack depth checking.&nbsp; On recent gcc we use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * __builtin_frame_address() to avoid a warning about storing a local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * variable's address in a long-lived variable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef HAVE__BUILTIN_FRAME_ADDRESS<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a> = __builtin_frame_address(<span class="Constant">0</span>);<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a> = &amp;stack_base;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> old;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3514" title="tcop/postgres.c:3514">restore_stack_base</a>: restore reference point for stack depth checking<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This can be used after <a href="#L3481" title="tcop/postgres.c:3481">set_stack_base</a>() to restore the old value. This<br/></li>
<li></span><span class="Comment"> * is currently only used in PL/Java. When PL/Java calls a backend function<br/></li>
<li></span><span class="Comment"> * from different thread, the thread's stack is at a different location than<br/></li>
<li></span><span class="Comment"> * the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> thread's stack, so it sets the base pointer <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the call, and<br/></li>
<li></span><span class="Comment"> * restores it afterwards.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3514">&#x200c;</a></span><span class="linkable">restore_stack_base</span>(pg_stack_base_t base)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a> = base;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>/<a href="#L3545" title="tcop/postgres.c:3545">stack_is_too_deep</a>: check for excessively deep recursion<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called someplace in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recursive routine that might possibly<br/></li>
<li></span><span class="Comment"> * recurse deep enough to overflow the stack.&nbsp; Most Unixen treat stack<br/></li>
<li></span><span class="Comment"> * overflow as an unrecoverable SIGSEGV, so we want to error out ourselves<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> hitting the hardware limit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>() just throws an error summarily.&nbsp; <a href="#L3545" title="tcop/postgres.c:3545">stack_is_too_deep</a>()<br/></li>
<li></span><span class="Comment"> * can be used by code that wants to handle the error condition itself.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3531">&#x200c;</a></span><span class="linkable">check_stack_depth</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L3545" title="tcop/postgres.c:3545">stack_is_too_deep</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_STATEMENT_TOO_COMPLEX),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;stack depth limit exceeded&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Increase the configuration parameter <a href="#L98" title="tcop/postgres.c:98">max_stack_depth</a> (currently </span><span class="Special">%d</span><span class="Constant">kB), &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;after ensuring the platform's stack depth limit is adequate.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L98" title="tcop/postgres.c:98">max_stack_depth</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3545">&#x200c;</a></span><span class="linkable">stack_is_too_deep</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; stack_top_loc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; stack_depth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute distance from reference point to my local variables<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stack_depth = (<span class="Type">long</span>) (<a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a> - &amp;stack_top_loc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Take abs value, since stacks grow up on some machines, down on others<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stack_depth &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stack_depth = -stack_depth;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Trouble?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The test on <a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a> prevents us from erroring out if called<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during process setup or in a non-backend process.&nbsp; Logically it should<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done first, but putting it here avoids wasting cycles during normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stack_depth &gt; <a href="#L125" title="tcop/postgres.c:125">max_stack_depth_bytes</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L131" title="tcop/postgres.c:131">stack_base_ptr</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC check hook for <a href="#L98" title="tcop/postgres.c:98">max_stack_depth</a> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3578">&#x200c;</a></span><span class="linkable">check_max_stack_depth</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; newval_bytes = *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> * <span class="Constant">1024L</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; stack_rlimit = <a href="#L4961" title="tcop/postgres.c:4961">get_stack_depth_rlimit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stack_rlimit &gt; <span class="Constant">0</span> &amp;&amp; newval_bytes &gt; stack_rlimit - STACK_DEPTH_SLOP)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;<a href="#L98" title="tcop/postgres.c:98">max_stack_depth</a> must not exceed </span><span class="Special">%ld</span><span class="Constant">kB.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (stack_rlimit - STACK_DEPTH_SLOP) / <span class="Constant">1024L</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errhint(<span class="Constant">&quot;Increase the platform's stack depth limit via </span><span class="Special">\&quot;</span><span class="Constant">ulimit -s</span><span class="Special">\&quot;</span><span class="Constant"> or local equivalent.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC assign hook for <a href="#L98" title="tcop/postgres.c:98">max_stack_depth</a> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3595">&#x200c;</a></span><span class="linkable">assign_max_stack_depth</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; newval_bytes = <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> * <span class="Constant">1024L</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L125" title="tcop/postgres.c:125">max_stack_depth_bytes</a> = newval_bytes;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="#L104" title="tcop/postgres.c:104">client_connection_check_interval</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3606">&#x200c;</a></span><span class="linkable">check_client_connection_check_interval</span>(<span class="Type">int</span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/ipc/latch.c.html#L2215" title="storage/ipc/latch.c:2215">WaitEventSetCanReportClosed</a>() &amp;&amp; *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;<a href="#L104" title="tcop/postgres.c:104">client_connection_check_interval</a> must be set to 0 on this platform.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>, <a href="../utils/misc/guc_tables.c.html#L506" title="utils/misc/guc_tables.c:506">log_planner_stats</a>, <a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function and <a href="#L3641" title="tcop/postgres.c:3641">check_log_stats</a> interact to prevent their variables from<br/></li>
<li></span><span class="Comment"> * being set in a disallowed combination.&nbsp; This is a hack that doesn't really<br/></li>
<li></span><span class="Comment"> * work right; for example it might fail while applying pg_db_role_setting<br/></li>
<li></span><span class="Comment"> * <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> even though the final state would have been acceptable.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * since these variables are legacy settings with little production usage,<br/></li>
<li></span><span class="Comment"> * we tolerate that.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3627">&#x200c;</a></span><span class="linkable">check_stage_log_stats</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp; <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Cannot enable parameter when </span><span class="Special">\&quot;</span><span class="Constant"><a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a></span><span class="Special">\&quot;</span><span class="Constant"> is true.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC check_hook for <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3641">&#x200c;</a></span><span class="linkable">check_log_stats</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> **extra, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a> || <a href="../utils/misc/guc_tables.c.html#L506" title="utils/misc/guc_tables.c:506">log_planner_stats</a> || <a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; GUC_check_errdetail(<span class="Constant">&quot;Cannot enable <a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a> when &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>, <a href="../utils/misc/guc_tables.c.html#L506" title="utils/misc/guc_tables.c:506">log_planner_stats</a>, &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;or <a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a> is true.&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* GUC assign hook for transaction_timeout */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3656">&#x200c;</a></span><span class="linkable">assign_transaction_timeout</span>(<span class="Type">int</span> <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>, <span class="Type">void</span> *extra)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L384" title="access/transam/xact.c:384">IsTransactionState</a>())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If transaction_timeout GUC has changed within the transaction block<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * enable or disable the timer correspondingly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &gt; <span class="Constant">0</span> &amp;&amp; !<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(TRANSACTION_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(TRANSACTION_TIMEOUT, <a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../utils/misc/guc.c.html#L3703" title="utils/misc/guc.c:3703">newval</a> &lt;= <span class="Constant">0</span> &amp;&amp; <a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(TRANSACTION_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(TRANSACTION_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3679" title="tcop/postgres.c:3679">set_debug_options</a> --- apply &quot;-d N&quot; command line option<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * -d is not quite the same as setting <a href="../utils/misc/guc_tables.c.html#L524" title="utils/misc/guc_tables.c:524">log_min_messages</a> because it enables<br/></li>
<li></span><span class="Comment"> * other output options.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3679">&#x200c;</a></span><span class="linkable">set_debug_options</span>(<span class="Type">int</span> debug_flag, GucContext context, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debug_flag &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; debugstr[<span class="Constant">64</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sprintf(debugstr, <span class="Constant">&quot;debug</span><span class="Special">%d</span><span class="Constant">&quot;</span>, debug_flag);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L524" title="utils/misc/guc_tables.c:524">log_min_messages</a>&quot;</span>, debugstr, context, source);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L524" title="utils/misc/guc_tables.c:524">log_min_messages</a>&quot;</span>, <span class="Constant">&quot;notice&quot;</span>, context, source);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debug_flag &gt;= <span class="Constant">1</span> &amp;&amp; context == PGC_POSTMASTER)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;log_connections&quot;</span>, <span class="Constant">&quot;true&quot;</span>, context, source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="#L5109" title="tcop/postgres.c:5109">log_disconnections</a>&quot;</span>, <span class="Constant">&quot;true&quot;</span>, context, source);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debug_flag &gt;= <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="#L95" title="tcop/postgres.c:95">log_statement</a>&quot;</span>, <span class="Constant">&quot;all&quot;</span>, context, source);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debug_flag &gt;= <span class="Constant">3</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;debug_print_parse&quot;</span>, <span class="Constant">&quot;true&quot;</span>, context, source);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debug_flag &gt;= <span class="Constant">4</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;debug_print_plan&quot;</span>, <span class="Constant">&quot;true&quot;</span>, context, source);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (debug_flag &gt;= <span class="Constant">5</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;debug_print_rewritten&quot;</span>, <span class="Constant">&quot;true&quot;</span>, context, source);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3708">&#x200c;</a></span><span class="linkable">set_plan_disabling_options</span>(<span class="Type">const</span> <span class="Type">char</span> *arg, GucContext context, GucSource source)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tmp = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (arg[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'s'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* seqscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L134" title="optimizer/path/costsize.c:134">enable_seqscan</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'i'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L135" title="optimizer/path/costsize.c:135">enable_indexscan</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'o'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* indexonlyscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L136" title="optimizer/path/costsize.c:136">enable_indexonlyscan</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* bitmapscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L137" title="optimizer/path/costsize.c:137">enable_bitmapscan</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'t'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* tidscan */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L138" title="optimizer/path/costsize.c:138">enable_tidscan</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'n'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nestloop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L142" title="optimizer/path/costsize.c:142">enable_nestloop</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'m'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* mergejoin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L145" title="optimizer/path/costsize.c:145">enable_mergejoin</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'h'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hashjoin */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tmp = <span class="Constant">&quot;<a href="../optimizer/path/costsize.c.html#L146" title="optimizer/path/costsize.c:146">enable_hashjoin</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tmp)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(tmp, <span class="Constant">&quot;false&quot;</span>, context, source);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3750">&#x200c;</a><span class="linkable">get_stats_option_name</span>(<span class="Type">const</span> <span class="Type">char</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (arg[<span class="Constant">0</span>])<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'p'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (optarg[<span class="Constant">1</span>] == <span class="Constant">'a'</span>)&nbsp; &nbsp; <span class="Comment">/* &quot;parser&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L505" title="utils/misc/guc_tables.c:505">log_parser_stats</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (optarg[<span class="Constant">1</span>] == <span class="Constant">'l'</span>)&nbsp; &nbsp; <span class="Comment">/* &quot;<a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L506" title="utils/misc/guc_tables.c:506">log_planner_stats</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'e'</span>:&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;executor&quot; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L507" title="utils/misc/guc_tables.c:507">log_executor_stats</a>&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L3790" title="tcop/postgres.c:3790">process_postgres_switches</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; Parse command line arguments for backends<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is called twice, once for the &quot;secure&quot; options coming from the<br/></li>
<li></span><span class="Comment"> * postmaster or command line, and once for the &quot;insecure&quot; options coming<br/></li>
<li></span><span class="Comment"> * from the client's startup packet.&nbsp; The latter have the same syntax but<br/></li>
<li></span><span class="Comment"> * may be restricted in what they can do.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * argv[0] is ignored in either case (it's assumed to be the program name).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * ctx is PGC_POSTMASTER for secure options, PGC_BACKEND for insecure options<br/></li>
<li></span><span class="Comment"> * coming from the client, or PGC_SU_BACKEND for insecure options coming from<br/></li>
<li></span><span class="Comment"> * a <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> client.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If a database name is present in the command line arguments, it's<br/></li>
<li></span><span class="Comment"> * returned into *dbname (this is allowed only if *dbname is initially NULL).<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3790">&#x200c;</a></span><span class="linkable">process_postgres_switches</span>(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[], GucContext ctx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> **dbname)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; secure = (ctx == PGC_POSTMASTER);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errs = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; GucSource&nbsp; &nbsp; gucsource;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flag;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gucsource = PGC_S_ARGV; <span class="Comment">/* switches came from command line */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore the initial --single argument, if present */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (argc &gt; <span class="Constant">1</span> &amp;&amp; strcmp(argv[<span class="Constant">1</span>], <span class="Constant">&quot;--single&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argv++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; argc--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; gucsource = PGC_S_CLIENT;&nbsp; &nbsp; <span class="Comment">/* switches came from client */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li><span class="PreProc">#ifdef HAVE_INT_OPTERR<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Turn this off because it's either printed to stderr and not the log<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where we'd want it, or argv[0] is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> &quot;--single&quot;, which would make for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a weird error message.&nbsp; We <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> our own error message below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; opterr = <span class="Constant">0</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse command-line options.&nbsp; CAUTION: keep this in sync with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster/postmaster.c (the option sets should not conflict) and with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the common <a href="../main/main.c.html#L320" title="main/main.c:320">help</a>() function in <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>/<a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a>.c.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> ((flag = getopt(argc, argv, <span class="Constant">&quot;B:bC:c:D:d:EeFf:h:ijk:lN:nOPp:r:S:sTt:v:W:-:&quot;</span>)) != -<span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (flag)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'B'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;shared_buffers&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'b'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Undocumented flag used for binary upgrades */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'C'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignored for consistency with the postmaster */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'c'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'-'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L6321" title="utils/misc/guc.c:6321">ParseLongOption</a>(optarg, &amp;name, &amp;value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!value)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (flag == <span class="Constant">'-'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;--</span><span class="Special">%s</span><span class="Constant"> requires a value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optarg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;-c </span><span class="Special">%s</span><span class="Constant"> requires a value&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optarg)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(name, value, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'D'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L161" title="tcop/postgres.c:161">userDoption</a> = strdup(optarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'d'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3679" title="tcop/postgres.c:3679">set_debug_options</a>(atoi(optarg), ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'E'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L162" title="tcop/postgres.c:162">EchoQuery</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'e'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;datestyle&quot;</span>, <span class="Constant">&quot;euro&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'F'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;fsync&quot;</span>, <span class="Constant">&quot;false&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'f'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3708" title="tcop/postgres.c:3708">set_plan_disabling_options</a>(optarg, ctx, gucsource))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'h'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;listen_addresses&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'i'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;listen_addresses&quot;</span>, <span class="Constant">&quot;*&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'j'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L163" title="tcop/postgres.c:163">UseSemiNewlineNewline</a> = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'k'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;unix_socket_directories&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'l'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;ssl&quot;</span>, <span class="Constant">&quot;true&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'N'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;max_connections&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'n'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignored for consistency with postmaster */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'O'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;allow_system_table_mods&quot;</span>, <span class="Constant">&quot;true&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'P'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;ignore_system_indexes&quot;</span>, <span class="Constant">&quot;true&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'p'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;port&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'r'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> output (stdout and stderr) to the given file */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strlcpy(<a href="../utils/init/globals.c.html#L76" title="utils/init/globals.c:76">OutputFileName</a>, optarg, MAXPGPATH);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/init/globals.c.html#L128" title="utils/init/globals.c:128">work_mem</a>&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'s'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;<a href="../utils/misc/guc_tables.c.html#L508" title="utils/misc/guc_tables.c:508">log_statement_stats</a>&quot;</span>, <span class="Constant">&quot;true&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'T'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignored for consistency with the postmaster */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'t'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *tmp = <a href="#L3750" title="tcop/postgres.c:3750">get_stats_option_name</a>(optarg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tmp)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(tmp, <span class="Constant">&quot;true&quot;</span>, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'v'</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * -v is no longer used in normal operation, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/init/globals.c.html#L28" title="utils/init/globals.c:28">FrontendProtocol</a> is already set <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we get here. We keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the switch only for possible use in standalone operation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in case we ever support using normal FE/BE protocol with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standalone backend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (secure)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L28" title="utils/init/globals.c:28">FrontendProtocol</a> = (ProtocolVersion) atoi(optarg);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'W'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L4285" title="utils/misc/guc.c:4285">SetConfigOption</a>(<span class="Constant">&quot;post_auth_delay&quot;</span>, optarg, ctx, gucsource);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; errs++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Optional database name should be there only if *dbname is NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!errs &amp;&amp; dbname &amp;&amp; *dbname == <span class="Constant">NULL</span> &amp;&amp; argc - optind &gt;= <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *dbname = strdup(argv[optind++]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (errs || argc != optind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (errs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; optind--;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* complain about the previous argument */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* spell the error message a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> differently depending on context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid command-line argument for server process: </span><span class="Special">%s</span><span class="Constant">&quot;</span>, argv[optind]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Try </span><span class="Special">\&quot;%s</span><span class="Constant"> --<a href="../main/main.c.html#L320" title="main/main.c:320">help</a></span><span class="Special">\&quot;</span><span class="Constant"> for more information.&quot;</span>, <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: invalid command-line argument: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>, argv[optind]),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Try </span><span class="Special">\&quot;%s</span><span class="Constant"> --<a href="../main/main.c.html#L320" title="main/main.c:320">help</a></span><span class="Special">\&quot;</span><span class="Constant"> for more information.&quot;</span>, <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reset getopt(3) library so that it will work correctly in subprocesses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or when this function is called a second time with another array.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; optind = <span class="Constant">1</span>;<br/></li>
<li><span class="PreProc">#ifdef HAVE_INT_OPTRESET<br/></li>
<li></span>&nbsp; &nbsp; optreset = <span class="Constant">1</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* some systems need this too */<br/></li>
<li></span><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4042" title="tcop/postgres.c:4042">PostgresSingleUserMain</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Entry point for single user mode. argc/argv are the command line<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; arguments to be used.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Performs single user specific setup then calls <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a>() to actually<br/></li>
<li></span><span class="Comment"> * process queries. Single user mode specific setup should go here, rather<br/></li>
<li></span><span class="Comment"> * than <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a>() or <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>() when reasonably possible.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4042">&#x200c;</a></span><span class="linkable">PostgresSingleUserMain</span>(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *username)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *dbname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize startup process environment. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L181" title="utils/init/miscinit.c:181">InitStandaloneProcess</a>(argv[<span class="Constant">0</span>]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for command-line options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L1532" title="utils/misc/guc.c:1532">InitializeGUCOptions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Parse command-line options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3790" title="tcop/postgres.c:3790">process_postgres_switches</a>(argc, argv, PGC_POSTMASTER, &amp;dbname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Must have gotten a database name, or have a default (the username) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dbname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dbname = username;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dbname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: no database nor user name specified&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Acquire configuration parameters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/guc.c.html#L1786" title="utils/misc/guc.c:1786">SelectConfigFiles</a>(<a href="#L161" title="tcop/postgres.c:161">userDoption</a>, <a href="../main/main.c.html#L44" title="main/main.c:44">progname</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validate we have been given a reasonable-looking <a href="../utils/init/globals.c.html#L68" title="utils/init/globals.c:68">DataDir</a> and change<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * into it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L341" title="utils/init/miscinit.c:341">checkDataDir</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L454" title="utils/init/miscinit.c:454">ChangeToDataDir</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create lockfile for data directory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1455" title="utils/init/miscinit.c:1455">CreateDataDirLockFile</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* read control file (error checking and contains config ) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L4813" title="access/transam/xlog.c:4813">LocalProcessControlFile</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> libraries that should be preloaded at postmaster start<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1843" title="utils/init/miscinit.c:1843">process_shared_preload_libraries</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize <a href="../utils/init/globals.c.html#L143" title="utils/init/globals.c:143">MaxBackends</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L575" title="utils/init/postinit.c:575">InitializeMaxBackends</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Give preloaded libraries a chance to request additional shared memory.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L1871" title="utils/init/miscinit.c:1871">process_shmem_requests</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that loadable modules have had their chance to request additional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared memory, determine the value of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> runtime-computed GUCs that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * depend on the amount of shared memory required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/ipc/ipci.c.html#L369" title="storage/ipc/ipci.c:369">InitializeShmemGUCs</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that modules have been loaded, we can process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> custom resource<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * managers specified in the <a href="../access/transam/xlog.c.html#L126" title="access/transam/xlog.c:126">wal_consistency_checking</a> GUC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L4751" title="access/transam/xlog.c:4751">InitializeWalConsistencyChecking</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../storage/ipc/ipci.c.html#L199" title="storage/ipc/ipci.c:199">CreateSharedMemoryAndSemaphores</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Remember stand-alone backend startup time,roughly at the same point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during startup that postmaster does so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L52" title="utils/adt/timestamp.c:52">PgStartTime</a> = <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create a per-backend PGPROC struct in shared memory. We must do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can use LWLocks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L296" title="storage/lmgr/proc.c:296">InitProcess</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now that sufficient infrastructure has been initialized, <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can do the rest.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a>(dbname, username);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> * <a href="#L4152" title="tcop/postgres.c:4152">PostgresMain</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp;&nbsp; postgres <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop -- all backends, interactive or otherwise loop here<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * dbname is the name of the database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to, username is the<br/></li>
<li></span><span class="Comment"> * PostgreSQL user name to be used for the session.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: Single user mode specific setup should go to <a href="#L4042" title="tcop/postgres.c:4042">PostgresSingleUserMain</a>()<br/></li>
<li></span><span class="Comment"> * if reasonably possible.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4152">&#x200c;</a></span><span class="linkable">PostgresMain</span>(<span class="Type">const</span> <span class="Type">char</span> *dbname, <span class="Type">const</span> <span class="Type">char</span> *username)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; sigjmp_buf&nbsp; &nbsp; local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* these must be volatile to ensure state is preserved across longjmp: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> send_ready_for_query = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> idle_in_transaction_timeout_enabled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> idle_session_timeout_enabled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(dbname != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(username != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(InitProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up signal handlers.&nbsp; (<a href="../utils/init/miscinit.c.html#L95" title="utils/init/miscinit.c:95">InitPostmasterChild</a> or <a href="../utils/init/miscinit.c.html#L181" title="utils/init/miscinit.c:181">InitStandaloneProcess</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has already set up <a href="../libpq/pqsignal.c.html#L23" title="libpq/pqsignal.c:23">BlockSig</a> and made that the active signal mask.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that postmaster blocked all signals <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> forking child process,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so there is no race condition whereby we might receive a signal <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we have set up the handler.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also note: it's best not to use <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> signals that are SIG_IGNored in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * postmaster.&nbsp; If such a signal arrives <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we are able to change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handler to non-SIG_IGN, it'll get dropped.&nbsp; Instead, make a dummy<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * handler in the postmaster to reserve the signal. (Of course, this isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an issue for signals that are locally generated, such as SIGALRM and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SIGPIPE.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L3590" title="replication/walsender.c:3590">WalSndSignals</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGHUP</span>, <a href="../postmaster/interrupt.c.html#L61" title="postmaster/interrupt.c:61">SignalHandlerForConfigReload</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGINT</span>, <a href="#L3002" title="tcop/postgres.c:3002">StatementCancelHandler</a>);&nbsp; &nbsp; <span class="Comment">/* cancel current query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGTERM</span>, <a href="#L2972" title="tcop/postgres.c:2972">die</a>); <span class="Comment">/* cancel current query and exit */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a postmaster child backend, replace <a href="../postmaster/interrupt.c.html#L73" title="postmaster/interrupt.c:73">SignalHandlerForCrashExit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with <a href="#L2875" title="tcop/postgres.c:2875">quickdie</a>, so we can tell the client we're dying.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a standalone backend, SIGQUIT can be generated from the keyboard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * easily, while SIGTERM cannot, so we make both signals do <a href="#L2972" title="tcop/postgres.c:2972">die</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than <a href="#L2875" title="tcop/postgres.c:2875">quickdie</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGQUIT</span>, <a href="#L2875" title="tcop/postgres.c:2875">quickdie</a>);&nbsp; &nbsp; <span class="Comment">/* hard crash time */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGQUIT</span>, <a href="#L2972" title="tcop/postgres.c:2972">die</a>); <span class="Comment">/* cancel current query and exit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L470" title="utils/misc/timeout.c:470">InitializeTimeouts</a>();&nbsp; &nbsp; <span class="Comment">/* establishes SIGALRM handler */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore failure to write to frontend. Note: if frontend closes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connection, we will notice it and exit cleanly when control <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * returns to outer loop.&nbsp; This seems safer than forcing exit in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * midst of output during who-knows-what operation...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGPIPE</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR1</span>, <a href="../storage/ipc/procsignal.c.html#L635" title="storage/ipc/procsignal.c:635">procsignal_sigusr1_handler</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGUSR2</span>, <span class="Constant">SIG_IGN</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGFPE</span>, <a href="#L3019" title="tcop/postgres.c:3019">FloatExceptionHandler</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset some signals that are accepted by postmaster but not by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pqsignal(<span class="Constant">SIGCHLD</span>, <span class="Constant">SIG_DFL</span>); <span class="Comment">/* system() requires this on some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * platforms */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Early initialization */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L645" title="utils/init/postinit.c:645">BaseInit</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need to allow SIGINT, etc during the initial transaction */<br/></li>
<li></span>&nbsp; &nbsp; sigprocmask(SIG_SETMASK, &amp;<a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * General initialization.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if you are tempted to add code in this vicinity, consider putting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it inside <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>() instead.&nbsp; In particular, anything that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involves database access should be there, not here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Honor session_preload_libraries if not dealing with a WAL sender.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a>(dbname, InvalidOid,&nbsp; &nbsp; <span class="Comment">/* database to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> to */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; username, InvalidOid,&nbsp; &nbsp; <span class="Comment">/* role to <a href="../port/win32/socket.c.html#L35" title="port/win32/socket.c:35">connect</a> as */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>) ? INIT_PG_LOAD_SESSION_LIBS : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no out_dbname */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> is still around, recycle the space; we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need it anymore after <a href="../utils/init/postinit.c.html#L736" title="utils/init/postinit.c:736">InitPostgres</a> completes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L454" title="utils/mmgr/mcxt.c:454">MemoryContextDelete</a>(<a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L151" title="utils/mmgr/mcxt.c:151">PostmasterContext</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; SetProcessingMode(NormalProcessing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now all GUC states are fully set up.&nbsp; Report them to client if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2548" title="utils/misc/guc.c:2548">BeginReportingGUCOptions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also set up handler to log session end; we have to wait till <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sure <a href="#L93" title="tcop/postgres.c:93">Log_disconnections</a> has its final value.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L117" title="utils/init/globals.c:117">IsUnderPostmaster</a> &amp;&amp; <a href="#L93" title="tcop/postgres.c:93">Log_disconnections</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a>(<a href="#L5109" title="tcop/postgres.c:5109">log_disconnections</a>, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/pgstat_database.c.html#L191" title="utils/activity/pgstat_database.c:191">pgstat_report_connect</a>(<a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform initialization specific to a WAL sender process. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L278" title="replication/walsender.c:278">InitWalSender</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Send this backend's cancellation info to the frontend.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L88" title="libpq/pqformat.c:88">pq_beginmessage</a>(&amp;buf, PqMsg_BackendKeyData);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, (int32) <a href="../utils/init/globals.c.html#L45" title="utils/init/globals.c:45">MyProcPid</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pq_sendint32(&amp;buf, (int32) <a href="../utils/init/globals.c.html#L50" title="utils/init/globals.c:50">MyCancelKey</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L296" title="libpq/pqformat.c:296">pq_endmessage</a>(&amp;buf);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need not flush since <a href="dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a> will do it. */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Welcome banner for standalone case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestDebug)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PostgreSQL stand-alone backend </span><span class="Special">%s\n</span><span class="Constant">&quot;</span>, PG_VERSION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the memory context we will use in the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> is reset once per iteration of the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> loop, ie, upon<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * completion of processing of each command message from the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a> = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create memory context and buffer used for RowDescription messages. As<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/common/printtup.c.html#L165" title="access/common/printtup.c:165">SendRowDescriptionMessage</a>(), via <a href="#L2597" title="tcop/postgres.c:2597">exec_describe_statement_message</a>(), is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * frequently executed for ever single statement, we don't want to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate a separate buffer every time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L170" title="tcop/postgres.c:170">row_description_context</a> = AllocSetContextCreate(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;RowDescriptionContext&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ALLOCSET_DEFAULT_SIZES);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="#L170" title="tcop/postgres.c:170">row_description_context</a>);<br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;<a href="#L171" title="tcop/postgres.c:171">row_description_buf</a>);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fire <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> defined login event triggers, if appropriate */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../commands/event_trigger.c.html#L890" title="commands/event_trigger.c:890">EventTriggerOnLogin</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * POSTGRES <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> processing loop begins here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an exception is encountered, processing resumes here so we abort the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current transaction and start a new one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * You might wonder why this isn't coded as an infinite loop around a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PG_TRY construct.&nbsp; The reason is that this is the bottom of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exception stack, and so with PG_TRY there would be no exception handler<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in force at all during the CATCH part.&nbsp; By leaving the outermost setjmp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * always active, we have at least some chance of recovering from an error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * during error recovery.&nbsp; (If we get into an infinite loop thereby, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will soon be stopped by overflow of elog.c's <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> state stack.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that we use sigsetjmp(..., 1), so that this function's signal mask<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (to wit, <a href="../libpq/pqsignal.c.html#L22" title="libpq/pqsignal.c:22">UnBlockSig</a>) will be restored when longjmp'ing to here.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is essential in case we longjmp'd out of a signal handler on a platform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * where that leaves the signal blocked.&nbsp; It's not redundant with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unblock in <a href="../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>() because the latter is only called if we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * were inside a transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sigsetjmp(local_sigjmp_buf, <span class="Constant">1</span>) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if you are tempted to add more code in this if-block,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consider the high probability that it should be in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>() instead.&nbsp; The only stuff done directly here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should be stuff that is guaranteed to apply *only* for outer-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * error recovery, such as adjusting the FE/BE protocol status.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Since not using PG_TRY, must reset error stack by hand */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prevent interrupts while cleaning up */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HOLD_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forget <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> pending QueryCancel request, since we're returning to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the idle loop anyway, and cancel <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> active timeout requests.&nbsp; (In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * future we might want to allow some timeout requests to survive, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * at minimum it'd be necessary to do <a href="../utils/misc/timeout.c.html#L540" title="utils/misc/timeout.c:540">reschedule_timeouts</a>(), in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we got here because of a query cancel interrupting the SIGALRM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * interrupt handler.)&nbsp; &nbsp; Note in particular that we must clear the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * statement and lock timeout indicators, to prevent <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> future plain<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query cancels from being misreported as timeouts in case we're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forgetting a timeout cancel.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L751" title="utils/misc/timeout.c:751">disable_all_timeouts</a>(<span class="Constant">false</span>);&nbsp; &nbsp; <span class="Comment">/* do first to avoid race condition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idle_in_transaction_timeout_enabled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idle_session_timeout_enabled = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not reading from the client anymore. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure libpq is in a good state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pq_comm_reset();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report the error to the client and/or server log */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1672" title="utils/error/elog.c:1672">EmitErrorReport</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If Valgrind noticed something during the erroneous query, <a href="../nodes/print.c.html#L36" title="nodes/print.c:36">print</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query string, assuming we have one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<a href="#L87" title="tcop/postgres.c:87">debug_query_string</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> gets reset <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we possibly clobber<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the storage it points at.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L87" title="tcop/postgres.c:87">debug_query_string</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Abort the current transaction in order to recover.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3387" title="access/transam/xact.c:3387">AbortCurrentTransaction</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/walsender.c.html#L327" title="replication/walsender.c:327">WalSndErrorCleanup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L917" title="utils/mmgr/portalmem.c:917">PortalErrorCleanup</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can't release replication slots inside <a href="../access/transam/xact.c.html#L2749" title="access/transam/xact.c:2749">AbortTransaction</a>() as we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to be able to start and abort transactions while having a slot<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * acquired. But we never need to hold them across top level errors,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so releasing here is fine. There also is a <a href="../storage/ipc/ipc.c.html#L337" title="storage/ipc/ipc.c:337">before_shmem_exit</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * callback ensuring correct <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> on FATAL errors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/slot.c.html#L138" title="replication/slot.c:138">MyReplicationSlot</a> != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/slot.c.html#L652" title="replication/slot.c:652">ReplicationSlotRelease</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We also want to <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> temporary slots on error. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../replication/slot.c.html#L745" title="replication/slot.c:745">ReplicationSlotCleanup</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../jit/jit.c.html#L127" title="jit/jit.c:127">jit_reset_after_error</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now return to normal top-level context and clear <a href="../utils/mmgr/mcxt.c.html#L150" title="utils/mmgr/mcxt.c:150">ErrorContext</a> for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1836" title="utils/error/elog.c:1836">FlushErrorState</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we were handling an extended-query-protocol message, initiate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> till <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> Sync.&nbsp; This also causes us not to issue<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a> (until we get Sync).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L151" title="tcop/postgres.c:151">ignore_till_sync</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We don't have a transaction command open anymore */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L137" title="tcop/postgres.c:137">xact_started</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If an error occurred while we were reading a message from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * client, we have potentially lost track of where the previous<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * message ends and the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> one begins.&nbsp; Even though we have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise recovered from the error, we cannot safely read <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages from the client, so there isn't much we can do with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * connection anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../libpq/pqcomm.c.html#L1180" title="libpq/pqcomm.c:1180">pq_is_reading_msg</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;terminating connection because protocol synchronization was lost&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now we can allow interrupts again */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; RESUME_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> handle ereport(ERROR) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L96" title="utils/error/elog.c:96">PG_exception_stack</a> = &amp;local_sigjmp_buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L151" title="tcop/postgres.c:151">ignore_till_sync</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; send_ready_for_query = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* initially, or after error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Non-error queries loop here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (;;)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstchar;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StringInfoData input_message;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At top of loop, reset extended-query-message flag, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * errors encountered in &quot;idle&quot; state don't provoke <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L150" title="tcop/postgres.c:150">doing_extended_query_message</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For valgrind reporting purposes, the &quot;current query&quot; begins here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef USE_VALGRIND<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L204" title="tcop/postgres.c:204">old_valgrind_error_count</a> = VALGRIND_COUNT_ERRORS;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Release storage left over from prior query cycle, and create a new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * query input buffer in the cleared <a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; initStringInfo(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also consider releasing our catalog snapshot if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, so that it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not preventing advance of global xmin while we wait for the client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L443" title="utils/time/snapmgr.c:443">InvalidateCatalogSnapshotConditionally</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (1) If we've reached idle state, tell the frontend we're ready for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a new query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: this includes fflush()'ing the last of the prior output.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This is also a good time to flush out collected statistics to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cumulative stats system, and to update the PS stats display.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * avoid doing those every time through the message loop because it'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slow down processing of batched messages, and because we don't want<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to report uncommitted updates (that confuses autovacuum).&nbsp; The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * notification processor wants a call too, if we are not in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction block.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Also, if an idle timeout is enabled, start the timer for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (send_ready_for_query)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L404" title="access/transam/xact.c:404">IsAbortedTransactionBlockState</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;idle in transaction (aborted)&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLEINTRANSACTION_ABORTED, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start the idle-in-transaction timer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a> &gt; <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a> &lt; <a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> || <a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idle_in_transaction_timeout_enabled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L4933" title="access/transam/xact.c:4933">IsTransactionOrTransactionBlock</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;idle in transaction&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLEINTRANSACTION, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start the idle-in-transaction timer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a> &gt; <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a> &lt; <a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> || <a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idle_in_transaction_timeout_enabled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(IDLE_IN_TRANSACTION_SESSION_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/lmgr/proc.c.html#L60" title="storage/lmgr/proc.c:60">IdleInTransactionSessionTimeout</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; stats_timeout;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process incoming notifies (including self-notifies), if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> relevant messages to the client.&nbsp; Doing it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here helps ensure stable behavior in tests: if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> notifies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * were received during the just-finished transaction, they'll<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be seen by the client <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a> is.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../commands/async.c.html#L413" title="commands/async.c:413">notifyInterruptPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/async.c.html#L1834" title="commands/async.c:1834">ProcessNotifyInterrupt</a>(<span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check if we need to report stats. If <a href="../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * decides it's too soon to flush out pending stats / lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contention prevented reporting, it'll tell us when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should try to report stats again (so that stats updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aren't unduly delayed if the connection goes idle for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * long time). We only enable the timeout if we don't already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have a timeout in progress, because we don't disable the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * timeout below. <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>() needs to determine<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current timestamp, which can have a negative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * performance impact. That's OK because <a href="../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * won't have us wake up sooner than a prior call.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats_timeout = <a href="../utils/activity/pgstat.c.html#L579" title="utils/activity/pgstat.c:579">pgstat_report_stat</a>(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stats_timeout &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(IDLE_STATS_UPDATE_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(IDLE_STATS_UPDATE_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stats_timeout);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all stats flushed, no need for the timeout */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(IDLE_STATS_UPDATE_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(IDLE_STATS_UPDATE_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;idle&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_IDLE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Start the idle-session timer */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L62" title="storage/lmgr/proc.c:62">IdleSessionTimeout</a> &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idle_session_timeout_enabled = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(IDLE_SESSION_TIMEOUT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../storage/lmgr/proc.c.html#L62" title="storage/lmgr/proc.c:62">IdleSessionTimeout</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> recently-changed GUC options */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2598" title="utils/misc/guc.c:2598">ReportChangedGUCOptions</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dest.c.html#L256" title="tcop/dest.c:256">ReadyForQuery</a>(<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send_ready_for_query = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (2) Allow asynchronous signals to be executed immediately if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * come in while we are <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for client input. (This must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conditional since we don't want, say, reads on behalf of COPY FROM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * STDIN doing the same thing.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (3) read a command (loop blocks here)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; firstchar = <a href="#L488" title="tcop/postgres.c:488">ReadCommand</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (4) turn off the idle-in-transaction and idle-session timeouts if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * active.&nbsp; We do this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> step (5) so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> last-moment timeout<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is certain to be detected in step (5).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At most one of these timeouts will be active, so there's no need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * worry about combining the timeout.c calls into one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idle_in_transaction_timeout_enabled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(IDLE_IN_TRANSACTION_SESSION_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idle_in_transaction_timeout_enabled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idle_session_timeout_enabled)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(IDLE_SESSION_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idle_session_timeout_enabled = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (5) disable async signal conditions again.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Query cancel is supposed to be a no-op when there is no query in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * progress, so if a query cancel arrived while we were idle, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset <a href="../utils/init/globals.c.html#L31" title="utils/init/globals.c:31">QueryCancelPending</a>. <a href="#L3244" title="tcop/postgres.c:3244">ProcessInterrupts</a>() has that effect when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's called when <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> is set, so check for interrupts<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> resetting <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L144" title="tcop/postgres.c:144">DoingCommandRead</a> = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (6) check for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other interesting events that happened while we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * slept.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../postmaster/interrupt.c.html#L27" title="postmaster/interrupt.c:27">ConfigReloadPending</a> = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ProcessConfigFile(PGC_SIGHUP);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (7) process the command.&nbsp; But ignore it if we're skipping till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sync.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L151" title="tcop/postgres.c:151">ignore_till_sync</a> &amp;&amp; firstchar != <span class="Constant">EOF</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (firstchar)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Query:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../replication/walsender.c.html#L1977" title="replication/walsender.c:1977">exec_replication_command</a>(query_string))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1013" title="tcop/postgres.c:1013">exec_simple_query</a>(query_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1013" title="tcop/postgres.c:1013">exec_simple_query</a>(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(query_string);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send_ready_for_query = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Parse:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stmt_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *query_string;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numParams;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *paramTypes = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(firstchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt_name = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; query_string = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numParams = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;input_message, <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (numParams &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes = palloc_array(Oid, numParams);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; numParams; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; paramTypes[i] = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;input_message, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1391" title="tcop/postgres.c:1391">exec_parse_message</a>(query_string, stmt_name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; paramTypes, numParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(query_string);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Bind:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(firstchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this message is complex enough that it seems best to put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the field extraction out-of-line<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1626" title="tcop/postgres.c:1626">exec_bind_message</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L1626" title="tcop/postgres.c:1626">exec_bind_message</a> does <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Execute:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *portal_name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_rows;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(firstchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal_name = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; max_rows = <a href="../libpq/pqformat.c.html#L415" title="libpq/pqformat.c:415">pq_getmsgint</a>(&amp;input_message, <span class="Constant">4</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2085" title="tcop/postgres.c:2085">exec_execute_message</a>(portal_name, max_rows);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L2085" title="tcop/postgres.c:2085">exec_execute_message</a> does <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_FunctionCall:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(firstchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Report query to various monitoring facilities. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L503" title="utils/activity/backend_status.c:503">pgstat_report_activity</a>(STATE_FASTPATH, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set_ps_display(<span class="Constant">&quot;&lt;FASTPATH&gt;&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* start an xact for this function invocation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2743" title="tcop/postgres.c:2743">start_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we may at this point be inside an aborted<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction.&nbsp; We can't throw error for that until we've<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finished reading the function-call message, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="fastpath.c.html#L189" title="tcop/fastpath.c:189">HandleFunctionRequest</a>() must check for it after doing so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Be careful not to do anything that assumes we're inside a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * valid transaction here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* switch back to message context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L153" title="utils/mmgr/mcxt.c:153">MessageContext</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="fastpath.c.html#L189" title="tcop/fastpath.c:189">HandleFunctionRequest</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* commit the function-invocation transaction */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<span class="Constant">&quot;fastpath function call&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send_ready_for_query = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Close:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *close_target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(firstchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close_type = <a href="../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close_target = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (close_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (close_target[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/prepare.c.html#L516" title="commands/prepare.c:516">DropPreparedStatement</a>(close_target, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* special-case the unnamed statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2850" title="tcop/postgres.c:2850">drop_unnamed_stmt</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'P'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Portal&nbsp; &nbsp; &nbsp; &nbsp; portal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; portal = <a href="../utils/mmgr/portalmem.c.html#L130" title="utils/mmgr/portalmem.c:130">GetPortalByName</a>(close_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (PortalIsValid(portal))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/portalmem.c.html#L468" title="utils/mmgr/portalmem.c:468">PortalDrop</a>(portal, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid CLOSE message subtype </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; close_type)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L388" title="libpq/pqformat.c:388">pq_putemptymessage</a>(PqMsg_CloseComplete);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<span class="Constant">&quot;CLOSE message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Describe:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; describe_type;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *describe_target;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4939" title="tcop/postgres.c:4939">forbidden_in_wal_sender</a>(firstchar);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set <a href="../utils/adt/timestamp.c.html#L1624" title="utils/adt/timestamp.c:1624">statement_timestamp</a>() (needed for xact) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L911" title="access/transam/xact.c:911">SetCurrentStatementStartTimestamp</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; describe_type = <a href="../libpq/pqformat.c.html#L399" title="libpq/pqformat.c:399">pq_getmsgbyte</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; describe_target = <a href="../libpq/pqformat.c.html#L579" title="libpq/pqformat.c:579">pq_getmsgstring</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (describe_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'S'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2597" title="tcop/postgres.c:2597">exec_describe_statement_message</a>(describe_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">'P'</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2691" title="tcop/postgres.c:2691">exec_describe_portal_message</a>(describe_target);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid DESCRIBE message subtype </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; describe_type)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<span class="Constant">&quot;DESCRIBE message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Flush:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq_flush();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Sync:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../libpq/pqformat.c.html#L635" title="libpq/pqformat.c:635">pq_getmsgend</a>(&amp;input_message);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2771" title="tcop/postgres.c:2771">finish_xact_command</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L212" title="tcop/postgres.c:212">valgrind_report_error_query</a>(<span class="Constant">&quot;SYNC message&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; send_ready_for_query = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * 'X' means that the frontend is closing down the <a href="../port/win32/socket.c.html#L31" title="port/win32/socket.c:31">socket</a>. EOF<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * means unexpected loss of frontend connection. Either way,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perform normal shutdown.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> <span class="Constant">EOF</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* for the cumulative statistics system */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/pgstat_database.c.html#L32" title="utils/activity/pgstat_database.c:32">pgStatSessionEndCause</a> = DISCONNECT_CLIENT_EOF;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALLTHROUGH */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_Terminate:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Reset <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> to prevent ereport from attempting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> more messages to client.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> == DestRemote)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L90" title="tcop/postgres.c:90">whereToSendOutput</a> = DestNone;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if you are tempted to add more code here, DON'T!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Whatever you had in mind to do should be set up as an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> or <a href="../storage/ipc/ipc.c.html#L365" title="storage/ipc/ipc.c:365">on_shmem_exit</a> callback, instead. Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it will fail to be called during other backend-shutdown<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * scenarios.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/ipc/ipc.c.html#L104" title="storage/ipc/ipc.c:104">proc_exit</a>(<span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyData:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyDone:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PqMsg_CopyFail:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Accept but ignore these messages, per protocol spec; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * probably got here because a COPY failed, and the frontend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is still sending data.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(FATAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid frontend message type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; firstchar)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* end of input-reading loop */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Throw an error if we're a WAL sender process.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used to forbid anything else than simple query protocol messages<br/></li>
<li></span><span class="Comment"> * in a WAL sender process.&nbsp; 'firstchar' specifies what kind of a forbidden<br/></li>
<li></span><span class="Comment"> * message was received, and is used to construct the error message.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4939">&#x200c;</a></span><span class="linkable">forbidden_in_wal_sender</span>(<span class="Type">char</span> firstchar)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../replication/walsender.c.html#L115" title="replication/walsender.c:115">am_walsender</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (firstchar == PqMsg_FunctionCall)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;fastpath function calls not supported in a replication connection&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_PROTOCOL_VIOLATION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;extended query protocol not supported in a replication connection&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Obtain platform stack depth limit (in bytes)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Return -1 if unknown<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">long<br/></li>
<li><a id="L4961">&#x200c;</a></span><span class="linkable">get_stack_depth_rlimit</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li><span class="PreProc">#if defined(HAVE_GETRLIMIT)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type">long</span> val = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This won't change after process launch, so check just once */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (val == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">struct</span> rlimit rlim;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (getrlimit(RLIMIT_STACK, &amp;rlim) &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rlim.rlim_cur == RLIM_INFINITY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <span class="Constant">LONG_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* rlim_cur is probably of an unsigned type, so check for overflow */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rlim.rlim_cur &gt;= <span class="Constant">LONG_MAX</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <span class="Constant">LONG_MAX</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = rlim.rlim_cur;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> val;<br/></li>
<li><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* On Windows we set the backend stack size in src/backend/Makefile */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> WIN32_STACK_RLIMIT;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><a id="L4989">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> rusage <span class="linkable">Save_r</span>;<br/></li>
<li><a id="L4990">&#x200c;</a><span class="Type">static</span> <span class="Type">struct</span> timeval <span class="linkable">Save_t</span>;<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L4993">&#x200c;</a></span><span class="linkable">ResetUsage</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; getrusage(RUSAGE_SELF, &amp;<a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>);<br/></li>
<li>&nbsp; &nbsp; gettimeofday(&amp;<a href="#L4990" title="tcop/postgres.c:4990">Save_t</a>, <span class="Constant">NULL</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L5000">&#x200c;</a></span><span class="linkable">ShowUsage</span>(<span class="Type">const</span> <span class="Type">char</span> *title)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData str;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval user,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sys;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> timeval elapse_t;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">struct</span> rusage r;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; getrusage(RUSAGE_SELF, &amp;r);<br/></li>
<li>&nbsp; &nbsp; gettimeofday(&amp;elapse_t, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) &amp;user, (<span class="Type">char</span> *) &amp;r.ru_utime, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(user));<br/></li>
<li>&nbsp; &nbsp; memcpy((<span class="Type">char</span> *) &amp;sys, (<span class="Type">char</span> *) &amp;r.ru_stime, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(sys));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (elapse_t.tv_usec &lt; <a href="#L4990" title="tcop/postgres.c:4990">Save_t</a>.tv_usec)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elapse_t.tv_sec--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elapse_t.tv_usec += <span class="Constant">1000000</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r.ru_utime.tv_usec &lt; <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_utime.tv_usec)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r.ru_utime.tv_sec--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r.ru_utime.tv_usec += <span class="Constant">1000000</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (r.ru_stime.tv_usec &lt; <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_stime.tv_usec)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r.ru_stime.tv_sec--;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; r.ru_stime.tv_usec += <span class="Constant">1000000</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The only stats we don't show here are ixrss, idrss, isrss.&nbsp; It takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * some work to interpret them, and most platforms don't fill them in.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; initStringInfo(&amp;str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;str, <span class="Constant">&quot;! system usage stats:</span><span class="Special">\n</span><span class="Constant">&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t%ld</span><span class="Constant">.</span><span class="Special">%06ld</span><span class="Constant"> s user, </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%06ld</span><span class="Constant"> s system, </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%06ld</span><span class="Constant"> s elapsed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (r.ru_utime.tv_sec - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_utime.tv_sec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (r.ru_utime.tv_usec - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_utime.tv_usec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (r.ru_stime.tv_sec - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_stime.tv_sec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (r.ru_stime.tv_usec - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_stime.tv_usec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (elapse_t.tv_sec - <a href="#L4990" title="tcop/postgres.c:4990">Save_t</a>.tv_sec),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) (elapse_t.tv_usec - <a href="#L4990" title="tcop/postgres.c:4990">Save_t</a>.tv_usec));<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t</span><span class="Constant">[</span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%06ld</span><span class="Constant"> s user, </span><span class="Special">%ld</span><span class="Constant">.</span><span class="Special">%06ld</span><span class="Constant"> s system total]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) user.tv_sec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) user.tv_usec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) sys.tv_sec,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">long</span>) sys.tv_usec);<br/></li>
<li><span class="PreProc">#ifndef WIN32<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The following rusage fields are not defined by POSIX, but they're<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present on all current Unix-like systems so we use them without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * special checks.&nbsp; Some of these could be provided in our Windows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * emulation in src/port/win32getrusage.c with more work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t%ld</span><span class="Constant"> kB max resident size</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li><span class="PreProc">#if defined(__darwin__)<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* in bytes on macOS */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_maxrss / <span class="Constant">1024<br/></li>
<li></span><span class="PreProc">#else<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* in kilobytes on most other platforms */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_maxrss<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; );<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant"> [</span><span class="Special">%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant">] filesystem blocks in/out</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_inblock - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_inblock,<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* they only drink coffee at dec */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_oublock - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_oublock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_inblock, r.ru_oublock);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant"> [</span><span class="Special">%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant">] page faults/reclaims, </span><span class="Special">%ld</span><span class="Constant"> [</span><span class="Special">%ld</span><span class="Constant">] swaps</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_majflt - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_majflt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_minflt - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_minflt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_majflt, r.ru_minflt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nswap - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_nswap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nswap);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t%ld</span><span class="Constant"> [</span><span class="Special">%ld</span><span class="Constant">] signals rcvd, </span><span class="Special">%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant"> [</span><span class="Special">%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant">] messages rcvd/sent</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nsignals - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_nsignals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nsignals,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_msgrcv - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_msgrcv,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_msgsnd - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_msgsnd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_msgrcv, r.ru_msgsnd);<br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;str,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;!</span><span class="Special">\t%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant"> [</span><span class="Special">%ld</span><span class="Constant">/</span><span class="Special">%ld</span><span class="Constant">] voluntary/involuntary context switches</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nvcsw - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_nvcsw,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nivcsw - <a href="#L4989" title="tcop/postgres.c:4989">Save_r</a>.ru_nivcsw,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; r.ru_nvcsw, r.ru_nivcsw);<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !WIN32 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove trailing <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (str.data[str.len - <span class="Constant">1</span>] == <span class="Special">'\n'</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; str.data[--str.len] = <span class="Special">'\0'</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, title),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>, str.data)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(str.data);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="../storage/ipc/ipc.c.html#L309" title="storage/ipc/ipc.c:309">on_proc_exit</a> handler to log end of session<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5109">&#x200c;</a></span><span class="linkable">log_disconnections</span>(<span class="Type">int</span> code, Datum arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Port&nbsp; &nbsp; &nbsp;&nbsp; *port = <a href="../utils/init/globals.c.html#L49" title="utils/init/globals.c:49">MyProcPort</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; secs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; usecs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; msecs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hours,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minutes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seconds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1730" title="utils/adt/timestamp.c:1730">TimestampDifference</a>(<a href="../utils/init/globals.c.html#L47" title="utils/init/globals.c:47">MyStartTimestamp</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/timestamp.c.html#L1654" title="utils/adt/timestamp.c:1654">GetCurrentTimestamp</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;secs, &amp;usecs);<br/></li>
<li>&nbsp; &nbsp; msecs = usecs / <span class="Constant">1000</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hours = secs / SECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; secs %= SECS_PER_HOUR;<br/></li>
<li>&nbsp; &nbsp; minutes = secs / SECS_PER_MINUTE;<br/></li>
<li>&nbsp; &nbsp; seconds = secs % SECS_PER_MINUTE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;disconnection: session time: </span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">:</span><span class="Special">%02d</span><span class="Constant">.</span><span class="Special">%03d</span><span class="Constant"> &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;user=</span><span class="Special">%s</span><span class="Constant"> database=</span><span class="Special">%s</span><span class="Constant"> host=</span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hours, minutes, seconds, msecs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;user_name, port-&gt;database_name, port-&gt;remote_host,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; port-&gt;remote_port[<span class="Constant">0</span>] ? <span class="Constant">&quot; port=&quot;</span> : <span class="Constant">&quot;&quot;</span>, port-&gt;remote_port)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Start statement timeout timer, if enabled.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there's already a timeout running, don't restart the timer.&nbsp; That<br/></li>
<li></span><span class="Comment"> * enables compromises between accuracy of timeouts and cost of starting a<br/></li>
<li></span><span class="Comment"> * timeout.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5145">&#x200c;</a></span><span class="linkable">enable_statement_timeout</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* must be within an xact */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L137" title="tcop/postgres.c:137">xact_started</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/lmgr/proc.c.html#L58" title="storage/lmgr/proc.c:58">StatementTimeout</a> &gt; <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (<a href="../storage/lmgr/proc.c.html#L58" title="storage/lmgr/proc.c:58">StatementTimeout</a> &lt; <a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> || <a href="../storage/lmgr/proc.c.html#L61" title="storage/lmgr/proc.c:61">TransactionTimeout</a> == <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(STATEMENT_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L560" title="utils/misc/timeout.c:560">enable_timeout_after</a>(STATEMENT_TIMEOUT, <a href="../storage/lmgr/proc.c.html#L58" title="storage/lmgr/proc.c:58">StatementTimeout</a>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(STATEMENT_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(STATEMENT_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Disable statement timeout, if active.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L5167">&#x200c;</a></span><span class="linkable">disable_statement_timeout</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/misc/timeout.c.html#L780" title="utils/misc/timeout.c:780">get_timeout_active</a>(STATEMENT_TIMEOUT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/timeout.c.html#L685" title="utils/misc/timeout.c:685">disable_timeout</a>(STATEMENT_TIMEOUT, <span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
