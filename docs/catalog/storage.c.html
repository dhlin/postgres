<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>catalog/storage.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>catalog/storage.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L76">pendingDeletes</a></li>
<li><a href="#L77">pendingSyncHash</a></li>
<li><a href="#L39">wal_skip_threshold</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L61">PendingRelDelete</a></li>
<li><a href="#L68">PendingRelDelete</a></li>
<li><a href="#L70">PendingRelSync</a></li>
<li><a href="#L74">PendingRelSync</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L85">AddPendingSync</a></li>
<li><a href="#L934">AtSubAbort_smgr</a></li>
<li><a href="#L914">AtSubCommit_smgr</a></li>
<li><a href="#L546">EstimatePendingSyncsSpace</a></li>
<li><a href="#L893">PostPrepare_smgr</a></li>
<li><a href="#L532">RelFileLocatorSkippingWAL</a></li>
<li><a href="#L452">RelationCopyStorage</a></li>
<li><a href="#L121">RelationCreateStorage</a></li>
<li><a href="#L206">RelationDropStorage</a></li>
<li><a href="#L424">RelationPreTruncate</a></li>
<li><a href="#L251">RelationPreserveStorage</a></li>
<li><a href="#L288">RelationTruncate</a></li>
<li><a href="#L610">RestorePendingSyncs</a></li>
<li><a href="#L559">SerializePendingSyncs</a></li>
<li><a href="#L186">log_smgrcreate</a></li>
<li><a href="#L632">smgrDoPendingDeletes</a></li>
<li><a href="#L700">smgrDoPendingSyncs</a></li>
<li><a href="#L852">smgrGetPendingDeletes</a></li>
<li><a href="#L940">smgr_redo</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * storage.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; code to create and destroy physical storage for relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/catalog/storage.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Some of this code used to be in storage/smgr/smgr.c, and the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; function names still reflect that.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xloginsert.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xlogutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bulk_write.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/freespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/hsearch.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* GUC variables */<br/></li>
<li><a id="L39">&#x200c;</a></span><span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">wal_skip_threshold</span> = <span class="Constant">2048</span>;&nbsp; &nbsp; <span class="Comment">/* in kilobytes */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * We keep a list of all relations (represented as RelFileLocator <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>)<br/></li>
<li></span><span class="Comment"> * that have been created or deleted in the current transaction.&nbsp; When<br/></li>
<li></span><span class="Comment"> * a relation is created, we create the physical file immediately, but<br/></li>
<li></span><span class="Comment"> * remember it so that we can delete the file again if the current<br/></li>
<li></span><span class="Comment"> * transaction is aborted.&nbsp; Conversely, a deletion request is NOT<br/></li>
<li></span><span class="Comment"> * executed immediately, but is just entered in the list.&nbsp; When and if<br/></li>
<li></span><span class="Comment"> * the transaction commits, we can delete the physical file.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To handle subtransactions, every entry is marked with its transaction<br/></li>
<li></span><span class="Comment"> * nesting level.&nbsp; At subtransaction commit, we reassign the subtransaction's<br/></li>
<li></span><span class="Comment"> * entries to the parent nesting level.&nbsp; At subtransaction abort, we can<br/></li>
<li></span><span class="Comment"> * immediately execute the abort-time actions for all entries of the current<br/></li>
<li></span><span class="Comment"> * nesting level.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the list is kept in <a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a> to be sure it won't disappear<br/></li>
<li></span><span class="Comment"> * unbetimes.&nbsp; It'd probably be OK to keep it in <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>,<br/></li>
<li></span><span class="Comment"> * but I'm being paranoid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L61">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PendingRelDelete</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;&nbsp; &nbsp; <span class="Comment">/* relation that may need to be deleted */<br/></li>
<li></span>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; procNumber;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* INVALID_PROC_NUMBER if not a temp rel */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; atCommit;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* T=delete at commit; F=delete at abort */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestLevel;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* xact nesting level of request */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">struct</span> <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;&nbsp; &nbsp; <span class="Comment">/* linked-list link */<br/></li>
<li><a id="L68">&#x200c;</a></span>} <span class="linkable">PendingRelDelete</span>;<br/></li>
<li><br/></li>
<li><a id="L70">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">PendingRelSync</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator rlocator;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_truncated;&nbsp; &nbsp; <span class="Comment">/* Has the file experienced truncation? */<br/></li>
<li><a id="L74">&#x200c;</a></span>} <span class="linkable">PendingRelSync</span>;<br/></li>
<li><br/></li>
<li><a id="L76">&#x200c;</a><span class="Type">static</span> <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *<span class="linkable">pendingDeletes</span> = <span class="Constant">NULL</span>; <span class="Comment">/* head of linked list */<br/></li>
<li><a id="L77">&#x200c;</a></span><span class="Type">static</span> <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">pendingSyncHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L85" title="catalog/storage.c:85">AddPendingSync</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Queue an at-commit fsync.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L85">&#x200c;</a></span><span class="linkable">AddPendingSync</span>(<span class="Type">const</span> RelFileLocator *rlocator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="catalog/storage.c:70">PendingRelSync</a> *pending;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* create the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> if not yet */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L70" title="catalog/storage.c:70">PendingRelSync</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.hcxt = <a href="../utils/mmgr/mcxt.c.html#L154" title="utils/mmgr/mcxt.c:154">TopTransactionContext</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;pending sync <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>, <span class="Constant">16</span>, &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pending = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>, rlocator, HASH_ENTER, &amp;found);<br/></li>
<li>&nbsp; &nbsp; Assert(!found);<br/></li>
<li>&nbsp; &nbsp; pending-&gt;is_truncated = <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L121" title="catalog/storage.c:121">RelationCreateStorage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create physical storage for a relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create the underlying disk file storage for the relation. This only<br/></li>
<li></span><span class="Comment"> * creates the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork; additional forks are created lazily by the<br/></li>
<li></span><span class="Comment"> * modules that need them.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is transactional. The creation is WAL-logged, and if the<br/></li>
<li></span><span class="Comment"> * transaction aborts later on, the storage will be destroyed.&nbsp; A caller<br/></li>
<li></span><span class="Comment"> * that does not want the storage to be destroyed in case of an abort may<br/></li>
<li></span><span class="Comment"> * pass register_delete = false.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SMgrRelation<br/></li>
<li><a id="L121">&#x200c;</a><span class="linkable">RelationCreateStorage</span>(RelFileLocator rlocator, <span class="Type">char</span> relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> register_delete)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; procNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; needs_wal;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!<a href="../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>());&nbsp; &nbsp; <span class="Comment">/* couldn't update <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (relpersistence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procNumber = ProcNumberForTempRelations();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_wal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_UNLOGGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_wal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_PERMANENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; needs_wal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid relpersistence: </span><span class="Special">%c</span><span class="Constant">&quot;</span>, relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* placate compiler */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; srel = <a href="../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(rlocator, procNumber);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(srel, MAIN_FORKNUM, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needs_wal)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L186" title="catalog/storage.c:186">log_smgrcreate</a>(&amp;srel-&gt;smgr_rlocator.locator, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add the relation to the list of stuff to delete at abort, if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * asked to do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (register_delete)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending = (<a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;rlocator = rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;procNumber = procNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;atCommit = <span class="Constant">false</span>;&nbsp; &nbsp; <span class="Comment">/* delete if abort */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;nestLevel = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a> = pending;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relpersistence == RELPERSISTENCE_PERMANENT &amp;&amp; !XLogIsNeeded())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(procNumber == INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="catalog/storage.c:85">AddPendingSync</a>(&amp;rlocator);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> srel;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Perform <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a> of an XLOG_SMGR_CREATE record to WAL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L186">&#x200c;</a></span><span class="linkable">log_smgrcreate</span>(<span class="Type">const</span> RelFileLocator *rlocator, ForkNumber forkNum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; xl_smgr_create xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make an XLOG entry reporting the file creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; xlrec.rlocator = *rlocator;<br/></li>
<li>&nbsp; &nbsp; xlrec.forkNum = forkNum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SMGR_ID, XLOG_SMGR_CREATE | XLR_SPECIAL_REL_UPDATE);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L206" title="catalog/storage.c:206">RelationDropStorage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Schedule unlinking of physical storage at transaction commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L206">&#x200c;</a></span><span class="linkable">RelationDropStorage</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add the relation to the list of stuff to delete at commit */<br/></li>
<li></span>&nbsp; &nbsp; pending = (<a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1180" title="utils/mmgr/mcxt.c:1180">MemoryContextAlloc</a>(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a>));<br/></li>
<li>&nbsp; &nbsp; pending-&gt;rlocator = rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; pending-&gt;procNumber = rel-&gt;rd_backend;<br/></li>
<li>&nbsp; &nbsp; pending-&gt;atCommit = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* delete if commit */<br/></li>
<li></span>&nbsp; &nbsp; pending-&gt;nestLevel = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a> = pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: if the relation was created in this transaction, it will <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * present in the pending-delete list twice, once with atCommit true and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * once with atCommit false.&nbsp; Hence, it will be physically deleted at end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of xact in either case (and the other entry will be ignored by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L632" title="catalog/storage.c:632">smgrDoPendingDeletes</a>, so no error will occur).&nbsp; We could instead remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the existing list entry and delete the physical file immediately, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> I'll keep the logic simple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; RelationCloseSmgr(rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L251" title="catalog/storage.c:251">RelationPreserveStorage</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark a relation as not to be deleted after all.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need this function because relation mapping changes are committed<br/></li>
<li></span><span class="Comment"> * separately from commit of the whole transaction, so it's still possible<br/></li>
<li></span><span class="Comment"> * for the transaction to abort after the mapping update is done.<br/></li>
<li></span><span class="Comment"> * When a new physical relation is installed in the map, it would be<br/></li>
<li></span><span class="Comment"> * scheduled for delete-on-abort, so we'd delete it, and be in trouble.<br/></li>
<li></span><span class="Comment"> * The relation mapper fixes this by telling us to not delete such relations<br/></li>
<li></span><span class="Comment"> * after all as part of its commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We also use this to reuse an old build of an index during ALTER TABLE, this<br/></li>
<li></span><span class="Comment"> * time removing the delete-at-commit entry.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * No-op if the relation is not among those scheduled for deletion.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L251">&#x200c;</a></span><span class="linkable">RelationPreserveStorage</span>(RelFileLocator rlocator, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> atCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *prev;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (RelFileLocatorEquals(rlocator, pending-&gt;rlocator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; pending-&gt;atCommit == atCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unlink and delete list entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a> = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pending);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prev does not change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unrelated entry, don't touch it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = pending;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L288" title="catalog/storage.c:288">RelationTruncate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Physically truncate a relation to the specified number of blocks.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This includes getting rid of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffers for the blocks that are to be<br/></li>
<li></span><span class="Comment"> * dropped.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L288">&#x200c;</a></span><span class="linkable">RelationTruncate</span>(Relation rel, BlockNumber nblocks)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; fsm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; vm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_fsm_vacuum = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forks[MAX_FORKNUM];<br/></li>
<li>&nbsp; &nbsp; BlockNumber blocks[MAX_FORKNUM];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure smgr_targblock etc aren't pointing somewhere past new end.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Note: don't rely on this reln pointer below this loop.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; reln = RelationGetSmgr(rel);<br/></li>
<li>&nbsp; &nbsp; reln-&gt;smgr_targblock = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt;= MAX_FORKNUM; ++i)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln-&gt;smgr_cached_nblocks[i] = InvalidBlockNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare for truncation of MAIN fork of the relation */<br/></li>
<li></span>&nbsp; &nbsp; forks[nforks] = MAIN_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; blocks[nforks] = nblocks;<br/></li>
<li>&nbsp; &nbsp; nforks++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare for truncation of the FSM if it exists */<br/></li>
<li></span>&nbsp; &nbsp; fsm = <a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(RelationGetSmgr(rel), FSM_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fsm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocks[nforks] = <a href="../storage/freespace/freespace.c.html#L275" title="storage/freespace/freespace.c:275">FreeSpaceMapPrepareTruncateRel</a>(rel, nblocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blocks[nforks]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forks[nforks] = FSM_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_fsm_vacuum = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare for truncation of the visibility map too if it exists */<br/></li>
<li></span>&nbsp; &nbsp; vm = <a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(RelationGetSmgr(rel), VISIBILITYMAP_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (vm)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; blocks[nforks] = <a href="../access/heap/visibilitymap.c.html#L438" title="access/heap/visibilitymap.c:438">visibilitymap_prepare_truncate</a>(rel, nblocks);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blocks[nforks]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forks[nforks] = VISIBILITYMAP_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L424" title="catalog/storage.c:424">RelationPreTruncate</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure that a concurrent checkpoint can't complete while truncation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is in progress.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The truncation operation might drop buffers that the checkpoint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise would have flushed. If it does, then it's essential that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * files actually get truncated on disk <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the checkpoint record is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * written. Otherwise, if reply begins from that checkpoint, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to-be-truncated blocks might still exist on disk but have older<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents than expected, which can cause replay to fail. It's OK for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * blocks to not exist on disk at all, but not for them to have the wrong<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert((<a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp; DELAY_CHKPT_COMPLETE) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags |= DELAY_CHKPT_COMPLETE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We WAL-log the truncation <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually truncating, which means<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trouble if the truncation fails. If we then crash, the WAL replay<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * likely isn't going to succeed in the truncation either, and cause a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * PANIC. It's tempting to put a critical section here, but that cure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * would be worse than the disease. It would turn a usually harmless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure to truncate, that might spell trouble at WAL replay, into a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certain PANIC.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RelationNeedsWAL(rel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make an XLOG entry reporting the file truncation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_truncate xlrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.blkno = nblocks;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.rlocator = rel-&gt;rd_locator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xlrec.flags = SMGR_TRUNCATE_ALL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L149" title="access/transam/xloginsert.c:149">XLogBeginInsert</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L364" title="access/transam/xloginsert.c:364">XLogRegisterData</a>((<span class="Type">char</span> *) &amp;xlrec, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(xlrec));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lsn = <a href="../access/transam/xloginsert.c.html#L474" title="access/transam/xloginsert.c:474">XLogInsert</a>(RM_SMGR_ID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; XLOG_SMGR_TRUNCATE | XLR_SPECIAL_REL_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Flush, because otherwise the truncation of the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> relation might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hit the disk <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the WAL record, and the truncation of the FSM<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or visibility map. If we crashed during that window, we'd be left<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * with a truncated heap, but the FSM or visibility map would still<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contain entries for the non-existent heap pages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (fsm || vm)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This will first remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> buffers from the buffer pool that should no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * longer exist after truncation is complete, and then truncate the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * corresponding files on disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L703" title="storage/smgr/smgr.c:703">smgrtruncate</a>(RelationGetSmgr(rel), forks, nforks, blocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We've done all the critical work, so checkpoints are OK <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/proc.c.html#L66" title="storage/lmgr/proc.c:66">MyProc</a>-&gt;delayChkptFlags &amp;= ~DELAY_CHKPT_COMPLETE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level FSM pages to account for the truncation. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * important because the just-truncated pages were likely marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * all-free, and would be preferentially selected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NB: There's no point in delaying checkpoints until this is done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because the FSM is not WAL-logged, we have to be prepared for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibility of corruption after a crash anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (need_fsm_vacuum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(rel, nblocks, InvalidBlockNumber);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L424" title="catalog/storage.c:424">RelationPreTruncate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Perform AM-independent work <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> a physical truncation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an access method's relation_nontransactional_truncate does not call<br/></li>
<li></span><span class="Comment"> * <a href="#L288" title="catalog/storage.c:288">RelationTruncate</a>(), it must call this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> decreasing the table size.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L424">&#x200c;</a></span><span class="linkable">RelationPreTruncate</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="catalog/storage.c:70">PendingRelSync</a> *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pending = <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;(RelationGetSmgr(rel)-&gt;smgr_rlocator.locator),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pending)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;is_truncated = <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Copy a fork's data, block by block.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this requires that there is no dirty data in shared buffers. If<br/></li>
<li></span><span class="Comment"> * it's possible that there are, callers need to flush those using<br/></li>
<li></span><span class="Comment"> * e.g. <a href="../storage/buffer/bufmgr.c.html#L4435" title="storage/buffer/bufmgr.c:4435">FlushRelationBuffers</a>(rel).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Also note that this is frequently called via locutions such as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L452" title="catalog/storage.c:452">RelationCopyStorage</a>(RelationGetSmgr(rel), ...);<br/></li>
<li></span><span class="Comment"> * That's safe only because we perform only smgr and WAL operations here.<br/></li>
<li></span><span class="Comment"> * If we invoked anything else, a relcache flush could cause our SMgrRelation<br/></li>
<li></span><span class="Comment"> * argument to become a dangling pointer.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L452">&#x200c;</a></span><span class="linkable">RelationCopyStorage</span>(SMgrRelation src, SMgrRelation dst,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ForkNumber forkNum, <span class="Type">char</span> relpersistence)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; use_wal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; copying_initfork;<br/></li>
<li>&nbsp; &nbsp; BlockNumber nblocks;<br/></li>
<li>&nbsp; &nbsp; BlockNumber blkno;<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/smgr/bulk_write.c.html#L60" title="storage/smgr/bulk_write.c:60">BulkWriteState</a> *bulkstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The init fork for an unlogged relation in many respects has to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * treated the same as normal relation, changes need to be WAL logged and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it needs to be synced to disk.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; copying_initfork = relpersistence == RELPERSISTENCE_UNLOGGED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forkNum == INIT_FORKNUM;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to log the copied data in WAL iff WAL archiving/streaming is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabled AND it's a permanent relation.&nbsp; This gives the same answer as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;RelationNeedsWAL(rel) || copying_initfork&quot;, because we know the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current operation created new relation storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; use_wal = XLogIsNeeded() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (relpersistence == RELPERSISTENCE_PERMANENT || copying_initfork);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; bulkstate = <a href="../storage/smgr/bulk_write.c.html#L99" title="storage/smgr/bulk_write.c:99">smgr_bulk_start_smgr</a>(dst, forkNum, use_wal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nblocks = <a href="../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(src, forkNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (blkno = <span class="Constant">0</span>; blkno &lt; nblocks; blkno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BulkWriteBuffer buf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If we got a cancel signal during the copy of the data, quit */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; buf = <a href="../storage/smgr/bulk_write.c.html#L295" title="storage/smgr/bulk_write.c:295">smgr_bulk_get_buf</a>(bulkstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; smgrread(src, forkNum, blkno, (Page) buf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../storage/page/bufpage.c.html#L88" title="storage/page/bufpage.c:88">PageIsVerifiedExtended</a>((Page) buf, blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PIV_LOG_WARNING | PIV_REPORT_STAT))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For paranoia's sake, capture the file path <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> invoking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ereport machinery.&nbsp; This guards against the possibility of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relcache flush caused by, e.g., an errcontext callback.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (errcontext callbacks shouldn't be risking <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> such thing, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * people have been known to forget that rule.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *relpath = relpathbackend(src-&gt;smgr_rlocator.locator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; src-&gt;smgr_rlocator.backend,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; forkNum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATA_CORRUPTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid page in block </span><span class="Special">%u</span><span class="Constant"> of relation </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blkno, relpath)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Queue the page for WAL-logging and writing out.&nbsp; Unfortunately we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't know what kind of a page this is, so we have to log the full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page including <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused space.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/bulk_write.c.html#L271" title="storage/smgr/bulk_write.c:271">smgr_bulk_write</a>(bulkstate, blkno, buf, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/smgr/bulk_write.c.html#L129" title="storage/smgr/bulk_write.c:129">smgr_bulk_finish</a>(bulkstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L532" title="catalog/storage.c:532">RelFileLocatorSkippingWAL</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check if a BM_PERMANENT relfilelocator is using WAL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Changes to certain relations must not write WAL; see &quot;Skipping WAL for<br/></li>
<li></span><span class="Comment"> * New RelFileLocator&quot; in src/backend/access/transam/README.&nbsp; Though it is<br/></li>
<li></span><span class="Comment"> * known from Relation efficiently, this function is intended for the code<br/></li>
<li></span><span class="Comment"> * paths not having access to Relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L532">&#x200c;</a></span><span class="linkable">RelFileLocatorSkippingWAL</span>(RelFileLocator rlocator)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>, &amp;rlocator, HASH_FIND, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L546" title="catalog/storage.c:546">EstimatePendingSyncsSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate space needed to pass syncs to parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L546">&#x200c;</a><span class="linkable">EstimatePendingSyncsSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">long</span>&nbsp; &nbsp; &nbsp; &nbsp; entries;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; entries = <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> ? <a href="../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>) : <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Constant">1</span> + entries, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L559" title="catalog/storage.c:559">SerializePendingSyncs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize syncs for parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L559">&#x200c;</a></span><span class="linkable">SerializePendingSyncs</span>(Size maxSize, <span class="Type">char</span> *startAddress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a>&nbsp; &nbsp; &nbsp;&nbsp; *tmphash;<br/></li>
<li>&nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="catalog/storage.c:70">PendingRelSync</a> *sync;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *delete;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *src;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *dest = (RelFileLocator *) startAddress;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">goto</span> terminate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create temporary <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> to collect active relfilelocators */<br/></li>
<li></span>&nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator);<br/></li>
<li>&nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator);<br/></li>
<li>&nbsp; &nbsp; ctl.hcxt = <a href="../utils/mmgr/mcxt.c.html#L143" title="utils/mmgr/mcxt.c:143">CurrentMemoryContext</a>;<br/></li>
<li>&nbsp; &nbsp; tmphash = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;tmp relfilelocators&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1341" title="utils/hash/dynahash.c:1341">hash_get_num_entries</a>(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>), &amp;ctl,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_ELEM | HASH_BLOBS | HASH_CONTEXT);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* collect all rlocator from pending syncs */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan, <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((sync = (<a href="#L70" title="catalog/storage.c:70">PendingRelSync</a> *) <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(tmphash, &amp;sync-&gt;rlocator, HASH_ENTER, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remove deleted rnodes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (delete = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; delete != <span class="Constant">NULL</span>; delete = delete-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (delete-&gt;atCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(tmphash, &amp;delete-&gt;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan, tmphash);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((src = (RelFileLocator *) <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *dest++ = *src;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L865" title="utils/hash/dynahash.c:865">hash_destroy</a>(tmphash);<br/></li>
<li><br/></li>
<li><span class="Statement">terminate</span><span class="cUserCont">:<br/></li>
<li></span>&nbsp; &nbsp; MemSet(dest, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L610" title="catalog/storage.c:610">RestorePendingSyncs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Restore syncs within a parallel worker.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * RelationNeedsWAL() and <a href="#L532" title="catalog/storage.c:532">RelFileLocatorSkippingWAL</a>() must offer the correct<br/></li>
<li></span><span class="Comment"> * answer to parallel workers.&nbsp; Only <a href="#L700" title="catalog/storage.c:700">smgrDoPendingSyncs</a>() reads the<br/></li>
<li></span><span class="Comment"> * is_truncated field, at end of transaction.&nbsp; Hence, don't restore it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L610">&#x200c;</a></span><span class="linkable">RestorePendingSyncs</span>(<span class="Type">char</span> *startAddress)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *rlocator;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (rlocator = (RelFileLocator *) startAddress; rlocator-&gt;relNumber != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rlocator++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="catalog/storage.c:85">AddPendingSync</a>(rlocator);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L632" title="catalog/storage.c:632">smgrDoPendingDeletes</a>() -- Take care of relation deletes at end of xact.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This also runs when aborting a subxact; we want to clean up a failed<br/></li>
<li></span><span class="Comment"> * subxact immediately.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: It's possible that we're being asked to remove a relation that has<br/></li>
<li></span><span class="Comment"> * no physical storage in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> fork. In particular, it's possible that we're<br/></li>
<li></span><span class="Comment"> * cleaning up an old temporary relation for which <a href="../storage/file/fd.c.html#L3274" title="storage/file/fd.c:3274">RemovePgTempFiles</a> has<br/></li>
<li></span><span class="Comment"> * already recovered the physical storage.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L632">&#x200c;</a></span><span class="linkable">smgrDoPendingDeletes</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestLevel = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *prev;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation *srels = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; prev = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;nestLevel &lt; nestLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* outer-level entries should not be processed yet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev = pending;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* unlink list entry first, so we don't retry on failure */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prev)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prev-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a> = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* do deletion if called for */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;atCommit == isCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srel = <a href="../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(pending-&gt;rlocator, pending-&gt;procNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate the initial array, or extend it, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxrels == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelation) * maxrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (maxrels &lt;= nrels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels = <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(srels, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelation) * maxrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels[nrels++] = srel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must explicitly free the list entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pending);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prev does not change */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L462" title="storage/smgr/smgr.c:462">smgrdounlinkall</a>(srels, nrels, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; nrels; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L320" title="storage/smgr/smgr.c:320">smgrclose</a>(srels[i]);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(srels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L700" title="catalog/storage.c:700">smgrDoPendingSyncs</a>() -- Take care of relation syncs at end of xact.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L700">&#x200c;</a></span><span class="linkable">smgrDoPendingSyncs</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isCommit, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isParallelWorker)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels = <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; SMgrRelation *srels = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS scan;<br/></li>
<li>&nbsp; &nbsp; <a href="#L70" title="catalog/storage.c:70">PendingRelSync</a> *pendingsync;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>() == <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no relation needs sync */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Abort -- just throw away all pending syncs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isCommit)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3123" title="utils/cache/relcache.c:3123">AssertPendingSyncs_RelationCache</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Parallel worker -- just throw away all pending syncs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isParallelWorker)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Skip syncing nodes that <a href="#L632" title="catalog/storage.c:632">smgrDoPendingDeletes</a>() will delete. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;atCommit)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>, &amp;pending-&gt;rlocator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_REMOVE, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;scan, <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((pendingsync = (<a href="#L70" title="catalog/storage.c:70">PendingRelSync</a> *) <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; fork;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber nblocks[MAX_FORKNUM + <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber total_blocks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation srel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; srel = <a href="../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(pendingsync-&gt;rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We emit newpage WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for smaller relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Small WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> have a chance to be flushed along with other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * backends' WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a>.&nbsp; We emit WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> instead of syncing for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * files that are smaller than a certain threshold, expecting faster<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commit.&nbsp; The threshold is defined by the GUC <a href="#L39" title="catalog/storage.c:39">wal_skip_threshold</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!pendingsync-&gt;is_truncated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (fork = <span class="Constant">0</span>; fork &lt;= MAX_FORKNUM; fork++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(srel, fork))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BlockNumber n = <a href="../storage/smgr/smgr.c.html#L655" title="storage/smgr/smgr.c:655">smgrnblocks</a>(srel, fork);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we shouldn't come here for unlogged relations */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(fork != INIT_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks[fork] = n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_blocks += n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nblocks[fork] = InvalidBlockNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Sync file or emit WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for its contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although we emit WAL record if the file is small enough, do file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sync regardless of the size if the file has experienced a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * truncation. It is because the file would be followed by trailing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * garbage blocks after a crash recovery if, while a past longer file<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * had been flushed out, we omitted syncing-out of the file and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitted WAL instead.&nbsp; You might think that we could choose WAL if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the current <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork is longer than ever, but there's a case where<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> fork is longer than ever but FSM fork gets shorter.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pendingsync-&gt;is_truncated ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; total_blocks * BLCKSZ / <span class="Constant">1024</span> &gt;= <a href="#L39" title="catalog/storage.c:39">wal_skip_threshold</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* allocate the initial array, or extend it, if needed */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (maxrels == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels = <span class="Constant">8</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelation) * maxrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (maxrels &lt;= nrels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxrels *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels = <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(srels, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(SMgrRelation) * maxrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; srels[nrels++] = srel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Emit WAL <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> for all blocks.&nbsp; The file is small enough. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (fork = <span class="Constant">0</span>; fork &lt;= MAX_FORKNUM; fork++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = nblocks[fork];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!BlockNumberIsValid(n))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Emit WAL for the whole file.&nbsp; Unfortunately we don't know<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * what kind of a page this is, so we have to log the full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * page including <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused space.&nbsp; <a href="../storage/buffer/bufmgr.c.html#L792" title="storage/buffer/bufmgr.c:792">ReadBufferExtended</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * counts some pgstat events; unfortunately, we discard them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(srel-&gt;smgr_rlocator.locator);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xloginsert.c.html#L1270" title="access/transam/xloginsert.c:1270">log_newpage_range</a>(rel, fork, <span class="Constant">0</span>, n, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L77" title="catalog/storage.c:77">pendingSyncHash</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L426" title="storage/smgr/smgr.c:426">smgrdosyncall</a>(srels, nrels);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(srels);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L852" title="catalog/storage.c:852">smgrGetPendingDeletes</a>() -- Get a list of non-temp relations to be deleted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The return value is the number of relations scheduled for termination.<br/></li>
<li></span><span class="Comment"> * *ptr is set to point to a freshly-<a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d array of RelFileLocators.<br/></li>
<li></span><span class="Comment"> * If there are no relations to be deleted, *ptr is set to NULL.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Only non-temporary relations are included in the returned list.&nbsp; This is OK<br/></li>
<li></span><span class="Comment"> * because the list is used only in contexts where temporary relations don't<br/></li>
<li></span><span class="Comment"> * matter: we're either writing to the two-phase state file (and transactions<br/></li>
<li></span><span class="Comment"> * that have touched temp tables can't be prepared) or we're writing to xlog<br/></li>
<li></span><span class="Comment"> * (and all temporary files will be zapped if we restart anyway, so no need<br/></li>
<li></span><span class="Comment"> * for redo to do it also).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the list does not include anything scheduled for termination<br/></li>
<li></span><span class="Comment"> * by <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level transactions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L852">&#x200c;</a></span><span class="linkable">smgrGetPendingDeletes</span>(<span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> forCommit, RelFileLocator **ptr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestLevel = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels;<br/></li>
<li>&nbsp; &nbsp; RelFileLocator *rptr;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; nrels = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;nestLevel &gt;= nestLevel &amp;&amp; pending-&gt;atCommit == forCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; pending-&gt;procNumber == INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nrels++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nrels == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ptr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; rptr = (RelFileLocator *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(nrels * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(RelFileLocator));<br/></li>
<li>&nbsp; &nbsp; *ptr = rptr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;nestLevel &gt;= nestLevel &amp;&amp; pending-&gt;atCommit == forCommit<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; pending-&gt;procNumber == INVALID_PROC_NUMBER)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *rptr = pending-&gt;rlocator;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rptr++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> nrels;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="#L893" title="catalog/storage.c:893">PostPrepare_smgr</a> -- Clean up after a successful PREPARE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * What we have to do here is throw away the in-memory state about pending<br/></li>
<li></span><span class="Comment"> * relation deletes.&nbsp; It's all been recorded in the 2PC state file and<br/></li>
<li></span><span class="Comment"> * it's no longer smgr's job to worry about it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L893">&#x200c;</a></span><span class="linkable">PostPrepare_smgr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a> = <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* must explicitly free the list entry */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pending);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L914" title="catalog/storage.c:914">AtSubCommit_smgr</a>() --- Take care of subtransaction commit.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Reassign all items in the pending-deletes list to the parent transaction.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L914">&#x200c;</a></span><span class="linkable">AtSubCommit_smgr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nestLevel = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/storage.c:61">PendingRelDelete</a> *pending;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (pending = <a href="#L76" title="catalog/storage.c:76">pendingDeletes</a>; pending != <span class="Constant">NULL</span>; pending = pending-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pending-&gt;nestLevel &gt;= nestLevel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pending-&gt;nestLevel = nestLevel - <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L934" title="catalog/storage.c:934">AtSubAbort_smgr</a>() --- Take care of subtransaction abort.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> created relations and forget about deleted relations.<br/></li>
<li></span><span class="Comment"> * We can execute these operations immediately because we know this<br/></li>
<li></span><span class="Comment"> * subtransaction will not commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L934">&#x200c;</a></span><span class="linkable">AtSubAbort_smgr</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L632" title="catalog/storage.c:632">smgrDoPendingDeletes</a>(<span class="Constant">false</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">void<br/></li>
<li><a id="L940">&#x200c;</a></span><span class="linkable">smgr_redo</span>(XLogReaderState *record)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; XLogRecPtr&nbsp; &nbsp; lsn = record-&gt;EndRecPtr;<br/></li>
<li>&nbsp; &nbsp; uint8&nbsp; &nbsp; &nbsp; &nbsp; info = XLogRecGetInfo(record) &amp; ~XLR_INFO_MASK;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Backup blocks are not used in smgr <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!XLogRecHasAnyBlockRefs(record));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info == XLOG_SMGR_CREATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_create *xlrec = (xl_smgr_create *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(xlrec-&gt;rlocator, INVALID_PROC_NUMBER);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(reln, xlrec-&gt;forkNum, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (info == XLOG_SMGR_TRUNCATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; xl_smgr_truncate *xlrec = (xl_smgr_truncate *) XLogRecGetData(record);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SMgrRelation reln;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ForkNumber&nbsp; &nbsp; forks[MAX_FORKNUM];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber blocks[MAX_FORKNUM];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_fsm_vacuum = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reln = <a href="../storage/smgr/smgr.c.html#L198" title="storage/smgr/smgr.c:198">smgropen</a>(xlrec-&gt;rlocator, INVALID_PROC_NUMBER);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Forcibly create relation if it doesn't exist (which suggests that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it was dropped somewhere later in the WAL sequence).&nbsp; As in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../access/transam/xlogutils.c.html#L314" title="access/transam/xlogutils.c:314">XLogReadBufferForRedo</a>, we prefer to recreate the rel and replay the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * log as best we can until the drop is seen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(reln, MAIN_FORKNUM, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before we perform the truncation, update minimum recovery point to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cover this WAL record. Once the relation is truncated, there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * going back. The buffer manager enforces the WAL-first rule for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * normal updates to relation files, so that the minimum recovery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * point is always updated <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the corresponding change in the data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * file is flushed to disk. We have to do the same manually here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Doing this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the truncation means that if the truncation fails<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for some reason, you cannot start up the system even after restart,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * until you fix the underlying situation so that the truncation will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * succeed. Alternatively, we could update the minimum recovery point<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after truncation, but that would leave a small window where the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WAL-first rule could be violated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlog.c.html#L2791" title="access/transam/xlog.c:2791">XLogFlush</a>(lsn);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare for truncation of MAIN fork */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((xlrec-&gt;flags &amp; SMGR_TRUNCATE_HEAP) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forks[nforks] = MAIN_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocks[nforks] = xlrec-&gt;blkno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks++;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also tell xlogutils.c about it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L671" title="access/transam/xlogutils.c:671">XLogTruncateRelation</a>(xlrec-&gt;rlocator, MAIN_FORKNUM, xlrec-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare for truncation of FSM and VM too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/transam/xlogutils.c.html#L582" title="access/transam/xlogutils.c:582">CreateFakeRelcacheEntry</a>(xlrec-&gt;rlocator);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((xlrec-&gt;flags &amp; SMGR_TRUNCATE_FSM) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(reln, FSM_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocks[nforks] = <a href="../storage/freespace/freespace.c.html#L275" title="storage/freespace/freespace.c:275">FreeSpaceMapPrepareTruncateRel</a>(rel, xlrec-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blocks[nforks]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forks[nforks] = FSM_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_fsm_vacuum = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((xlrec-&gt;flags &amp; SMGR_TRUNCATE_VM) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(reln, VISIBILITYMAP_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; blocks[nforks] = <a href="../access/heap/visibilitymap.c.html#L438" title="access/heap/visibilitymap.c:438">visibilitymap_prepare_truncate</a>(rel, xlrec-&gt;blkno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (BlockNumberIsValid(blocks[nforks]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; forks[nforks] = VISIBILITYMAP_FORKNUM;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nforks++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Do the real work to truncate relation forks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nforks &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L703" title="storage/smgr/smgr.c:703">smgrtruncate</a>(reln, forks, nforks, blocks);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Update <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level FSM pages to account for the truncation. This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * important because the just-truncated pages were likely marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all-free, and would be preferentially selected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (need_fsm_vacuum)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/freespace/freespace.c.html#L377" title="storage/freespace/freespace.c:377">FreeSpaceMapVacuumRange</a>(rel, xlrec-&gt;blkno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidBlockNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xlogutils.c.html#L629" title="access/transam/xlogutils.c:629">FreeFakeRelcacheEntry</a>(rel);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(PANIC, <span class="Constant">&quot;<a href="#L940" title="catalog/storage.c:940">smgr_redo</a>: unknown op code </span><span class="Special">%u</span><span class="Constant">&quot;</span>, info);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
