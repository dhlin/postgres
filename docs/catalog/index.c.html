<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>catalog/index.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>catalog/index.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L84">binary_upgrade_next_index_pg_class_oid</a></li>
<li><a href="#L85">binary_upgrade_next_index_pg_class_relfilenumber</a></li>
<li><a href="#L4045">currentlyReindexedHeap</a></li>
<li><a href="#L4046">currentlyReindexedIndex</a></li>
<li><a href="#L4047">pendingReindexedIndexes</a></li>
<li><a href="#L4048">reindexingNestLevel</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L98">SerializedReindexState</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L510">AppendAttributeTuples</a></li>
<li><a href="#L2466">BuildDummyIndexInfo</a></li>
<li><a href="#L2407">BuildIndexInfo</a></li>
<li><a href="#L2645">BuildSpeculativeIndexInfo</a></li>
<li><a href="#L2514">CompareIndexInfo</a></li>
<li><a href="#L280">ConstructTupleDescriptor</a></li>
<li><a href="#L4178">EstimateReindexStateSpace</a></li>
<li><a href="#L2705">FormIndexDatum</a></li>
<li><a href="#L3138">IndexCheckExclusion</a></li>
<li><a href="#L3527">IndexGetRelation</a></li>
<li><a href="#L492">InitializeAttributeOids</a></li>
<li><a href="#L4065">ReindexIsCurrentlyProcessingIndex</a></li>
<li><a href="#L4055">ReindexIsProcessingHeap</a></li>
<li><a href="#L4076">ReindexIsProcessingIndex</a></li>
<li><a href="#L4136">RemoveReindexPending</a></li>
<li><a href="#L4106">ResetReindexProcessing</a></li>
<li><a href="#L4149">ResetReindexState</a></li>
<li><a href="#L4207">RestoreReindexState</a></li>
<li><a href="#L4189">SerializeReindexState</a></li>
<li><a href="#L4120">SetReindexPending</a></li>
<li><a href="#L4087">SetReindexProcessing</a></li>
<li><a href="#L561">UpdateIndexRelation</a></li>
<li><a href="#L2945">index_build</a></li>
<li><a href="#L201">index_check_primary_key</a></li>
<li><a href="#L1481">index_concurrently_build</a></li>
<li><a href="#L1297">index_concurrently_create_copy</a></li>
<li><a href="#L1819">index_concurrently_set_dead</a></li>
<li><a href="#L1548">index_concurrently_swap</a></li>
<li><a href="#L1881">index_constraint_create</a></li>
<li><a href="#L724">index_create</a></li>
<li><a href="#L2117">index_drop</a></li>
<li><a href="#L3447">index_set_state_flags</a></li>
<li><a href="#L2784">index_update_stats</a></li>
<li><a href="#L3552">reindex_index</a></li>
<li><a href="#L3892">reindex_relation</a></li>
<li><a href="#L147">relationHasPrimaryKey</a></li>
<li><a href="#L3294">validate_index</a></li>
<li><a href="#L3427">validate_index_callback</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * index.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; code to create and destroy POSTGRES index relations<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/catalog/index.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * INTERFACE ROUTINES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L724" title="catalog/index.c:724">index_create</a>()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Create a cataloged index relation<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2117" title="catalog/index.c:2117">index_drop</a>()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Removes index relation from catalogs<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>()&nbsp; &nbsp; &nbsp; &nbsp; - Prepare to insert index tuples<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2705" title="catalog/index.c:2705">FormIndexDatum</a>()&nbsp; &nbsp; &nbsp; &nbsp; - Construct datum vector for one index tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/amapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/multixact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relscan.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/tableam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_compression.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/visibilitymap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;bootstrap/bootstrap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/binary_upgrade.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_description.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_inherits.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_trigger.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/storage_xlog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L367" title="utils/adt/pseudotypes.c:367">event_trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/progress.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;pgstat.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/bufmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/lmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/predicate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;storage/smgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/guc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/memutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/pg_rusage.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/tuplesort.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Potentially set by pg_upgrade_support <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li><a id="L84">&#x200c;</a></span>Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="linkable">binary_upgrade_next_index_pg_class_oid</span> = InvalidOid;<br/></li>
<li><a id="L85">&#x200c;</a>RelFileNumber <span class="linkable">binary_upgrade_next_index_pg_class_relfilenumber</span> =<br/></li>
<li>InvalidRelFileNumber;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Pointer-free representation of variables used when reindexing system<br/></li>
<li></span><span class="Comment"> * catalogs; we use this to propagate those <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> to parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numPendingReindexedIndexes;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>[FLEXIBLE_ARRAY_MEMBER];<br/></li>
<li><a id="L98">&#x200c;</a>} <span class="linkable">SerializedReindexState</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* non-export function prototypes */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L147" title="catalog/index.c:147">relationHasPrimaryKey</a>(Relation rel);<br/></li>
<li><span class="Type">static</span> TupleDesc <a href="#L280" title="catalog/index.c:280">ConstructTupleDescriptor</a>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> List *indexColNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid accessMethodId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *collationIds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *opclassIds);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L492" title="catalog/index.c:492">InitializeAttributeOids</a>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numatts, Oid indexoid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L510" title="catalog/index.c:510">AppendAttributeTuples</a>(Relation indexRelation, <span class="Type">const</span> Datum *attopts, <span class="Type">const</span> NullableDatum *stattargets);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L561" title="catalog/index.c:561">UpdateIndexRelation</a>(Oid indexoid, Oid heapoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *collationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *opclassOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int16 *coloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> primary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isexclusion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> immediate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isvalid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isready);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2784" title="catalog/index.c:2784">index_update_stats</a>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> reltuples);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3138" title="catalog/index.c:3138">IndexCheckExclusion</a>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexInfo *indexInfo);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3427" title="catalog/index.c:3427">validate_index_callback</a>(ItemPointer itemptr, <span class="Type">void</span> *opaque);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L4065" title="catalog/index.c:4065">ReindexIsCurrentlyProcessingIndex</a>(Oid indexOid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4087" title="catalog/index.c:4087">SetReindexProcessing</a>(Oid heapOid, Oid indexOid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4106" title="catalog/index.c:4106">ResetReindexProcessing</a>(<span class="Type">void</span>);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4120" title="catalog/index.c:4120">SetReindexPending</a>(List *indexes);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4136" title="catalog/index.c:4136">RemoveReindexPending</a>(Oid indexOid);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L147" title="catalog/index.c:147">relationHasPrimaryKey</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; See whether an existing relation has a primary key.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have suitable lock on the relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we intentionally do not check indisvalid here; that's because this<br/></li>
<li></span><span class="Comment"> * is used to enforce the rule that there can be only one indisprimary index,<br/></li>
<li></span><span class="Comment"> * and we want that to be true even if said index is invalid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L147">&#x200c;</a></span><span class="linkable">relationHasPrimaryKey</span>(Relation rel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexoidlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexoidscan;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the list of index OIDs for the table from the relcache, and look up<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * each one in the pg_index syscache until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one marked primary key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (hopefully there isn't more than one such).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexoidlist = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(indexoidscan, indexoidlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexoid = lfirst_oid(indexoidscan);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(indexoid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))&nbsp; &nbsp; <span class="Comment">/* should not happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexoid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = ((Form_pg_index) GETSTRUCT(indexTuple))-&gt;indisprimary;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(indexTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (result)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(indexoidlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L201" title="catalog/index.c:201">index_check_primary_key</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Apply special checks needed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> creating a PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This processing used to be in <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>(), but has been split out<br/></li>
<li></span><span class="Comment"> * so that it can be applied during ALTER TABLE ADD PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> USING INDEX.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We check for a pre-existing primary key, and that all columns of the index<br/></li>
<li></span><span class="Comment"> * are simple column references (not expressions), and that all those<br/></li>
<li></span><span class="Comment"> * columns are marked NOT NULL.&nbsp; If not, fail.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We used to automatically change unmarked columns to NOT NULL here by doing<br/></li>
<li></span><span class="Comment"> * our own local ALTER TABLE command.&nbsp; But that doesn't work well if we're<br/></li>
<li></span><span class="Comment"> * executing one subcommand of an ALTER TABLE: the operations may not get<br/></li>
<li></span><span class="Comment"> * performed in the right order overall.&nbsp; Now we expect that the parser<br/></li>
<li></span><span class="Comment"> * inserted <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> required ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NOT NULL operations <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> trying<br/></li>
<li></span><span class="Comment"> * to create a primary-key index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller had better have at least ShareLock on the table, else the not-null<br/></li>
<li></span><span class="Comment"> * checking isn't trustworthy.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L201">&#x200c;</a></span><span class="linkable">index_check_primary_key</span>(Relation heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_alter_table,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> IndexStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If ALTER TABLE or CREATE TABLE .. PARTITION OF, check that there isn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already a PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>.&nbsp; In CREATE TABLE for an ordinary relation, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have faith that the parser rejected multiple pkey clauses; and CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INDEX doesn't have a way to say PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, so it's no problem either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((is_alter_table || heapRel-&gt;rd_rel-&gt;relispartition) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L147" title="catalog/index.c:147">relationHasPrimaryKey</a>(heapRel))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple primary keys for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> are not allowed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(heapRel))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Indexes created with NULLS NOT DISTINCT cannot be used for primary key<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraints. While there is no direct syntax to reach here, it can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * done by creating a separate index and attaching it via ALTER TABLE ..<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * USING INDEX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_NullsNotDistinct)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;primary keys cannot use NULLS NOT DISTINCT indexes&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that all of the attributes in a primary key are marked as not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * null.&nbsp; (We don't really expect to see that; it'd mean the parser messed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * up.&nbsp; But it seems wise to check anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = indexInfo-&gt;ii_IndexAttrNumbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;primary keys cannot be expressions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* System attributes are never null, so no need to check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttuple = <a href="../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(heapRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, RelationGetRelid(heapRel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attform = (Form_pg_attribute) GETSTRUCT(atttuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!attform-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;primary key column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not marked NOT NULL&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(attform-&gt;attname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(atttuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L280" title="catalog/index.c:280">ConstructTupleDescriptor</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build an index tuple descriptor for a new index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> TupleDesc<br/></li>
<li><a id="L280">&#x200c;</a><span class="linkable">ConstructTupleDescriptor</span>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> List *indexColNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid accessMethodId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *collationIds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *opclassIds)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numatts = indexInfo-&gt;ii_NumIndexAttrs;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numkeyatts = indexInfo-&gt;ii_NumIndexKeyAttrs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *colnames_item = list_head(indexColNames);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item = list_head(indexInfo-&gt;ii_Expressions);<br/></li>
<li>&nbsp; &nbsp; IndexAmRoutine *amroutine;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; heapTupDesc;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indexTupDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; natts;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* #atts in heap rel --- for error checks */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We need access to the index AM's API struct */<br/></li>
<li></span>&nbsp; &nbsp; amroutine = <a href="../access/index/amapi.c.html#L56" title="access/index/amapi.c:56">GetIndexAmRoutineByAmId</a>(accessMethodId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and to the table's tuple descriptor */<br/></li>
<li></span>&nbsp; &nbsp; heapTupDesc = RelationGetDescr(heapRelation);<br/></li>
<li>&nbsp; &nbsp; natts = RelationGetForm(heapRelation)-&gt;relnatts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allocate the new tuple descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexTupDesc = <a href="../access/common/tupdesc.c.html#L67" title="access/common/tupdesc.c:67">CreateTemplateTupleDesc</a>(numatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in the pg_attribute row.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; atnum = indexInfo-&gt;ii_IndexAttrNumbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute to = TupleDescAttr(indexTupDesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typeTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_opclass opclassTup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyType;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; MemSet(to, <span class="Constant">0</span>, ATTRIBUTE_FIXED_PART_SIZE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attnum = i + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attcacheoff = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attislocal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attcollation = (i &lt; numkeyatts) ? collationIds[i] : InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set the attribute name as specified by caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (colnames_item == <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too few entries in colnames list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;to-&gt;attname, (<span class="Type">const</span> <span class="Type">char</span> *) lfirst(colnames_item));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colnames_item = lnext(indexColNames, colnames_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For simple index columns, we copy some pg_attribute fields from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent relation.&nbsp; For expressions we have to look at the expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * result.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atnum != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> FormData_pg_attribute *from;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(atnum &gt; <span class="Constant">0</span>);&nbsp; &nbsp; <span class="Comment">/* should've been caught above */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (atnum &gt; natts)&nbsp; &nbsp; <span class="Comment">/* safety check */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid column number </span><span class="Special">%d</span><span class="Constant">&quot;</span>, atnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; from = TupleDescAttr(heapTupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AttrNumberGetAttrOffset(atnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;atttypid = from-&gt;atttypid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attlen = from-&gt;attlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attndims = from-&gt;attndims;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;atttypmod = from-&gt;atttypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attbyval = from-&gt;attbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attalign = from-&gt;attalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attstorage = from-&gt;attstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attcompression = from-&gt;attcompression;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expressional index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too few entries in indexprs list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) lfirst(indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(indexInfo-&gt;ii_Expressions, indexpr_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lookup the expression type in pg_type for the type length etc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyType = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(indexkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(keyType));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, keyType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeTup = (Form_pg_type) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Assign some of the attributes <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>. Leave the rest.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;atttypid = keyType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attlen = typeTup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;atttypmod = <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(indexkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attbyval = typeTup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attalign = typeTup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attstorage = typeTup-&gt;typstorage;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For expression columns, set attcompression invalid, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there's no table column from which to copy the value. Whenever<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we actually need to compress a value, we'll use whatever the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * current value of <a href="../access/common/toast_compression.c.html#L26" title="access/common/toast_compression.c:26">default_toast_compression</a> is at that point in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * time.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attcompression = InvalidCompressionMethod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make sure the expression yields a type that's safe to store in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an index.&nbsp; We need this defense because we have index opclasses<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for pseudo-types such as &quot;record&quot;, and the actually stored type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * had better be safe; eg, a named composite type is okay, an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anonymous record type is not.&nbsp; The test is the same as for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether a table column is of a safe type (which is why we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needn't check for the non-expression case).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="heap.c.html#L548" title="catalog/heap.c:548">CheckAttributeType</a>(NameStr(to-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; to-&gt;atttypid, to-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We do not yet have the correct relation OID for the index, so just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set it invalid for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; <a href="#L492" title="catalog/index.c:492">InitializeAttributeOids</a>() will fix it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attrelid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check the opclass and index AM to see if either provides a keytype<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (overriding the attribute type).&nbsp; Opclass (if exists) takes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * precedence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; keyType = amroutine-&gt;amkeytype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclassIds[i]));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclassIds[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclassTup = (Form_pg_opclass) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(opclassTup-&gt;opckeytype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyType = opclassTup-&gt;opckeytype;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If keytype is specified as ANYELEMENT, and opcintype is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ANYARRAY, then the attribute type must be an array (else it'd<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not have matched this opclass); use its <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We could also allow ANYCOMPATIBLE/ANYCOMPATIBLEARRAY here, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there seems no need to do so; there's no reason to declare an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * opclass as taking ANYCOMPATIBLEARRAY rather than ANYARRAY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keyType == ANYELEMENTOID &amp;&amp; opclassTup-&gt;opcintype == ANYARRAYOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyType = <a href="../utils/cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(to-&gt;atttypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(keyType))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not get <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type of array type </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; to-&gt;atttypid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a key type different from the heap value is specified, update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the type-related fields in the index tupdesc.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(keyType) &amp;&amp; keyType != to-&gt;atttypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(TYPEOID, ObjectIdGetDatum(keyType));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for type </span><span class="Special">%u</span><span class="Constant">&quot;</span>, keyType);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeTup = (Form_pg_type) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;atttypid = keyType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;atttypmod = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attlen = typeTup-&gt;typlen;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attbyval = typeTup-&gt;typbyval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attalign = typeTup-&gt;typalign;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attstorage = typeTup-&gt;typstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As above, use the default compression method in this case */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to-&gt;attcompression = InvalidCompressionMethod;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(amroutine);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexTupDesc;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L492" title="catalog/index.c:492">InitializeAttributeOids</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L492">&#x200c;</a></span><span class="linkable">InitializeAttributeOids</span>(Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> numatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid indexoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDescriptor;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupleDescriptor = RelationGetDescr(indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numatts; i += <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(tupleDescriptor, i)-&gt;attrelid = indexoid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L510" title="catalog/index.c:510">AppendAttributeTuples</a><br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L510">&#x200c;</a></span><span class="linkable">AppendAttributeTuples</span>(Relation indexRelation, <span class="Type">const</span> Datum *attopts, <span class="Type">const</span> NullableDatum *stattargets)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_attribute;<br/></li>
<li>&nbsp; &nbsp; CatalogIndexState indstate;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indexTupDesc;<br/></li>
<li>&nbsp; &nbsp; FormExtraData_pg_attribute *attrs_extra = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attopts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrs_extra = palloc0_array(FormExtraData_pg_attribute, indexRelation-&gt;rd_att-&gt;natts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; indexRelation-&gt;rd_att-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attopts[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs_extra[i].attoptions.value = attopts[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs_extra[i].attoptions.isnull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stattargets)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs_extra[i].attstattarget = stattargets[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrs_extra[i].attstattarget.isnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open the attribute relation and its indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_attribute = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indstate = <a href="indexing.c.html#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a>(pg_attribute);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert data from new index's tupdesc into pg_attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexTupDesc = RelationGetDescr(indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="heap.c.html#L702" title="catalog/heap.c:702">InsertPgAttributeTuples</a>(pg_attribute, indexTupDesc, InvalidOid, attrs_extra, indstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L61" title="catalog/indexing.c:61">CatalogCloseIndexes</a>(indstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_attribute, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L561" title="catalog/index.c:561">UpdateIndexRelation</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Construct and insert a new entry in the pg_index catalog<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L561">&#x200c;</a></span><span class="linkable">UpdateIndexRelation</span>(Oid indexoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid heapoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *collationOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *opclassOids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int16 *coloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> primary,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isexclusion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> immediate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isvalid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isready)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; int2vector *indkey;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indcollation;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; int2vector *indoption;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; exprsDatum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; predDatum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Natts_pg_index];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Natts_pg_index] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_index;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the index key, opclass, and indoption info into arrays (should we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * make the caller pass them like this to start with?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indkey = <a href="../utils/adt/int.c.html#L114" title="utils/adt/int.c:114">buildint2vector</a>(<span class="Constant">NULL</span>, indexInfo-&gt;ii_NumIndexAttrs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indkey-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = indexInfo-&gt;ii_IndexAttrNumbers[i];<br/></li>
<li>&nbsp; &nbsp; indcollation = <a href="../utils/adt/oid.c.html#L87" title="utils/adt/oid.c:87">buildoidvector</a>(collationOids, indexInfo-&gt;ii_NumIndexKeyAttrs);<br/></li>
<li>&nbsp; &nbsp; indclass = <a href="../utils/adt/oid.c.html#L87" title="utils/adt/oid.c:87">buildoidvector</a>(opclassOids, indexInfo-&gt;ii_NumIndexKeyAttrs);<br/></li>
<li>&nbsp; &nbsp; indoption = <a href="../utils/adt/int.c.html#L114" title="utils/adt/int.c:114">buildint2vector</a>(coloptions, indexInfo-&gt;ii_NumIndexKeyAttrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert the index expressions (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) to a text datum<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Expressions != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *exprsString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprsString = <a href="../nodes/outfuncs.c.html#L791" title="nodes/outfuncs.c:791">nodeToString</a>(indexInfo-&gt;ii_Expressions);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprsDatum = CStringGetTextDatum(exprsString);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(exprsString);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprsDatum = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Convert the index predicate (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) to a text datum.&nbsp; Note we convert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * implicit-AND format to normal explicit-AND for storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Predicate != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *predString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predString = <a href="../nodes/outfuncs.c.html#L791" title="nodes/outfuncs.c:791">nodeToString</a>(<a href="../nodes/makefuncs.c.html#L726" title="nodes/makefuncs.c:726">make_ands_explicit</a>(indexInfo-&gt;ii_Predicate));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predDatum = CStringGetTextDatum(predString);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(predString);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; predDatum = (Datum) <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open the system catalog index relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a pg_index tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indexrelid - <span class="Constant">1</span>] = ObjectIdGetDatum(indexoid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indrelid - <span class="Constant">1</span>] = ObjectIdGetDatum(heapoid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indnatts - <span class="Constant">1</span>] = Int16GetDatum(indexInfo-&gt;ii_NumIndexAttrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indnkeyatts - <span class="Constant">1</span>] = Int16GetDatum(indexInfo-&gt;ii_NumIndexKeyAttrs);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisunique - <span class="Constant">1</span>] = BoolGetDatum(indexInfo-&gt;ii_Unique);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indnullsnotdistinct - <span class="Constant">1</span>] = BoolGetDatum(indexInfo-&gt;ii_NullsNotDistinct);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisprimary - <span class="Constant">1</span>] = BoolGetDatum(primary);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisexclusion - <span class="Constant">1</span>] = BoolGetDatum(isexclusion);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indimmediate - <span class="Constant">1</span>] = BoolGetDatum(immediate);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisclustered - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisvalid - <span class="Constant">1</span>] = BoolGetDatum(isvalid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indcheckxmin - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisready - <span class="Constant">1</span>] = BoolGetDatum(isready);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indislive - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indisreplident - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indkey - <span class="Constant">1</span>] = PointerGetDatum(indkey);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indcollation - <span class="Constant">1</span>] = PointerGetDatum(indcollation);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indclass - <span class="Constant">1</span>] = PointerGetDatum(indclass);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indoption - <span class="Constant">1</span>] = PointerGetDatum(indoption);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indexprs - <span class="Constant">1</span>] = exprsDatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (exprsDatum == (Datum) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Anum_pg_index_indexprs - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_index_indpred - <span class="Constant">1</span>] = predDatum;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (predDatum == (Datum) <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Anum_pg_index_indpred - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(RelationGetDescr(pg_index), <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert the tuple into the pg_index catalog<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>(pg_index, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close the relation and free the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L724" title="catalog/index.c:724">index_create</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heapRelation: table to build index on (suitably locked by caller)<br/></li>
<li></span><span class="Comment"> * indexRelationName: what it say<br/></li>
<li></span><span class="Comment"> * indexRelationId: normally, pass InvalidOid to let this routine<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; generate an OID for the index.&nbsp; During bootstrap this may be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; nonzero to specify a preselected OID.<br/></li>
<li></span><span class="Comment"> * parentIndexRelid: if creating an index partition, the OID of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; parent index; otherwise InvalidOid.<br/></li>
<li></span><span class="Comment"> * parentConstraintId: if creating a constraint on a partition, the OID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; of the constraint in the parent; otherwise InvalidOid.<br/></li>
<li></span><span class="Comment"> * relFileNumber: normally, pass InvalidRelFileNumber to get new storage.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; May be nonzero to attach an existing valid build.<br/></li>
<li></span><span class="Comment"> * indexInfo: same info executor uses to insert into the index<br/></li>
<li></span><span class="Comment"> * indexColNames: column names to use for index (List of char *)<br/></li>
<li></span><span class="Comment"> * accessMethodId: OID of index AM to use<br/></li>
<li></span><span class="Comment"> * tableSpaceId: OID of tablespace to use<br/></li>
<li></span><span class="Comment"> * collationIds: array of collation OIDs, one per index column<br/></li>
<li></span><span class="Comment"> * opclassIds: array of index opclass OIDs, one per index column<br/></li>
<li></span><span class="Comment"> * coloptions: array of per-index-column indoption settings<br/></li>
<li></span><span class="Comment"> * reloptions: AM-specific options<br/></li>
<li></span><span class="Comment"> * flags: bitmask that can include <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> combination of these bits:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_IS_PRIMARY<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; the index is a primary key<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_ADD_CONSTRAINT:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; invoke <a href="#L1881" title="catalog/index.c:1881">index_constraint_create</a> also<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_SKIP_BUILD:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the <a href="#L2945" title="catalog/index.c:2945">index_build</a>() step for the moment; caller must do it<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; later (typically via <a href="#L3552" title="catalog/index.c:3552">reindex_index</a>())<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_CONCURRENT:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do not lock the table against writers.&nbsp; The index will be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; marked &quot;invalid&quot; and the caller must take additional steps<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; to fix it up.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_IF_NOT_EXISTS:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; do not throw an error if a relation with the same name<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; already exists.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_PARTITIONED:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; create a partitioned index (table must be partitioned)<br/></li>
<li></span><span class="Comment"> * constr_flags: flags passed to <a href="#L1881" title="catalog/index.c:1881">index_constraint_create</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; (only if INDEX_CREATE_ADD_CONSTRAINT is set)<br/></li>
<li></span><span class="Comment"> * allow_system_table_mods: allow table to be a system catalog<br/></li>
<li></span><span class="Comment"> * is_internal: if true, post creation hook for new index<br/></li>
<li></span><span class="Comment"> * constraintId: if not NULL, receives OID of created constraint<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the OID of the created index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L724">&#x200c;</a><span class="linkable">index_create</span>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *indexRelationName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentIndexRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid parentConstraintId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelFileNumber relFileNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> List *indexColNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid accessMethodId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid tableSpaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *collationIds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *opclassIds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Datum *opclassOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> int16 *coloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> NullableDatum *stattargets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum reloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bits16 flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bits16 constr_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_system_table_mods,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_internal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *constraintId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRelationId = RelationGetRelid(heapRelation);<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelation;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indexTupDesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; shared_relation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mapped_relation;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_exclusion;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relpersistence;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isprimary = (flags &amp; INDEX_CREATE_IS_PRIMARY) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; invalid = (flags &amp; INDEX_CREATE_INVALID) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; concurrent = (flags &amp; INDEX_CREATE_CONCURRENT) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; partitioned = (flags &amp; INDEX_CREATE_PARTITIONED) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; relkind;<br/></li>
<li>&nbsp; &nbsp; TransactionId relfrozenxid;<br/></li>
<li>&nbsp; &nbsp; MultiXactId relminmxid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; create_storage = !RelFileNumberIsValid(relFileNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* constraint flags can only be set when a constraint is requested */<br/></li>
<li></span>&nbsp; &nbsp; Assert((constr_flags == <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) != <span class="Constant">0</span>));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* partitioned indexes must never be &quot;built&quot; by themselves */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!partitioned || (flags &amp; INDEX_CREATE_SKIP_BUILD));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relkind = partitioned ? RELKIND_PARTITIONED_INDEX : RELKIND_INDEX;<br/></li>
<li>&nbsp; &nbsp; is_exclusion = (indexInfo-&gt;ii_ExclusionOps != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The index will be in the same namespace as its parent table, and is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shared across databases if and only if the parent is.&nbsp; Likewise, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will use the relfilenumber map if and only if the parent does; and it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * inherits the parent's relpersistence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; namespaceId = RelationGetNamespace(heapRelation);<br/></li>
<li>&nbsp; &nbsp; shared_relation = heapRelation-&gt;rd_rel-&gt;relisshared;<br/></li>
<li>&nbsp; &nbsp; mapped_relation = RelationIsMapped(heapRelation);<br/></li>
<li>&nbsp; &nbsp; relpersistence = heapRelation-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check parameters<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_NumIndexAttrs &lt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;must index at least one column&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!allow_system_table_mods &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(heapRelation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsNormalProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;user-defined indexes on system catalog tables are not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Btree text_pattern_ops uses text_eq as the equality operator, which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fine as long as the collation is deterministic; text_eq then reduces to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bitwise equality and so it is semantically compatible with the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators and <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in that opclass.&nbsp; But with a nondeterministic<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collation, text_eq could yield results that are incompatible with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * actual behavior of the index (which is determined by the opclass's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comparison function).&nbsp; We prevent such problems by refusing creation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an index with that opclass and a nondeterministic collation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The same applies to varchar_pattern_ops and bpchar_pattern_ops.&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> more cases, we might decide to create a real mechanism for marking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * opclasses as incompatible with nondeterminism; but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, this small<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hack suffices.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another solution is to use a special operator, not text_eq, as the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * equality opclass member; but that is undesirable because it would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevent index usage in many queries that work fine today.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collation = collationIds[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclass = opclassIds[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((opclass == TEXT_BTREE_PATTERN_OPS_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opclass == VARCHAR_BTREE_PATTERN_OPS_OID ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opclass == BPCHAR_BTREE_PATTERN_OPS_OID) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/cache/lsyscache.c.html#L1054" title="utils/cache/lsyscache.c:1054">get_collation_isdeterministic</a>(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; classtup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classtup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(classtup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator class </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;nondeterministic collations are not supported for operator class </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(((Form_pg_opclass) GETSTRUCT(classtup))-&gt;opcname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(classtup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Concurrent index build on a system catalog is unsafe because we tend to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * release locks <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> committing in catalogs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catalog.c.html#L103" title="catalog/catalog.c:103">IsCatalogRelation</a>(heapRelation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;concurrent index creation on system catalog tables is not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This case is currently not supported.&nbsp; There's no way to ask for it in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the grammar with CREATE INDEX, but it can happen with REINDEX.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent &amp;&amp; is_exclusion)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;concurrent index creation for exclusion constraints is not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot allow indexing a shared relation after initdb (because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no way to make the entry in other databases' pg_class).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared_relation &amp;&amp; !IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;shared indexes cannot be created after initdb&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Shared relations must be in pg_global, too (last-ditch check)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (shared_relation &amp;&amp; tableSpaceId != GLOBALTABLESPACE_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;shared relations must be placed in pg_global tablespace&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for duplicate name (both as to the index, and as to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * associated constraint if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).&nbsp; Such cases would fail on the relevant<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs' unique indexes anyway, but we prefer to give a friendlier<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * error message.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(indexRelationName, namespaceId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; INDEX_CREATE_IF_NOT_EXISTS) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationName)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationName)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) != <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_constraint.c.html#L403" title="catalog/pg_constraint.c:403">ConstraintNameIsUsed</a>(CONSTRAINT_RELATION, heapRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRelationName))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INDEX_CREATE_IF_NOT_EXISTS does not apply here, since the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conflicting constraint is not an index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationName, RelationGetRelationName(heapRelation))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * construct tuple descriptor for index tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexTupDesc = <a href="#L280" title="catalog/index.c:280">ConstructTupleDescriptor</a>(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexColNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessMethodId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collationIds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclassIds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Allocate an OID for the index, unless we were told what to use.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The OID will be the relfilenumber as well, so make sure it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * collide with either pg_class OIDs or existing physical files.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(indexRelationId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Use binary-upgrade override for pg_class.oid and relfilenumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(<a href="#L84" title="catalog/index.c:84">binary_upgrade_next_index_pg_class_oid</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;pg_class index OID value not set when in binary upgrade mode&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationId = <a href="#L84" title="catalog/index.c:84">binary_upgrade_next_index_pg_class_oid</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L84" title="catalog/index.c:84">binary_upgrade_next_index_pg_class_oid</a> = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Override the index relfilenumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((relkind == RELKIND_INDEX) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (!RelFileNumberIsValid(<a href="#L85" title="catalog/index.c:85">binary_upgrade_next_index_pg_class_relfilenumber</a>)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index relfilenumber value not set when in binary upgrade mode&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relFileNumber = <a href="#L85" title="catalog/index.c:85">binary_upgrade_next_index_pg_class_relfilenumber</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L85" title="catalog/index.c:85">binary_upgrade_next_index_pg_class_relfilenumber</a> = InvalidRelFileNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we want create_storage = true for binary upgrade. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * storage we create here will be replaced later, but we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have something on disk in the meanwhile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(create_storage);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationId =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="catalog.c.html#L500" title="catalog/catalog.c:500">GetNewRelFileNumber</a>(tableSpaceId, pg_class, relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create the index relation's relcache entry and, if necessary, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical disk file. (If we fail further down, it's the smgr's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * responsibility to remove the disk file again, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexRelation = <a href="heap.c.html#L289" title="catalog/heap.c:289">heap_create</a>(indexRelationName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tableSpaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relFileNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; accessMethodId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexTupDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relkind,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relpersistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; shared_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mapped_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allow_system_table_mods,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;relfrozenxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;relminmxid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; create_storage);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(relfrozenxid == InvalidTransactionId);<br/></li>
<li>&nbsp; &nbsp; Assert(relminmxid == InvalidMultiXactId);<br/></li>
<li>&nbsp; &nbsp; Assert(indexRelationId == RelationGetRelid(indexRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Obtain exclusive lock on it.&nbsp; Although no other transactions can see it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * until we commit, this prevents deadlock-risk complaints from lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manager in cases such as CLUSTER.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L244" title="storage/lmgr/lmgr.c:244">LockRelation</a>(indexRelation, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fill in fields of the index's pg_class entry that are not set correctly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * by <a href="heap.c.html#L289" title="catalog/heap.c:289">heap_create</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> should have a cleaner way to create cataloged indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexRelation-&gt;rd_rel-&gt;relowner = heapRelation-&gt;rd_rel-&gt;relowner;<br/></li>
<li>&nbsp; &nbsp; indexRelation-&gt;rd_rel-&gt;relam = accessMethodId;<br/></li>
<li>&nbsp; &nbsp; indexRelation-&gt;rd_rel-&gt;relispartition = OidIsValid(parentIndexRelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * store index's pg_class entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="heap.c.html#L895" title="catalog/heap.c:895">InsertPgClassTuple</a>(pg_class, indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(indexRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; reloptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done with pg_class */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> update the object id's of all the attribute tuple forms in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index relation's tuple descriptor<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L492" title="catalog/index.c:492">InitializeAttributeOids</a>(indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_NumIndexAttrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * append ATTRIBUTE tuples for the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L510" title="catalog/index.c:510">AppendAttributeTuples</a>(indexRelation, opclassOptions, stattargets);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; update pg_index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; (append INDEX tuple)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; Note that this stows away a representation of &quot;predicate&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; (Or, could define a rule to maintain the predicate) --Nels, Feb '92<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ----------------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L561" title="catalog/index.c:561">UpdateIndexRelation</a>(indexRelationId, heapRelationId, parentIndexRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collationIds, opclassIds, coloptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isprimary, is_exclusion,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (constr_flags &amp; INDEX_CONSTR_CREATE_DEFERRABLE) == <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !concurrent &amp;&amp; !invalid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !concurrent);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register relcache invalidation on the indexes' heap relation, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * maintain consistency of its index list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(heapRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* update pg_inherits and the parent's relhassubclass, if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(parentIndexRelid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_inherits.c.html#L508" title="catalog/pg_inherits.c:508">StoreSingleInheritance</a>(indexRelationId, parentIndexRelid, <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/tablecmds.c.html#L3588" title="commands/tablecmds.c:3588">SetRelationHasSubclass</a>(parentIndexRelid, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register constraint and dependencies for the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index is from a CONSTRAINT clause, construct a pg_constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * entry.&nbsp; The index will be linked to the constraint, which in turn is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * linked to the table.&nbsp; If it's not a CONSTRAINT, we need to make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependency directly on the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't need a dependency on the namespace, because there'll be an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indirect dependency via our parent table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * During bootstrap we can't register <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> dependencies, and we don't try<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to make a constraint either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *addrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(myself, RelationRelationId, indexRelationId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; constraintType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress localaddr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isprimary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintType = CONSTRAINT_PRIMARY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (indexInfo-&gt;ii_Unique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintType = CONSTRAINT_UNIQUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (is_exclusion)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintType = CONSTRAINT_EXCLUSION;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;constraint must be PRIMARY, UNIQUE or EXCLUDE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintType = <span class="Constant">0</span>; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; localaddr = <a href="#L1881" title="catalog/index.c:1881">index_constraint_create</a>(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentConstraintId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constr_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; allow_system_table_mods,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_internal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraintId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *constraintId = localaddr.objectId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; have_simple_col = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addrs = <a href="dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create auto dependencies on simply-referenced columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_IndexAttrNumbers[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSubSet(referenced, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_IndexAttrNumbers[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have_simple_col = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If there are no simply-referenced columns, give the index an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * auto dependency on the whole table.&nbsp; In most cases, this will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * be redundant, but it might not be if the index expressions and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * predicate contain no Vars or only whole-row Vars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!have_simple_col)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heapRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2740" title="catalog/dependency.c:2740">record_object_address_dependencies</a>(&amp;myself, addrs, DEPENDENCY_AUTO);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is an index partition, create partition dependencies on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * both the parent index and the table.&nbsp; (Note: these must be *in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * addition to*, not instead of, all other dependencies.&nbsp; Otherwise<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll be short some dependencies after DETACH PARTITION.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(parentIndexRelid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, RelationRelationId, parentIndexRelid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_PRI);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, RelationRelationId, heapRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_SEC);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* placeholder for normal dependencies */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; addrs = <a href="dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store dependency on collations */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The default collation is pinned, so don't bother recording it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(collationIds[i]) &amp;&amp; collationIds[i] != DEFAULT_COLLATION_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, CollationRelationId, collationIds[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store dependency on operator classes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, OperatorClassRelationId, opclassIds[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2740" title="catalog/dependency.c:2740">record_object_address_dependencies</a>(&amp;myself, addrs, DEPENDENCY_NORMAL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(addrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store dependencies on anything mentioned in index expressions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Expressions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L1594" title="catalog/dependency.c:1594">recordDependencyOnSingleRelExpr</a>(&amp;myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) indexInfo-&gt;ii_Expressions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_AUTO, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Store dependencies on anything mentioned in predicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Predicate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L1594" title="catalog/dependency.c:1594">recordDependencyOnSingleRelExpr</a>(&amp;myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Node *) indexInfo-&gt;ii_Predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_AUTO, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Bootstrap mode - assert we weren't asked for constraint support */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((flags &amp; INDEX_CREATE_ADD_CONSTRAINT) == <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Post creation hook for new index */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostCreateHookArg(RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelationId, <span class="Constant">0</span>, is_internal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Advance the command counter so that we can see the newly-entered<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalog tuples for the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In bootstrap mode, we have to fill in the index strategy structure with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * information from the catalogs.&nbsp; If we aren't bootstrapping, then the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache entry has already been rebuilt thanks to sinval update during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L1425" title="utils/cache/relcache.c:1425">RelationInitIndexAccessInfo</a>(indexRelation);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(indexRelation-&gt;rd_indexcxt != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRelation-&gt;rd_index-&gt;indnkeyatts = indexInfo-&gt;ii_NumIndexKeyAttrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate opclass-specific options */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (opclassOptions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexKeyAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/index/indexam.c.html#L996" title="access/index/indexam.c:996">index_opclass_options</a>(indexRelation, i + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opclassOptions[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is bootstrap (initdb) time, then we don't actually fill in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index yet.&nbsp; We'll be creating more indexes and classes later, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * delay filling them in until just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we're done with bootstrapping.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly, if the caller specified to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the build then filling the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index is delayed till later (ALTER TABLE can save work in some cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with this).&nbsp; Otherwise, we call the AM routine that constructs the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L901" title="bootstrap/bootstrap.c:901">index_register</a>(heapRelationId, indexRelationId, indexInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((flags &amp; INDEX_CREATE_SKIP_BUILD) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Caller is responsible for filling the index later on.&nbsp; However,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'd better make sure that the heap relation is correctly marked as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * having an index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2784" title="catalog/index.c:2784">index_update_stats</a>(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1.0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make the above update visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="catalog/index.c:2945">index_build</a>(heapRelation, indexRelation, indexInfo, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the index; but we keep the lock that we acquired above until end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of transaction.&nbsp; Closing the heap is caller's responsibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRelation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexRelationId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1297" title="catalog/index.c:1297">index_concurrently_create_copy</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Create concurrently an index based on the definition of the one provided by<br/></li>
<li></span><span class="Comment"> * caller.&nbsp; The index is inserted into catalogs and needs to be built later<br/></li>
<li></span><span class="Comment"> * on.&nbsp; This is called during concurrent reindex processing.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;tablespaceOid&quot; is the tablespace to use for this index.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L1297">&#x200c;</a><span class="linkable">index_concurrently_create_copy</span>(Relation heapRelation, Oid oldIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid tablespaceOid, <span class="Type">const</span> <span class="Type">char</span> *newName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelation;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *oldInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *newInfo;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newIndexId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; classTuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colOptionDatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloptionsDatum;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *opclassOptions;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; int2vector *indcoloptions;<br/></li>
<li>&nbsp; &nbsp; NullableDatum *stattargets;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexColNames = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexExprs = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexPreds = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRelation = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(oldIndexId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The new index needs some information from the old index */<br/></li>
<li></span>&nbsp; &nbsp; oldInfo = <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Concurrent build of an index with exclusion constraints is not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * supported.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldInfo-&gt;ii_ExclusionOps != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;concurrent index creation for exclusion constraints is not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the array of class and column options IDs from index info */<br/></li>
<li></span>&nbsp; &nbsp; indexTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(oldIndexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldIndexId);<br/></li>
<li>&nbsp; &nbsp; indclassDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; colOptionDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indoption);<br/></li>
<li>&nbsp; &nbsp; indcoloptions = (int2vector *) DatumGetPointer(colOptionDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch reloptions of index if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; classTuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(oldIndexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(classTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldIndexId);<br/></li>
<li>&nbsp; &nbsp; reloptionsDatum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(RELOID, classTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_reloptions, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch the list of expressions and predicates directly from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * catalogs.&nbsp; This cannot rely on the information from IndexInfo of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * old index as these have been flattened for the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (oldInfo-&gt;ii_Expressions != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; exprDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *exprString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indexprs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprString = TextDatumGetCString(exprDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexExprs = (List *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(exprString);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(exprString);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oldInfo-&gt;ii_Predicate != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; predDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *predString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, indexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indpred);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; predString = TextDatumGetCString(predDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexPreds = (List *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(predString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Also convert to implicit-AND format */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexPreds = <a href="../nodes/makefuncs.c.html#L737" title="nodes/makefuncs.c:737">make_ands_implicit</a>((Expr *) indexPreds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(predString);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build the index information for the new index.&nbsp; Note that rebuild of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes with exclusion constraints is not supported, hence there is no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need to fill all the ii_Exclusion* fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newInfo = <a href="../nodes/makefuncs.c.html#L761" title="nodes/makefuncs.c:761">makeIndexInfo</a>(oldInfo-&gt;ii_NumIndexAttrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldInfo-&gt;ii_NumIndexKeyAttrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldInfo-&gt;ii_Am,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexExprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexPreds,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldInfo-&gt;ii_Unique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldInfo-&gt;ii_NullsNotDistinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* not ready for inserts */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indam-&gt;amsummarizing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Extract the list of column names and the column numbers for the new<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index information.&nbsp; All this information will be used for the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; oldInfo-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; indexTupDesc = RelationGetDescr(indexRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute att = TupleDescAttr(indexTupDesc, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexColNames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(indexColNames, NameStr(att-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newInfo-&gt;ii_IndexAttrNumbers[i] = oldInfo-&gt;ii_IndexAttrNumbers[i];<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract opclass options for each attribute */<br/></li>
<li></span>&nbsp; &nbsp; opclassOptions = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Datum) * newInfo-&gt;ii_NumIndexAttrs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; newInfo-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; opclassOptions[i] = <a href="../utils/cache/lsyscache.c.html#L970" title="utils/cache/lsyscache.c:970">get_attoptions</a>(oldIndexId, i + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract statistic targets for each attribute */<br/></li>
<li></span>&nbsp; &nbsp; stattargets = palloc0_array(NullableDatum, newInfo-&gt;ii_NumIndexAttrs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; newInfo-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; dat;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tp = <a href="../utils/cache/syscache.c.html#L229" title="utils/cache/syscache.c:229">SearchSysCache2</a>(ATTNUM, ObjectIdGetDatum(oldIndexId), Int16GetDatum(i + <span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tp))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i + <span class="Constant">1</span>, oldIndexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dat = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(ATTNUM, tp, Anum_pg_attribute_attstattarget, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tp);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stattargets[i].value = dat;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stattargets[i].isnull = isnull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now create the new index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For a partition index, we adjust the partition dependency later, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure a consistent state at all times.&nbsp; That is why parentIndexRelid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is not set here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newIndexId = <a href="#L724" title="catalog/index.c:724">index_create</a>(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* indexRelationId */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* parentIndexRelid */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* parentConstraintId */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidRelFileNumber, <span class="Comment">/* relFileNumber */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexColNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_rel-&gt;relam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tablespaceOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indclass-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opclassOptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indcoloptions-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stattargets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloptionsDatum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_CREATE_SKIP_BUILD | INDEX_CREATE_CONCURRENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, <span class="Comment">/* allow table to be a system catalog? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,&nbsp; &nbsp; <span class="Comment">/* is_internal? */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close the relations used and clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRelation, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(indexTuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(classTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newIndexId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1481" title="catalog/index.c:1481">index_concurrently_build</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Build index for a concurrent operation.&nbsp; Low-level locks are taken when<br/></li>
<li></span><span class="Comment"> * this operation is performed to prevent only schema changes, but they need<br/></li>
<li></span><span class="Comment"> * to be kept until the end of the transaction performing this operation.<br/></li>
<li></span><span class="Comment"> * 'indexOid' refers to an index relation OID already created as part of<br/></li>
<li></span><span class="Comment"> * previous processing, and 'heapOid' refers to its parent heap relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1481">&#x200c;</a></span><span class="linkable">index_concurrently_build</span>(Oid heapRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid indexRelationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelation;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This had better make sure that a snapshot is active */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/time/snapmgr.c.html#L782" title="utils/time/snapmgr.c:782">ActiveSnapshotSet</a>());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open and lock the parent heap relation */<br/></li>
<li></span>&nbsp; &nbsp; heapRel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapRelationId, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to the table owner's userid, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as that user.&nbsp; Also lock down security-restricted operations and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange to make GUC variable changes local to this command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(heapRel-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRelation = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to re-build the IndexInfo struct, since it was lost in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit of the transaction where this concurrent index was created at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the catalog level.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo = <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(indexRelation);<br/></li>
<li>&nbsp; &nbsp; Assert(!indexInfo-&gt;ii_ReadyForInserts);<br/></li>
<li>&nbsp; &nbsp; indexInfo-&gt;ii_Concurrent = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; indexInfo-&gt;ii_BrokenHotChain = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now build the index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2945" title="catalog/index.c:2945">index_build</a>(heapRel, indexRelation, indexInfo, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes executed by index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close both the relations, but keep the locks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRelation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the pg_index row to mark the index as ready for inserts. Once we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit this transaction, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> new transactions that open the table must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert new entries into the index for insertions and non-HOT updates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3447" title="catalog/index.c:3447">index_set_state_flags</a>(indexRelationId, INDEX_CREATE_SET_READY);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1548" title="catalog/index.c:1548">index_concurrently_swap</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Swap name, dependencies, and constraints of the old index over to the new<br/></li>
<li></span><span class="Comment"> * index, while marking the old index as invalid and the new as valid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1548">&#x200c;</a></span><span class="linkable">index_concurrently_swap</span>(Oid newIndexId, Oid oldIndexId, <span class="Type">const</span> <span class="Type">char</span> *oldName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_constraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_trigger;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; oldClassRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newClassRel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; oldClassTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newClassTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class oldClassForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newClassForm;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; oldIndexTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newIndexTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index oldIndexForm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newIndexForm;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isPartition;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexConstraintOid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *constraintOids = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Take a necessary lock on the old and new index <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> swapping them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldClassRel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(oldIndexId, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; newClassRel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(newIndexId, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now swap names and dependencies of those indexes */<br/></li>
<li></span>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldClassTuple = SearchSysCacheCopy1(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(oldIndexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(oldClassTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldIndexId);<br/></li>
<li>&nbsp; &nbsp; newClassTuple = SearchSysCacheCopy1(RELOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(newIndexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(newClassTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, newIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldClassForm = (Form_pg_class) GETSTRUCT(oldClassTuple);<br/></li>
<li>&nbsp; &nbsp; newClassForm = (Form_pg_class) GETSTRUCT(newClassTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Swap the names */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;newClassForm-&gt;relname, NameStr(oldClassForm-&gt;relname));<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;oldClassForm-&gt;relname, oldName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Swap the partition flags to track inheritance properly */<br/></li>
<li></span>&nbsp; &nbsp; isPartition = newClassForm-&gt;relispartition;<br/></li>
<li>&nbsp; &nbsp; newClassForm-&gt;relispartition = oldClassForm-&gt;relispartition;<br/></li>
<li>&nbsp; &nbsp; oldClassForm-&gt;relispartition = isPartition;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;oldClassTuple-&gt;t_self, oldClassTuple);<br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_class, &amp;newClassTuple-&gt;t_self, newClassTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(oldClassTuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newClassTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now swap index info */<br/></li>
<li></span>&nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldIndexTuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(oldIndexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(oldIndexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, oldIndexId);<br/></li>
<li>&nbsp; &nbsp; newIndexTuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(newIndexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(newIndexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, newIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oldIndexForm = (Form_pg_index) GETSTRUCT(oldIndexTuple);<br/></li>
<li>&nbsp; &nbsp; newIndexForm = (Form_pg_index) GETSTRUCT(newIndexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy constraint flags from the old index. This is safe because the old<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index guaranteed uniqueness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newIndexForm-&gt;indisprimary = oldIndexForm-&gt;indisprimary;<br/></li>
<li>&nbsp; &nbsp; oldIndexForm-&gt;indisprimary = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; newIndexForm-&gt;indisexclusion = oldIndexForm-&gt;indisexclusion;<br/></li>
<li>&nbsp; &nbsp; oldIndexForm-&gt;indisexclusion = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; newIndexForm-&gt;indimmediate = oldIndexForm-&gt;indimmediate;<br/></li>
<li>&nbsp; &nbsp; oldIndexForm-&gt;indimmediate = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Preserve indisreplident in the new index */<br/></li>
<li></span>&nbsp; &nbsp; newIndexForm-&gt;indisreplident = oldIndexForm-&gt;indisreplident;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Preserve indisclustered in the new index */<br/></li>
<li></span>&nbsp; &nbsp; newIndexForm-&gt;indisclustered = oldIndexForm-&gt;indisclustered;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Mark the new index as valid, and the old index as invalid similarly to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what <a href="#L3447" title="catalog/index.c:3447">index_set_state_flags</a>() does.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; newIndexForm-&gt;indisvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; oldIndexForm-&gt;indisvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; oldIndexForm-&gt;indisclustered = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; oldIndexForm-&gt;indisreplident = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;oldIndexTuple-&gt;t_self, oldIndexTuple);<br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;newIndexTuple-&gt;t_self, newIndexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(oldIndexTuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(newIndexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move constraints and triggers over to the new index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; constraintOids = <a href="pg_depend.c.html#L1024" title="catalog/pg_depend.c:1024">get_index_ref_constraints</a>(oldIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexConstraintOid = <a href="pg_depend.c.html#L968" title="catalog/pg_depend.c:968">get_index_constraint</a>(oldIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(indexConstraintOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintOids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(constraintOids, indexConstraintOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_constraint = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(ConstraintRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; pg_trigger = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(TriggerRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, constraintOids)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; constraintTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triggerTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint conForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintOid = lfirst_oid(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Move the constraint from the old to the new index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; constraintTuple = SearchSysCacheCopy1(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(constraintOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(constraintTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>, constraintOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; conForm = ((Form_pg_constraint) GETSTRUCT(constraintTuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (conForm-&gt;conindid == oldIndexId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conForm-&gt;conindid = newIndexId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_constraint, &amp;constraintTuple-&gt;t_self, constraintTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(constraintTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search for <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> <a href="../access/transam/twophase.c.html#L1025" title="access/transam/twophase.c:1025">records</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_trigger_tgconstraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(constraintOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(pg_trigger, TriggerConstraintIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid((triggerTuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan))))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_trigger tgForm = (Form_pg_trigger) GETSTRUCT(triggerTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tgForm-&gt;tgconstrindid != oldIndexId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make a modifiable copy */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; triggerTuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(triggerTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgForm = (Form_pg_trigger) GETSTRUCT(triggerTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tgForm-&gt;tgconstrindid = newIndexId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_trigger, &amp;triggerTuple-&gt;t_self, triggerTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(triggerTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Move comment if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; description;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData skey[<span class="Constant">3</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SysScanDesc sd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Natts_pg_description] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Natts_pg_description] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replaces[Natts_pg_description] = {<span class="Constant">0</span>};<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_description_objoid - <span class="Constant">1</span>] = ObjectIdGetDatum(newIndexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replaces[Anum_pg_description_objoid - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_description_objoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(oldIndexId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_description_classoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(RelationRelationId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">2</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_description_objsubid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_INT4EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(<span class="Constant">0</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; description = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(DescriptionRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sd = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(description, DescriptionObjIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">3</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(sd)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tuple, RelationGetDescr(description),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls, replaces);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(description, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assume there can be only one match */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(sd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(description, NoLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Swap inheritance relationship with parent index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L2027" title="utils/cache/lsyscache.c:2027">get_rel_relispartition</a>(oldIndexId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ancestors = <a href="partition.c.html#L134" title="catalog/partition.c:134">get_partition_ancestors</a>(oldIndexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parentIndexRelid = linitial_oid(ancestors);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_inherits.c.html#L552" title="catalog/pg_inherits.c:552">DeleteInheritsTuple</a>(oldIndexId, parentIndexRelid, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_inherits.c.html#L508" title="catalog/pg_inherits.c:508">StoreSingleInheritance</a>(newIndexId, parentIndexRelid, <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(ancestors);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Swap all dependencies of and on the old index to the new one, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * vice-versa.&nbsp; Note that a call to <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>() would cause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * duplicate entries in pg_depend, so this should not be done.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pg_depend.c.html#L564" title="catalog/pg_depend.c:564">changeDependenciesOf</a>(RelationRelationId, newIndexId, oldIndexId);<br/></li>
<li>&nbsp; &nbsp; <a href="pg_depend.c.html#L620" title="catalog/pg_depend.c:620">changeDependenciesOn</a>(RelationRelationId, newIndexId, oldIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pg_depend.c.html#L564" title="catalog/pg_depend.c:564">changeDependenciesOf</a>(RelationRelationId, oldIndexId, newIndexId);<br/></li>
<li>&nbsp; &nbsp; <a href="pg_depend.c.html#L620" title="catalog/pg_depend.c:620">changeDependenciesOn</a>(RelationRelationId, oldIndexId, newIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* copy over statistics from old to new index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/activity/pgstat_relation.c.html#L58" title="utils/activity/pgstat_relation.c:58">pgstat_copy_relation_stats</a>(newClassRel, oldClassRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy data of pg_statistic from the old index to the new one */<br/></li>
<li></span>&nbsp; &nbsp; <a href="heap.c.html#L3229" title="catalog/heap.c:3229">CopyStatistics</a>(oldIndexId, newIndexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close relations */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_constraint, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_trigger, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* The lock taken previously is not released until the end of transaction */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(oldClassRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(newClassRel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1819" title="catalog/index.c:1819">index_concurrently_set_dead</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Perform the last invalidation stage of DROP INDEX CONCURRENTLY or REINDEX<br/></li>
<li></span><span class="Comment"> * CONCURRENTLY <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> actually dropping the index.&nbsp; After calling this<br/></li>
<li></span><span class="Comment"> * function, the index is seen by all the backends as dead.&nbsp; Low-level locks<br/></li>
<li></span><span class="Comment"> * taken here are kept until the end of the transaction calling this function.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L1819">&#x200c;</a></span><span class="linkable">index_concurrently_set_dead</span>(Oid heapId, Oid indexId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; userHeapRelation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; userIndexRelation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * No more predicate locks will be acquired on this index, and we're about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to stop doing inserts into the index which could show conflicts with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing predicate locks, so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is the time to move them to the heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; userHeapRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapId, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; userIndexRelation = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexId, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../storage/lmgr/predicate.c.html#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a>(userIndexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we are sure that nobody uses the index for queries; they just might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have it open for updating it.&nbsp; So <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we can unset indisready and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indislive, then wait till nobody could be using it at all anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3447" title="catalog/index.c:3447">index_set_state_flags</a>(indexId, INDEX_DROP_SET_DEAD);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Invalidate the relcache for the table, so that after this commit all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sessions will refresh the table's index list.&nbsp; Forgetting just the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index's relcache entry is not enough.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(userHeapRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the relations again, though still holding session lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(userHeapRelation, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(userIndexRelation, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1881" title="catalog/index.c:1881">index_constraint_create</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Set up a constraint associated with an index.&nbsp; Return the new constraint's<br/></li>
<li></span><span class="Comment"> * address.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heapRelation: table owning the index (must be suitably locked by caller)<br/></li>
<li></span><span class="Comment"> * indexRelationId: OID of the index<br/></li>
<li></span><span class="Comment"> * parentConstraintId: if constraint is on a partition, the OID of the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; constraint in the parent.<br/></li>
<li></span><span class="Comment"> * indexInfo: same info executor uses to insert into the index<br/></li>
<li></span><span class="Comment"> * constraintName: what it say (generally, should match name of index)<br/></li>
<li></span><span class="Comment"> * constraintType: one of CONSTRAINT_PRIMARY, CONSTRAINT_UNIQUE, or<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; CONSTRAINT_EXCLUSION<br/></li>
<li></span><span class="Comment"> * flags: bitmask that can include <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> combination of these bits:<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: index is a PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_DEFERRABLE: constraint is DEFERRABLE<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_INIT_DEFERRED: constraint is INITIALLY DEFERRED<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_UPDATE_INDEX: update the pg_index row<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: remove existing dependencies<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; of index on table's columns<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; INDEX_CONSTR_CREATE_WITHOUT_OVERLAPS: constraint uses WITHOUT OVERLAPS<br/></li>
<li></span><span class="Comment"> * allow_system_table_mods: allow table to be a system catalog<br/></li>
<li></span><span class="Comment"> * is_internal: index is constructed due to <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> process<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L1881">&#x200c;</a><span class="linkable">index_constraint_create</span>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid indexRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid parentConstraintId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *constraintName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span> constraintType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bits16 constr_flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> allow_system_table_mods,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_internal)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceId = RelationGetNamespace(heapRelation);<br/></li>
<li>&nbsp; &nbsp; ObjectAddress myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxaddr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; deferrable;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; initdeferred;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; mark_as_primary;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; islocal;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; noinherit;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_without_overlaps;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inhcount;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; deferrable = (constr_flags &amp; INDEX_CONSTR_CREATE_DEFERRABLE) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; initdeferred = (constr_flags &amp; INDEX_CONSTR_CREATE_INIT_DEFERRED) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; mark_as_primary = (constr_flags &amp; INDEX_CONSTR_CREATE_MARK_AS_PRIMARY) != <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; is_without_overlaps = (constr_flags &amp; INDEX_CONSTR_CREATE_WITHOUT_OVERLAPS) != <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* constraint creation support doesn't work while bootstrapping */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!IsBootstrapProcessingMode());<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* enforce system-table restriction */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!allow_system_table_mods &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(heapRelation) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IsNormalProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;user-defined indexes on system catalog tables are not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* primary/unique constraints shouldn't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Expressions &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraintType != CONSTRAINT_EXCLUSION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;constraints cannot have index expressions&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're manufacturing a constraint for a pre-existing index, we need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to get rid of the existing auto dependencies for the index (the ones<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="#L724" title="catalog/index.c:724">index_create</a>() would have made instead of calling this function).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: this code would not necessarily do the right thing if the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions or predicate, but we'd never be turning such an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index into a UNIQUE or PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constr_flags &amp; INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L350" title="catalog/pg_depend.c:350">deleteDependencyRecordsForClass</a>(RelationRelationId, indexRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationRelationId, DEPENDENCY_AUTO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(parentConstraintId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; islocal = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhcount = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; noinherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; islocal = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inhcount = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; noinherit = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a pg_constraint entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; conOid = <a href="pg_constraint.c.html#L51" title="catalog/pg_constraint.c:51">CreateConstraintEntry</a>(constraintName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; namespaceId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraintType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; deferrable,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; initdeferred,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parentConstraintId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(heapRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_IndexAttrNumbers,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_NumIndexKeyAttrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_NumIndexAttrs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no domain */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRelationId, <span class="Comment">/* index OID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid,&nbsp; &nbsp; <span class="Comment">/* no foreign key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">' '</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">' '</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">' '</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_ExclusionOps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no check constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; islocal,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; inhcount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; noinherit,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_without_overlaps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; is_internal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Register the index as internally dependent on the constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the constraint has a dependency on the table, so we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * need (or want) <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> direct dependency from the index to the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ObjectAddressSet(myself, ConstraintRelationId, conOid);<br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(idxaddr, RelationRelationId, indexRelationId);<br/></li>
<li>&nbsp; &nbsp; <a href="pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;idxaddr, &amp;myself, DEPENDENCY_INTERNAL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, if this is a constraint on a partition, give it partition-type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dependencies on the parent constraint as well as the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(parentConstraintId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress referenced;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ConstraintRelationId, parentConstraintId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_PRI);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(heapRelation));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;myself, &amp;referenced, DEPENDENCY_PARTITION_SEC);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the constraint is deferrable, create the deferred uniqueness<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * checking <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>.&nbsp; (The <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> will be given an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> dependency on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the constraint by <a href="../commands/trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (deferrable)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CreateTrigStmt *<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a> = makeNode(CreateTrigStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;replace = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;isconstraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;trigname = (constraintType == CONSTRAINT_PRIMARY) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;PK_ConstraintTrigger&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;Unique_ConstraintTrigger&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;relation = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;funcname = SystemFuncName(<span class="Constant">&quot;<a href="../commands/constraint.c.html#L39" title="commands/constraint.c:39">unique_key_recheck</a>&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;args = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;row = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;timing = TRIGGER_TYPE_AFTER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;events = TRIGGER_TYPE_INSERT | TRIGGER_TYPE_UPDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;columns = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;whenClause = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;transitionRels = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;deferrable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;initdeferred = initdeferred;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>-&gt;constrrel = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="../commands/trigger.c.html#L158" title="commands/trigger.c:158">CreateTrigger</a>(<a href="../utils/adt/pseudotypes.c.html#L366" title="utils/adt/pseudotypes.c:366">trigger</a>, <span class="Constant">NULL</span>, RelationGetRelid(heapRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, conOid, indexRelationId, InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, <span class="Constant">NULL</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If needed, mark the index as primary and/or deferred in pg_index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: When making an existing index into a constraint, caller must have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a table lock that prevents concurrent table updates; otherwise, there<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a risk that concurrent readers of the table will <a href="../regex/rege_dfa.c.html#L777" title="regex/rege_dfa.c:777">miss</a> seeing this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((constr_flags &amp; INDEX_CONSTR_CREATE_UPDATE_INDEX) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (mark_as_primary || deferrable))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; pg_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; marked_as_primary = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexTuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(indexRelationId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexRelationId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm = (Form_pg_index) GETSTRUCT(indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (mark_as_primary &amp;&amp; !indexForm-&gt;indisprimary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisprimary = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; marked_as_primary = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (deferrable &amp;&amp; indexForm-&gt;indimmediate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indimmediate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (dirty)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we mark an existing index as primary, force a relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * flush on its parent table, so that all sessions will become<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aware that the table <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> has a primary key.&nbsp; This is important<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because it affects some replication behaviors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (marked_as_primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(heapRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvokeObjectPostAlterHookArg(IndexRelationId, indexRelationId, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, is_internal);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(indexTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> myself;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2117" title="catalog/index.c:2117">index_drop</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: this routine should <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> only be called through <a href="dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(),<br/></li>
<li></span><span class="Comment"> * else associated dependencies won't be cleaned up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If concurrent is true, do a DROP INDEX CONCURRENTLY.&nbsp; If concurrent is<br/></li>
<li></span><span class="Comment"> * false but concurrent_lock_mode is true, then do a normal DROP INDEX but<br/></li>
<li></span><span class="Comment"> * take a lock for CONCURRENTLY processing.&nbsp; That is used as part of REINDEX<br/></li>
<li></span><span class="Comment"> * CONCURRENTLY.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2117">&#x200c;</a></span><span class="linkable">index_drop</span>(Oid indexId, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> concurrent_lock_mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapId;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; userHeapRelation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; userIndexRelation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; indexRelation;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hasexprs;<br/></li>
<li>&nbsp; &nbsp; LockRelId&nbsp; &nbsp; heaprelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexrelid;<br/></li>
<li>&nbsp; &nbsp; LOCKTAG&nbsp; &nbsp; &nbsp; &nbsp; heaplocktag;<br/></li>
<li>&nbsp; &nbsp; LOCKMODE&nbsp; &nbsp; lockmode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A temporary relation uses a non-concurrent DROP.&nbsp; Other backends can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * access a temporary relation, so there's no harm in grabbing a stronger<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock (see comments in <a href="../commands/tablecmds.c.html#L1484" title="commands/tablecmds.c:1484">RemoveRelations</a>), and a non-concurrent DROP is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * more efficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="../utils/cache/lsyscache.c.html#L2078" title="utils/cache/lsyscache.c:2078">get_rel_persistence</a>(indexId) != RELPERSISTENCE_TEMP ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!concurrent &amp;&amp; !concurrent_lock_mode));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To drop an index safely, we must grab exclusive lock on its parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.&nbsp; Exclusive lock on the index alone is insufficient because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * another backend might be about to execute a query on the parent table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it relies on a previously cached list of index OIDs, then it could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attempt to access the just-dropped index.&nbsp; We must therefore take a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table lock strong enough to prevent all queries on the table from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * proceeding until we commit and <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out a shared-cache-inval notice<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that will make them update their index lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In the concurrent case we avoid this requirement by disabling index use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in multiple steps and <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> out <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactions that might be using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index, so we don't need exclusive lock on the parent table. Instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we take ShareUpdateExclusiveLock, to ensure that two sessions aren't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doing CREATE/DROP INDEX CONCURRENTLY on the same index.&nbsp; (We will get<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AccessExclusiveLock on the index below, once we're sure nobody else is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heapId = <a href="#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(indexId, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; lockmode = (concurrent || concurrent_lock_mode) ? ShareUpdateExclusiveLock : AccessExclusiveLock;<br/></li>
<li>&nbsp; &nbsp; userHeapRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapId, lockmode);<br/></li>
<li>&nbsp; &nbsp; userIndexRelation = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexId, lockmode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We might still have open queries using it in our own session, which the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * above locking won't prevent, so test explicitly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../commands/tablecmds.c.html#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(userIndexRelation, <span class="Constant">&quot;DROP INDEX&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Drop Index Concurrently is more or less the reverse process of Create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Index Concurrently.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First we unset indisvalid so queries starting afterwards don't use the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index to answer queries anymore.&nbsp; We have to keep indisready = true so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transactions that are still scanning the index can continue to see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * valid index contents.&nbsp; For instance, if they are using READ COMMITTED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mode, and another transaction makes changes and commits, they need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see those new tuples in the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * After all transactions that could possibly have used the index for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * queries end, we can unset indisready and indislive, then wait till<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * nobody could be touching it anymore.&nbsp; (Note: we need indislive because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this state must be distinct from the initial state during CREATE INDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CONCURRENTLY, which has indislive true while indisready and indisvalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are false.&nbsp; That's because in that state, transactions must examine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index for HOT-safety decisions, while in this state we don't want them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to open it at all.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Since all predicate locks on the index are about to be made invalid, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must promote them to predicate locks on the heap.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-concurrent case we can just do that <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.&nbsp; In the concurrent case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> trickier.&nbsp; The predicate locks must be moved when there are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no index scans in progress on the index and no more can subsequently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * start, so that no new predicate locks can be made on the index.&nbsp; Also,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * they must be moved <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> heap inserts stop maintaining the index, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the conflict with the predicate lock on the index gap could be missed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the lock on the heap relation is in place to detect a conflict<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * based on the heap tuple insert.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must commit our transaction in order to make the first pg_index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state update visible to other sessions.&nbsp; If the DROP machinery has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already performed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other actions (removal of other objects,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_depend entries, etc), the commit would make those actions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * permanent, which would leave us with inconsistent catalog state if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we fail partway through the following sequence.&nbsp; Since DROP INDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CONCURRENTLY is restricted to dropping just one index that has no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * dependencies, we should get here <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> anything's been done ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but let's check that to be sure.&nbsp; We can verify that the current<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transaction has not executed <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transactional updates by checking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that no XID has been assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L438" title="access/transam/xact.c:438">GetTopTransactionIdIfAny</a>() != InvalidTransactionId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DROP INDEX CONCURRENTLY must be first action in transaction&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Mark index invalid by updating its pg_index entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3447" title="catalog/index.c:3447">index_set_state_flags</a>(indexId, INDEX_DROP_CLEAR_VALID);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalidate the relcache for the table, so that after this commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all sessions will refresh <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> cached plans that might reference the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(userHeapRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* save lockrelid and locktag for below, then close but keep locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; heaprelid = userHeapRelation-&gt;rd_lockInfo.lockRelId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SET_LOCKTAG_RELATION(heaplocktag, heaprelid.dbId, heaprelid.relId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexrelid = userIndexRelation-&gt;rd_lockInfo.lockRelId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(userHeapRelation, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(userIndexRelation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must commit our current transaction so that the indisvalid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update becomes visible to other transactions; then start another.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> previously-built data structures are lost in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * commit.&nbsp; The only data we keep past here are the relation IDs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Before committing, get a session-level lock on the table, to ensure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that neither it nor the index can be dropped <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we finish. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cannot block, even if someone else is <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for access, because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we already have the same lock within our transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L397" title="storage/lmgr/lmgr.c:397">LockRelationIdForSession</a>(&amp;heaprelid, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L397" title="storage/lmgr/lmgr.c:397">LockRelationIdForSession</a>(&amp;indexrelid, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L743" title="utils/time/snapmgr.c:743">PopActiveSnapshot</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now we must wait until no running transaction could be using the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * index for a query.&nbsp; Use AccessExclusiveLock here to check for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * running transactions that hold locks of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> kind on the table. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we do not need to worry about xacts that open the table for reading<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * after this point; they will see the index as invalid when they open<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the reason we use actual lock acquisition here, rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * just checking the ProcArray and sleeping, is that deadlock is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * possible if one of the transactions in question is blocked trying<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to acquire an exclusive lock on our table.&nbsp; The lock code will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * detect deadlock and error out properly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: we report progress through <a href="../storage/lmgr/lmgr.c.html#L985" title="storage/lmgr/lmgr.c:985">WaitForLockers</a>() unconditionally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here, even though it will only be used when we're called by REINDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CONCURRENTLY and not when called by DROP INDEX CONCURRENTLY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L985" title="storage/lmgr/lmgr.c:985">WaitForLockers</a>(heaplocktag, AccessExclusiveLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Finish invalidation of index and mark it as dead */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1819" title="catalog/index.c:1819">index_concurrently_set_dead</a>(heapId, indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Again, commit the transaction to make the pg_index update visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to other sessions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L3093" title="access/transam/xact.c:3093">CommitTransactionCommand</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L2995" title="access/transam/xact.c:2995">StartTransactionCommand</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Wait till every transaction that saw the old index state has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * finished.&nbsp; See above about progress reporting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L985" title="storage/lmgr/lmgr.c:985">WaitForLockers</a>(heaplocktag, AccessExclusiveLock, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-open relations to allow us to complete our actions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At this point, nothing should be accessing the index, but lets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * leave nothing to chance and grab AccessExclusiveLock on the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the physical deletion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; userHeapRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapId, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; userIndexRelation = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexId, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Not concurrent, so just transfer predicate locks and we're good */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/predicate.c.html#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a>(userIndexRelation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Schedule physical removal of the files (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELKIND_HAS_STORAGE(userIndexRelation-&gt;rd_rel-&gt;relkind))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="storage.c.html#L206" title="catalog/storage.c:206">RelationDropStorage</a>(userIndexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure that stats are dropped if transaction commits */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/activity/pgstat_relation.c.html#L180" title="utils/activity/pgstat_relation.c:180">pgstat_drop_relation</a>(userIndexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close and flush the index's relcache entry, to ensure relcache doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * try to rebuild it while we're deleting catalog entries. We keep the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lock though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(userIndexRelation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L2873" title="utils/cache/relcache.c:2873">RelationForgetRelation</a>(indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix INDEX relation, and check for expressional index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(indexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; hasexprs = !<a href="../access/common/heaptuple.c.html#L455" title="access/common/heaptuple.c:455">heap_attisnull</a>(tuple, Anum_pg_index_indexprs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetDescr(indexRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a>(indexRelation, &amp;tuple-&gt;t_self);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(indexRelation, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it has <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expression columns, we might have stored statistics about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (hasexprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="heap.c.html#L3282" title="catalog/heap.c:3282">RemoveStatistics</a>(indexId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix ATTRIBUTE relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="heap.c.html#L1578" title="catalog/heap.c:1578">DeleteAttributeTuples</a>(indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix RELATION relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="heap.c.html#L1549" title="catalog/heap.c:1549">DeleteRelationTuple</a>(indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fix INHERITS relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pg_inherits.c.html#L552" title="catalog/pg_inherits.c:552">DeleteInheritsTuple</a>(indexId, InvalidOid, <span class="Constant">false</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We are presently too lazy to attempt to compute the new correct value<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of relhasindex (the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> VACUUM will fix it if necessary). So there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no need to update the pg_class tuple for the owning relation. But we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must <a href="../port/win32/socket.c.html#L38" title="port/win32/socket.c:38">send</a> out a shared-cache-inval notice on the owning relation to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure other backends update their relcache lists of indexes.&nbsp; (In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * concurrent case, this is redundant but harmless.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(userHeapRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close owning rel, but keep lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(userHeapRelation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Release the session locks <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we go.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L410" title="storage/lmgr/lmgr.c:410">UnlockRelationIdForSession</a>(&amp;heaprelid, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/lmgr/lmgr.c.html#L410" title="storage/lmgr/lmgr.c:410">UnlockRelationIdForSession</a>(&amp;indexrelid, ShareUpdateExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2945" title="catalog/index.c:2945">index_build</a> support<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Construct an IndexInfo record for an open index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IndexInfo stores the information about the index that's needed by<br/></li>
<li></span><span class="Comment"> * <a href="#L2705" title="catalog/index.c:2705">FormIndexDatum</a>, which is used for both <a href="#L2945" title="catalog/index.c:2945">index_build</a>() and later insertion<br/></li>
<li></span><span class="Comment"> * of individual index tuples.&nbsp; Normally we build an IndexInfo for an index<br/></li>
<li></span><span class="Comment"> * just once per command, and then use it for (potentially) many tuples.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexInfo *<br/></li>
<li><a id="L2407">&#x200c;</a><span class="linkable">BuildIndexInfo</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *ii;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index indexStruct = index-&gt;rd_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAtts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the number of keys, and copy attr numbers into the IndexInfo */<br/></li>
<li></span>&nbsp; &nbsp; numAtts = indexStruct-&gt;indnatts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numAtts &lt; <span class="Constant">1</span> || numAtts &gt; INDEX_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid indnatts </span><span class="Special">%d</span><span class="Constant"> for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numAtts, RelationGetRelid(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the node, fetching <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions needed for expressional<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes and index predicate if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ii = <a href="../nodes/makefuncs.c.html#L761" title="nodes/makefuncs.c:761">makeIndexInfo</a>(indexStruct-&gt;indnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indnkeyatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_rel-&gt;relam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a>(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indisunique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indnullsnotdistinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indisready,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_indam-&gt;amsummarizing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill in attribute numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAtts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;ii_IndexAttrNumbers[i] = indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fetch exclusion constraint info if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexStruct-&gt;indisexclusion)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L5581" title="utils/cache/relcache.c:5581">RelationGetExclusionInfo</a>(index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ii-&gt;ii_ExclusionOps,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ii-&gt;ii_ExclusionProcs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ii-&gt;ii_ExclusionStrats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ii;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2466" title="catalog/index.c:2466">BuildDummyIndexInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Construct a dummy IndexInfo record for an open index<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This differs from the real <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a> in that it will never run <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * user-defined code that might exist in index expressions or predicates.<br/></li>
<li></span><span class="Comment"> * Instead of the real index expressions, we return null constants that have<br/></li>
<li></span><span class="Comment"> * the right types/typmods/collations.&nbsp; Predicates and exclusion clauses are<br/></li>
<li></span><span class="Comment"> * just ignored.&nbsp; This is sufficient for the purpose of truncating an index,<br/></li>
<li></span><span class="Comment"> * since we will not need to actually evaluate the expressions or predicates;<br/></li>
<li></span><span class="Comment"> * the only thing that's likely to be done with the data is construction of<br/></li>
<li></span><span class="Comment"> * a tupdesc describing the index's rowtype.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexInfo *<br/></li>
<li><a id="L2466">&#x200c;</a><span class="linkable">BuildDummyIndexInfo</span>(Relation index)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *ii;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index indexStruct = index-&gt;rd_index;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numAtts;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* check the number of keys, and copy attr numbers into the IndexInfo */<br/></li>
<li></span>&nbsp; &nbsp; numAtts = indexStruct-&gt;indnatts;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numAtts &lt; <span class="Constant">1</span> || numAtts &gt; INDEX_MAX_KEYS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid indnatts </span><span class="Special">%d</span><span class="Constant"> for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numAtts, RelationGetRelid(index));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Create the node, using dummy index expressions, and pretending there is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no predicate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ii = <a href="../nodes/makefuncs.c.html#L761" title="nodes/makefuncs.c:761">makeIndexInfo</a>(indexStruct-&gt;indnatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indnkeyatts,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_rel-&gt;relam,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/relcache.c.html#L5084" title="utils/cache/relcache.c:5084">RelationGetDummyIndexExpressions</a>(index),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indisunique,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indnullsnotdistinct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexStruct-&gt;indisready,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_indam-&gt;amsummarizing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* fill in attribute numbers */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numAtts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;ii_IndexAttrNumbers[i] = indexStruct-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We ignore the exclusion constraint if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ii;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2514" title="catalog/index.c:2514">CompareIndexInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Return whether the properties of two indexes (in different tables)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; indicate that they have the &quot;same&quot; definitions.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: passing collations and opfamilies separately is a kludge.&nbsp; Adding<br/></li>
<li></span><span class="Comment"> * them to IndexInfo may result in better coding here and elsewhere.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Use <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(index2, index1) to build the attmap.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L2514">&#x200c;</a></span><span class="linkable">CompareIndexInfo</span>(<span class="Type">const</span> IndexInfo *info1, <span class="Type">const</span> IndexInfo *info2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *collations1, <span class="Type">const</span> Oid *collations2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> Oid *opfamilies1, <span class="Type">const</span> Oid *opfamilies2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> AttrMap *attmap)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_Unique != info2-&gt;ii_Unique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_NullsNotDistinct != info2-&gt;ii_NullsNotDistinct)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* indexes are only equivalent if they have the same access method */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_Am != info2-&gt;ii_Am)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and same number of attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_NumIndexAttrs != info2-&gt;ii_NumIndexAttrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and same number of key attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_NumIndexKeyAttrs != info2-&gt;ii_NumIndexKeyAttrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and columns match through the attribute map (actual attribute numbers<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * might differ!)&nbsp; Note that this checks that index columns that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions appear in the same positions.&nbsp; We will <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../optimizer/geqo/geqo_pool.c.html#L145" title="optimizer/geqo/geqo_pool.c:145">compare</a> the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expressions themselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; info1-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attmap-&gt;maplen &lt; info2-&gt;ii_IndexAttrNumbers[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;incorrect attribute map&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore expressions for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> (but check their collation/opfamily) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!(info1-&gt;ii_IndexAttrNumbers[i] == InvalidAttrNumber &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info2-&gt;ii_IndexAttrNumbers[i] == InvalidAttrNumber))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* fail if just one index has an expression in this column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_IndexAttrNumbers[i] == InvalidAttrNumber ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info2-&gt;ii_IndexAttrNumbers[i] == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both are columns, so check for match after mapping */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attmap-&gt;attnums[info2-&gt;ii_IndexAttrNumbers[i] - <span class="Constant">1</span>] !=<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; info1-&gt;ii_IndexAttrNumbers[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* collation and opfamily are not valid for included columns */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &gt;= info1-&gt;ii_NumIndexKeyAttrs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (collations1[i] != collations2[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opfamilies1[i] != opfamilies2[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For expression indexes: either both are expression indexes, or neither<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is; if they are, make sure the expressions match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((info1-&gt;ii_Expressions != NIL) != (info2-&gt;ii_Expressions != NIL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_Expressions != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *mapped;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapped = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>((Node *) info2-&gt;ii_Expressions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>, attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we could throw an error here, but seems out of scope for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(info1-&gt;ii_Expressions, mapped))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Partial index predicates must be identical, if they exist */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((info1-&gt;ii_Predicate == <span class="Constant">NULL</span>) != (info2-&gt;ii_Predicate == <span class="Constant">NULL</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_Predicate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *mapped;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; mapped = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>((Node *) info2-&gt;ii_Predicate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>, attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we could throw an error here, but seems out of scope for this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * routine.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(info1-&gt;ii_Predicate, mapped))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No support currently for comparing exclusion indexes. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (info1-&gt;ii_ExclusionOps != <span class="Constant">NULL</span> || info2-&gt;ii_ExclusionOps != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2645" title="catalog/index.c:2645">BuildSpeculativeIndexInfo</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Add extra state to IndexInfo record<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For unique indexes, we usually don't want to add info to the IndexInfo for<br/></li>
<li></span><span class="Comment"> * checking uniqueness, since the B-Tree AM handles that directly.&nbsp; However,<br/></li>
<li></span><span class="Comment"> * in the case of speculative insertion, additional support is required.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Do this processing here rather than in <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>() to not incur the<br/></li>
<li></span><span class="Comment"> * overhead in the common non-speculative cases.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2645">&#x200c;</a></span><span class="linkable">BuildSpeculativeIndexInfo</span>(Relation index, IndexInfo *ii)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indnkeyatts;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indnkeyatts = IndexRelationGetNumberOfKeyAttributes(index);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch info for checking unique indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(ii-&gt;ii_Unique);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;rd_rel-&gt;relam != BTREE_AM_OID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected non-btree speculative unique index&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ii-&gt;ii_UniqueOps = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; ii-&gt;ii_UniqueProcs = (Oid *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid) * indnkeyatts);<br/></li>
<li>&nbsp; &nbsp; ii-&gt;ii_UniqueStrats = (uint16 *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(uint16) * indnkeyatts);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have to look up the operator's strategy number.&nbsp; This provides a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cross-check that the operator does match the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* We need the func OIDs and strategy numbers too */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indnkeyatts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;ii_UniqueStrats[i] = BTEqualStrategyNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;ii_UniqueOps[i] =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L166" title="utils/cache/lsyscache.c:166">get_opfamily_member</a>(index-&gt;rd_opfamily[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rd_opcintype[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;rd_opcintype[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;ii_UniqueStrats[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(ii-&gt;ii_UniqueOps[i]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;missing operator </span><span class="Special">%d</span><span class="Constant">(</span><span class="Special">%u</span><span class="Constant">,</span><span class="Special">%u</span><span class="Constant">) in opfamily </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ii-&gt;ii_UniqueStrats[i], index-&gt;rd_opcintype[i],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_opcintype[i], index-&gt;rd_opfamily[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ii-&gt;ii_UniqueProcs[i] = <a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(ii-&gt;ii_UniqueOps[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2705" title="catalog/index.c:2705">FormIndexDatum</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Construct <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] and isnull[] arrays for a new index tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; indexInfo&nbsp; &nbsp; &nbsp; &nbsp; Info about the index<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; slot&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Heap tuple for which we must prepare an index entry<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; estate&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; executor state for evaluating <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index expressions<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Array of index Datums (output area)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isnull&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Array of is-null indicators (output area)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When there are no index expressions, estate may be NULL.&nbsp; Otherwise it<br/></li>
<li></span><span class="Comment"> * must be supplied, *and* the ecxt_scantuple slot of its per-tuple expr<br/></li>
<li></span><span class="Comment"> * context must point to the heap tuple passed in.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Notice we don't actually call <a href="../access/common/indextuple.c.html#L44" title="access/common/indextuple.c:44">index_form_tuple</a>() here; we just prepare<br/></li>
<li></span><span class="Comment"> * its input arrays <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] and isnull[].&nbsp; This is because the index AM<br/></li>
<li></span><span class="Comment"> * may wish to alter the data <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> storage.<br/></li>
<li></span><span class="Comment"> * ----------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2705">&#x200c;</a></span><span class="linkable">FormIndexDatum</span>(IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TupleTableSlot *slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EState *estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Datum *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isnull)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Expressions != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_ExpressionsState == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through, set up expression evaluation state */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_ExpressionsState =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execExpr.c.html#L813" title="executor/execExpr.c:813">ExecPrepareExprList</a>(indexInfo-&gt;ii_Expressions, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check caller has set up context correctly */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(GetPerTupleExprContext(estate)-&gt;ecxt_scantuple == slot);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; indexpr_item = list_head(indexInfo-&gt;ii_ExpressionsState);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; indexInfo-&gt;ii_NumIndexAttrs; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keycol = indexInfo-&gt;ii_IndexAttrNumbers[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; iDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keycol &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iDatum = slot_getsysattr(slot, keycol, &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (keycol != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Plain index column; get the value we need directly from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * heap tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iDatum = slot_getattr(slot, keycol, &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Index expression --- need to evaluate it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of index expressions&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iDatum = ExecEvalExprSwitchContext((ExprState *) lfirst(indexpr_item),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; GetPerTupleExprContext(estate),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(indexInfo-&gt;ii_ExpressionsState, indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = iDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isnull[i] = isNull;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;wrong number of index expressions&quot;</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2784" title="catalog/index.c:2784">index_update_stats</a> --- update pg_class entry after CREATE INDEX or REINDEX<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine updates the pg_class row of either an index or its parent<br/></li>
<li></span><span class="Comment"> * relation after CREATE INDEX or REINDEX.&nbsp; Its rather bizarre API is designed<br/></li>
<li></span><span class="Comment"> * to ensure we can do all the necessary work in just one update.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * hasindex: set relhasindex to this value<br/></li>
<li></span><span class="Comment"> * reltuples: if &gt;= 0, set reltuples to this value; else no change<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If reltuples &gt;= 0, relpages and relallvisible are also updated (using<br/></li>
<li></span><span class="Comment"> * RelationGetNumberOfBlocks() and <a href="../access/heap/visibilitymap.c.html#L384" title="access/heap/visibilitymap.c:384">visibilitymap_count</a>()).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: an important side-effect of this operation is that an SI invalidation<br/></li>
<li></span><span class="Comment"> * message is sent out to all backends --- including me --- causing relcache<br/></li>
<li></span><span class="Comment"> * entries to be flushed or updated with the new data.&nbsp; This must happen even<br/></li>
<li></span><span class="Comment"> * if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> that no change is needed in the pg_class row.&nbsp; When updating<br/></li>
<li></span><span class="Comment"> * a heap entry, this ensures that other backends <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out about the new<br/></li>
<li></span><span class="Comment"> * index.&nbsp; When updating an index, it's important because some index AMs<br/></li>
<li></span><span class="Comment"> * expect a relcache flush to occur after REINDEX.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2784">&#x200c;</a></span><span class="linkable">index_update_stats</span>(Relation rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">double</span> reltuples)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relid = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_class;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class rd_rel;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; dirty;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We always update the pg_class row using a non-transactional,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * overwrite-in-place update.&nbsp; There are several reasons for this:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 1. In bootstrap mode, we have no choice --- UPDATE wouldn't work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 2. We could be reindexing pg_class itself, in which case we can't move<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its pg_class row because <a href="indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>/<a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a> might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not know about all the indexes yet (see <a href="#L3892" title="catalog/index.c:3892">reindex_relation</a>).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 3. Because we execute CREATE INDEX with just share lock on the parent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rel (to allow concurrent index creations), an ordinary update could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suffer a tuple-concurrently-updated failure against another CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INDEX committing at about the same time.&nbsp; We can avoid that by having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them both do nontransactional updates (we assume they will both be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * trying to change the pg_class row to the same thing, so it doesn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter which goes first).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is safe to use a non-transactional update even though our<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transaction could still fail <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> committing.&nbsp; Setting relhasindex<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * true is safe even if there are no indexes (VACUUM will eventually fix<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it).&nbsp; And of course the new relpages and reltuples counts are correct<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regardless.&nbsp; However, we don't want to change relpages (or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relallvisible) if the caller isn't providing an updated reltuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * count, because that would bollix the reltuples/relpages ratio which is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * what's really important.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pg_class = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(RelationRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a copy of the tuple to update.&nbsp; Normally we use the syscache, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't rely on that during bootstrap or while reindexing pg_class<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * itself.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode() ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4055" title="catalog/index.c:4055">ReindexIsProcessingHeap</a>(RelationRelationId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't assume syscache will work */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; TableScanDesc pg_class_scan;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ScanKeyData key[<span class="Constant">1</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_class_scan = <a href="../access/table/tableam.c.html#L112" title="access/table/tableam.c:112">table_beginscan_catalog</a>(pg_class, <span class="Constant">1</span>, key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/heap/heapam.c.html#L1248" title="access/heap/heapam.c:1248">heap_getnext</a>(pg_class_scan, ForwardScanDirection);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L776" title="access/common/heaptuple.c:776">heap_copytuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_endscan(pg_class_scan);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* normal case, use syscache */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tuple = SearchSysCacheCopy1(RELOID, ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, relid);<br/></li>
<li>&nbsp; &nbsp; rd_rel = (Form_pg_class) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Should this be a more comprehensive test? */<br/></li>
<li></span>&nbsp; &nbsp; Assert(rd_rel-&gt;relkind != RELKIND_PARTITIONED_INDEX);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a special hack, if we are dealing with an empty table and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * existing reltuples is -1, we leave that alone.&nbsp; This ensures that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creating an index as part of CREATE TABLE doesn't cause the table to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prematurely look like it's been vacuumed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reltuples == <span class="Constant">0</span> &amp;&amp; rd_rel-&gt;reltuples &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; reltuples = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Apply required updates, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, to copied tuple */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; dirty = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;relhasindex != hasindex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rd_rel-&gt;relhasindex = hasindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Avoid updating statistics during binary upgrade, because the indexes<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are created <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the data is moved into place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (reltuples &gt;= <span class="Constant">0</span> &amp;&amp; !<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber relpages = RelationGetNumberOfBlocks(rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; BlockNumber relallvisible;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;relkind != RELKIND_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/heap/visibilitymap.c.html#L384" title="access/heap/visibilitymap.c:384">visibilitymap_count</a>(rel, &amp;relallvisible, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't bother for indexes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relallvisible = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;relpages != (int32) relpages)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rd_rel-&gt;relpages = (int32) relpages;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;reltuples != (float4) reltuples)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rd_rel-&gt;reltuples = (float4) reltuples;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rd_rel-&gt;relallvisible != (int32) relallvisible)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rd_rel-&gt;relallvisible = (int32) relallvisible;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dirty = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If anything changed, write out the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (dirty)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L6055" title="access/heap/heapam.c:6055">heap_inplace_update</a>(pg_class, tuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the above sends a cache inval message */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* no need to change tuple, but force relcache inval anyway */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1396" title="utils/cache/inval.c:1396">CacheInvalidateRelcacheByTuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_class, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2945" title="catalog/index.c:2945">index_build</a> - invoke access-method-specific index build procedure<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * On entry, the index's catalog entries are valid, and its physical disk<br/></li>
<li></span><span class="Comment"> * file has been created but is empty.&nbsp; We call the AM-specific build<br/></li>
<li></span><span class="Comment"> * procedure to fill in the index contents.&nbsp; We then update the pg_class<br/></li>
<li></span><span class="Comment"> * entries of the index and heap relation as needed, using statistics<br/></li>
<li></span><span class="Comment"> * returned by ambuild as well as data passed by the caller.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * isreindex indicates we are recreating a previously-existing index.<br/></li>
<li></span><span class="Comment"> * parallel indicates if parallelism may be useful.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Postgres 8.2, the passed-in heap and index Relations<br/></li>
<li></span><span class="Comment"> * were automatically closed by this routine.&nbsp; This is no longer the case.<br/></li>
<li></span><span class="Comment"> * The caller opened 'em, and the caller should close 'em.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L2945">&#x200c;</a></span><span class="linkable">index_build</span>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexInfo *indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isreindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> parallel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexBuildResult *stats;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(RelationIsValid(indexRelation));<br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(indexRelation-&gt;rd_indam));<br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(indexRelation-&gt;rd_indam-&gt;ambuild));<br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(indexRelation-&gt;rd_indam-&gt;ambuildempty));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine worker process details for parallel CREATE INDEX.&nbsp; Currently,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only btree has support for parallel builds.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> considers parallel safety for us.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (parallel &amp;&amp; IsNormalProcessingMode() &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indam-&gt;amcanbuildparallel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_ParallelWorkers =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/plan/planner.c.html#L6657" title="optimizer/plan/planner.c:6657">plan_create_index_workers</a>(RelationGetRelid(heapRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(indexRelation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_ParallelWorkers == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;building index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> serially&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(heapRelation))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;building index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> on table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> with request for </span><span class="Special">%d</span><span class="Constant"> parallel workers&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(indexRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(heapRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo-&gt;ii_ParallelWorkers)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to the table owner's userid, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as that user.&nbsp; Also lock down security-restricted operations and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange to make GUC variable changes local to this command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(heapRelation-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up initial progress report status */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_SUBPHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_TUPLES_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_TUPLES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_TOTAL<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int64 progress_vals[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_PHASE_BUILD,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_SUBPHASE_INITIALIZE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">6</span>, progress_index, progress_vals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the access method's build procedure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stats = indexRelation-&gt;rd_indam-&gt;ambuild(heapRelation, indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo);<br/></li>
<li>&nbsp; &nbsp; Assert(PointerIsValid(stats));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is an unlogged index, we may need to write out an init fork for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it -- but we must first check whether one already exists.&nbsp; If, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * example, an unlogged relation is truncated in the transaction that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * created it, or truncated twice in a subsequent transaction, the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relfilenumber won't change, and nothing needs to be done here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexRelation-&gt;rd_rel-&gt;relpersistence == RELPERSISTENCE_UNLOGGED &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../storage/smgr/smgr.c.html#L398" title="storage/smgr/smgr.c:398">smgrexists</a>(RelationGetSmgr(indexRelation), INIT_FORKNUM))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../storage/smgr/smgr.c.html#L411" title="storage/smgr/smgr.c:411">smgrcreate</a>(RelationGetSmgr(indexRelation), INIT_FORKNUM, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="storage.c.html#L186" title="catalog/storage.c:186">log_smgrcreate</a>(&amp;indexRelation-&gt;rd_locator, INIT_FORKNUM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexRelation-&gt;rd_indam-&gt;ambuildempty(indexRelation);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> potentially broken HOT chains, mark the index as not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * being usable until the current transaction is below the event horizon.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * See src/backend/access/heap/README.HOT for discussion.&nbsp; While it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * become safe to use the index earlier based on actual <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> activity<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and other active transactions, the test for that would be much more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * complex and would require some form of blocking, so keep it simple and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fast by just using the current transaction.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * However, when reindexing an existing index, we should do nothing here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Any HOT chains that are broken with respect to the index must predate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index's original creation, so there is no need to change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index's usability horizon.&nbsp; Moreover, we *must not* try to change the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index's pg_index entry while reindexing pg_index itself, and this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * optimization nicely prevents that.&nbsp; The more complex rules needed for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reindex are handled separately after this function returns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also need not set indcheckxmin during a concurrent index build,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because we won't set indisvalid true until all transactions that care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about the broken HOT chains are gone.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Therefore, this code path can only be taken during non-concurrent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CREATE INDEX.&nbsp; Thus the fact that <a href="../access/heap/heapam.c.html#L3146" title="access/heap/heapam.c:3146">heap_update</a> will set the pg_index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tuple's xmin doesn't matter, because that tuple was created in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current transaction anyway.&nbsp; That also means we don't need to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * about <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> concurrent readers of the tuple; no other transaction can see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it yet.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_BrokenHotChain &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !isreindex &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !indexInfo-&gt;ii_Concurrent)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexId = RelationGetRelid(indexRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; pg_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexTuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(indexId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm = (Form_pg_index) GETSTRUCT(indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a new index, indcheckxmin shouldn't be set ... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indcheckxmin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indcheckxmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(indexTuple);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update heap and index pg_class rows<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2784" title="catalog/index.c:2784">index_update_stats</a>(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stats-&gt;heap_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L2784" title="catalog/index.c:2784">index_update_stats</a>(indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stats-&gt;index_tuples);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make the updated catalog row versions visible */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's for an exclusion constraint, make a second pass over the heap<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to verify that the constraint is satisfied.&nbsp; We must not do this until<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index is fully valid.&nbsp; (Broken HOT chains shouldn't matter, though;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * see comments for <a href="#L3138" title="catalog/index.c:3138">IndexCheckExclusion</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_ExclusionOps != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3138" title="catalog/index.c:3138">IndexCheckExclusion</a>(heapRelation, indexRelation, indexInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes executed by index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3138" title="catalog/index.c:3138">IndexCheckExclusion</a> - verify that a new exclusion constraint is satisfied<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When creating an exclusion constraint, we first build the index normally<br/></li>
<li></span><span class="Comment"> * and then rescan the heap to check for conflicts.&nbsp; We assume that we only<br/></li>
<li></span><span class="Comment"> * need to validate tuples that are live according to an up-to-date snapshot,<br/></li>
<li></span><span class="Comment"> * and that these were correctly indexed even in the presence of broken HOT<br/></li>
<li></span><span class="Comment"> * chains.&nbsp; This should be OK since we are holding at least ShareLock on the<br/></li>
<li></span><span class="Comment"> * table, meaning there can be no uncommitted updates from other transactions.<br/></li>
<li></span><span class="Comment"> * (Note: that wouldn't necessarily work for system catalogs, since many<br/></li>
<li></span><span class="Comment"> * operations release write lock early on the system catalogs.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3138">&#x200c;</a></span><span class="linkable">IndexCheckExclusion</span>(Relation heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexInfo *indexInfo)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TableScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; ExprState&nbsp; *predicate;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate;<br/></li>
<li>&nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; Snapshot&nbsp; &nbsp; snapshot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are reindexing the target index, mark it as no longer being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reindexed, to forestall an Assert in <a href="../access/index/indexam.c.html#L256" title="access/index/indexam.c:256">index_beginscan</a> when we try to use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index for probes.&nbsp; This is OK because the index is <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> fully valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4065" title="catalog/index.c:4065">ReindexIsCurrentlyProcessingIndex</a>(RelationGetRelid(indexRelation)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4106" title="catalog/index.c:4106">ResetReindexProcessing</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Need an EState for evaluation of index expressions and partial-index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * predicates.&nbsp; Also a slot to hold the current tuple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li>&nbsp; &nbsp; slot = <a href="../access/table/tableam.c.html#L91" title="access/table/tableam.c:91">table_slot_create</a>(heapRelation, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Arrange for econtext's scan tuple to be the tuple under test */<br/></li>
<li></span>&nbsp; &nbsp; econtext-&gt;ecxt_scantuple = slot;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up execution state for predicate, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; predicate = <a href="../executor/execExpr.c.html#L767" title="executor/execExpr.c:767">ExecPrepareQual</a>(indexInfo-&gt;ii_Predicate, estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan all live tuples in the base relation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; snapshot = <a href="../utils/time/snapmgr.c.html#L794" title="utils/time/snapmgr.c:794">RegisterSnapshot</a>(<a href="../utils/time/snapmgr.c.html#L291" title="utils/time/snapmgr.c:291">GetLatestSnapshot</a>());<br/></li>
<li>&nbsp; &nbsp; scan = table_beginscan_strat(heapRelation,&nbsp; &nbsp; <span class="Comment">/* relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snapshot,&nbsp; &nbsp; <span class="Comment">/* snapshot */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Comment">/* number of keys */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* scan key */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,&nbsp; &nbsp; <span class="Comment">/* buffer access strategy OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>); <span class="Comment">/* syncscan OK */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (table_scan_getnextslot(scan, ForwardScanDirection, slot))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In a partial index, ignore tuples that don't satisfy the predicate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (predicate != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!ExecQual(predicate, econtext))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract index column <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, including computing expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2705" title="catalog/index.c:2705">FormIndexDatum</a>(indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that this tuple has no conflicts.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execIndexing.c.html#L915" title="executor/execIndexing.c:915">check_exclusion_constraint</a>(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexRelation, indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(slot-&gt;tts_tid), <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, isnull,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; estate, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L383" title="utils/mmgr/mcxt.c:383">MemoryContextReset</a>(econtext-&gt;ecxt_per_tuple_memory);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; table_endscan(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/time/snapmgr.c.html#L836" title="utils/time/snapmgr.c:836">UnregisterSnapshot</a>(snapshot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(slot);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These may have been pointing to the <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>-gone estate */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo-&gt;ii_ExpressionsState = NIL;<br/></li>
<li>&nbsp; &nbsp; indexInfo-&gt;ii_PredicateState = <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3294" title="catalog/index.c:3294">validate_index</a> - support code for concurrent index builds<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We do a concurrent index build by first inserting the catalog entry for the<br/></li>
<li></span><span class="Comment"> * index via <a href="#L724" title="catalog/index.c:724">index_create</a>(), marking it not indisready and not indisvalid.<br/></li>
<li></span><span class="Comment"> * Then we commit our transaction and start a new one, then we wait for all<br/></li>
<li></span><span class="Comment"> * transactions that could have been modifying the table to terminate.&nbsp; Now<br/></li>
<li></span><span class="Comment"> * we know that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequently-started transactions will see the index and<br/></li>
<li></span><span class="Comment"> * honor its constraints on HOT updates; so while existing HOT-chains might<br/></li>
<li></span><span class="Comment"> * be broken with respect to the index, no currently live tuple will have an<br/></li>
<li></span><span class="Comment"> * incompatible HOT update done to it.&nbsp; We <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> build the index normally via<br/></li>
<li></span><span class="Comment"> * <a href="#L2945" title="catalog/index.c:2945">index_build</a>(), while holding a weak lock that allows concurrent<br/></li>
<li></span><span class="Comment"> * insert/update/delete.&nbsp; Also, we index only tuples that are valid<br/></li>
<li></span><span class="Comment"> * as of the start of the scan (see table_index_build_scan), whereas a normal<br/></li>
<li></span><span class="Comment"> * build takes care to include recently-dead tuples.&nbsp; This is OK because<br/></li>
<li></span><span class="Comment"> * we won't mark the index valid until all transactions that might be able<br/></li>
<li></span><span class="Comment"> * to see those tuples are gone.&nbsp; The reason for doing that is to avoid<br/></li>
<li></span><span class="Comment"> * bogus unique-index failures due to concurrent UPDATEs (we might see<br/></li>
<li></span><span class="Comment"> * different versions of the same row as being valid when we pass over them,<br/></li>
<li></span><span class="Comment"> * if we used <a href="../access/heap/heapam_visibility.c.html#L1162" title="access/heap/heapam_visibility.c:1162">HeapTupleSatisfiesVacuum</a>).&nbsp; This leaves us with an index that<br/></li>
<li></span><span class="Comment"> * does not contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> tuples added to the table while we built the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Next, we mark the index &quot;indisready&quot; (but still not &quot;indisvalid&quot;) and<br/></li>
<li></span><span class="Comment"> * commit the second transaction and start a third.&nbsp; Again we wait for all<br/></li>
<li></span><span class="Comment"> * transactions that could have been modifying the table to terminate.&nbsp; Now<br/></li>
<li></span><span class="Comment"> * we know that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsequently-started transactions will see the index and<br/></li>
<li></span><span class="Comment"> * insert their new tuples into it.&nbsp; We then take a new reference snapshot<br/></li>
<li></span><span class="Comment"> * which is passed to <a href="#L3294" title="catalog/index.c:3294">validate_index</a>().&nbsp; Any tuples that are valid according<br/></li>
<li></span><span class="Comment"> * to this snap, but are not in the index, must be added to the index.<br/></li>
<li></span><span class="Comment"> * (Any tuples committed live after the snap will be inserted into the<br/></li>
<li></span><span class="Comment"> * index by their originating transaction.&nbsp; Any tuples committed dead <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment"> * the snap need not be indexed, because we will wait out all transactions<br/></li>
<li></span><span class="Comment"> * that might care about them <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we mark the index valid.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="#L3294" title="catalog/index.c:3294">validate_index</a>() works by first gathering all the TIDs currently in the<br/></li>
<li></span><span class="Comment"> * index, using a bulkdelete callback that just stores the TIDs and doesn't<br/></li>
<li></span><span class="Comment"> * ever say &quot;delete it&quot;.&nbsp; (This should be faster than a plain indexscan;<br/></li>
<li></span><span class="Comment"> * also, not all index AMs support full-index indexscan.)&nbsp; Then we sort the<br/></li>
<li></span><span class="Comment"> * TIDs, and finally scan the table doing a &quot;<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join&quot; against the TID list<br/></li>
<li></span><span class="Comment"> * to see which tuples are missing from the index.&nbsp; Thus we will ensure that<br/></li>
<li></span><span class="Comment"> * all tuples valid according to the reference snapshot are in the index.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Building a unique index this way is tricky: we might try to insert a<br/></li>
<li></span><span class="Comment"> * tuple that is already dead or is in process of being deleted, and we<br/></li>
<li></span><span class="Comment"> * mustn't have a uniqueness failure against an updated version of the same<br/></li>
<li></span><span class="Comment"> * row.&nbsp; We could try to check the tuple to see if it's already dead and tell<br/></li>
<li></span><span class="Comment"> * <a href="../access/index/indexam.c.html#L213" title="access/index/indexam.c:213">index_insert</a>() not to do the uniqueness check, but that still leaves us<br/></li>
<li></span><span class="Comment"> * with a race condition against an in-progress update.&nbsp; To handle that,<br/></li>
<li></span><span class="Comment"> * we expect the index AM to recheck liveness of the to-be-inserted tuple<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it declares a uniqueness error.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * After completing <a href="#L3294" title="catalog/index.c:3294">validate_index</a>(), we wait until all transactions that<br/></li>
<li></span><span class="Comment"> * were alive at the time of the reference snapshot are gone; this is<br/></li>
<li></span><span class="Comment"> * necessary to be sure there are <a href="../optimizer/util/predtest.c.html#L1670" title="optimizer/util/predtest.c:1670">none</a> left with a transaction snapshot<br/></li>
<li></span><span class="Comment"> * older than the reference (and hence possibly able to see tuples we did<br/></li>
<li></span><span class="Comment"> * not index).&nbsp; Then we mark the index &quot;indisvalid&quot; and commit.&nbsp; Subsequent<br/></li>
<li></span><span class="Comment"> * transactions will be able to use it for queries.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Doing two full table scans is a brute-force strategy.&nbsp; We could try to be<br/></li>
<li></span><span class="Comment"> * cleverer, eg storing new tuples in a special area of the table (perhaps<br/></li>
<li></span><span class="Comment"> * making the table append-only by setting use_fsm).&nbsp; However that would<br/></li>
<li></span><span class="Comment"> * add yet more locking issues.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3294">&#x200c;</a></span><span class="linkable">validate_index</span>(Oid heapId, Oid indexId, Snapshot snapshot)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelation;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li>&nbsp; &nbsp; IndexVacuumInfo ivinfo;<br/></li>
<li>&nbsp; &nbsp; ValidateIndexState state;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_TUPLES_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_TUPLES_TOTAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_TOTAL<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int64 progress_vals[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_PHASE_VALIDATE_IDXSCAN,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0</span>, <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">5</span>, progress_index, progress_vals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open and lock the parent heap relation */<br/></li>
<li></span>&nbsp; &nbsp; heapRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapId, ShareUpdateExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to the table owner's userid, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as that user.&nbsp; Also lock down security-restricted operations and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange to make GUC variable changes local to this command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(heapRelation-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexRelation = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch info needed for <a href="../access/index/indexam.c.html#L213" title="access/index/indexam.c:213">index_insert</a>.&nbsp; (You might think this should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * passed in from <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>, but its copy is long gone due to having<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been built in a previous transaction.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo = <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(indexRelation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark build is concurrent just for consistency */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo-&gt;ii_Concurrent = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the index and gather up all the TIDs into a tuplesort object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ivinfo.index = indexRelation;<br/></li>
<li>&nbsp; &nbsp; ivinfo.heaprel = heapRelation;<br/></li>
<li>&nbsp; &nbsp; ivinfo.analyze_only = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.report_progress = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.estimated_count = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; ivinfo.message_level = DEBUG2;<br/></li>
<li>&nbsp; &nbsp; ivinfo.num_heap_tuples = heapRelation-&gt;rd_rel-&gt;reltuples;<br/></li>
<li>&nbsp; &nbsp; ivinfo.strategy = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Encode TIDs as int8 <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the sort, rather than directly sorting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * item pointers.&nbsp; This can be significantly faster, primarily because TID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is a pass-by-reference type on all platforms, whereas int8 is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pass-by-value on most platforms.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; state.tuplesort = <a href="../utils/sort/tuplesortvariants.c.html#L584" title="utils/sort/tuplesortvariants.c:584">tuplesort_begin_datum</a>(INT8OID, Int8LessOperator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/globals.c.html#L130" title="utils/init/globals.c:130">maintenance_work_mem</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, TUPLESORT_NONE);<br/></li>
<li>&nbsp; &nbsp; state.htups = state.itups = state.tups_inserted = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ambulkdelete updates progress metrics */<br/></li>
<li></span>&nbsp; &nbsp; (<span class="Type">void</span>) <a href="../access/index/indexam.c.html#L748" title="access/index/indexam.c:748">index_bulk_delete</a>(&amp;ivinfo, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L3427" title="catalog/index.c:3427">validate_index_callback</a>, (<span class="Type">void</span> *) &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Execute the sort */<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_index[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_DONE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_SCAN_BLOCKS_TOTAL<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int64 progress_vals[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_PHASE_VALIDATE_SORT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>, <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">3</span>, progress_index, progress_vals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L1385" title="utils/sort/tuplesort.c:1385">tuplesort_performsort</a>(state.tuplesort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now scan the heap and &quot;<a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a>&quot; it with the index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_PHASE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PROGRESS_CREATEIDX_PHASE_VALIDATE_TABLESCAN);<br/></li>
<li>&nbsp; &nbsp; table_index_validate_scan(heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snapshot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;state);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with tuplesort object */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/sort/tuplesort.c.html#L971" title="utils/sort/tuplesort.c:971">tuplesort_end</a>(state.tuplesort);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make sure to release resources cached in indexInfo (if needed). */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L241" title="access/index/indexam.c:241">index_insert_cleanup</a>(indexRelation, indexInfo);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; elog(DEBUG2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;<a href="#L3294" title="catalog/index.c:3294">validate_index</a> found </span><span class="Special">%.0f</span><span class="Constant"> heap tuples, </span><span class="Special">%.0f</span><span class="Constant"> index tuples; inserted </span><span class="Special">%.0f</span><span class="Constant"> missing tuples&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; state.htups, state.itups, state.tups_inserted);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes executed by index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close rels, but keep locks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(indexRelation, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRelation, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3427" title="catalog/index.c:3427">validate_index_callback</a> - bulkdelete callback to collect the index TIDs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3427">&#x200c;</a></span><span class="linkable">validate_index_callback</span>(ItemPointer itemptr, <span class="Type">void</span> *opaque)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ValidateIndexState *state = (ValidateIndexState *) opaque;<br/></li>
<li>&nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; encoded = itemptr_encode(itemptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/sort/tuplesortvariants.c.html#L826" title="utils/sort/tuplesortvariants.c:826">tuplesort_putdatum</a>(state-&gt;tuplesort, <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(encoded), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; state-&gt;itups += <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* never actually delete anything */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3447" title="catalog/index.c:3447">index_set_state_flags</a> - adjust pg_index state flags<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is used during CREATE/DROP INDEX CONCURRENTLY to adjust the pg_index<br/></li>
<li></span><span class="Comment"> * flags that denote the index's state.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>() sends a cache invalidation message for the<br/></li>
<li></span><span class="Comment"> * tuple, so other sessions will hear about the update as soon as we commit.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3447">&#x200c;</a></span><span class="linkable">index_set_state_flags</span>(Oid indexId, IndexStateFlagsAction action)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_index;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index indexForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open pg_index and fetch a writable copy of the index's tuple */<br/></li>
<li></span>&nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexTuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(indexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexId);<br/></li>
<li>&nbsp; &nbsp; indexForm = (Form_pg_index) GETSTRUCT(indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Perform the requested state change on the copy */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (action)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_CREATE_SET_READY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set indisready during a CREATE INDEX CONCURRENTLY sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(indexForm-&gt;indislive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indisready);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indisvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisready = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_CREATE_SET_VALID:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set indisvalid during a CREATE INDEX CONCURRENTLY sequence */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(indexForm-&gt;indislive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(indexForm-&gt;indisready);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indisvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_DROP_CLEAR_VALID:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear indisvalid during a DROP INDEX CONCURRENTLY sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If indisready == true we leave it set so the index still gets<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maintained by active transactions.&nbsp; We only need to ensure that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indisvalid is false.&nbsp; (We don't assert that either is initially<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * true, though, since we want to be able to retry a DROP INDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CONCURRENTLY that failed partway through.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: the CLUSTER logic assumes that indisclustered cannot be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid index, so clear that flag too.&nbsp; For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cleanliness, also clear indisreplident.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisvalid = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisclustered = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisreplident = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> INDEX_DROP_SET_DEAD:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Clear indisready/indislive during DROP INDEX CONCURRENTLY<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We clear both indisready and indislive, because we not only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to stop updates, we want to prevent sessions from touching<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the index at all.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indisvalid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indisclustered);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!indexForm-&gt;indisreplident);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisready = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indislive = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ... and update it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3527" title="catalog/index.c:3527">IndexGetRelation</a>: given an index's relation OID, get the OID of the<br/></li>
<li></span><span class="Comment"> * relation it is an index on.&nbsp; Uses the system cache.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L3527">&#x200c;</a><span class="linkable">IndexGetRelation</span>(Oid indexId, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> missing_ok)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index index;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(INDEXRELID, ObjectIdGetDatum(indexId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (missing_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexId);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; index = (Form_pg_index) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; Assert(index-&gt;indexrelid == indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = index-&gt;indrelid;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3552" title="catalog/index.c:3552">reindex_index</a> - This routine is used to recreate a single index<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3552">&#x200c;</a></span><span class="linkable">reindex_index</span>(<span class="Type">const</span> ReindexStmt *stmt, Oid indexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skip_constraint_checks, <span class="Type">char</span> persistence,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> ReindexParams *params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; iRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapRelation;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapId;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_userid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_sec_context;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_nestlevel;<br/></li>
<li>&nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">volatile</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipped_constraint = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; PGRUsage&nbsp; &nbsp; ru0;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; progress = ((params-&gt;options &amp; REINDEXOPT_REPORT_PROGRESS) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; set_tablespace = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/pg_rusage.c.html#L27" title="utils/misc/pg_rusage.c:27">pg_rusage_init</a>(&amp;ru0);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open and lock the parent heap relation.&nbsp; ShareLock is sufficient since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we only need to be sure no schema or data changes are going on.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; heapId = <a href="#L3527" title="catalog/index.c:3527">IndexGetRelation</a>(indexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (params-&gt;options &amp; REINDEXOPT_MISSING_OK) != <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if relation is missing, leave */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(heapId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; REINDEXOPT_MISSING_OK) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; heapRelation = <a href="../access/table/table.c.html#L60" title="access/table/table.c:60">try_table_open</a>(heapId, ShareLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; heapRelation = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(heapId, ShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if relation is gone, leave */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!heapRelation)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Switch to the table owner's userid, so that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are run<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as that user.&nbsp; Also lock down security-restricted operations and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arrange to make GUC variable changes local to this command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L635" title="utils/init/miscinit.c:635">GetUserIdAndSecContext</a>(&amp;save_userid, &amp;save_sec_context);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(heapRelation-&gt;rd_rel-&gt;relowner,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; save_sec_context | SECURITY_RESTRICTED_OPERATION);<br/></li>
<li>&nbsp; &nbsp; save_nestlevel = <a href="../utils/misc/guc.c.html#L2237" title="utils/misc/guc.c:2237">NewGUCNestLevel</a>();<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2248" title="utils/misc/guc.c:2248">RestrictSearchPath</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">int</span>&nbsp; &nbsp; progress_cols[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_COMMAND,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_INDEX_OID<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> int64 progress_vals[] = {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PROGRESS_CREATEIDX_COMMAND_REINDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexId<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; };<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L28" title="utils/activity/backend_progress.c:28">pgstat_progress_start_command</a>(PROGRESS_COMMAND_CREATE_INDEX,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L122" title="utils/activity/backend_progress.c:122">pgstat_progress_update_multi_param</a>(<span class="Constant">2</span>, progress_cols, progress_vals);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the target index relation and get an exclusive lock on it, to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that no one else is touching this particular index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; REINDEXOPT_MISSING_OK) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iRel = <a href="../access/index/indexam.c.html#L152" title="access/index/indexam.c:152">try_index_open</a>(indexId, AccessExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iRel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(indexId, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if index relation is gone, leave */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!iRel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close parent heap relation, but keep locks */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRelation, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CREATEIDX_ACCESS_METHOD_OID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; iRel-&gt;rd_rel-&gt;relam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a statement is available, telling that this comes from a REINDEX<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command, collect the index for event triggers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, indexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/event_trigger.c.html#L1590" title="commands/event_trigger.c:1590">EventTriggerCollectSimpleCommand</a>(address,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) stmt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Partitioned indexes should never get processed here, as they have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (iRel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_INDEX)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot reindex partitioned index </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(iRel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(iRel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow reindex on temp tables of other backends ... their local<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * buffer manager is not going to cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (RELATION_IS_OTHER_TEMP(iRel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot reindex temporary tables of other sessions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Don't allow reindex of an invalid index on TOAST table.&nbsp; This is a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leftover from a failed REINDEX CONCURRENTLY, and if rebuilt it would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not be possible to drop it anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="catalog.c.html#L200" title="catalog/catalog.c:200">IsToastNamespace</a>(RelationGetNamespace(iRel)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/cache/lsyscache.c.html#L3578" title="utils/cache/lsyscache.c:3578">get_index_isvalid</a>(indexId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot reindex invalid index on TOAST table&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * System relations cannot be moved even if allow_system_table_mods is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enabled to keep things consistent with the concurrent case where all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indexes of a relation are processed in series, including indexes of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toast relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that this check is not part of <a href="../commands/tablecmds.c.html#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>() as it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * gets used for ALTER TABLE <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> TABLESPACE that could cascade across<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toast relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(params-&gt;tablespaceOid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="catalog.c.html#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(iRel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot move system relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(iRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check if the tablespace of this index needs to be changed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(params-&gt;tablespaceOid) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/tablecmds.c.html#L3629" title="commands/tablecmds.c:3629">CheckRelationTableSpaceMove</a>(iRel, params-&gt;tablespaceOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; set_tablespace = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also check for active uses of the index in the current transaction; we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * don't want to reindex underneath an open indexscan.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../commands/tablecmds.c.html#L4346" title="commands/tablecmds.c:4346">CheckTableNotInUse</a>(iRel, <span class="Constant">&quot;REINDEX INDEX&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set new tablespace, if requested */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (set_tablespace)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Update its pg_class row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/tablecmds.c.html#L3686" title="commands/tablecmds.c:3686">SetRelationTableSpace</a>(iRel, params-&gt;tablespaceOid, InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Schedule unlinking of the old index storage at transaction commit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="storage.c.html#L206" title="catalog/storage.c:206">RelationDropStorage</a>(iRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3925" title="utils/cache/relcache.c:3925">RelationAssumeNewRelfilelocator</a>(iRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure the reltablespace change is visible */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All predicate locks on the index are about to be made invalid. Promote<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them to relation locks on the heap.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../storage/lmgr/predicate.c.html#L3108" title="storage/lmgr/predicate.c:3108">TransferPredicateLocksToHeapRelation</a>(iRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch info needed for <a href="#L2945" title="catalog/index.c:2945">index_build</a> */<br/></li>
<li></span>&nbsp; &nbsp; indexInfo = <a href="#L2407" title="catalog/index.c:2407">BuildIndexInfo</a>(iRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If requested, <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> checking uniqueness/exclusion constraints */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skip_constraint_checks)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexInfo-&gt;ii_Unique || indexInfo-&gt;ii_ExclusionOps != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipped_constraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_Unique = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_ExclusionOps = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_ExclusionProcs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo-&gt;ii_ExclusionStrats = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Suppress use of the target index while rebuilding it */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4087" title="catalog/index.c:4087">SetReindexProcessing</a>(heapId, indexId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Create a new physical relation for the index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/relcache.c.html#L3726" title="utils/cache/relcache.c:3726">RelationSetNewRelfilenumber</a>(iRel, persistence);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Initialize the index and rebuild */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Note: we do not need to re-establish pkey setting */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2945" title="catalog/index.c:2945">index_build</a>(heapRelation, iRel, indexInfo, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Re-allow use of target index */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4106" title="catalog/index.c:4106">ResetReindexProcessing</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index is marked invalid/not-ready/dead (ie, it's from a failed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CREATE INDEX CONCURRENTLY, or a DROP INDEX CONCURRENTLY failed midway),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and we didn't <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> a uniqueness check, we can <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> mark it valid.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allows REINDEX to be used to clean up in such cases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We can also reset indcheckxmin, because we have <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> done a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * non-concurrent index build, *except* in the case where <a href="#L2945" title="catalog/index.c:2945">index_build</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * found some still-broken HOT chains. If it did, and we don't have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * change <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the other flags, we just leave indcheckxmin alone (note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that <a href="#L2945" title="catalog/index.c:2945">index_build</a> won't have changed it, because this is a reindex).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This is okay and desirable because not updating the tuple leaves the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * index's usability horizon (recorded as the tuple's xmin value) the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * as it was.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * But, if the index was invalid/not-ready/dead and there were broken HOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * chains, we had better force indcheckxmin true, because the normal<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * argument that the HOT chains couldn't conflict with the index is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * suspect for an invalid index.&nbsp; (A conflict is definitely possible if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the index was dead.&nbsp; It probably shouldn't happen otherwise, but let's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be conservative.)&nbsp; In this case advancing the usability horizon is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Another reason for avoiding unnecessary updates here is that while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reindexing pg_index itself, we must not try to update tuples in it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_index's indexes should always have these flags in their clean state,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so that won't happen.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!skipped_constraint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; pg_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; indexTuple;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index indexForm;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; index_bad;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pg_index = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(IndexRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexTuple = SearchSysCacheCopy1(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(indexId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(indexTuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for index </span><span class="Special">%u</span><span class="Constant">&quot;</span>, indexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexForm = (Form_pg_index) GETSTRUCT(indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index_bad = (!indexForm-&gt;indisvalid ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !indexForm-&gt;indisready ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; !indexForm-&gt;indislive);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_bad ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (indexForm-&gt;indcheckxmin &amp;&amp; !indexInfo-&gt;ii_BrokenHotChain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!indexInfo-&gt;ii_BrokenHotChain)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indcheckxmin = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (index_bad)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indcheckxmin = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisvalid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indisready = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexForm-&gt;indislive = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_index, &amp;indexTuple-&gt;t_self, indexTuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Invalidate the relcache for the table, so that after we commit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all sessions will refresh the table's index list.&nbsp; This ensures<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that if anyone misses seeing the pg_index row during this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update, they'll refresh their list <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attempting <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> update<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * on the table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1360" title="utils/cache/inval.c:1360">CacheInvalidateRelcache</a>(heapRelation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_index, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Log what we did */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; REINDEXOPT_VERBOSE) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(INFO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> was reindexed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(indexId)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1232" title="utils/error/elog.c:1232">errdetail_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/pg_rusage.c.html#L40" title="utils/misc/pg_rusage.c:40">pg_rusage_show</a>(&amp;ru0))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Roll back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC changes executed by index <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/misc/guc.c.html#L2264" title="utils/misc/guc.c:2264">AtEOXact_GUC</a>(<span class="Constant">false</span>, save_nestlevel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Restore userid and security context */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/init/miscinit.c.html#L642" title="utils/init/miscinit.c:642">SetUserIdAndSecContext</a>(save_userid, save_sec_context);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close rels, but keep locks */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(iRel, NoLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(heapRelation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (progress)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L151" title="utils/activity/backend_progress.c:151">pgstat_progress_end_command</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3892" title="catalog/index.c:3892">reindex_relation</a> - This routine is used to recreate all indexes<br/></li>
<li></span><span class="Comment"> * of a relation (and optionally its toast relation too, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;flags&quot; is a bitmask that can include <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> combination of these bits:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * REINDEX_REL_PROCESS_TOAST: if true, process the toast table too (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * REINDEX_REL_SUPPRESS_INDEX_USE: if true, the relation was just completely<br/></li>
<li></span><span class="Comment"> * rebuilt by an operation such as VACUUM FULL or CLUSTER, and therefore its<br/></li>
<li></span><span class="Comment"> * indexes are inconsistent with it.&nbsp; This makes things tricky if the relation<br/></li>
<li></span><span class="Comment"> * is a system catalog that we might consult during the reindexing.&nbsp; To deal<br/></li>
<li></span><span class="Comment"> * with that case, we mark all of the indexes as pending rebuild so that they<br/></li>
<li></span><span class="Comment"> * won't be trusted until rebuilt.&nbsp; The caller is required to call us *without*<br/></li>
<li></span><span class="Comment"> * having made the rebuilt table visible by doing <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>;<br/></li>
<li></span><span class="Comment"> * we'll do CCI after having collected the index list.&nbsp; (This way we can still<br/></li>
<li></span><span class="Comment"> * use catalog indexes while collecting the list.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * REINDEX_REL_CHECK_CONSTRAINTS: if true, recheck unique and exclusion<br/></li>
<li></span><span class="Comment"> * constraint conditions, else don't.&nbsp; To avoid deadlocks, VACUUM FULL or<br/></li>
<li></span><span class="Comment"> * CLUSTER on a system catalog must omit this flag.&nbsp; REINDEX should be used to<br/></li>
<li></span><span class="Comment"> * rebuild an index if constraint inconsistency is suspected.&nbsp; For optimal<br/></li>
<li></span><span class="Comment"> * performance, other callers should include the flag only after transforming<br/></li>
<li></span><span class="Comment"> * the data in a manner that risks a change in constraint validity.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * REINDEX_REL_FORCE_INDEXES_UNLOGGED: if true, set the persistence of the<br/></li>
<li></span><span class="Comment"> * rebuilt indexes to unlogged.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * REINDEX_REL_FORCE_INDEXES_PERMANENT: if true, set the persistence of the<br/></li>
<li></span><span class="Comment"> * rebuilt indexes to permanent.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes were rebuilt (including toast table's index<br/></li>
<li></span><span class="Comment"> * when relevant).&nbsp; Note that a <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a> will occur after each<br/></li>
<li></span><span class="Comment"> * index rebuild.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3892">&#x200c;</a></span><span class="linkable">reindex_relation</span>(<span class="Type">const</span> ReindexStmt *stmt, Oid relid, <span class="Type">int</span> flags,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> ReindexParams *params)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; toast_relid;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexIds;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; persistence;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open and lock the relation.&nbsp; ShareLock is sufficient since we only need<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to prevent schema and data changes in it.&nbsp; The lock level used here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * should match <a href="../commands/indexcmds.c.html#L3026" title="commands/indexcmds.c:3026">ReindexTable</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((params-&gt;options &amp; REINDEXOPT_MISSING_OK) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L60" title="access/table/table.c:60">try_table_open</a>(relid, ShareLock);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(relid, ShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if relation is gone, leave */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Partitioned tables should never get processed here, as they have no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * physical storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot reindex partitioned table </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(RelationGetNamespace(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; toast_relid = rel-&gt;rd_rel-&gt;reltoastrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get the list of index OIDs for this relation.&nbsp; (We trust the relcache<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to get this with a sequential scan if ignoring system indexes.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; indexIds = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; REINDEX_REL_SUPPRESS_INDEX_USE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Suppress use of all the indexes until they are rebuilt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4120" title="catalog/index.c:4120">SetReindexPending</a>(indexIds);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the new heap contents visible --- <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> things might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inconsistent!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Reindex the toast table, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This helps in cases where a corruption in the toast table's index would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * otherwise error and stop REINDEX TABLE command when it tries to fetch a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * toasted datum.&nbsp; This way. the toast table's index is rebuilt and fixed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> it is used for reindexing the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * It is critical to call <a href="#L3892" title="catalog/index.c:3892">reindex_relation</a>() *after* the call to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>() returning the list of indexes on the relation,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because <a href="#L3892" title="catalog/index.c:3892">reindex_relation</a>() will call <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>() after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * every <a href="#L3552" title="catalog/index.c:3552">reindex_index</a>().&nbsp; See REINDEX_REL_SUPPRESS_INDEX_USE for more<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * details.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((flags &amp; REINDEX_REL_PROCESS_TOAST) &amp;&amp; OidIsValid(toast_relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that this should fail if the toast relation is missing, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reset REINDEXOPT_MISSING_OK.&nbsp; Even if a new tablespace is set for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the parent relation, the indexes on its toast table are not moved.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This rule is enforced by setting tablespaceOid to InvalidOid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ReindexParams newparams = *params;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newparams.options &amp;= ~(REINDEXOPT_MISSING_OK);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newparams.tablespaceOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result |= <a href="#L3892" title="catalog/index.c:3892">reindex_relation</a>(stmt, toast_relid, flags, &amp;newparams);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Compute persistence of indexes: same as that of owning rel, unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * caller specified otherwise.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (flags &amp; REINDEX_REL_FORCE_INDEXES_UNLOGGED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; persistence = RELPERSISTENCE_UNLOGGED;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (flags &amp; REINDEX_REL_FORCE_INDEXES_PERMANENT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; persistence = RELPERSISTENCE_PERMANENT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; persistence = rel-&gt;rd_rel-&gt;relpersistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reindex all the indexes. */<br/></li>
<li></span>&nbsp; &nbsp; i = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(indexId, indexIds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid = lfirst_oid(indexId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexNamespaceId = <a href="../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(indexOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid indexes on a TOAST table.&nbsp; These can only be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * duplicate leftovers from a failed REINDEX CONCURRENTLY, and if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rebuilt it would not be possible to drop them anymore.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="catalog.c.html#L200" title="catalog/catalog.c:200">IsToastNamespace</a>(indexNamespaceId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="../utils/cache/lsyscache.c.html#L3578" title="utils/cache/lsyscache.c:3578">get_index_isvalid</a>(indexOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot reindex invalid index </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant"> on TOAST table, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(indexNamespaceId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(indexOid))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3552" title="catalog/index.c:3552">reindex_index</a>(stmt, indexOid, !(flags &amp; REINDEX_REL_CHECK_CONSTRAINTS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; persistence, params);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Index should no longer be in the pending list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="#L4076" title="catalog/index.c:4076">ReindexIsProcessingIndex</a>(indexOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Set index rebuild count */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/activity/backend_progress.c.html#L49" title="utils/activity/backend_progress.c:49">pgstat_progress_update_param</a>(PROGRESS_CLUSTER_INDEX_REBUILD_COUNT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close rel, but continue to hold the lock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result |= (indexIds != NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; System index reindexing support<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When we are busy reindexing a system index, this code provides support<br/></li>
<li></span><span class="Comment"> * for preventing catalog lookups from using that index.&nbsp; We also make use<br/></li>
<li></span><span class="Comment"> * of this to catch attempted uses of user indexes during reindexing of<br/></li>
<li></span><span class="Comment"> * those indexes.&nbsp; This information is propagated to parallel workers;<br/></li>
<li></span><span class="Comment"> * attempting to change it during a parallel operation is not permitted.<br/></li>
<li></span><span class="Comment"> * ----------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><a id="L4045">&#x200c;</a><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">currentlyReindexedHeap</span> = InvalidOid;<br/></li>
<li><a id="L4046">&#x200c;</a><span class="Type">static</span> Oid&nbsp; &nbsp; <span class="linkable">currentlyReindexedIndex</span> = InvalidOid;<br/></li>
<li><a id="L4047">&#x200c;</a><span class="Type">static</span> List *<span class="linkable">pendingReindexedIndexes</span> = NIL;<br/></li>
<li><a id="L4048">&#x200c;</a><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <span class="linkable">reindexingNestLevel</span> = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4055" title="catalog/index.c:4055">ReindexIsProcessingHeap</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True if heap specified by OID is currently being reindexed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4055">&#x200c;</a></span><span class="linkable">ReindexIsProcessingHeap</span>(Oid heapOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> heapOid == <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4065" title="catalog/index.c:4065">ReindexIsCurrentlyProcessingIndex</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True if index specified by OID is currently being reindexed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4065">&#x200c;</a></span><span class="linkable">ReindexIsCurrentlyProcessingIndex</span>(Oid indexOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexOid == <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4076" title="catalog/index.c:4076">ReindexIsProcessingIndex</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True if index specified by OID is currently being reindexed,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; or should be treated as invalid because it is awaiting reindex.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L4076">&#x200c;</a></span><span class="linkable">ReindexIsProcessingIndex</span>(Oid indexOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> indexOid == <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L722" title="nodes/list.c:722">list_member_oid</a>(<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>, indexOid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4087" title="catalog/index.c:4087">SetReindexProcessing</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set flag that specified heap/index are being reindexed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4087">&#x200c;</a></span><span class="linkable">SetReindexProcessing</span>(Oid heapOid, Oid indexOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(heapOid) &amp;&amp; OidIsValid(indexOid));<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reindexing is not re-entrant. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot reindex while reindexing&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a> = heapOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a> = indexOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Index is no longer &quot;pending&quot; reindex. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4136" title="catalog/index.c:4136">RemoveReindexPending</a>(indexOid);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This may have been set already, but in case it isn't, do so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4048" title="catalog/index.c:4048">reindexingNestLevel</a> = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4106" title="catalog/index.c:4106">ResetReindexProcessing</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Unset reindexing status.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4106">&#x200c;</a></span><span class="linkable">ResetReindexProcessing</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L4048" title="catalog/index.c:4048">reindexingNestLevel</a> remains set till end of (sub)transaction */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4120" title="catalog/index.c:4120">SetReindexPending</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Mark the given indexes as pending reindex.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: we assume that the current memory context stays valid throughout.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4120">&#x200c;</a></span><span class="linkable">SetReindexPending</span>(List *indexes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Reindexing is not re-entrant. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot reindex while reindexing&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot modify reindex state during a parallel operation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a> = <a href="../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(indexes);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4048" title="catalog/index.c:4048">reindexingNestLevel</a> = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4136" title="catalog/index.c:4136">RemoveReindexPending</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Remove the given index from the pending list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4136">&#x200c;</a></span><span class="linkable">RemoveReindexPending</span>(Oid indexOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../access/transam/xact.c.html#L1086" title="access/transam/xact.c:1086">IsInParallelMode</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cannot modify reindex state during a parallel operation&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a> = <a href="../nodes/list.c.html#L910" title="nodes/list.c:910">list_delete_oid</a>(<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexOid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4149" title="catalog/index.c:4149">ResetReindexState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Clear all reindexing state during (sub)transaction abort.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4149">&#x200c;</a></span><span class="linkable">ResetReindexState</span>(<span class="Type">int</span> nestLevel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Because reindexing is not re-entrant, we don't need to cope with nested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * reindexing states.&nbsp; We just need to avoid messing up the outer-level<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * state in case a subtransaction fails within a REINDEX.&nbsp; So checking the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * current nest level against that of the reindex operation is sufficient.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L4048" title="catalog/index.c:4048">reindexingNestLevel</a> &gt;= nestLevel)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a> = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a> = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We needn't try to release the contents of <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that list should be in a transaction-lifespan context, so it will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * go away automatically.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a> = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4048" title="catalog/index.c:4048">reindexingNestLevel</a> = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4178" title="catalog/index.c:4178">EstimateReindexStateSpace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Estimate space needed to pass reindex state to parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Size<br/></li>
<li><a id="L4178">&#x200c;</a><span class="linkable">EstimateReindexStateSpace</span>(<span class="Type">void</span>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> offsetof(<a href="#L98" title="catalog/index.c:98">SerializedReindexState</a>, <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; + <a href="../storage/ipc/shmem.c.html#L510" title="storage/ipc/shmem.c:510">mul_size</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(Oid), list_length(<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4189" title="catalog/index.c:4189">SerializeReindexState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Serialize reindex state for parallel workers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4189">&#x200c;</a></span><span class="linkable">SerializeReindexState</span>(Size maxsize, <span class="Type">char</span> *start_address)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L98" title="catalog/index.c:98">SerializedReindexState</a> *sistate = (<a href="#L98" title="catalog/index.c:98">SerializedReindexState</a> *) start_address;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sistate-&gt;<a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a> = <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a>;<br/></li>
<li>&nbsp; &nbsp; sistate-&gt;<a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a> = <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a>;<br/></li>
<li>&nbsp; &nbsp; sistate-&gt;numPendingReindexedIndexes = list_length(<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>);<br/></li>
<li>&nbsp; &nbsp; foreach(lc, <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sistate-&gt;<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>[c++] = lfirst_oid(lc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4207" title="catalog/index.c:4207">RestoreReindexState</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Restore reindex state in a parallel worker.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L4207">&#x200c;</a></span><span class="linkable">RestoreReindexState</span>(<span class="Type">const</span> <span class="Type">void</span> *reindexstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <a href="#L98" title="catalog/index.c:98">SerializedReindexState</a> *sistate = (<span class="Type">const</span> <a href="#L98" title="catalog/index.c:98">SerializedReindexState</a> *) reindexstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; MemoryContext oldcontext;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a> = sistate-&gt;<a href="#L4045" title="catalog/index.c:4045">currentlyReindexedHeap</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a> = sistate-&gt;<a href="#L4046" title="catalog/index.c:4046">currentlyReindexedIndex</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a> == NIL);<br/></li>
<li>&nbsp; &nbsp; oldcontext = MemoryContextSwitchTo(<a href="../utils/mmgr/mcxt.c.html#L149" title="utils/mmgr/mcxt.c:149">TopMemoryContext</a>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (c = <span class="Constant">0</span>; c &lt; sistate-&gt;numPendingReindexedIndexes; ++c)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a> =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sistate-&gt;<a href="#L4047" title="catalog/index.c:4047">pendingReindexedIndexes</a>[c]);<br/></li>
<li>&nbsp; &nbsp; MemoryContextSwitchTo(oldcontext);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Note the worker has its own transaction nesting level */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4048" title="catalog/index.c:4048">reindexingNestLevel</a> = <a href="../access/transam/xact.c.html#L926" title="access/transam/xact.c:926">GetCurrentTransactionNestLevel</a>();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
