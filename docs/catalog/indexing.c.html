<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>catalog/indexing.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>catalog/indexing.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L61">CatalogCloseIndexes</a></li>
<li><a href="#L75">CatalogIndexInsert</a></li>
<li><a href="#L43">CatalogOpenIndexes</a></li>
<li><a href="#L195">CatalogTupleCheckConstraints</a></li>
<li><a href="#L365">CatalogTupleDelete</a></li>
<li><a href="#L233">CatalogTupleInsert</a></li>
<li><a href="#L256">CatalogTupleInsertWithInfo</a></li>
<li><a href="#L313">CatalogTupleUpdate</a></li>
<li><a href="#L337">CatalogTupleUpdateWithInfo</a></li>
<li><a href="#L273">CatalogTuplesMultiInsertWithInfo</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L217">CatalogTupleCheckConstraints</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * indexing.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; This file contains routines to support indexes defined on system<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; catalogs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/catalog/indexing.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/heapam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a> - open the indexes on a system catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When inserting or updating tuples in a system catalog, call this<br/></li>
<li></span><span class="Comment"> * to prepare to update the indexes for the catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In the current implementation, we share code for opening/closing the<br/></li>
<li></span><span class="Comment"> * indexes with execUtils.c.&nbsp; But we do not use <a href="../executor/execIndexing.c.html#L298" title="executor/execIndexing.c:298">ExecInsertIndexTuples</a>,<br/></li>
<li></span><span class="Comment"> * because we don't want to create an EState.&nbsp; This implies that we<br/></li>
<li></span><span class="Comment"> * do not support partial or expressional indexes on system catalogs,<br/></li>
<li></span><span class="Comment"> * nor can we support generalized exclusion constraints.<br/></li>
<li></span><span class="Comment"> * This could be fixed with localized changes here if we wanted to pay<br/></li>
<li></span><span class="Comment"> * the extra overhead of building an EState.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CatalogIndexState<br/></li>
<li><a id="L43">&#x200c;</a><span class="linkable">CatalogOpenIndexes</span>(Relation heapRel)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ResultRelInfo *resultRelInfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; resultRelInfo = makeNode(ResultRelInfo);<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_RangeTableIndex = <span class="Constant">0</span>;&nbsp; &nbsp; <span class="Comment">/* dummy */<br/></li>
<li></span>&nbsp; &nbsp; resultRelInfo-&gt;ri_RelationDesc = heapRel;<br/></li>
<li>&nbsp; &nbsp; resultRelInfo-&gt;ri_TrigDesc = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* we don't fire triggers */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execIndexing.c.html#L156" title="executor/execIndexing.c:156">ExecOpenIndices</a>(resultRelInfo, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> resultRelInfo;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L61" title="catalog/indexing.c:61">CatalogCloseIndexes</a> - clean up resources allocated by <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a><br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L61">&#x200c;</a></span><span class="linkable">CatalogCloseIndexes</span>(CatalogIndexState indstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execIndexing.c.html#L231" title="executor/execIndexing.c:231">ExecCloseIndices</a>(indstate);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(indstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L75" title="catalog/indexing.c:75">CatalogIndexInsert</a> - insert index entries for one catalog tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be called for each inserted or updated catalog tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is effectively a cut-down version of <a href="../executor/execIndexing.c.html#L298" title="executor/execIndexing.c:298">ExecInsertIndexTuples</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L75">&#x200c;</a></span><span class="linkable">CatalogIndexInsert</span>(CatalogIndexState indstate, HeapTuple heapTuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TU_UpdateIndexes updateIndexes)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numIndexes;<br/></li>
<li>&nbsp; &nbsp; RelationPtr relationDescs;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; heapRelation;<br/></li>
<li>&nbsp; &nbsp; TupleTableSlot *slot;<br/></li>
<li>&nbsp; &nbsp; IndexInfo **indexInfoArray;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull[INDEX_MAX_KEYS];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; onlySummarized = (updateIndexes == TU_Summarizing);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * HOT update does not require index inserts. But with asserts enabled we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * want to check that it'd be legal to currently insert into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table/index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifndef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsHeapOnly(heapTuple) &amp;&amp; !onlySummarized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* When only updating summarized indexes, the tuple has to be HOT. */<br/></li>
<li></span>&nbsp; &nbsp; Assert((!onlySummarized) || HeapTupleIsHeapOnly(heapTuple));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Get information from the state structure.&nbsp; Fall out if nothing to do.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; numIndexes = indstate-&gt;ri_NumIndices;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numIndexes == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; relationDescs = indstate-&gt;ri_IndexRelationDescs;<br/></li>
<li>&nbsp; &nbsp; indexInfoArray = indstate-&gt;ri_IndexRelationInfo;<br/></li>
<li>&nbsp; &nbsp; heapRelation = indstate-&gt;ri_RelationDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Need a slot to hold the tuple being examined */<br/></li>
<li></span>&nbsp; &nbsp; slot = <a href="../executor/execTuples.c.html#L1325" title="executor/execTuples.c:1325">MakeSingleTupleTableSlot</a>(RelationGetDescr(heapRelation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;<a href="../executor/execTuples.c.html#L85" title="executor/execTuples.c:85">TTSOpsHeapTuple</a>);<br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1439" title="executor/execTuples.c:1439">ExecStoreHeapTuple</a>(heapTuple, slot, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for each index, form and insert the index tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; numIndexes; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexInfo&nbsp; *indexInfo;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexInfo = indexInfoArray[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = relationDescs[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If the index is marked as read-only, ignore it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!indexInfo-&gt;ii_ReadyForInserts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Expressional and partial indexes on system catalogs are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * supported, nor exclusion constraints, nor deferred uniqueness<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(indexInfo-&gt;ii_Expressions == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(indexInfo-&gt;ii_Predicate == NIL);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(indexInfo-&gt;ii_ExclusionOps == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(index-&gt;rd_index-&gt;indimmediate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(indexInfo-&gt;ii_NumIndexKeyAttrs != <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see earlier check above */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsHeapOnly(heapTuple) &amp;&amp; !onlySummarized)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!<a href="index.c.html#L4076" title="catalog/index.c:4076">ReindexIsProcessingIndex</a>(RelationGetRelid(index)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_ASSERT_CHECKING */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Skip insertions into non-summarizing indexes if we only need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * update summarizing indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (onlySummarized &amp;&amp; !indexInfo-&gt;ii_Summarizing)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a> fills in its <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> and isnull parameters with the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * appropriate <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> for the column(s) of the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="index.c.html#L2705" title="catalog/index.c:2705">FormIndexDatum</a>(indexInfo,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,&nbsp; &nbsp; <span class="Comment">/* no expression eval to do */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The index AM does the rest.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L213" title="access/index/indexam.c:213">index_insert</a>(index,&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* index relation */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,&nbsp; &nbsp; <span class="Comment">/* array of index Datums */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isnull,&nbsp; &nbsp; <span class="Comment">/* is-null flags */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;(heapTuple-&gt;t_self),&nbsp; &nbsp; <span class="Comment">/* tid of heap tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; heapRelation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index-&gt;rd_index-&gt;indisunique ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; UNIQUE_CHECK_YES : UNIQUE_CHECK_NO,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indexInfo);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../executor/execTuples.c.html#L1341" title="executor/execTuples.c:1341">ExecDropSingleTupleTableSlot</a>(slot);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Subroutine to verify that catalog constraints are honored.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Tuples inserted via <a href="#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>/<a href="#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a> are generally<br/></li>
<li></span><span class="Comment"> * &quot;hand made&quot;, so that it's possible that they fail to satisfy constraints<br/></li>
<li></span><span class="Comment"> * that would be checked if they were being inserted by the executor.&nbsp; That's<br/></li>
<li></span><span class="Comment"> * a coding error, so we only bother to check for it in assert-enabled builds.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef USE_ASSERT_CHECKING<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L195">&#x200c;</a></span><span class="linkable">CatalogTupleCheckConstraints</span>(Relation heapRel, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, the only constraints implemented for system catalogs are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * attnotnull constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleHasNulls(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc = RelationGetDescr(heapRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; bits8&nbsp; &nbsp; &nbsp;&nbsp; *bp = tup-&gt;t_data-&gt;t_bits;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> attnum = <span class="Constant">0</span>; attnum &lt; tupdesc-&gt;natts; attnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute thisatt = TupleDescAttr(tupdesc, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(!(thisatt-&gt;attnotnull &amp;&amp; att_isnull(attnum, bp)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#else</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* !USE_ASSERT_CHECKING */<br/></li>
<li></span><br/></li>
<li><a id="L217">&#x200c;</a><span class="PreProc">#define <span class="linkable">CatalogTupleCheckConstraints</span>(heapRel, tup)&nbsp; ((</span><span class="Type">void</span><span class="PreProc">) </span><span class="Constant">0</span><span class="PreProc">)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* USE_ASSERT_CHECKING */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a> - do heap and indexing work for a new catalog tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the tuple data in &quot;tup&quot; into the specified catalog relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine for the common case of inserting a single<br/></li>
<li></span><span class="Comment"> * tuple in a system catalog; it inserts a new heap tuple, keeping indexes<br/></li>
<li></span><span class="Comment"> * current.&nbsp; Avoid using it for multiple tuples, since opening the indexes<br/></li>
<li></span><span class="Comment"> * and building the index info structures is moderately expensive.<br/></li>
<li></span><span class="Comment"> * (Use <a href="#L256" title="catalog/indexing.c:256">CatalogTupleInsertWithInfo</a> in such cases.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L233">&#x200c;</a></span><span class="linkable">CatalogTupleInsert</span>(Relation heapRel, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CatalogIndexState indstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="catalog/indexing.c:195">CatalogTupleCheckConstraints</a>(heapRel, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indstate = <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a>(heapRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L2621" title="access/heap/heapam.c:2621">simple_heap_insert</a>(heapRel, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="catalog/indexing.c:75">CatalogIndexInsert</a>(indstate, tup, TU_All);<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/indexing.c:61">CatalogCloseIndexes</a>(indstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L256" title="catalog/indexing.c:256">CatalogTupleInsertWithInfo</a> - as above, but with caller-supplied index info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used when it's important to amortize <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a>/<br/></li>
<li></span><span class="Comment"> * <a href="#L61" title="catalog/indexing.c:61">CatalogCloseIndexes</a> work across multiple insertions.&nbsp; At some point we<br/></li>
<li></span><span class="Comment"> * might cache the CatalogIndexState data somewhere (perhaps in the relcache)<br/></li>
<li></span><span class="Comment"> * so that callers needn't trouble over this ... but we don't do so today.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L256">&#x200c;</a></span><span class="linkable">CatalogTupleInsertWithInfo</span>(Relation heapRel, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CatalogIndexState indstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="catalog/indexing.c:195">CatalogTupleCheckConstraints</a>(heapRel, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L2621" title="access/heap/heapam.c:2621">simple_heap_insert</a>(heapRel, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="catalog/indexing.c:75">CatalogIndexInsert</a>(indstate, tup, TU_All);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L273" title="catalog/indexing.c:273">CatalogTuplesMultiInsertWithInfo</a> - as above, but for multiple tuples<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> multiple tuples into the given catalog relation at once, with an<br/></li>
<li></span><span class="Comment"> * amortized cost of <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L273">&#x200c;</a></span><span class="linkable">CatalogTuplesMultiInsertWithInfo</span>(Relation heapRel, TupleTableSlot **slot,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> ntuples, CatalogIndexState indstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ntuples &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a>(heapRel, slot, ntuples,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L826" title="access/transam/xact.c:826">GetCurrentCommandId</a>(<span class="Constant">true</span>), <span class="Constant">0</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There is no equivalent to <a href="../access/heap/heapam.c.html#L2259" title="access/heap/heapam.c:2259">heap_multi_insert</a> for the catalog indexes, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we must loop over and insert individually.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (<span class="Type">int</span> i = <span class="Constant">0</span>; i &lt; ntuples; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; should_free;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple = <a href="../executor/execTuples.c.html#L1731" title="executor/execTuples.c:1731">ExecFetchSlotHeapTuple</a>(slot[i], <span class="Constant">true</span>, &amp;should_free);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tuple-&gt;t_tableOid = slot[i]-&gt;tts_tableOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L75" title="catalog/indexing.c:75">CatalogIndexInsert</a>(indstate, tuple, TU_All);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (should_free)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a> - do heap and indexing work for updating a catalog tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Update the tuple identified by &quot;otid&quot;, replacing it with the data in &quot;tup&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine for the common case of updating a single<br/></li>
<li></span><span class="Comment"> * tuple in a system catalog; it updates one heap tuple, keeping indexes<br/></li>
<li></span><span class="Comment"> * current.&nbsp; Avoid using it for multiple tuples, since opening the indexes<br/></li>
<li></span><span class="Comment"> * and building the index info structures is moderately expensive.<br/></li>
<li></span><span class="Comment"> * (Use <a href="#L337" title="catalog/indexing.c:337">CatalogTupleUpdateWithInfo</a> in such cases.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L313">&#x200c;</a></span><span class="linkable">CatalogTupleUpdate</span>(Relation heapRel, ItemPointer otid, HeapTuple tup)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; CatalogIndexState indstate;<br/></li>
<li>&nbsp; &nbsp; TU_UpdateIndexes updateIndexes = TU_All;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="catalog/indexing.c:195">CatalogTupleCheckConstraints</a>(heapRel, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indstate = <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a>(heapRel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L4217" title="access/heap/heapam.c:4217">simple_heap_update</a>(heapRel, otid, tup, &amp;updateIndexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="catalog/indexing.c:75">CatalogIndexInsert</a>(indstate, tup, updateIndexes);<br/></li>
<li>&nbsp; &nbsp; <a href="#L61" title="catalog/indexing.c:61">CatalogCloseIndexes</a>(indstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L337" title="catalog/indexing.c:337">CatalogTupleUpdateWithInfo</a> - as above, but with caller-supplied index info<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This should be used when it's important to amortize <a href="#L43" title="catalog/indexing.c:43">CatalogOpenIndexes</a>/<br/></li>
<li></span><span class="Comment"> * <a href="#L61" title="catalog/indexing.c:61">CatalogCloseIndexes</a> work across multiple updates.&nbsp; At some point we<br/></li>
<li></span><span class="Comment"> * might cache the CatalogIndexState data somewhere (perhaps in the relcache)<br/></li>
<li></span><span class="Comment"> * so that callers needn't trouble over this ... but we don't do so today.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L337">&#x200c;</a></span><span class="linkable">CatalogTupleUpdateWithInfo</span>(Relation heapRel, ItemPointer otid, HeapTuple tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CatalogIndexState indstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TU_UpdateIndexes updateIndexes = TU_All;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L195" title="catalog/indexing.c:195">CatalogTupleCheckConstraints</a>(heapRel, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L4217" title="access/heap/heapam.c:4217">simple_heap_update</a>(heapRel, otid, tup, &amp;updateIndexes);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L75" title="catalog/indexing.c:75">CatalogIndexInsert</a>(indstate, tup, updateIndexes);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a> - do heap and indexing work for deleting a catalog tuple<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> the tuple identified by &quot;tid&quot; in the specified catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * With Postgres heaps, there is no index work to do at deletion time;<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> will be done later by VACUUM.&nbsp; However, callers of this function<br/></li>
<li></span><span class="Comment"> * shouldn't have to know that; we'd like a uniform abstraction for all<br/></li>
<li></span><span class="Comment"> * catalog tuple changes.&nbsp; Hence, provide this currently-trivial wrapper.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The abstraction is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> leaky in that we don't provide an optimized<br/></li>
<li></span><span class="Comment"> * CatalogTupleDeleteWithInfo version, because there is currently nothing to<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_nfa.c.html#L1593" title="regex/regc_nfa.c:1593">optimize</a>.&nbsp; If we ever need that, rather than touching a lot of call sites,<br/></li>
<li></span><span class="Comment"> * it might be better to do something about caching CatalogIndexState.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L365">&#x200c;</a></span><span class="linkable">CatalogTupleDelete</span>(Relation heapRel, ItemPointer tid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="../access/heap/heapam.c.html#L3100" title="access/heap/heapam.c:3100">simple_heap_delete</a>(heapRel, tid);<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
