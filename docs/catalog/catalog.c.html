<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>catalog/catalog.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>catalog/catalog.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L391">GetNewOidWithIndex</a></li>
<li><a href="#L500">GetNewRelFileNumber</a></li>
<li><a href="#L182">IsCatalogNamespace</a></li>
<li><a href="#L103">IsCatalogRelation</a></li>
<li><a href="#L120">IsCatalogRelationOid</a></li>
<li><a href="#L313">IsPinnedObject</a></li>
<li><a href="#L217">IsReservedName</a></li>
<li><a href="#L243">IsSharedRelation</a></li>
<li><a href="#L85">IsSystemClass</a></li>
<li><a href="#L73">IsSystemRelation</a></li>
<li><a href="#L165">IsToastClass</a></li>
<li><a href="#L200">IsToastNamespace</a></li>
<li><a href="#L145">IsToastRelation</a></li>
<li><a href="#L586">pg_nextoid</a></li>
<li><a href="#L665">pg_stop_making_pinned_objects</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L55">GETNEWOID_LOG_MAX_INTERVAL</a></li>
<li><a href="#L54">GETNEWOID_LOG_THRESHOLD</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * catalog.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; routines concerned with catalog naming conventions and other<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; bits of hard-wired knowledge<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/catalog/catalog.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/transam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_auth_members.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_authid.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_database.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_db_role_setting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_largeobject.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_parameter_acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_replication_origin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shdepend.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shdescription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_shseclabel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_subscription.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgrprotos.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/snapmgr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Parameters to determine when to emit a log message in<br/></li>
<li></span><span class="Comment"> * <a href="#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li><a id="L54">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GETNEWOID_LOG_THRESHOLD</span> </span><span class="Constant">1000000<br/></li>
<li><a id="L55">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">GETNEWOID_LOG_MAX_INTERVAL</span> </span><span class="Constant">128000000<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L73" title="catalog/catalog.c:73">IsSystemRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff the relation is either a system catalog or a toast table.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; See <a href="#L103" title="catalog/catalog.c:103">IsCatalogRelation</a> for the exact definition of a system catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We treat toast tables of user relations as &quot;system relations&quot; for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; protection purposes, e.g. you can't change their schemas without<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; special permissions.&nbsp; Therefore, most uses of this function are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; checking whether allow_system_table_mods restrictions apply.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For other purposes, consider whether you shouldn't be using<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L103" title="catalog/catalog.c:103">IsCatalogRelation</a> instead.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function does not perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog accesses.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Some callers rely on that!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L73">&#x200c;</a></span><span class="linkable">IsSystemRelation</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L85" title="catalog/catalog.c:85">IsSystemClass</a>(RelationGetRelid(relation), relation-&gt;rd_rel);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L85" title="catalog/catalog.c:85">IsSystemClass</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like the above, but takes a Form_pg_class as argument.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Used when we do not want to open the relation and have to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; search pg_class directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L85">&#x200c;</a></span><span class="linkable">IsSystemClass</span>(Oid relid, Form_pg_class reltuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L120" title="catalog/catalog.c:120">IsCatalogRelationOid</a> is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> faster, so test that first */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (<a href="#L120" title="catalog/catalog.c:120">IsCatalogRelationOid</a>(relid) || <a href="#L165" title="catalog/catalog.c:165">IsToastClass</a>(reltuple));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L103" title="catalog/catalog.c:103">IsCatalogRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff the relation is a system catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; By a system catalog, we mean one that is created during the bootstrap<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; phase of initdb.&nbsp; That includes not just the catalogs per se, but<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; also their indexes, and TOAST tables and indexes if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function does not perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog accesses.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Some callers rely on that!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L103">&#x200c;</a></span><span class="linkable">IsCatalogRelation</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L120" title="catalog/catalog.c:120">IsCatalogRelationOid</a>(RelationGetRelid(relation));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L120" title="catalog/catalog.c:120">IsCatalogRelationOid</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff the relation identified by this OID is a system catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; By a system catalog, we mean one that is created during the bootstrap<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; phase of initdb.&nbsp; That includes not just the catalogs per se, but<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; also their indexes, and TOAST tables and indexes if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This function does not perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog accesses.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Some callers rely on that!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L120">&#x200c;</a></span><span class="linkable">IsCatalogRelationOid</span>(Oid relid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We consider a relation to be a system catalog if it has a pinned OID.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This includes all the defined catalogs, their indexes, and their TOAST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables and indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This rule excludes the relations in information_schema, which are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * integral to the system and can be treated the same as user relations.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Since it's valid to drop and recreate information_schema, <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> rule<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that did not act this way would be wrong.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This test is reliable since an OID wraparound will <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * OIDs; see <a href="../access/transam/varsup.c.html#L555" title="access/transam/varsup.c:555">GetNewObjectId</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (relid &lt; (Oid) FirstUnpinnedObjectId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L145" title="catalog/catalog.c:145">IsToastRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff relation is a TOAST support relation (or index).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does not perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog accesses.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L145">&#x200c;</a></span><span class="linkable">IsToastRelation</span>(Relation relation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * What we actually check is whether the relation belongs to a pg_toast<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * namespace.&nbsp; This should be equivalent because of restrictions that are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enforced elsewhere against creating user relations in, or moving<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relations into/out of, a pg_toast namespace.&nbsp; Notice also that this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will not say &quot;true&quot; for toast tables belonging to other sessions' temp<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * tables; we expect that other mechanisms will prevent access to those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L200" title="catalog/catalog.c:200">IsToastNamespace</a>(RelationGetNamespace(relation));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L165" title="catalog/catalog.c:165">IsToastClass</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like the above, but takes a Form_pg_class as argument.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Used when we do not want to open the relation and have to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; search pg_class directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L165">&#x200c;</a></span><span class="linkable">IsToastClass</span>(Form_pg_class reltuple)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; relnamespace = reltuple-&gt;relnamespace;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L200" title="catalog/catalog.c:200">IsToastNamespace</a>(relnamespace);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L182" title="catalog/catalog.c:182">IsCatalogNamespace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff namespace is pg_catalog.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does not perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog accesses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: the reason this isn't a macro is to avoid having to include<br/></li>
<li></span><span class="Comment"> * catalog/pg_namespace.h in a lot of places.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L182">&#x200c;</a></span><span class="linkable">IsCatalogNamespace</span>(Oid namespaceId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> namespaceId == PG_CATALOG_NAMESPACE;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L200" title="catalog/catalog.c:200">IsToastNamespace</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff namespace is pg_toast or my temporary-toast-table namespace.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Does not perform <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> catalog accesses.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this will return false for temporary-toast-table namespaces belonging<br/></li>
<li></span><span class="Comment"> * to other backends.&nbsp; Those are treated the same as other backends' regular<br/></li>
<li></span><span class="Comment"> * temp table namespaces, and access is prevented where appropriate.<br/></li>
<li></span><span class="Comment"> * If you need to check for those, you may be able to use <a href="namespace.c.html#L3672" title="catalog/namespace.c:3672">isAnyTempNamespace</a>,<br/></li>
<li></span><span class="Comment"> * but beware that that does involve a catalog access.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L200">&#x200c;</a></span><span class="linkable">IsToastNamespace</span>(Oid namespaceId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (namespaceId == PG_TOAST_NAMESPACE) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="namespace.c.html#L3646" title="catalog/namespace.c:3646">isTempToastNamespace</a>(namespaceId);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L217" title="catalog/catalog.c:217">IsReservedName</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; True iff name starts with the pg_ prefix.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; For some classes of objects, the prefix pg_ is reserved for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; system objects only.&nbsp; As of 8.0, this was only true for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; schema and tablespace names.&nbsp; With 9.6, this is also true<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for roles.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L217">&#x200c;</a></span><span class="linkable">IsReservedName</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ugly coding for speed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> (name[<span class="Constant">0</span>] == <span class="Constant">'p'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">1</span>] == <span class="Constant">'g'</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name[<span class="Constant">2</span>] == <span class="Constant">'<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>'</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L243" title="catalog/catalog.c:243">IsSharedRelation</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the OID of a relation, determine whether it's supposed to be<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; shared across an entire database <a href="../commands/cluster.c.html#L108" title="commands/cluster.c:108">cluster</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In older releases, this had to be hard-wired so that we could compute the<br/></li>
<li></span><span class="Comment"> * locktag for a relation and lock it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> examining its catalog entry.<br/></li>
<li></span><span class="Comment"> * Since we <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> have MVCC catalog access, the race conditions that made that<br/></li>
<li></span><span class="Comment"> * a hard requirement are gone, so we could look at relaxing this restriction.<br/></li>
<li></span><span class="Comment"> * However, if we scanned the pg_class entry to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> relisshared, and only<br/></li>
<li></span><span class="Comment"> * then locked the relation, pg_class could get updated in the meantime,<br/></li>
<li></span><span class="Comment"> * forcing us to scan the relation again, which would definitely be complex<br/></li>
<li></span><span class="Comment"> * and might have undesirable performance consequences.&nbsp; Fortunately, the set<br/></li>
<li></span><span class="Comment"> * of shared relations is fairly static, so a hand-maintained list of their<br/></li>
<li></span><span class="Comment"> * OIDs isn't completely impractical.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L243">&#x200c;</a></span><span class="linkable">IsSharedRelation</span>(Oid relationId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These are the shared catalogs (look for BKI_SHARED_RELATION) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relationId == AuthIdRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == AuthMemRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == DatabaseRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == DbRoleSettingRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == ParameterAclRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == ReplicationOriginRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedDependRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedDescriptionRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedSecLabelRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SubscriptionRelationId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == TableSpaceRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These are their indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relationId == AuthIdOidIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == AuthIdRolnameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == AuthMemMemRoleIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == AuthMemRoleMemIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == AuthMemOidIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == AuthMemGrantorIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == DatabaseNameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == DatabaseOidIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == DbRoleSettingDatidRolidIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == ParameterAclOidIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == ParameterAclParnameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == ReplicationOriginIdentIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == ReplicationOriginNameIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedDependDependerIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedDependReferenceIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedDescriptionObjIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SharedSecLabelObjectIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SubscriptionNameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == SubscriptionObjectIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == TablespaceNameIndexId ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == TablespaceOidIndexId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* These are their toast tables and toast indexes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relationId == PgAuthidToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgAuthidToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgDatabaseToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgDatabaseToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgDbRoleSettingToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgDbRoleSettingToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgParameterAclToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgParameterAclToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgReplicationOriginToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgReplicationOriginToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgShdescriptionToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgShdescriptionToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgShseclabelToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgShseclabelToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgSubscriptionToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgSubscriptionToastIndex ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgTablespaceToastTable ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relationId == PgTablespaceToastIndex)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L313" title="catalog/catalog.c:313">IsPinnedObject</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the class + OID identity of a database object, report whether<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; it is &quot;pinned&quot;, that is not droppable because the system requires it.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We used to represent this explicitly in pg_depend, but that proved to be<br/></li>
<li></span><span class="Comment"> * an undesirable amount of overhead, so <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> we rely on an OID <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> test.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L313">&#x200c;</a></span><span class="linkable">IsPinnedObject</span>(Oid classId, Oid objectId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Objects with OIDs above FirstUnpinnedObjectId are never pinned.&nbsp; Since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the OID generator skips this <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> when wrapping around, this check<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * guarantees that user-defined objects are never considered pinned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (objectId &gt;= FirstUnpinnedObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Large objects are never pinned.&nbsp; We need this special case because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * their OIDs can be user-assigned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (classId == LargeObjectRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * There are a few objects defined in the catalog .dat files that, as a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * matter of policy, we prefer not to treat as pinned.&nbsp; We used to handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that by excluding them from pg_depend, but it's just as easy to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * hard-wire their OIDs here.&nbsp; (If the user does indeed drop and recreate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them, they'll have new but certainly-unpinned OIDs, so no problem.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Checking both classId and objectId is overkill, since OIDs below<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * FirstGenbkiObjectId should be globally unique, but do it anyway for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * robustness.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the public namespace is not pinned */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (classId == NamespaceRelationId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; objectId == PG_PUBLIC_NAMESPACE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Databases are never pinned.&nbsp; It might seem that it'd be prudent to pin<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * at least template0; but we do this intentionally so that template0 and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * template1 can be rebuilt from each other, thus letting them serve as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mutual backups (as long as you've not modified template1, anyway).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (classId == DatabaseRelationId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All other initdb-created objects are pinned.&nbsp; This is overkill (the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * system doesn't really depend on having every last weird datatype, for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * instance) but generating only the minimum required set of dependencies<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems hard, and enforcing an accurate list would be much more expensive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * than the simple <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> test used here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a new OID that is unique within the system relation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Since the OID is not immediately inserted into the table, there is a<br/></li>
<li></span><span class="Comment"> * race condition here; but a problem could occur only if someone else<br/></li>
<li></span><span class="Comment"> * managed to cycle through 2^32 OIDs and generate the same OID <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment"> * finish inserting our row.&nbsp; This seems unlikely to be a problem.&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that if we had to *commit* the row to end the race condition, the risk<br/></li>
<li></span><span class="Comment"> * would be rather higher; therefore we use SnapshotAny in the test, so that<br/></li>
<li></span><span class="Comment"> * we will see uncommitted rows.&nbsp; (We used to use SnapshotDirty, but that has<br/></li>
<li></span><span class="Comment"> * the disadvantage that it ignores recently-deleted rows, creating a risk<br/></li>
<li></span><span class="Comment"> * of transient conflicts for as long as our own MVCC snapshots think a<br/></li>
<li></span><span class="Comment"> * recently-deleted row is live.&nbsp; The risk is far higher when selecting TOAST<br/></li>
<li></span><span class="Comment"> * OIDs, because SnapshotToast considers dead rows as active indefinitely.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that we are effectively assuming that the table has a relatively small<br/></li>
<li></span><span class="Comment"> * number of entries (much less than 2^32) and there aren't very long runs of<br/></li>
<li></span><span class="Comment"> * consecutive existing OIDs.&nbsp; This is a mostly reasonable assumption for<br/></li>
<li></span><span class="Comment"> * system catalogs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller must have a suitable lock on the relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L391">&#x200c;</a><span class="linkable">GetNewOidWithIndex</span>(Relation relation, Oid indexId, AttrNumber oidcolumn)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newOid;<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collides;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; retries = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; uint64&nbsp; &nbsp; &nbsp; &nbsp; retries_before_log = <a href="#L54" title="catalog/catalog.c:54">GETNEWOID_LOG_THRESHOLD</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Only system relations are supported */<br/></li>
<li></span>&nbsp; &nbsp; Assert(<a href="#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* In bootstrap mode, we don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indexes to use */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsBootstrapProcessingMode())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <a href="../access/transam/varsup.c.html#L555" title="access/transam/varsup.c:555">GetNewObjectId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We should never be asked to generate a new pg_type OID during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pg_upgrade; doing so would risk collisions with the OIDs it wants to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assign.&nbsp; Hitting this assert means there's some path where we failed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ensure that a type OID is determined by commands in the <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> script.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a> || RelationGetRelid(relation) != TypeRelationId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Generate new OIDs until we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> one not in the table */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newOid = <a href="../access/transam/varsup.c.html#L555" title="access/transam/varsup.c:555">GetNewObjectId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oidcolumn,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(newOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see notes above about using SnapshotAny */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(relation, indexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SnapshotAny, <span class="Constant">1</span>, &amp;key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; collides = HeapTupleIsValid(<a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Log that we iterate more than <a href="#L54" title="catalog/catalog.c:54">GETNEWOID_LOG_THRESHOLD</a> but have not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * yet found OID unused in the relation. Then <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> logging with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exponentially increasing intervals until we iterate more than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L55" title="catalog/catalog.c:55">GETNEWOID_LOG_MAX_INTERVAL</a>. Finally <a href="../regex/regcomp.c.html#L1584" title="regex/regcomp.c:1584">repeat</a> logging every<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="#L55" title="catalog/catalog.c:55">GETNEWOID_LOG_MAX_INTERVAL</a> unless an unused OID is found. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic is necessary not to fill up the server log with the similar<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * messages.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retries &gt;= retries_before_log)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;still searching for an unused OID in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1297" title="utils/error/elog.c:1297">errdetail_plural</a>(<span class="Constant">&quot;OID candidates have been checked </span><span class="Special">%llu</span><span class="Constant"> time, but no unused OID has been found yet.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;OID candidates have been checked </span><span class="Special">%llu</span><span class="Constant"> times, but no unused OID has been found yet.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retries,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) retries)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Double the number of retries to do <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> logging <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> until it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * reaches <a href="#L55" title="catalog/catalog.c:55">GETNEWOID_LOG_MAX_INTERVAL</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (retries_before_log * <span class="Constant">2</span> &lt;= <a href="#L55" title="catalog/catalog.c:55">GETNEWOID_LOG_MAX_INTERVAL</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retries_before_log *= <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; retries_before_log += <a href="#L55" title="catalog/catalog.c:55">GETNEWOID_LOG_MAX_INTERVAL</a>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; retries++;<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (collides);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If at least one log message is emitted, also log the completion of OID<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assignment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (retries &gt; <a href="#L54" title="catalog/catalog.c:54">GETNEWOID_LOG_THRESHOLD</a>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(LOG,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;new OID has been assigned in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> after </span><span class="Special">%llu</span><span class="Constant"> retry&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;new OID has been assigned in relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> after </span><span class="Special">%llu</span><span class="Constant"> retries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; retries,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation), (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">long</span>) retries)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> newOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L500" title="catalog/catalog.c:500">GetNewRelFileNumber</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate a new relfilenumber that is unique within the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; database of the given tablespace.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the relfilenumber will also be used as the relation's OID, pass the<br/></li>
<li></span><span class="Comment"> * opened pg_class catalog, and this routine will guarantee that the result<br/></li>
<li></span><span class="Comment"> * is also an unused OID within pg_class.&nbsp; If the result is to be used only<br/></li>
<li></span><span class="Comment"> * as a relfilenumber for an existing relation, pass NULL for pg_class.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with <a href="#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(), there is some theoretical risk of a race<br/></li>
<li></span><span class="Comment"> * condition, but it doesn't seem worth worrying about.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: we don't support using this in bootstrap mode.&nbsp; All relations<br/></li>
<li></span><span class="Comment"> * created by bootstrap have preassigned OIDs, so there's no need.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>RelFileNumber<br/></li>
<li><a id="L500">&#x200c;</a><span class="linkable">GetNewRelFileNumber</span>(Oid reltablespace, Relation pg_class, <span class="Type">char</span> relpersistence)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RelFileLocatorBackend rlocator;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rpath;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; collides;<br/></li>
<li>&nbsp; &nbsp; ProcNumber&nbsp; &nbsp; procNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we ever get here during pg_upgrade, there's something wrong; all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relfilenumber assignments during a binary-upgrade run should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determined by commands in the <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> script.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../utils/init/globals.c.html#L118" title="utils/init/globals.c:118">IsBinaryUpgrade</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (relpersistence)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_TEMP:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procNumber = ProcNumberForTempRelations();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_UNLOGGED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELPERSISTENCE_PERMANENT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procNumber = INVALID_PROC_NUMBER;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid relpersistence: </span><span class="Special">%c</span><span class="Constant">&quot;</span>, relpersistence);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidRelFileNumber;&nbsp; &nbsp; <span class="Comment">/* placate compiler */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* This logic should match <a href="../utils/cache/relcache.c.html#L1319" title="utils/cache/relcache.c:1319">RelationInitPhysicalAddr</a> */<br/></li>
<li></span>&nbsp; &nbsp; rlocator.locator.spcOid = reltablespace ? reltablespace : <a href="../utils/init/globals.c.html#L93" title="utils/init/globals.c:93">MyDatabaseTableSpace</a>;<br/></li>
<li>&nbsp; &nbsp; rlocator.locator.dbOid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (rlocator.locator.spcOid == GLOBALTABLESPACE_OID) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; InvalidOid : <a href="../utils/init/globals.c.html#L91" title="utils/init/globals.c:91">MyDatabaseId</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The relpath will vary based on the backend number, so we must<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> that properly here to make sure that <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> collisions based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filename are properly detected.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rlocator.backend = procNumber;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">do<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; CHECK_FOR_INTERRUPTS();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Generate the OID */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pg_class)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator.locator.relNumber = <a href="#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(pg_class, ClassOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rlocator.locator.relNumber = <a href="../access/transam/varsup.c.html#L555" title="access/transam/varsup.c:555">GetNewObjectId</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for existing file of same name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rpath = relpath(rlocator, MAIN_FORKNUM);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (access(rpath, F_OK) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* definite collision */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collides = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Here we have a little <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of a dilemma: if errno is something<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other than ENOENT, should we declare a collision and loop? In<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * practice it seems best to go ahead regardless of the errno.&nbsp; If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * there is a colliding file we will get an smgr failure when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * attempt to create the new relation file.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collides = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(rpath);<br/></li>
<li>&nbsp; &nbsp; } <span class="Statement">while</span> (collides);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rlocator.locator.relNumber;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL callable interface for <a href="#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>().&nbsp; Outside of initdb's<br/></li>
<li></span><span class="Comment"> * direct insertions into catalog tables, and recovering from corruption, this<br/></li>
<li></span><span class="Comment"> * should rarely be needed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Function is intentionally not documented in the user facing docs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L586">&#x200c;</a><span class="linkable">pg_nextoid</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; reloid = PG_GETARG_OID(<span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; Name&nbsp; &nbsp; &nbsp; &nbsp; attname = PG_GETARG_NAME(<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxoid = PG_GETARG_OID(<span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; idx;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttuple;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attform;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As this function is not intended to be used during normal running, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only supports system catalogs (which require <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> permissions to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * modify), just checking for <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> ought to not obstruct valid<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * usecases.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;must be <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> to call </span><span class="Special">%s</span><span class="Constant">()&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L586" title="catalog/catalog.c:586">pg_nextoid</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(reloid, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; idx = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(idxoid, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L73" title="catalog/catalog.c:73">IsSystemRelation</a>(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;<a href="#L586" title="catalog/catalog.c:586">pg_nextoid</a>() can only be used on system catalogs&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (idx-&gt;rd_index-&gt;indrelid != RelationGetRelid(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not belong to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(idx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; atttuple = <a href="../utils/cache/syscache.c.html#L359" title="utils/cache/syscache.c:359">SearchSysCacheAttName</a>(reloid, NameStr(*attname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*attname), RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attform = ((Form_pg_attribute) GETSTRUCT(atttuple));<br/></li>
<li>&nbsp; &nbsp; attno = attform-&gt;attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (attform-&gt;atttypid != OIDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not of type oid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*attname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IndexRelationGetNumberOfKeyAttributes(idx) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; idx-&gt;rd_index-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">0</span>] != attno)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_PARAMETER_VALUE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not the index for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(idx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(*attname))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; newoid = <a href="#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(rel, idxoid, attno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(atttuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(idx, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_OID(newoid);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL callable interface for <a href="../access/transam/varsup.c.html#L652" title="access/transam/varsup.c:652">StopGeneratingPinnedObjectIds</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is only to be used by initdb, so it's intentionally not documented in<br/></li>
<li></span><span class="Comment"> * the user facing docs.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Datum<br/></li>
<li><a id="L665">&#x200c;</a><span class="linkable">pg_stop_making_pinned_objects</span>(PG_FUNCTION_ARGS)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Belt-and-suspenders check, since <a href="../access/transam/varsup.c.html#L652" title="access/transam/varsup.c:652">StopGeneratingPinnedObjectIds</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fail anyway in non-single-user mode.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INSUFFICIENT_PRIVILEGE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;must be <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a> to call </span><span class="Special">%s</span><span class="Constant">()&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;<a href="#L665" title="catalog/catalog.c:665">pg_stop_making_pinned_objects</a>&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/transam/varsup.c.html#L652" title="access/transam/varsup.c:652">StopGeneratingPinnedObjectIds</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; PG_RETURN_VOID();<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
