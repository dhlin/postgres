<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>catalog/pg_operator.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>catalog/pg_operator.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L321">OperatorCreate</a></li>
<li><a href="#L124">OperatorGet</a></li>
<li><a href="#L164">OperatorLookup</a></li>
<li><a href="#L193">OperatorShellMake</a></li>
<li><a href="#L684">OperatorUpd</a></li>
<li><a href="#L556">OperatorValidateParams</a></li>
<li><a href="#L622">get_other_operator</a></li>
<li><a href="#L853">makeOperatorDependencies</a></li>
<li><a href="#L68">validOperatorName</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pg_operator.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines to support manipulation of the pg_operator relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/catalog/pg_operator.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NOTES<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; these routines moved here from commands/define.c and somewhat cleaned up.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/xact.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_oper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L124" title="catalog/pg_operator.c:124">OperatorGet</a>(<span class="Type">const</span> <span class="Type">char</span> *operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid leftObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid rightObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *defined);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L193" title="catalog/pg_operator.c:193">OperatorShellMake</a>(<span class="Type">const</span> <span class="Type">char</span> *operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid rightTypeId);<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L622" title="catalog/pg_operator.c:622">get_other_operator</a>(List *otherOp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid otherLeftTypeId, Oid otherRightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *operatorName, Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid leftTypeId, Oid rightTypeId);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check whether a proposed operator name is legal<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This had better match the behavior of parser/scan.l!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We need this because the parser is not smart enough to check that<br/></li>
<li></span><span class="Comment"> * the arguments of CREATE OPERATOR's COMMUTATOR, NEGATOR, etc clauses<br/></li>
<li></span><span class="Comment"> * are operator names rather than some other lexical entity.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L68">&#x200c;</a></span><span class="linkable">validOperatorName</span>(<span class="Type">const</span> <span class="Type">char</span> *name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">size_t</span>&nbsp; &nbsp; &nbsp; &nbsp; len = strlen(name);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't be empty or too long */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len == <span class="Constant">0</span> || len &gt;= NAMEDATALEN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> invalid characters */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* Test string here should match op_chars in scan.l */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strspn(name, <span class="Constant">&quot;~!@#^&amp;|`?+-*/%&lt;&gt;=&quot;</span>) != len)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't contain slash-star or dash-dash (comment starts) */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strstr(name, <span class="Constant">&quot;/*&quot;</span>) || strstr(name, <span class="Constant">&quot;--&quot;</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For SQL standard compatibility, '+' and '-' cannot be the last char of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * a multi-char operator unless the operator contains chars that are not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in SQL operators. The idea is to lex '=-' as two operators, but not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forbid operator names like '?-' that could not be sequences of standard<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SQL operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (len &gt; <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (name[len - <span class="Constant">1</span>] == <span class="Constant">'+'</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name[len - <span class="Constant">1</span>] == <span class="Constant">'-'</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ic;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ic = len - <span class="Constant">2</span>; ic &gt;= <span class="Constant">0</span>; ic--)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strchr(<span class="Constant">&quot;~!@#^&amp;|`?%&quot;</span>, name[ic]))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ic &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nope, not valid */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* != isn't valid either, because parser will convert it to &lt;&gt; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(name, <span class="Constant">&quot;!=&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L124" title="catalog/pg_operator.c:124">OperatorGet</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; finds an operator given an exact specification (name, namespace,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; left and right type IDs).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; *defined is set true if defined (not a shell)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L124">&#x200c;</a><span class="linkable">OperatorGet</span>(<span class="Type">const</span> <span class="Type">char</span> *operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid leftObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid rightObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *defined)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L251" title="utils/cache/syscache.c:251">SearchSysCache4</a>(OPERNAMENSP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PointerGetDatum(operatorName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(leftObjectId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(rightObjectId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operatorNamespace));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator oprform = (Form_pg_operator) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId = oprform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *defined = RegProcedureIsValid(oprform-&gt;oprcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *defined = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> operatorObjectId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L164" title="catalog/pg_operator.c:164">OperatorLookup</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; looks up an operator given a possibly-qualified name and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; left and right type IDs.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; *defined is set true if defined (not a shell)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L164">&#x200c;</a><span class="linkable">OperatorLookup</span>(List *operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid leftObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid rightObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *defined)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId;<br/></li>
<li>&nbsp; &nbsp; RegProcedure oprcode;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; operatorObjectId = <a href="../parser/parse_oper.c.html#L99" title="parser/parse_oper.c:99">LookupOperName</a>(<span class="Constant">NULL</span>, operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftObjectId, rightObjectId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(operatorObjectId))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *defined = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oprcode = <a href="../utils/cache/lsyscache.c.html#L1285" title="utils/cache/lsyscache.c:1285">get_opcode</a>(operatorObjectId);<br/></li>
<li>&nbsp; &nbsp; *defined = RegProcedureIsValid(oprcode);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> operatorObjectId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L193" title="catalog/pg_operator.c:193">OperatorShellMake</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Make a &quot;shell&quot; entry for a not-yet-existing operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L193">&#x200c;</a><span class="linkable">OperatorShellMake</span>(<span class="Type">const</span> <span class="Type">char</span> *operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid rightTypeId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_operator_desc;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Natts_pg_operator];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Natts_pg_operator];<br/></li>
<li>&nbsp; &nbsp; NameData&nbsp; &nbsp; oname;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupDesc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validate operator name<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L68" title="catalog/pg_operator.c:68">validOperatorName</a>(operatorName))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a valid operator name&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * open pg_operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; pg_operator_desc = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(OperatorRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; tupDesc = pg_operator_desc-&gt;rd_att;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> our *nulls and *<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> arrays<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; Natts_pg_operator; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = (Datum) <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* redundant, but safe */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[] with the operator name and input data types. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that oprcode is set to InvalidOid, indicating it's a shell.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; operatorObjectId = <a href="catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(pg_operator_desc, OperatorOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_operator_oid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oid - <span class="Constant">1</span>] = ObjectIdGetDatum(operatorObjectId);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;oname, operatorName);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprname - <span class="Constant">1</span>] = NameGetDatum(&amp;oname);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprnamespace - <span class="Constant">1</span>] = ObjectIdGetDatum(operatorNamespace);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprowner - <span class="Constant">1</span>] = ObjectIdGetDatum(<a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>());<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprkind - <span class="Constant">1</span>] = CharGetDatum(leftTypeId ? <span class="Constant">'b'</span> : <span class="Constant">'l'</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcanmerge - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcanhash - <span class="Constant">1</span>] = BoolGetDatum(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprleft - <span class="Constant">1</span>] = ObjectIdGetDatum(leftTypeId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprright - <span class="Constant">1</span>] = ObjectIdGetDatum(rightTypeId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprresult - <span class="Constant">1</span>] = ObjectIdGetDatum(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcom - <span class="Constant">1</span>] = ObjectIdGetDatum(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprnegate - <span class="Constant">1</span>] = ObjectIdGetDatum(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcode - <span class="Constant">1</span>] = ObjectIdGetDatum(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprrest - <span class="Constant">1</span>] = ObjectIdGetDatum(InvalidOid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprjoin - <span class="Constant">1</span>] = ObjectIdGetDatum(InvalidOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * create a new operator tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(tupDesc, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * insert our &quot;shell&quot; operator tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>(pg_operator_desc, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add dependencies for the entry */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L853" title="catalog/pg_operator.c:853">makeOperatorDependencies</a>(tup, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Post creation hook for new shell operator */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostCreateHook(OperatorRelationId, operatorObjectId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure the tuple is visible for subsequent lookups/updates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * close the operator relation and return the oid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_operator_desc, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> operatorObjectId;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L321" title="catalog/pg_operator.c:321">OperatorCreate</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;X&quot; indicates an optional argument (i.e. one that can be NULL or 0)<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; operatorName&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name for new operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; operatorNamespace&nbsp; &nbsp; &nbsp; &nbsp; namespace for new operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; leftTypeId&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X left type ID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; rightTypeId&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X right type ID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; procedureId&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; procedure ID for operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; commutatorName&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X commutator operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; negatorName&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X negator operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; restrictionId&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X restriction selectivity procedure ID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; joinId&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; X join selectivity procedure ID<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; canMerge&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join can be used with this operator<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; canHash&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> join can be used with this operator<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The caller should have validated properties and permissions for the<br/></li>
<li></span><span class="Comment"> * objects passed as OID references.&nbsp; We must handle the commutator and<br/></li>
<li></span><span class="Comment"> * negator operator references specially, however, since those need not<br/></li>
<li></span><span class="Comment"> * exist beforehand.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This routine gets complicated because it allows the user to<br/></li>
<li></span><span class="Comment"> * specify operators that do not exist.&nbsp; For example, if operator<br/></li>
<li></span><span class="Comment"> * &quot;op&quot; is being defined, the negator operator &quot;negop&quot; and the<br/></li>
<li></span><span class="Comment"> * commutator &quot;commop&quot; can also be defined without specifying<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> information other than their names.&nbsp; Since in order to<br/></li>
<li></span><span class="Comment"> * add &quot;op&quot; to the PG_OPERATOR catalog, all the Oid's for these<br/></li>
<li></span><span class="Comment"> * operators must be placed in the fields of &quot;op&quot;, a forward<br/></li>
<li></span><span class="Comment"> * declaration is done on the commutator and negator operators.<br/></li>
<li></span><span class="Comment"> * This is called creating a shell, and its <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> effect is to<br/></li>
<li></span><span class="Comment"> * create a tuple in the PG_OPERATOR catalog with minimal<br/></li>
<li></span><span class="Comment"> * information about the operator (just its name and types).<br/></li>
<li></span><span class="Comment"> * Forward declaration is used only for this purpose, it is<br/></li>
<li></span><span class="Comment"> * not available to the user as it is for type definition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L321">&#x200c;</a><span class="linkable">OperatorCreate</span>(<span class="Type">const</span> <span class="Type">char</span> *operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid rightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid procedureId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *commutatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *negatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid restrictionId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid joinId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canMerge,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canHash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_operator_desc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isUpdate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nulls[Natts_pg_operator];<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replaces[Natts_pg_operator];<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Natts_pg_operator];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; operatorAlreadyDefined;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operResultType;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; commutatorId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; negatorId;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; selfCommutator = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; NameData&nbsp; &nbsp; oname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Sanity checks<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L68" title="catalog/pg_operator.c:68">validOperatorName</a>(operatorName))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_NAME),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a valid operator name&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; operResultType = <a href="../utils/cache/lsyscache.c.html#L1655" title="utils/cache/lsyscache.c:1655">get_func_rettype</a>(procedureId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L556" title="catalog/pg_operator.c:556">OperatorValidateParams</a>(leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operResultType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; commutatorName != NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; negatorName != NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OidIsValid(restrictionId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OidIsValid(joinId),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; canMerge,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; canHash);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; operatorObjectId = <a href="#L124" title="catalog/pg_operator.c:124">OperatorGet</a>(operatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;operatorAlreadyDefined);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (operatorAlreadyDefined)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator </span><span class="Special">%s</span><span class="Constant"> already exists&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorName)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * At this point, if operatorObjectId is not InvalidOid then we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * filling in a previously-created shell.&nbsp; Insist that the user own <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * such shell.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(operatorObjectId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; !<a href="aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(OperatorRelationId, operatorObjectId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_OPERATOR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operatorName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up the other operators.&nbsp; If they do not currently exist, create<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shells in order to get ObjectId's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (commutatorName)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* commutator has reversed arg types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; commutatorId = <a href="#L622" title="catalog/pg_operator.c:622">get_other_operator</a>(commutatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightTypeId, leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operatorName, operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftTypeId, rightTypeId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Permission check: must own other operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(commutatorId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(OperatorRelationId, commutatorId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_OPERATOR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(commutatorName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If self-linkage to the new operator is requested, we'll fix it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * below.&nbsp; (In case of self-linkage to an existing shell operator, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need do nothing special.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(commutatorId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selfCommutator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; commutatorId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (negatorName)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* negator has same arg types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; negatorId = <a href="#L622" title="catalog/pg_operator.c:622">get_other_operator</a>(negatorName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftTypeId, rightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operatorName, operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftTypeId, rightTypeId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Permission check: must own other operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(negatorId) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !<a href="aclchk.c.html#L4130" title="catalog/aclchk.c:4130">object_ownercheck</a>(OperatorRelationId, negatorId, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>()))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(ACLCHECK_NOT_OWNER, OBJECT_OPERATOR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(negatorName));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prevent self negation, as it doesn't make sense.&nbsp; It's self<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * negation if result is InvalidOid (negator would be the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * operator but it doesn't exist yet) or operatorObjectId (we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replacing a shell that would need to be its own negator).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(negatorId) || negatorId == operatorObjectId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator cannot be its own negator&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; negatorId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * set up <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> in the operator tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; Natts_pg_operator; ++i)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] = (Datum) <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replaces[i] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nulls[i] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/adt/name.c.html#L233" title="utils/adt/name.c:233">namestrcpy</a>(&amp;oname, operatorName);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprname - <span class="Constant">1</span>] = NameGetDatum(&amp;oname);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprnamespace - <span class="Constant">1</span>] = ObjectIdGetDatum(operatorNamespace);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprowner - <span class="Constant">1</span>] = ObjectIdGetDatum(<a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>());<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprkind - <span class="Constant">1</span>] = CharGetDatum(leftTypeId ? <span class="Constant">'b'</span> : <span class="Constant">'l'</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcanmerge - <span class="Constant">1</span>] = BoolGetDatum(canMerge);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcanhash - <span class="Constant">1</span>] = BoolGetDatum(canHash);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprleft - <span class="Constant">1</span>] = ObjectIdGetDatum(leftTypeId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprright - <span class="Constant">1</span>] = ObjectIdGetDatum(rightTypeId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprresult - <span class="Constant">1</span>] = ObjectIdGetDatum(operResultType);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcom - <span class="Constant">1</span>] = ObjectIdGetDatum(commutatorId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprnegate - <span class="Constant">1</span>] = ObjectIdGetDatum(negatorId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprcode - <span class="Constant">1</span>] = ObjectIdGetDatum(procedureId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprrest - <span class="Constant">1</span>] = ObjectIdGetDatum(restrictionId);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oprjoin - <span class="Constant">1</span>] = ObjectIdGetDatum(joinId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pg_operator_desc = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(OperatorRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are replacing an operator shell, update; else insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (operatorObjectId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isUpdate = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = SearchSysCacheCopy1(OPEROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operatorObjectId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operatorObjectId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replaces[Anum_pg_operator_oid - <span class="Constant">1</span>] = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(tup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetDescr(pg_operator_desc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nulls,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replaces);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_operator_desc, &amp;tup-&gt;t_self, tup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isUpdate = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operatorObjectId = <a href="catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(pg_operator_desc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OperatorOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_operator_oid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_operator_oid - <span class="Constant">1</span>] = ObjectIdGetDatum(operatorObjectId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(RelationGetDescr(pg_operator_desc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>(pg_operator_desc, tup);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Add dependencies for the entry */<br/></li>
<li></span>&nbsp; &nbsp; address = <a href="#L853" title="catalog/pg_operator.c:853">makeOperatorDependencies</a>(tup, <span class="Constant">true</span>, isUpdate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a commutator and/or negator link is provided, update the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operator(s) to point at this one, if they don't already have a link.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This supports an alternative style of operator definition wherein the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * user first defines one operator without giving negator or commutator,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * then defines the other operator of the pair with the proper commutator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or negator attribute.&nbsp; That style doesn't require creation of a shell,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and it's the only style that worked right <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> Postgres version 6.5.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This code also takes care of the situation where the new operator is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its own commutator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (selfCommutator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; commutatorId = operatorObjectId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(commutatorId) || OidIsValid(negatorId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L684" title="catalog/pg_operator.c:684">OperatorUpd</a>(operatorObjectId, commutatorId, negatorId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Post creation hook for new operator */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostCreateHook(OperatorRelationId, operatorObjectId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_operator_desc, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> address;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L556" title="catalog/pg_operator.c:556">OperatorValidateParams</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check that an operator with argument types leftTypeId and rightTypeId,<br/></li>
<li></span><span class="Comment"> * returning operResultType, can have the attributes that are set to true.<br/></li>
<li></span><span class="Comment"> * Raise an error for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> disallowed attribute.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: in ALTER OPERATOR, we only bother to pass &quot;true&quot; for attributes<br/></li>
<li></span><span class="Comment"> * the command is trying to set, not those that may already be set.<br/></li>
<li></span><span class="Comment"> * This is OK as long as the attribute checks are independent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L556">&#x200c;</a></span><span class="linkable">OperatorValidateParams</span>(Oid leftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid rightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid operResultType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasCommutator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasNegator,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasRestrictionSelectivity,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> hasJoinSelectivity,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canMerge,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> canHash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!(OidIsValid(leftTypeId) &amp;&amp; OidIsValid(rightTypeId)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not a binary op, these things mustn't be set: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasCommutator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only binary operators can have commutators&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasJoinSelectivity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only binary operators can have join selectivity&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canMerge)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only binary operators can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canHash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only binary operators can <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (operResultType != BOOLOID)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's not a boolean op, these things mustn't be set: */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasNegator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only boolean operators can have negators&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasRestrictionSelectivity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only boolean operators can have restriction selectivity&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (hasJoinSelectivity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only boolean operators can have join selectivity&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canMerge)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only boolean operators can <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> join&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (canHash)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;only boolean operators can <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Try to lookup another operator (commutator, etc); return its OID<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If not found, check to see if it would be the same operator we are trying<br/></li>
<li></span><span class="Comment"> * to define; if so, return InvalidOid.&nbsp; (Caller must decide whether<br/></li>
<li></span><span class="Comment"> * that is sensible.)&nbsp; If it is not the same operator, create a shell<br/></li>
<li></span><span class="Comment"> * operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L622">&#x200c;</a><span class="linkable">get_other_operator</span>(List *otherOp, Oid otherLeftTypeId, Oid otherRightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *operatorName, Oid operatorNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid leftTypeId, Oid rightTypeId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other_oid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; otherDefined;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *otherName;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherNamespace;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; other_oid = <a href="#L164" title="catalog/pg_operator.c:164">OperatorLookup</a>(otherOp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherLeftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; otherRightTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;otherDefined);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(other_oid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* other op already in catalogs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> other_oid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; otherNamespace = <a href="namespace.c.html#L3472" title="catalog/namespace.c:3472">QualifiedNameGetCreationNamespace</a>(otherOp,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;otherName);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strcmp(otherName, operatorName) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherNamespace == operatorNamespace &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherLeftTypeId == leftTypeId &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; otherRightTypeId == rightTypeId)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* self-linkage to new operator; caller must handle this */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* not in catalogs, different from operator, so make shell */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; aclresult = <a href="aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(NamespaceRelationId, otherNamespace, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_CREATE);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_SCHEMA,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(otherNamespace));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; other_oid = <a href="#L193" title="catalog/pg_operator.c:193">OperatorShellMake</a>(otherName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherNamespace,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherLeftTypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherRightTypeId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> other_oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L684" title="catalog/pg_operator.c:684">OperatorUpd</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For a given operator, look up its negator and commutator operators.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; When isDelete is false, update their negator and commutator fields to<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; point back to the given operator; when isDelete is true, update those<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; fields to be InvalidOid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; The !isDelete case solves a problem for users who need to insert two new<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; operators that are the negator or commutator of each other, while the<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; isDelete case is needed so as not to leave dangling OID links behind<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; after dropping an operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L684">&#x200c;</a></span><span class="linkable">OperatorUpd</span>(Oid baseId, Oid commId, Oid negId, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isDelete)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; pg_operator_desc;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we're making an operator into its own commutator, then we need a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * command-counter increment here, since we've just inserted the tuple<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we're about to update.&nbsp; But when we're dropping an operator, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this because we're at the beginning of the command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isDelete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the relation. */<br/></li>
<li></span>&nbsp; &nbsp; pg_operator_desc = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(OperatorRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get a writable copy of the commutator's tuple. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(commId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = SearchSysCacheCopy1(OPEROID, ObjectIdGetDatum(commId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tup = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Update the commutator's tuple if need be. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator t = (Form_pg_operator) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; update_commutator = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing anything if the commutator's oprcom field is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already what we want.&nbsp; While that's not expected in the isDelete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, it's perfectly possible when filling in a shell operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isDelete &amp;&amp; OidIsValid(t-&gt;oprcom))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;oprcom = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_commutator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!isDelete &amp;&amp; t-&gt;oprcom != baseId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If commutator's oprcom field is already set to point to some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * third operator, it's an error.&nbsp; Changing its link would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unsafe, and letting the inconsistency stand would not be good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either.&nbsp; This might be indicative of catalog corruption, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't assume t-&gt;oprcom is necessarily a valid operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(t-&gt;oprcom))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *thirdop = <a href="../utils/cache/lsyscache.c.html#L1310" title="utils/cache/lsyscache.c:1310">get_opname</a>(t-&gt;oprcom);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thirdop != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;commutator operator </span><span class="Special">%s</span><span class="Constant"> is already the commutator of operator </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(t-&gt;oprname), thirdop)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;commutator operator </span><span class="Special">%s</span><span class="Constant"> is already the commutator of operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(t-&gt;oprname), t-&gt;oprcom)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;oprcom = baseId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_commutator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns were found to need modification, update tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update_commutator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_operator_desc, &amp;tup-&gt;t_self, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do CCI to make the updated tuple visible.&nbsp; We must do this in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case the commutator is also the negator.&nbsp; (Which would be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * logic error on the operator definer's part, but that's not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good reason to fail here.)&nbsp; We would need a CCI anyway in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * deletion case for a self-commutator with no negator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Similarly <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> and update the negator, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(negId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = SearchSysCacheCopy1(OPEROID, ObjectIdGetDatum(negId));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; tup = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator t = (Form_pg_operator) GETSTRUCT(tup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; update_negator = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> doing anything if the negator's oprnegate field is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * already what we want.&nbsp; While that's not expected in the isDelete<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * case, it's perfectly possible when filling in a shell operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isDelete &amp;&amp; OidIsValid(t-&gt;oprnegate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;oprnegate = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_negator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!isDelete &amp;&amp; t-&gt;oprnegate != baseId)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If negator's oprnegate field is already set to point to some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * third operator, it's an error.&nbsp; Changing its link would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * unsafe, and letting the inconsistency stand would not be good<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either.&nbsp; This might be indicative of catalog corruption, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't assume t-&gt;oprnegate is necessarily a valid operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(t-&gt;oprnegate))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *thirdop = <a href="../utils/cache/lsyscache.c.html#L1310" title="utils/cache/lsyscache.c:1310">get_opname</a>(t-&gt;oprnegate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thirdop != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negator operator </span><span class="Special">%s</span><span class="Constant"> is already the negator of operator </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(t-&gt;oprname), thirdop)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_FUNCTION_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;negator operator </span><span class="Special">%s</span><span class="Constant"> is already the negator of operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NameStr(t-&gt;oprname), t-&gt;oprnegate)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; t-&gt;oprnegate = baseId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; update_negator = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> columns were found to need modification, update tuple. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (update_negator)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(pg_operator_desc, &amp;tup-&gt;t_self, tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the deletion case, do CCI to make the updated tuple visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must do this in case the operator is its own negator. (Which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would be a logic error on the operator definer's part, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that's not a good reason to fail here.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isDelete)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/transam/xact.c.html#L1097" title="access/transam/xact.c:1097">CommandCounterIncrement</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close relation and release catalog lock. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pg_operator_desc, RowExclusiveLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create dependencies for an operator (either a freshly inserted<br/></li>
<li></span><span class="Comment"> * complete operator, a new shell operator, a just-updated shell,<br/></li>
<li></span><span class="Comment"> * or an operator that's being modified by ALTER OPERATOR).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * makeExtensionDep should be true when making a new operator or<br/></li>
<li></span><span class="Comment"> * replacing a shell, false for ALTER OPERATOR.&nbsp; Passing false<br/></li>
<li></span><span class="Comment"> * will prevent <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> change in the operator's extension membership.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: the OidIsValid tests in this routine are necessary, in case<br/></li>
<li></span><span class="Comment"> * the given operator is a shell.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L853">&#x200c;</a><span class="linkable">makeOperatorDependencies</span>(HeapTuple tuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> makeExtensionDep,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isUpdate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a> = (Form_pg_operator) GETSTRUCT(tuple);<br/></li>
<li>&nbsp; &nbsp; ObjectAddress myself,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; referenced;<br/></li>
<li>&nbsp; &nbsp; <a href="dependency.c.html#L113" title="catalog/dependency.c:113">ObjectAddresses</a> *addrs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ObjectAddressSet(myself, OperatorRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we are updating the operator, delete <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> existing entries, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for extension membership which should remain the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isUpdate)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L300" title="catalog/pg_depend.c:300">deleteDependencyRecordsFor</a>(myself.classId, myself.objectId, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_shdepend.c.html#L997" title="catalog/pg_shdepend.c:997">deleteSharedDependencyRecordsFor</a>(myself.classId, myself.objectId, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; addrs = <a href="dependency.c.html#L2485" title="catalog/dependency.c:2485">new_object_addresses</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on namespace */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprnamespace))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, NamespaceRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprnamespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on left type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprleft))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, TypeRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprleft);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on right type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprright))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, TypeRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprright);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on result type */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprresult))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, TypeRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprresult);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: we do not consider the operator to depend on the associated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operators oprcom and oprnegate.&nbsp; We do not want to delete this operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if those go away, but only reset the link fields; which is not a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * function that the dependency logic can handle.&nbsp; (It's taken care of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * manually within <a href="../commands/operatorcmds.c.html#L413" title="commands/operatorcmds.c:413">RemoveOperatorById</a>, instead.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on implementation function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprcode))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ProcedureRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprcode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on restriction selectivity function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprrest))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ProcedureRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprrest);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on join selectivity function */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprjoin))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(referenced, ProcedureRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprjoin);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L2531" title="catalog/dependency.c:2531">add_exact_object_address</a>(&amp;referenced, addrs);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="dependency.c.html#L2740" title="catalog/dependency.c:2740">record_object_address_dependencies</a>(&amp;myself, addrs, DEPENDENCY_NORMAL);<br/></li>
<li>&nbsp; &nbsp; <a href="dependency.c.html#L2771" title="catalog/dependency.c:2771">free_object_addresses</a>(addrs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on owner */<br/></li>
<li></span>&nbsp; &nbsp; <a href="pg_shdepend.c.html#L160" title="catalog/pg_shdepend.c:160">recordDependencyOnOwner</a>(OperatorRelationId, <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../parser/parse_oper.c.html#L370" title="parser/parse_oper.c:370">oper</a>-&gt;oprowner);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Dependency on extension */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (makeExtensionDep)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="pg_depend.c.html#L192" title="catalog/pg_depend.c:192">recordDependencyOnCurrentExtension</a>(&amp;myself, isUpdate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> myself;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
