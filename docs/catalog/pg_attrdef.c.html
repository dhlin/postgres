<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>catalog/pg_attrdef.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>catalog/pg_attrdef.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L381">GetAttrDefaultColumnAddress</a></li>
<li><a href="#L339">GetAttrDefaultOid</a></li>
<li><a href="#L213">RemoveAttrDefault</a></li>
<li><a href="#L268">RemoveAttrDefaultById</a></li>
<li><a href="#L46">StoreAttrDefault</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pg_attrdef.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; routines to support manipulation of the pg_attrdef relation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/catalog/pg_attrdef.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/genam.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/catalog.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/indexing.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/objectaccess.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_attrdef.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;executor/executor.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/array.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/fmgroids.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Store a default expression for column attnum of relation rel.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the OID of the new pg_attrdef tuple.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * add_column_mode must be true if we are storing the default for a new<br/></li>
<li></span><span class="Comment"> * attribute, and false if it's for an already existing attribute. The reason<br/></li>
<li></span><span class="Comment"> * for this is that the missing value must never be updated after it is set,<br/></li>
<li></span><span class="Comment"> * which can only be when a column is added to the table. Otherwise we would<br/></li>
<li></span><span class="Comment"> * in effect be changing existing tuples.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L46">&#x200c;</a><span class="linkable">StoreAttrDefault</span>(Relation rel, AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *expr, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> is_internal, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> add_column_mode)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *adbin;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; adrel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[<span class="Constant">4</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> nulls[<span class="Constant">4</span>] = {<span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">false</span>};<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrrel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; atttup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_attribute attStruct;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; attgenerated;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrdefOid;<br/></li>
<li>&nbsp; &nbsp; ObjectAddress colobject,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defobject;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; adrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttrDefaultRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Flatten expression to string form for storage.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; adbin = <a href="../nodes/outfuncs.c.html#L791" title="nodes/outfuncs.c:791">nodeToString</a>(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make the pg_attrdef entry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrdefOid = <a href="catalog.c.html#L391" title="catalog/catalog.c:391">GetNewOidWithIndex</a>(adrel, AttrDefaultOidIndexId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_oid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_attrdef_oid - <span class="Constant">1</span>] = ObjectIdGetDatum(attrdefOid);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_attrdef_adrelid - <span class="Constant">1</span>] = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_attrdef_adnum - <span class="Constant">1</span>] = attnum;<br/></li>
<li>&nbsp; &nbsp; <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_attrdef_adbin - <span class="Constant">1</span>] = CStringGetTextDatum(adbin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/common/heaptuple.c.html#L1116" title="access/common/heaptuple.c:1116">heap_form_tuple</a>(adrel-&gt;rd_att, <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>, nulls);<br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L233" title="catalog/indexing.c:233">CatalogTupleInsert</a>(adrel, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; defobject.classId = AttrDefaultRelationId;<br/></li>
<li>&nbsp; &nbsp; defobject.objectId = attrdefOid;<br/></li>
<li>&nbsp; &nbsp; defobject.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(adrel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> can free some of the stuff allocated above */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[Anum_pg_attrdef_adbin - <span class="Constant">1</span>]));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(adbin);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Update the pg_attribute entry for the column to show that a default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attrrel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; atttup = SearchSysCacheCopy2(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ObjectIdGetDatum(RelationGetRelid(rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(atttup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attnum, RelationGetRelid(rel));<br/></li>
<li>&nbsp; &nbsp; attStruct = (Form_pg_attribute) GETSTRUCT(atttup);<br/></li>
<li>&nbsp; &nbsp; attgenerated = attStruct-&gt;attgenerated;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!attStruct-&gt;atthasdef)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute defAttStruct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprState&nbsp; *exprState;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr2 = (Expr *) expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; EState&nbsp; &nbsp; &nbsp;&nbsp; *estate = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ExprContext *econtext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; valuesAtt[Natts_pg_attribute] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; nullsAtt[Natts_pg_attribute] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; replacesAtt[Natts_pg_attribute] = {<span class="Constant">0</span>};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; missingval = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; missingIsNull = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; valuesAtt[Anum_pg_attribute_atthasdef - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; replacesAtt[Anum_pg_attribute_atthasdef - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_RELATION &amp;&amp; add_column_mode &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !attgenerated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr2 = <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>(expr2);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; estate = <a href="../executor/execUtils.c.html#L88" title="executor/execUtils.c:88">CreateExecutorState</a>();<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprState = <a href="../executor/execExpr.c.html#L739" title="executor/execExpr.c:739">ExecPrepareExpr</a>(expr2, estate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; econtext = GetPerTupleExprContext(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingval = ExecEvalExpr(exprState, econtext,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;missingIsNull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../executor/execUtils.c.html#L189" title="executor/execUtils.c:189">FreeExecutorState</a>(estate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defAttStruct = TupleDescAttr(rel-&gt;rd_att, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (missingIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if the default evaluates to NULL, just store a NULL array */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingval = (Datum) <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise make a one-<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> array of the value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; missingval = PointerGetDatum(<a href="../utils/adt/arrayfuncs.c.html#L3354" title="utils/adt/arrayfuncs.c:3354">construct_array</a>(&amp;missingval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defAttStruct-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defAttStruct-&gt;attlen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defAttStruct-&gt;attbyval,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; defAttStruct-&gt;attalign));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valuesAtt[Anum_pg_attribute_atthasmissing - <span class="Constant">1</span>] = !missingIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replacesAtt[Anum_pg_attribute_atthasmissing - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valuesAtt[Anum_pg_attribute_attmissingval - <span class="Constant">1</span>] = missingval;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; replacesAtt[Anum_pg_attribute_attmissingval - <span class="Constant">1</span>] = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nullsAtt[Anum_pg_attribute_attmissingval - <span class="Constant">1</span>] = missingIsNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atttup = <a href="../access/common/heaptuple.c.html#L1209" title="access/common/heaptuple.c:1209">heap_modify_tuple</a>(atttup, RelationGetDescr(attrrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; valuesAtt, nullsAtt, replacesAtt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attrrel, &amp;atttup-&gt;t_self, atttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!missingIsNull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(DatumGetPointer(missingval));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrrel, RowExclusiveLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/heaptuple.c.html#L1434" title="access/common/heaptuple.c:1434">heap_freetuple</a>(atttup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a dependency so that the pg_attrdef entry goes away if the column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (or whole table) is deleted.&nbsp; In the case of a generated column, make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> dependency to prevent the default expression from being<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * deleted separately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; colobject.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; colobject.objectId = RelationGetRelid(rel);<br/></li>
<li>&nbsp; &nbsp; colobject.objectSubId = attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="pg_depend.c.html#L44" title="catalog/pg_depend.c:44">recordDependencyOn</a>(&amp;defobject, &amp;colobject,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attgenerated ? DEPENDENCY_INTERNAL : DEPENDENCY_AUTO);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Record dependencies on objects used in the expression, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="dependency.c.html#L1594" title="catalog/dependency.c:1594">recordDependencyOnSingleRelExpr</a>(&amp;defobject, expr, RelationGetRelid(rel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_NORMAL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DEPENDENCY_NORMAL, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Post creation hook for attribute defaults.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment">. ALTER TABLE ALTER COLUMN <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a>/DROP DEFAULT is implemented with a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * couple of deletion/creation of the attribute's default entry, so the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * callee should check existence of an older version of this entry if it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needs to distinguish.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; InvokeObjectPostCreateHookArg(AttrDefaultRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(rel), attnum, is_internal);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> attrdefOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L213" title="catalog/pg_attrdef.c:213">RemoveAttrDefault</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the specified relation/attribute has a default, remove it.<br/></li>
<li></span><span class="Comment"> * (If no default, raise error if complain is true, else return quietly.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L213">&#x200c;</a></span><span class="linkable">RemoveAttrDefault</span>(Oid relid, AttrNumber attnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DropBehavior behavior, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> complain, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a>)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrdef_rel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData scankeys[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrdef_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttrDefaultRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;scankeys[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_adrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;scankeys[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_adnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_INT2EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(attnum));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(attrdef_rel, AttrDefaultIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">2</span>, scankeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There should be at most one matching tuple, but we loop anyway */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">while</span> (HeapTupleIsValid(tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress object;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attrdef attrtuple = (Form_pg_attrdef) GETSTRUCT(tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.classId = AttrDefaultRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.objectId = attrtuple-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; object.objectSubId = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>(&amp;object, behavior,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> ? PERFORM_DELETION_INTERNAL : <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdef_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (complain &amp;&amp; !found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> attrdef tuple for relation </span><span class="Special">%u</span><span class="Constant"> attnum </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; relid, attnum);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L268" title="catalog/pg_attrdef.c:268">RemoveAttrDefaultById</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remove a pg_attrdef entry specified by OID.&nbsp; This is the guts of<br/></li>
<li></span><span class="Comment"> * attribute-default removal.&nbsp; Note it should be called via <a href="dependency.c.html#L273" title="catalog/dependency.c:273">performDeletion</a>,<br/></li>
<li></span><span class="Comment"> * not directly.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L268">&#x200c;</a></span><span class="linkable">RemoveAttrDefaultById</span>(Oid attrdefId)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrdef_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attr_rel;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; myrel;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData scankeys[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; myrelid;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; myattnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grab an appropriate lock on the pg_attrdef relation */<br/></li>
<li></span>&nbsp; &nbsp; attrdef_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttrDefaultRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Find the pg_attrdef tuple */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;scankeys[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(attrdefId));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(attrdef_rel, AttrDefaultOidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, scankeys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> tuple for attrdef </span><span class="Special">%u</span><span class="Constant">&quot;</span>, attrdefId);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; myrelid = ((Form_pg_attrdef) GETSTRUCT(tuple))-&gt;adrelid;<br/></li>
<li>&nbsp; &nbsp; myattnum = ((Form_pg_attrdef) GETSTRUCT(tuple))-&gt;adnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get an exclusive lock on the relation owning the attribute */<br/></li>
<li></span>&nbsp; &nbsp; myrel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(myrelid, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now we can delete the pg_attrdef row */<br/></li>
<li></span>&nbsp; &nbsp; <a href="indexing.c.html#L365" title="catalog/indexing.c:365">CatalogTupleDelete</a>(attrdef_rel, &amp;tuple-&gt;t_self);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdef_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fix the pg_attribute row */<br/></li>
<li></span>&nbsp; &nbsp; attr_rel = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttributeRelationId, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = SearchSysCacheCopy2(ATTNUM,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(myrelid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(myattnum));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(tuple))&nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; myattnum, myrelid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ((Form_pg_attribute) GETSTRUCT(tuple))-&gt;atthasdef = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="indexing.c.html#L313" title="catalog/indexing.c:313">CatalogTupleUpdate</a>(attr_rel, &amp;tuple-&gt;t_self, tuple);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Our update of the pg_attribute row will force a relcache rebuild, so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's nothing else to do here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attr_rel, RowExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Keep lock on attribute's rel until end of xact */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(myrel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Get the pg_attrdef OID of the default expression for a column<br/></li>
<li></span><span class="Comment"> * identified by relation OID and column number.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns InvalidOid if there is no such pg_attrdef entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L339">&#x200c;</a><span class="linkable">GetAttrDefaultOid</span>(Oid relid, AttrNumber attnum)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrdef;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData keys[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrdef = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttrDefaultRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;keys[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_adrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(relid));<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;keys[<span class="Constant">1</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_adnum,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; F_INT2EQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int16GetDatum(attnum));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(attrdef, AttrDefaultIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">2</span>, keys);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attrdef atdform = (Form_pg_attrdef) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = atdform-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdef, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Given a pg_attrdef OID, return the relation OID and column number of<br/></li>
<li></span><span class="Comment"> * the owning column (represented as an ObjectAddress for convenience).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns <a href="objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a> if there is no such pg_attrdef entry.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ObjectAddress<br/></li>
<li><a id="L381">&#x200c;</a><span class="linkable">GetAttrDefaultColumnAddress</span>(Oid attrdefoid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ObjectAddress result = <a href="objectaddress.c.html#L837" title="catalog/objectaddress.c:837">InvalidObjectAddress</a>;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; attrdef;<br/></li>
<li>&nbsp; &nbsp; ScanKeyData skey[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; SysScanDesc scan;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; attrdef = <a href="../access/table/table.c.html#L40" title="access/table/table.c:40">table_open</a>(AttrDefaultRelationId, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/scankey.c.html#L76" title="access/common/scankey.c:76">ScanKeyInit</a>(&amp;skey[<span class="Constant">0</span>],<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_attrdef_oid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BTEqualStrategyNumber, F_OIDEQ,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(attrdefoid));<br/></li>
<li>&nbsp; &nbsp; scan = <a href="../access/index/genam.c.html#L384" title="access/index/genam.c:384">systable_beginscan</a>(attrdef, AttrDefaultOidIndexId, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">1</span>, skey);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup = <a href="../access/index/genam.c.html#L503" title="access/index/genam.c:503">systable_getnext</a>(scan)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attrdef atdform = (Form_pg_attrdef) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result.classId = RelationRelationId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result.objectId = atdform-&gt;adrelid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result.objectSubId = atdform-&gt;adnum;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/index/genam.c.html#L596" title="access/index/genam.c:596">systable_endscan</a>(scan);<br/></li>
<li>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(attrdef, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
