<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>parser/parse_node.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>parser/parse_node.c - pgsql17devel-backend</h1>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L156">cancel_parser_errposition_callback</a></li>
<li><a href="#L72">free_parsestate</a></li>
<li><a href="#L347">make_const</a></li>
<li><a href="#L39">make_parsestate</a></li>
<li><a href="#L106">parser_errposition</a></li>
<li><a href="#L170">pcb_error_callback</a></li>
<li><a href="#L140">setup_parser_errposition_callback</a></li>
<li><a href="#L243">transformContainerSubscripts</a></li>
<li><a href="#L189">transformContainerType</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parse_node.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; various routines that make nodes for querytrees<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/parser/parse_node.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/subscripting.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_node.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L170" title="parser/parse_node.c:170">pcb_error_callback</a>(<span class="Type">void</span> *arg);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L39" title="parser/parse_node.c:39">make_parsestate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Allocate and <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> a new ParseState.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Caller should eventually release the ParseState via <a href="#L72" title="parser/parse_node.c:72">free_parsestate</a>().<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>ParseState *<br/></li>
<li><a id="L39">&#x200c;</a><span class="linkable">make_parsestate</span>(ParseState *parentParseState)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate = <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(<span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParseState));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;parentParseState = parentParseState;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill in fields that don't start at null/false/zero */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_next_resno = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_resolve_unknowns = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parentParseState)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_sourcetext = parentParseState-&gt;p_sourcetext;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all hooks are copied from parent */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_pre_columnref_hook = parentParseState-&gt;p_pre_columnref_hook;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_post_columnref_hook = parentParseState-&gt;p_post_columnref_hook;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_paramref_hook = parentParseState-&gt;p_paramref_hook;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_coerce_param_hook = parentParseState-&gt;p_coerce_param_hook;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_ref_hook_state = parentParseState-&gt;p_ref_hook_state;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* query environment stays in context for the whole <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_queryEnv = parentParseState-&gt;p_queryEnv;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pstate;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L72" title="parser/parse_node.c:72">free_parsestate</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Release a ParseState and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> subsidiary resources.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L72">&#x200c;</a></span><span class="linkable">free_parsestate</span>(ParseState *pstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that we did not produce too many resnos; at the very least we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cannot allow more than 2^16, since that would exceed the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AttrNumber. It seems safest to use MaxTupleAttributeNumber.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_next_resno - <span class="Constant">1</span> &gt; MaxTupleAttributeNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_TOO_MANY_COLUMNS),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;target lists can have at most </span><span class="Special">%d</span><span class="Constant"> entries&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MaxTupleAttributeNumber)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_target_relation != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(pstate-&gt;p_target_relation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(pstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L106" title="parser/parse_node.c:106">parser_errposition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Report a <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a>-analysis-time cursor position, if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is expected to be used within an ereport() call.&nbsp; The return value<br/></li>
<li></span><span class="Comment"> * is a dummy (always 0, in fact).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The locations stored in raw parsetrees are byte offsets into the source<br/></li>
<li></span><span class="Comment"> * string.&nbsp; We have to convert them to 1-based character indexes for reporting<br/></li>
<li></span><span class="Comment"> * to clients.&nbsp; (We do things this way to avoid unnecessary overhead in the<br/></li>
<li></span><span class="Comment"> * normal non-error case: computing character indexes would be much more<br/></li>
<li></span><span class="Comment"> * expensive than storing token offsets.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li><a id="L106">&#x200c;</a></span><span class="linkable">parser_errposition</span>(ParseState *pstate, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* No-op if location was not provided */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (location &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Can't do anything if source text is not available */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate == <span class="Constant">NULL</span> || pstate-&gt;p_sourcetext == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Convert offset to character number */<br/></li>
<li></span>&nbsp; &nbsp; pos = <a href="../utils/mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(pstate-&gt;p_sourcetext, location) + <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* And pass it to the ereport mechanism */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="../utils/error/elog.c.html#L1448" title="utils/error/elog.c:1448">errposition</a>(pos);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Arrange for non-parser errors to report an error position<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sometimes the parser calls <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that aren't part of the parser<br/></li>
<li></span><span class="Comment"> * subsystem and can't reasonably be passed a ParseState; yet we would<br/></li>
<li></span><span class="Comment"> * like <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors thrown in those <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to be tagged with a <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a><br/></li>
<li></span><span class="Comment"> * error location.&nbsp; Use this function to set up an error context stack<br/></li>
<li></span><span class="Comment"> * entry that will accomplish that.&nbsp; Usage pattern:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; declare a local variable &quot;ParseCallbackState pcbstate&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ...<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, pstate, location);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; call function that might throw error;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L140">&#x200c;</a></span><span class="linkable">setup_parser_errposition_callback</span>(ParseCallbackState *pcbstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParseState *pstate, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Setup error traceback support for ereport() */<br/></li>
<li></span>&nbsp; &nbsp; pcbstate-&gt;pstate = pstate;<br/></li>
<li>&nbsp; &nbsp; pcbstate-&gt;location = location;<br/></li>
<li>&nbsp; &nbsp; pcbstate-&gt;errcallback.callback = <a href="#L170" title="parser/parse_node.c:170">pcb_error_callback</a>;<br/></li>
<li>&nbsp; &nbsp; pcbstate-&gt;errcallback.arg = (<span class="Type">void</span> *) pcbstate;<br/></li>
<li>&nbsp; &nbsp; pcbstate-&gt;errcallback.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;pcbstate-&gt;errcallback;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel a previously-set-up <a href="../utils/error/elog.c.html#L1448" title="utils/error/elog.c:1448">errposition</a> callback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L156">&#x200c;</a></span><span class="linkable">cancel_parser_errposition_callback</span>(ParseCallbackState *pcbstate)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Pop the error context stack */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = pcbstate-&gt;errcallback.previous;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error context callback for inserting parser error location.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this will be called for *<a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>* error occurring while the<br/></li>
<li></span><span class="Comment"> * callback is installed.&nbsp; We avoid inserting an irrelevant error location<br/></li>
<li></span><span class="Comment"> * if the error is a query cancel --- are there <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other important cases?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L170">&#x200c;</a></span><span class="linkable">pcb_error_callback</span>(<span class="Type">void</span> *arg)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseCallbackState *pcbstate = (ParseCallbackState *) arg;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/error/elog.c.html#L1563" title="utils/error/elog.c:1563">geterrcode</a>() != ERRCODE_QUERY_CANCELED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L106" title="parser/parse_node.c:106">parser_errposition</a>(pcbstate-&gt;pstate, pcbstate-&gt;location);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L189" title="parser/parse_node.c:189">transformContainerType</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Identify the actual container type for a subscripting operation.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * containerType/containerTypmod are modified if necessary to identify<br/></li>
<li></span><span class="Comment"> * the actual container type and typmod.&nbsp; This mainly involves smashing<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> domain to its base type, but there are some special considerations.<br/></li>
<li></span><span class="Comment"> * Note that caller still needs to check if the result type is a container.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L189">&#x200c;</a></span><span class="linkable">transformContainerType</span>(Oid *containerType, int32 *containerTypmod)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the input is a domain, smash to base type, and extract the actual<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * typmod to be applied to the base type. Subscripting a domain is an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation that necessarily works on the base container type, not the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * domain itself. (Note that we provide no method whereby the creator of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * domain over a container type could hide its ability to be subscripted.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; *containerType = <a href="../utils/cache/lsyscache.c.html#L2538" title="utils/cache/lsyscache.c:2538">getBaseTypeAndTypmod</a>(*containerType, containerTypmod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We treat int2vector and oidvector as though they were domains over<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * int2[] and oid[].&nbsp; This is needed because array slicing could create an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array that doesn't satisfy the dimensionality constraints of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * xxxvector type; so we want the result of a slice operation to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * considered to be of the more general type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (*containerType == INT2VECTOROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *containerType = INT2ARRAYOID;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (*containerType == OIDVECTOROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *containerType = OIDARRAYOID;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L243" title="parser/parse_node.c:243">transformContainerSubscripts</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transform container (array, etc) subscripting.&nbsp; This is used for both<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; container fetch and container assignment.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In a container fetch, we are given a source container value and we produce<br/></li>
<li></span><span class="Comment"> * an expression that represents the result of extracting a single container<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or a container slice.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Container assignments are treated basically the same as container fetches<br/></li>
<li></span><span class="Comment"> * here.&nbsp; The caller will modify the result node to insert the source value<br/></li>
<li></span><span class="Comment"> * that is to be assigned to the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> or slice that a fetch would have<br/></li>
<li></span><span class="Comment"> * retrieved.&nbsp; The execution result will be a new container value with<br/></li>
<li></span><span class="Comment"> * the source value inserted into the right part of the container.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For both cases, if the source is of a domain-over-container type, the<br/></li>
<li></span><span class="Comment"> * result is the same as if it had been of the container type; essentially,<br/></li>
<li></span><span class="Comment"> * we must fold a domain to its base type <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> applying subscripting.<br/></li>
<li></span><span class="Comment"> * (Note that int2vector and oidvector are treated as domains here.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pstate&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Parse state<br/></li>
<li></span><span class="Comment"> * containerBase&nbsp; &nbsp; Already-transformed expression for the container as a whole<br/></li>
<li></span><span class="Comment"> * containerType&nbsp; &nbsp; OID of container's datatype (should match type of<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; containerBase, or be the base type of containerBase's<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; domain type)<br/></li>
<li></span><span class="Comment"> * containerTypMod&nbsp; &nbsp; typmod for the container<br/></li>
<li></span><span class="Comment"> * indirection&nbsp; &nbsp; &nbsp; &nbsp; Untransformed list of subscripts (must not be NIL)<br/></li>
<li></span><span class="Comment"> * isAssignment&nbsp; &nbsp; &nbsp; &nbsp; True if this will become a container assignment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SubscriptingRef *<br/></li>
<li><a id="L243">&#x200c;</a><span class="linkable">transformContainerSubscripts</span>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *containerBase,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid containerType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; int32 containerTypMod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *indirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isAssignment)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SubscriptingRef *sbsref;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> SubscriptRoutines *sbsroutines;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elementType;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isSlice = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *idx;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine the actual container type, smashing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> domain.&nbsp; In the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * assignment case the caller already did this, since it also needs to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * know the actual container type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isAssignment)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L189" title="parser/parse_node.c:189">transformContainerType</a>(&amp;containerType, &amp;containerTypMod);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify that the container type is subscriptable, and get its support<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> and typelem.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sbsroutines = <a href="../utils/cache/lsyscache.c.html#L3130" title="utils/cache/lsyscache.c:3130">getSubscriptingRoutines</a>(containerType, &amp;elementType);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!sbsroutines)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot subscript type </span><span class="Special">%s</span><span class="Constant"> because it does not support subscripting&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(containerType)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(containerBase))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Detect whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the indirection items are slice specifiers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * A list containing only simple subscripts refers to a single container<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of the items are slice specifiers (<a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a>:<a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>), then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the subscript expression means a container slice operation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(idx, indirection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; A_Indices&nbsp; *ai = lfirst_node(A_Indices, idx);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ai-&gt;is_slice)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isSlice = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ready to build the SubscriptingRef node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sbsref = makeNode(SubscriptingRef);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sbsref-&gt;refcontainertype = containerType;<br/></li>
<li>&nbsp; &nbsp; sbsref-&gt;refelemtype = elementType;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* refrestype is to be set by container-specific logic */<br/></li>
<li></span>&nbsp; &nbsp; sbsref-&gt;reftypmod = containerTypMod;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* refcollid will be set by parse_collate.c */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Comment">/* refupperindexpr, reflowerindexpr are to be set by container logic */<br/></li>
<li></span>&nbsp; &nbsp; sbsref-&gt;refexpr = (Expr *) containerBase;<br/></li>
<li>&nbsp; &nbsp; sbsref-&gt;refassgnexpr = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* caller will fill if it's an assignment */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Call the container-type-specific logic to transform the subscripts and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * determine the subscripting result type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sbsroutines-&gt;transform(sbsref, indirection, pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; isSlice, isAssignment);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Verify we got a valid type (this defends, for example, against someone<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using <a href="../utils/adt/arraysubs.c.html#L539" title="utils/adt/arraysubs.c:539">array_subscript_handler</a> as typsubscript without setting typelem).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(sbsref-&gt;refrestype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot subscript type </span><span class="Special">%s</span><span class="Constant"> because it does not support subscripting&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(containerType))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> sbsref;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L347" title="parser/parse_node.c:347">make_const</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Convert an A_Const node (as returned by the grammar) to a Const node<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; of the &quot;natural&quot; type for the constant.&nbsp; Note that this routine is<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; only used when there is no explicit cast for the constant, so we<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; have to guess what type is wanted.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For string literals we produce a constant of type UNKNOWN ---- whose<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; representation is the same as cstring, but it indicates to later type<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; resolution that we're not sure yet what type it should be considered.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Explicit &quot;NULL&quot; constants are also typed as UNKNOWN.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; For integers and floats we produce int4, int8, or <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> depending<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; on the value of the number.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> We should produce int2 as well,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; but additional <a href="../regex/regc_nfa.c.html#L2929" title="regex/regc_nfa.c:2929">cleanup</a> is needed <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can do that; there are<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; too many examples that fail if we try.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Const *<br/></li>
<li><a id="L347">&#x200c;</a><span class="linkable">make_const</span>(ParseState *pstate, A_Const *aconst)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *con;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; typebyval;<br/></li>
<li>&nbsp; &nbsp; ParseCallbackState pcbstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (aconst-&gt;isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return a null const */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; con = <a href="../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(UNKNOWNOID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; con-&gt;location = aconst-&gt;location;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> con;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(&amp;aconst-&gt;val))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Integer:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = Int32GetDatum(intVal(&amp;aconst-&gt;val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = INT4OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Float:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* could be an oversize integer as well as a float ... */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int64&nbsp; &nbsp; &nbsp; &nbsp; val64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val64 = <a href="../utils/adt/numutils.c.html#L651" title="utils/adt/numutils.c:651">pg_strtoint64_safe</a>(aconst-&gt;val.fval.fval, (Node *) &amp;escontext);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!escontext.error_occurred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It might actually fit in int32. Probably only INT_MIN<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can occur, but we'll code the test generally just to be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; val32 = (int32) val64;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (val64 == (int64) val32)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = Int32GetDatum(val32);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = INT4OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int32);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = <a href="../utils/fmgr/fmgr.c.html#L1807" title="utils/fmgr/fmgr.c:1807">Int64GetDatum</a>(val64);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = INT8OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(int64);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = FLOAT8PASSBYVAL;&nbsp; &nbsp; <span class="Comment">/* int8 and float8 alike */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arrange to report location if <a href="../utils/adt/numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>() fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, pstate, aconst-&gt;location);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = DirectFunctionCall3(<a href="../utils/adt/numeric.c.html#L628" title="utils/adt/numeric.c:628">numeric_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(aconst-&gt;val.fval.fval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = NUMERICOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = -<span class="Constant">1</span>;&nbsp; &nbsp; <span class="Comment">/* variable len */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Boolean:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = BoolGetDatum(boolVal(&amp;aconst-&gt;val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = BOOLOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_String:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume here that UNKNOWN's <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> representation is the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * same as CSTRING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = CStringGetDatum(strVal(&amp;aconst-&gt;val));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = UNKNOWNOID;&nbsp; &nbsp; <span class="Comment">/* will be coerced later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = -<span class="Constant">2</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cstring-style varwidth type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_BitString:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arrange to report location if <a href="../utils/adt/varbit.c.html#L147" title="utils/adt/varbit.c:147">bit_in</a>() fails */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, pstate, aconst-&gt;location);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = DirectFunctionCall3(<a href="../utils/adt/varbit.c.html#L147" title="utils/adt/varbit.c:147">bit_in</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CStringGetDatum(aconst-&gt;val.bsval.bsval),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(InvalidOid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Int32GetDatum(-<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeid = BITOID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) nodeTag(&amp;aconst-&gt;val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">NULL</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; con = <a href="../nodes/makefuncs.c.html#L301" title="nodes/makefuncs.c:301">makeConst</a>(typeid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>,&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* typmod -1 is OK for all cases */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, <span class="Comment">/* all cases are uncollatable types */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typelen,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typebyval);<br/></li>
<li>&nbsp; &nbsp; con-&gt;location = aconst-&gt;location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> con;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
