<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>parser/scan.l - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>parser/scan.l - pgsql17devel-backend</h1>

  <code><ol><li><span class="Special">%top{<br/></li>
<li></span><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * scan.l<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; lexical scanner for PostgreSQL<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rules in this file must be kept in sync with src/fe_utils/psqlscan.l<br/></li>
<li></span><span class="Comment"> * and src/interfaces/ecpg/preproc/pgc.l!<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The rules are designed so that the scanner never has to backtrack,<br/></li>
<li></span><span class="Comment"> * in the sense that there is always a rule that can match the input<br/></li>
<li></span><span class="Comment"> * consumed so far (the rule action may internally throw back some input<br/></li>
<li></span><span class="Comment"> * with yyless(), however).&nbsp; As explained in the flex manual, this makes<br/></li>
<li></span><span class="Comment"> * for a useful speed increase --- several percent faster when measuring<br/></li>
<li></span><span class="Comment"> * raw parsing (Flex + Bison).&nbsp; The extra complexity is mostly in the rules<br/></li>
<li></span><span class="Comment"> * for handling float numbers and continued string literals.&nbsp; If you change<br/></li>
<li></span><span class="Comment"> * the lexical rules, verify that you haven't broken the no-backtrack<br/></li>
<li></span><span class="Comment"> * property by running flex with the &quot;-b&quot; option and checking that the<br/></li>
<li></span><span class="Comment"> * resulting &quot;lex.backup&quot; file says that no backing up is needed.&nbsp; (As of<br/></li>
<li></span><span class="Comment"> * Postgres 9.2, this check is made automatically by the Makefile.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/parser/scan.l<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;common/string.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;gramparse.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/miscnodes.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parser.h&quot;</span><span class="lexInclude">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* only needed for GUC variables */<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/scansup.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;port/pg_bitutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;mb/pg_wchar.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Special">%{<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* LCOV_EXCL_START */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Avoid exit() on fatal scanner errors (a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> ugly -- see yy_fatal_error) */<br/></li>
<li></span><span class="PreProc">#undef fprintf<br/></li>
<li></span><span class="PreProc">#define fprintf(file, fmt, msg)&nbsp; fprintf_to_ereport(fmt, msg)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">void<br/></li>
<li></span><span class="lexInclude">fprintf_to_ereport(</span><span class="Type">const</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> *fmt, </span><span class="Type">const</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> *msg)<br/></li>
<li></span><span class="lexInclude">{<br/></li>
<li></span><span class="lexInclude">&nbsp; &nbsp; ereport(ERROR, (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(</span><span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span><span class="lexInclude">, msg)));<br/></li>
<li></span><span class="lexInclude">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * GUC variables.&nbsp; This is a DIRECT violation of the warning given at the<br/></li>
<li></span><span class="Comment"> * head of gram.y, ie flex/bison code must not depend on <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> GUC variables;<br/></li>
<li></span><span class="Comment"> * as such, changing their <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> can induce very unintuitive behavior.<br/></li>
<li></span><span class="Comment"> * But we shall have to live with it until we can remove these variables.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int</span><span class="lexInclude">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; backslash_quote = BACKSLASH_QUOTE_SAFE_ENCODING;<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span><span class="lexInclude">&nbsp; &nbsp; &nbsp; &nbsp; escape_string_warning = </span><span class="Constant">true</span><span class="lexInclude">;<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span><span class="lexInclude">&nbsp; &nbsp; &nbsp; &nbsp; standard_conforming_strings = </span><span class="Constant">true</span><span class="lexInclude">;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Constant data exported from this file.&nbsp; This array <a href="../utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c.html#L70" title="utils/mb/conversion_procs/utf8_and_iso8859/utf8_and_iso8859.c:70">maps</a> from the<br/></li>
<li></span><span class="Comment"> * zero-based keyword numbers returned by ScanKeywordLookup to the<br/></li>
<li></span><span class="Comment"> * Bison token numbers needed by gram.y.&nbsp; This is exported because<br/></li>
<li></span><span class="Comment"> * callers need to pass it to scanner_init, if they are using the<br/></li>
<li></span><span class="Comment"> * standard keyword list ScanKeywords.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#define PG_KEYWORD(kwname, value, category, collabel) value,<br/></li>
<li></span><br/></li>
<li><span class="Type">const</span><span class="lexInclude"> uint16 ScanKeywordTokens[] = {<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/kwlist.h&quot;<br/></li>
<li></span><span class="lexInclude">};<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#undef PG_KEYWORD<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the type of YYSTYPE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#define YYSTYPE core_YYSTYPE<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Set the type of yyextra.&nbsp; All state variables used by the scanner should<br/></li>
<li></span><span class="Comment"> * be in yyextra, *not* statically allocated.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#define YY_EXTRA_TYPE core_yy_extra_type *<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Each call to yylex must set yylloc to the location of the found token<br/></li>
<li></span><span class="Comment"> * (expressed as a byte offset from the start of the input text).<br/></li>
<li></span><span class="Comment"> * When we <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> a token that requires multiple lexer rules to process,<br/></li>
<li></span><span class="Comment"> * this should be done in the first such rule, else yylloc will point<br/></li>
<li></span><span class="Comment"> * into the middle of the token.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#define SET_YYLLOC()&nbsp; (*(yylloc) = yytext - yyextra-&gt;scanbuf)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Advance yylloc by the given number of bytes.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#define ADVANCE_YYLLOC(delta)&nbsp; ( *(yylloc) += (delta) )<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Sometimes, we do want yylloc to point into the middle of a token; this is<br/></li>
<li></span><span class="Comment"> * useful for instance to throw an <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> about an escape sequence within a<br/></li>
<li></span><span class="Comment"> * string literal.&nbsp; But if we <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> no <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> there, we want to revert yylloc<br/></li>
<li></span><span class="Comment"> * to the token start, so that that's the location reported to the parser.<br/></li>
<li></span><span class="Comment"> * Use PUSH_YYLLOC/POP_YYLLOC to save/restore yylloc around such code.<br/></li>
<li></span><span class="Comment"> * (Currently the implied &quot;stack&quot; is just one location, but someday we might<br/></li>
<li></span><span class="Comment"> * need to nest these.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#define PUSH_YYLLOC()&nbsp; &nbsp; (yyextra-&gt;save_yylloc = *(yylloc))<br/></li>
<li></span><span class="PreProc">#define POP_YYLLOC()&nbsp; &nbsp; (*(yylloc) = yyextra-&gt;save_yylloc)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#define startlit()&nbsp; &nbsp; ( yyextra-&gt;literallen = </span><span class="Constant">0</span><span class="PreProc"> )<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">void</span><span class="lexInclude"> addlit(</span><span class="Type">char</span><span class="lexInclude"> *ytext, </span><span class="Type">int</span><span class="lexInclude"> yleng, core_yyscan_t yyscanner);<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">void</span><span class="lexInclude"> addlitchar(</span><span class="Type">unsigned</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> ychar, core_yyscan_t yyscanner);<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> *litbufdup(core_yyscan_t yyscanner);<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">unsigned</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> unescape_single_char(</span><span class="Type">unsigned</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> c, core_yyscan_t yyscanner);<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">int</span><span class="lexInclude">&nbsp; &nbsp; process_integer_literal(</span><span class="Type">const</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> *token, YYSTYPE *lval, </span><span class="Type">int</span><span class="lexInclude"> base);<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">void</span><span class="lexInclude"> addunicode(pg_wchar c, yyscan_t yyscanner);<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#define yyerror(msg)&nbsp; scanner_yyerror(msg, yyscanner)<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#define lexer_errposition()&nbsp; scanner_errposition(*(yylloc), yyscanner)<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">void</span><span class="lexInclude"> check_string_escape_warning(</span><span class="Type">unsigned</span><span class="lexInclude"> </span><span class="Type">char</span><span class="lexInclude"> ychar, core_yyscan_t yyscanner);<br/></li>
<li></span><span class="Type">static</span><span class="lexInclude"> </span><span class="Type">void</span><span class="lexInclude"> check_escape_warning(core_yyscan_t yyscanner);<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Work around a bug in flex 2.5.35: it emits a couple of <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that<br/></li>
<li></span><span class="Comment"> * it forgets to emit declarations for.&nbsp; Since we use -Wmissing-prototypes,<br/></li>
<li></span><span class="Comment"> * this would cause warnings.&nbsp; Providing our own declarations should be<br/></li>
<li></span><span class="Comment"> * harmless even when the bug gets fixed.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">extern</span><span class="lexInclude"> </span><span class="Type">int</span><span class="lexInclude">&nbsp; &nbsp; core_yyget_column(yyscan_t yyscanner);<br/></li>
<li></span><span class="Type">extern</span><span class="lexInclude"> </span><span class="Type">void</span><span class="lexInclude"> core_yyset_column(</span><span class="Type">int</span><span class="lexInclude"> column_no, yyscan_t yyscanner);<br/></li>
<li></span><br/></li>
<li><span class="Special">%}<br/></li>
<li></span><br/></li>
<li><span class="PreProc">%option reentrant<br/></li>
<li></span><span class="PreProc">%option bison-bridge<br/></li>
<li></span><span class="PreProc">%option bison-locations<br/></li>
<li></span><span class="PreProc">%option 8bit<br/></li>
<li></span><span class="PreProc">%option never-interactive<br/></li>
<li></span><span class="PreProc">%option nodefault<br/></li>
<li></span><span class="PreProc">%option noinput<br/></li>
<li></span><span class="PreProc">%option nounput<br/></li>
<li></span><span class="PreProc">%option noyywrap<br/></li>
<li></span><span class="PreProc">%option noyyalloc<br/></li>
<li></span><span class="PreProc">%option noyyrealloc<br/></li>
<li></span><span class="PreProc">%option noyyfree<br/></li>
<li></span><span class="PreProc">%option warn<br/></li>
<li></span><span class="PreProc">%option prefix</span><span class="Statement">=</span><span class="Constant">&quot;</span><span class="Identifier">core_yy</span><span class="Constant">&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * OK, here is a short description of lex/flex rules behavior.<br/></li>
<li></span><span class="Comment"> * The <a href="../regex/rege_dfa.c.html#L42" title="regex/rege_dfa.c:42">longest</a> pattern which matches an input string is always chosen.<br/></li>
<li></span><span class="Comment"> * For <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>-length patterns, the first occurring in the rules list is chosen.<br/></li>
<li></span><span class="Comment"> * INITIAL is the starting state, to which all non-conditional rules apply.<br/></li>
<li></span><span class="Comment"> * Exclusive states change parsing rules while the state is active.&nbsp; When in<br/></li>
<li></span><span class="Comment"> * an exclusive state, only those rules defined for that state apply.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We use exclusive states for quoted strings, extended comments,<br/></li>
<li></span><span class="Comment"> * and to eliminate parsing troubles for <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> strings.<br/></li>
<li></span><span class="Comment"> * Exclusive states:<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xb&gt; <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> string literal<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xc&gt; extended C-style comments<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xd&gt; delimited identifiers (double-quoted identifiers)<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xh&gt; hexadecimal byte string<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xq&gt; standard quoted strings<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xqs&gt; quote stop (detect continued strings)<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xe&gt; extended quoted strings (support backslash escape sequences)<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xdolq&gt; $foo$ quoted strings<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xui&gt; quoted identifier with Unicode escapes<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xus&gt; quoted string with Unicode escapes<br/></li>
<li></span><span class="Comment"> *&nbsp; &lt;xeu&gt; Unicode surrogate pair in extended quoted string<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Remember to add an &lt;&lt;EOF&gt;&gt; case whenever you add a new exclusive state!<br/></li>
<li></span><span class="Comment"> * The default one is probably not the right thing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Special">%x</span><span class="Statement"> xb<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xc<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xd<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xh<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xq<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xqs<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xe<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xdolq<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xui<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xus<br/></li>
<li></span><span class="Special">%x</span><span class="Statement"> xeu<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * In order to make the world safe for Windows and Mac clients as well as<br/></li>
<li></span><span class="Comment"> * Unix ones, we <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> either \n or \r as a <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>.&nbsp; A DOS-style \r\n<br/></li>
<li></span><span class="Comment"> * sequence will be seen as two successive newlines, but that doesn't cause<br/></li>
<li></span><span class="Comment"> * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> problems.&nbsp; Comments that start with -- and extend to the <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a><br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> are treated as equivalent to a single whitespace character.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a> a fine point: if there is no <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> following --, we will absorb<br/></li>
<li></span><span class="Comment"> * everything to the end of the input as a comment.&nbsp; This is correct.&nbsp; Older<br/></li>
<li></span><span class="Comment"> * versions of Postgres failed to recognize -- as a comment if the input<br/></li>
<li></span><span class="Comment"> * did not end with a <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * non_newline_space tracks all the other space characters except newlines.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * XXX if you change the set of whitespace characters, fix <a href="scansup.c.html#L117" title="parser/scansup.c:117">scanner_isspace</a>()<br/></li>
<li></span><span class="Comment"> * to agree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Special">space</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier"> \t\n\r\f\v</span><span class="Constant">]<br/></li>
<li></span><span class="Special">non_newline_space</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier"> \t\f\v</span><span class="Constant">]<br/></li>
<li></span><span class="Special"><a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a></span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\n\r</span><span class="Constant">]<br/></li>
<li></span><span class="Special">non_newline</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^\n\r</span><span class="Constant">]<br/></li>
<li></span><br/></li>
<li><span class="Special">comment</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">(</span><span class="Constant">&quot;</span><span class="Identifier">--</span><span class="Constant">&quot;</span><span class="Identifier">{</span><span class="Special">non_newline</span><span class="Identifier">}*)<br/></li>
<li></span><br/></li>
<li><span class="Special">whitespace</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">({</span><span class="Special">space</span><span class="Identifier">}+|{</span><span class="Special">comment</span><span class="Identifier">})<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * SQL requires at least one <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a> in the whitespace separating<br/></li>
<li></span><span class="Comment"> * string literals that are to be concatenated.&nbsp; Silly, but who are we<br/></li>
<li></span><span class="Comment"> * to argue?&nbsp; Note that {whitespace_with_newline} should not have * after<br/></li>
<li></span><span class="Comment"> * it, whereas {whitespace} should generally have a * after it...<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Special">special_whitespace</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">({</span><span class="Special">space</span><span class="Identifier">}+|{</span><span class="Special">comment</span><span class="Identifier">}{</span><span class="Special"><a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a></span><span class="Identifier">})<br/></li>
<li></span><span class="Special">non_newline_whitespace</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">({</span><span class="Special">non_newline_space</span><span class="Identifier">}|{</span><span class="Special">comment</span><span class="Identifier">})<br/></li>
<li></span><span class="Special">whitespace_with_newline</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">({</span><span class="Special">non_newline_whitespace</span><span class="Identifier">}*{</span><span class="Special"><a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a></span><span class="Identifier">}{</span><span class="Special">special_whitespace</span><span class="Identifier">}*)<br/></li>
<li></span><br/></li>
<li><span class="Special">quote</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">'<br/></li>
<li></span><span class="Comment">/* If we see {quote} then {quotecontinue}, the quoted string continues */<br/></li>
<li></span><span class="Special">quotecontinue</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">whitespace_with_newline</span><span class="Identifier">}{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * {quotecontinuefail} is needed to avoid lexer backup when we fail to match<br/></li>
<li></span><span class="Comment"> * {quotecontinue}.&nbsp; It might seem that this could just be {whitespace}*,<br/></li>
<li></span><span class="Comment"> * but if there's a dash after {whitespace_with_newline}, it must be consumed<br/></li>
<li></span><span class="Comment"> * to see if there's another dash --- which would start a {comment} and thus<br/></li>
<li></span><span class="Comment"> * allow continuation of the {quotecontinue} token.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">quotecontinuefail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">whitespace</span><span class="Identifier">}*</span><span class="Constant">&quot;</span><span class="Identifier">-</span><span class="Constant">&quot;</span><span class="Identifier">?<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Bit string<br/></li>
<li></span><span class="Comment"> * It is tempting to scan the string for only those characters<br/></li>
<li></span><span class="Comment"> * which are allowed. However, this leads to silently swallowed<br/></li>
<li></span><span class="Comment"> * characters if illegal characters are included in the string.<br/></li>
<li></span><span class="Comment"> * For example, if xbinside is [01] then B'ABCD' is interpreted<br/></li>
<li></span><span class="Comment"> * as a zero-length string, and the ABCD' is lost!<br/></li>
<li></span><span class="Comment"> * Better to pass the string forward and let the input routines<br/></li>
<li></span><span class="Comment"> * validate the contents.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">xbstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">bB</span><span class="Constant">]</span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xbinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^'</span><span class="Constant">]</span><span class="Identifier">*<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Hexadecimal byte string */<br/></li>
<li></span><span class="Special">xhstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">xX</span><span class="Constant">]</span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xhinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^'</span><span class="Constant">]</span><span class="Identifier">*<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* National character */<br/></li>
<li></span><span class="Special">xnstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">nN</span><span class="Constant">]</span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Quoted string that allows backslash escapes */<br/></li>
<li></span><span class="Special">xestart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">eE</span><span class="Constant">]</span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xeinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^\\'</span><span class="Constant">]</span><span class="Identifier">+<br/></li>
<li></span><span class="Special">xeescape</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\\</span><span class="Constant">][</span><span class="Identifier">^0-7</span><span class="Constant">]<br/></li>
<li></span><span class="Special">xeoctesc</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\\</span><span class="Constant">][</span><span class="Identifier">0-7</span><span class="Constant">]</span><span class="Identifier">{1,3}<br/></li>
<li></span><span class="Special">xehexesc</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\\</span><span class="Constant">]</span><span class="Identifier">x</span><span class="Constant">[</span><span class="Identifier">0-9A-Fa-f</span><span class="Constant">]</span><span class="Identifier">{1,2}<br/></li>
<li></span><span class="Special">xeunicode</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\\</span><span class="Constant">]</span><span class="Identifier">(u</span><span class="Constant">[</span><span class="Identifier">0-9A-Fa-f</span><span class="Constant">]</span><span class="Identifier">{4}|U</span><span class="Constant">[</span><span class="Identifier">0-9A-Fa-f</span><span class="Constant">]</span><span class="Identifier">{8})<br/></li>
<li></span><span class="Special">xeunicodefail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\\</span><span class="Constant">]</span><span class="Identifier">(u</span><span class="Constant">[</span><span class="Identifier">0-9A-Fa-f</span><span class="Constant">]</span><span class="Identifier">{0,3}|U</span><span class="Constant">[</span><span class="Identifier">0-9A-Fa-f</span><span class="Constant">]</span><span class="Identifier">{0,7})<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Extended quote<br/></li>
<li></span><span class="Comment"> * xqdouble implements embedded quote, ''''<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">xqstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xqdouble</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xqinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^'</span><span class="Constant">]</span><span class="Identifier">+<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* $foo$ style quotes (&quot;dollar quoting&quot;)<br/></li>
<li></span><span class="Comment"> * The quoted string starts with $foo$ where &quot;foo&quot; is an optional string<br/></li>
<li></span><span class="Comment"> * in the form of an identifier, except that it may not contain &quot;$&quot;,<br/></li>
<li></span><span class="Comment"> * and extends to the first occurrence of an identical string.<br/></li>
<li></span><span class="Comment"> * There is *no* processing of the quoted text.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * {dolqfailed} is an <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> rule to avoid scanner backup when {dolqdelim}<br/></li>
<li></span><span class="Comment"> * fails to match its trailing &quot;$&quot;.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">dolq_start</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">A-Za-z\200-\377_</span><span class="Constant">]<br/></li>
<li></span><span class="Special">dolq_cont</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">A-Za-z\200-\377_0-9</span><span class="Constant">]<br/></li>
<li></span><span class="Special">dolqdelim</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\$({</span><span class="Special">dolq_start</span><span class="Identifier">}{</span><span class="Special">dolq_cont</span><span class="Identifier">}*)?\$<br/></li>
<li></span><span class="Special">dolqfailed</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\${</span><span class="Special">dolq_start</span><span class="Identifier">}{</span><span class="Special">dolq_cont</span><span class="Identifier">}*<br/></li>
<li></span><span class="Special">dolqinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^$</span><span class="Constant">]</span><span class="Identifier">+<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Double quote<br/></li>
<li></span><span class="Comment"> * Allows embedded spaces and other special characters into identifiers.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">dquote</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\&quot;<br/></li>
<li></span><span class="Special">xdstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">dquote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xdstop</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">dquote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xddouble</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">dquote</span><span class="Identifier">}{</span><span class="Special">dquote</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">xdinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^&quot;</span><span class="Constant">]</span><span class="Identifier">+<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Quoted identifier with Unicode escapes */<br/></li>
<li></span><span class="Special">xuistart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">uU</span><span class="Constant">]</span><span class="Identifier">&amp;{</span><span class="Special">dquote</span><span class="Identifier">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Quoted string with Unicode escapes */<br/></li>
<li></span><span class="Special">xusstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">uU</span><span class="Constant">]</span><span class="Identifier">&amp;{</span><span class="Special">quote</span><span class="Identifier">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> rule to avoid backup */<br/></li>
<li></span><span class="Special">xufailed</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">uU</span><span class="Constant">]</span><span class="Identifier">&amp;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* C-style comments<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The &quot;extended comment&quot; syntax closely resembles allowable operator syntax.<br/></li>
<li></span><span class="Comment"> * The tricky part here is to get lex to recognize a string starting with<br/></li>
<li></span><span class="Comment"> * slash-star as a comment, when interpreting it as an operator would produce<br/></li>
<li></span><span class="Comment"> * a longer match --- remember lex will prefer a longer match!&nbsp; Also, if we<br/></li>
<li></span><span class="Comment"> * have something like plus-slash-star, lex will think this is a 3-character<br/></li>
<li></span><span class="Comment"> * operator whereas we want to see it as a + operator and a comment start.<br/></li>
<li></span><span class="Comment"> * The solution is two-fold:<br/></li>
<li></span><span class="Comment"> * 1. append {op_chars}* to xcstart so that it matches as much text as<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; {operator} would. Then the tie-breaker (first matching rule of same<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; length) ensures xcstart wins.&nbsp; We put back the extra stuff with yyless()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; in case it contains a star-slash that should terminate the comment.<br/></li>
<li></span><span class="Comment"> * 2. In the operator rule, check for slash-star within the operator, and<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; if found throw it back with yyless().&nbsp; This handles the plus-slash-star<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; problem.<br/></li>
<li></span><span class="Comment"> * Dash-dash comments have similar interactions with the operator rule.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">xcstart</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\/\*{</span><span class="Special">op_chars</span><span class="Identifier">}*<br/></li>
<li></span><span class="Special">xcstop</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\*+\/<br/></li>
<li></span><span class="Special">xcinside</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">^*/</span><span class="Constant">]</span><span class="Identifier">+<br/></li>
<li></span><br/></li>
<li><span class="Special">ident_start</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">A-Za-z\200-\377_</span><span class="Constant">]<br/></li>
<li></span><span class="Special">ident_cont</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">A-Za-z\200-\377_0-9\$</span><span class="Constant">]<br/></li>
<li></span><br/></li>
<li><span class="Special">identifier</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">ident_start</span><span class="Identifier">}{</span><span class="Special">ident_cont</span><span class="Identifier">}*<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Assorted special-case operators and operator-like tokens */<br/></li>
<li></span><span class="Special">typecast</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">::</span><span class="Constant">&quot;<br/></li>
<li></span><span class="Special">dot_dot</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\.\.<br/></li>
<li></span><span class="Special">colon_equals</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">:=</span><span class="Constant">&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * These operator-like tokens (unlike the above ones) also match the {operator}<br/></li>
<li></span><span class="Comment"> * rule, which means that they might be overridden by a longer match if they<br/></li>
<li></span><span class="Comment"> * are followed by a comment start or a + or - character. Accordingly, if you<br/></li>
<li></span><span class="Comment"> * add to this list, you must also add corresponding code to the {operator}<br/></li>
<li></span><span class="Comment"> * block to return the correct token in such cases. (This is not needed in<br/></li>
<li></span><span class="Comment"> * psqlscan.l since the token value is ignored there.)<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">equals_greater</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">=&gt;</span><span class="Constant">&quot;<br/></li>
<li></span><span class="Special">less_equals</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">&lt;=</span><span class="Constant">&quot;<br/></li>
<li></span><span class="Special">greater_equals</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">&gt;=</span><span class="Constant">&quot;<br/></li>
<li></span><span class="Special">less_greater</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">&lt;&gt;</span><span class="Constant">&quot;<br/></li>
<li></span><span class="Special">not_equals</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">&quot;</span><span class="Identifier">!=</span><span class="Constant">&quot;<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * &quot;self&quot; is the set of chars that should be returned as single-character<br/></li>
<li></span><span class="Comment"> * tokens.&nbsp; &quot;op_chars&quot; is the set of chars that can make up &quot;Op&quot; tokens,<br/></li>
<li></span><span class="Comment"> * which can be one or more characters long (but if a single-char token<br/></li>
<li></span><span class="Comment"> * appears in the &quot;self&quot; set, it is not to be returned as an Op).&nbsp; Note<br/></li>
<li></span><span class="Comment"> * that the sets overlap, but each has some chars that are not in the other.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If you change either set, adjust the character lists appearing in the<br/></li>
<li></span><span class="Comment"> * rule for &quot;operator&quot;!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">self</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">,()\[\].;\:\+\-\*\/\%\^\&lt;\&gt;\=</span><span class="Constant">]<br/></li>
<li></span><span class="Special">op_chars</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">\~\!\@\#\^\&amp;\|\`\?\+\-\*\/\%\&lt;\&gt;\=</span><span class="Constant">]<br/></li>
<li></span><span class="Special">operator</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">op_chars</span><span class="Identifier">}+<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Numbers<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unary minus is not part of a number here.&nbsp; Instead we pass it separately to<br/></li>
<li></span><span class="Comment"> * the parser, and there it gets coerced via doNegate().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * {numericfail} is used because we would like &quot;1..10&quot; to lex as 1, dot_dot, 10.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * {realfail} is added to prevent the need for scanner<br/></li>
<li></span><span class="Comment"> * backup when the {real} rule fails to match completely.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Special">decdigit</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">0-9</span><span class="Constant">]<br/></li>
<li></span><span class="Special">hexdigit</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">0-9A-Fa-f</span><span class="Constant">]<br/></li>
<li></span><span class="Special">octdigit</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">0-7</span><span class="Constant">]<br/></li>
<li></span><span class="Special">bindigit</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">[</span><span class="Identifier">0-1</span><span class="Constant">]<br/></li>
<li></span><br/></li>
<li><span class="Special">decinteger</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">decdigit</span><span class="Identifier">}(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?{</span><span class="Special">decdigit</span><span class="Identifier">})*<br/></li>
<li></span><span class="Special">hexinteger</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">0</span><span class="Constant">[</span><span class="Identifier">xX</span><span class="Constant">]</span><span class="Identifier">(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?{</span><span class="Special">hexdigit</span><span class="Identifier">})+<br/></li>
<li></span><span class="Special">octinteger</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">0</span><span class="Constant">[</span><span class="Identifier">oO</span><span class="Constant">]</span><span class="Identifier">(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?{</span><span class="Special">octdigit</span><span class="Identifier">})+<br/></li>
<li></span><span class="Special">bininteger</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">0</span><span class="Constant">[</span><span class="Identifier">bB</span><span class="Constant">]</span><span class="Identifier">(<a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?{</span><span class="Special">bindigit</span><span class="Identifier">})+<br/></li>
<li></span><br/></li>
<li><span class="Special">hexfail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">0</span><span class="Constant">[</span><span class="Identifier">xX</span><span class="Constant">]</span><span class="Identifier"><a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?<br/></li>
<li></span><span class="Special">octfail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">0</span><span class="Constant">[</span><span class="Identifier">oO</span><span class="Constant">]</span><span class="Identifier"><a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?<br/></li>
<li></span><span class="Special">binfail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">0</span><span class="Constant">[</span><span class="Identifier">bB</span><span class="Constant">]</span><span class="Identifier"><a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>?<br/></li>
<li></span><br/></li>
<li><span class="Special"><a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">(({</span><span class="Special">decinteger</span><span class="Identifier">}\.{</span><span class="Special">decinteger</span><span class="Identifier">}?)|(\.{</span><span class="Special">decinteger</span><span class="Identifier">}))<br/></li>
<li></span><span class="Special">numericfail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">decdigit</span><span class="Identifier">}+\.\.<br/></li>
<li></span><br/></li>
<li><span class="Special">real</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">({</span><span class="Special">decinteger</span><span class="Identifier">}|{</span><span class="Special"><a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Identifier">})</span><span class="Constant">[</span><span class="Identifier">Ee</span><span class="Constant">][</span><span class="Identifier">-+</span><span class="Constant">]</span><span class="Identifier">?{</span><span class="Special">decinteger</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">realfail</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">({</span><span class="Special">decinteger</span><span class="Identifier">}|{</span><span class="Special"><a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Identifier">})</span><span class="Constant">[</span><span class="Identifier">Ee</span><span class="Constant">][</span><span class="Identifier">-+</span><span class="Constant">]<br/></li>
<li></span><br/></li>
<li><span class="Special">decinteger_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">decinteger</span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">hexinteger_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">hexinteger</span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">octinteger_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">octinteger</span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">bininteger_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">bininteger</span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">numeric_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special"><a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">real_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">{</span><span class="Special">real</span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><br/></li>
<li><span class="Special">param</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\${</span><span class="Special">decinteger</span><span class="Identifier">}<br/></li>
<li></span><span class="Special">param_junk</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">\${</span><span class="Special">decinteger</span><span class="Identifier">}{</span><span class="Special">ident_start</span><span class="Identifier">}<br/></li>
<li></span><br/></li>
<li><span class="Special">other</span><span class="lexAbbrvBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Identifier">.<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Dollar quoted strings are totally opaque, and no escaping is done on them.<br/></li>
<li></span><span class="Comment"> * Other quoted strings must allow some special characters such as single-quote<br/></li>
<li></span><span class="Comment"> *&nbsp; and <a href="../regex/regc_lex.c.html#L1010" title="regex/regc_lex.c:1010">newline</a>.<br/></li>
<li></span><span class="Comment"> * Embedded single-quotes are implemented both in the SQL standard<br/></li>
<li></span><span class="Comment"> *&nbsp; style of two adjacent single quotes &quot;''&quot; and in the Postgres/Java style<br/></li>
<li></span><span class="Comment"> *&nbsp; of escaped-quote &quot;\'&quot;.<br/></li>
<li></span><span class="Comment"> * Other embedded escaped characters are matched explicitly and the leading<br/></li>
<li></span><span class="Comment"> *&nbsp; backslash is dropped from the string.<br/></li>
<li></span><span class="Comment"> * Note that xcstart must appear <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> operator, as explained above!<br/></li>
<li></span><span class="Comment"> *&nbsp; Also whitespace (comment) must appear <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> operator.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Todo">%%<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">whitespace</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ignore */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xcstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Set location in case of syntax <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> in comment */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;xcdepth = </span><span class="Constant">0</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xc);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Put back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> characters past slash-star; see above */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(</span><span class="Constant">2</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Statement">&lt;xc&gt;{<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">xcstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (yyextra-&gt;xcdepth)++;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Put back <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> characters past slash-star; see above */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(</span><span class="Constant">2</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xcstop</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;xcdepth &lt;= </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(INITIAL);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (yyextra-&gt;xcdepth)--;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xcinside</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ignore */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">op_chars</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ignore */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">\*+</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ignore */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;unterminated /* comment&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">}</span><span class="lexPatSep"> </span><span class="Comment">/* &lt;xc&gt; */<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xbstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Binary <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At some point we should simply pass the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forward to the parser and label it there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the meantime, place a leading &quot;b&quot; on the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to mark it for the input routine as a binary string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xb);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(</span><span class="Constant">'b'</span><span class="lexPatCode">, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xh&gt;</span><span class="Identifier">{</span><span class="Special">xhinside</span><span class="Identifier">}&nbsp; &nbsp; |<br/></li>
<li></span><span class="Statement">&lt;xb&gt;</span><span class="Identifier">{</span><span class="Special">xbinside</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xb&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{</span><span class="lexPatCode"> yyerror(</span><span class="Constant">&quot;unterminated <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> string literal&quot;</span><span class="lexPatCode">); </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xhstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Hexadecimal <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At some point we should simply pass the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * forward to the parser and label it there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the meantime, place a leading &quot;x&quot; on the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to mark it for the input routine as a hex string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xh);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(</span><span class="Constant">'x'</span><span class="lexPatCode">, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xh&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{</span><span class="lexPatCode"> yyerror(</span><span class="Constant">&quot;unterminated hexadecimal string literal&quot;</span><span class="lexPatCode">); </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xnstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* National character.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We will pass this along as a normal character string,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but preceded with an internally-generated &quot;NCHAR&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; kwnum;<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(</span><span class="Constant">1</span><span class="lexPatCode">);&nbsp; &nbsp; </span><span class="Comment">/* eat only 'n' this time */<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kwnum = ScanKeywordLookup(</span><span class="Constant">&quot;nchar&quot;</span><span class="lexPatCode">,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;keywordlist);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (kwnum &gt;= </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;keyword = GetScanKeyword(kwnum,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; yyextra-&gt;keywordlist);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> yyextra-&gt;keyword_tokens[kwnum];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* If NCHAR isn't a keyword, just return &quot;n&quot; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(</span><span class="Constant">&quot;n&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> IDENT;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xqstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;warn_on_first_escape = </span><span class="Constant">true</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;saw_non_ascii = </span><span class="Constant">false</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;standard_conforming_strings)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xq);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xe);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">xestart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;warn_on_first_escape = </span><span class="Constant">false</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;saw_non_ascii = </span><span class="Constant">false</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xe);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">xusstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (!yyextra-&gt;standard_conforming_strings)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;unsafe use of string constant with Unicode escapes&quot;</span><span class="lexPatCode">),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(</span><span class="Constant">&quot;String constants with Unicode escapes cannot be used when standard_conforming_strings is off.&quot;</span><span class="lexPatCode">),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xus);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Statement">&lt;xb,xh,xq,xe,xus&gt;</span><span class="Identifier">{</span><span class="Special">quote</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we are scanning a quoted string and see an end<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * quote, we must look ahead for a possible continuation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we don't see one, we know the end quote was in fact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the end of the string.&nbsp; To reduce the lexer table size,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we use a single &quot;xqs&quot; state to do the lookahead for all<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types of strings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;state_before_str_stop = YYSTATE;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xqs);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xqs&gt;</span><span class="Identifier">{</span><span class="Special">quotecontinue</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Found a quote continuation, so return to the in-quote<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * state and continue scanning the literal.&nbsp; Nothing is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * added to the literal's contents.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(yyextra-&gt;state_before_str_stop);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xqs&gt;</span><span class="Identifier">{</span><span class="Special">quotecontinuefail</span><span class="Identifier">} |<br/></li>
<li></span><span class="Statement">&lt;xqs&gt;</span><span class="Identifier">{</span><span class="Special">other</span><span class="Identifier">} |<br/></li>
<li></span><span class="Statement">&lt;xqs&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Failed to see a quote continuation.&nbsp; Throw back<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * everything after the end quote, and handle the string<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * according to the state we were in previously.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(</span><span class="Constant">0</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(INITIAL);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">switch</span><span class="lexPatCode"> (yyextra-&gt;state_before_str_stop)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexPatCode"> xb:<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> BCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexPatCode"> xh:<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> XCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexPatCode"> xq:<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexPatCode"> xe:<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check that the data remains valid, if it might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have been made invalid by unescaping <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> chars.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;saw_non_ascii)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mb/mbutils.c.html#L1556" title="utils/mb/mbutils.c:1556">pg_verifymbstr</a>(yyextra-&gt;literalbuf,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; yyextra-&gt;literallen,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Constant">false</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> SCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexPatCode"> xus:<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> USCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">default</span><span class="lexPatCode">:<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;unhandled previous state in xqs&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Statement">&lt;xq,xe,xus&gt;</span><span class="Identifier">{</span><span class="Special">xqdouble</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(</span><span class="Special">'\''</span><span class="lexPatCode">, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xq,xus&gt;</span><span class="Identifier">{</span><span class="Special">xqinside</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe&gt;</span><span class="Identifier">{</span><span class="Special">xeinside</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe&gt;</span><span class="Identifier">{</span><span class="Special">xeunicode</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; c = strtoul(yytext + </span><span class="Constant">2</span><span class="lexPatCode">, </span><span class="Constant">NULL</span><span class="lexPatCode">, </span><span class="Constant">16</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For consistency with other productions, issue <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * escape warning with cursor pointing to start of string.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We might want to change that, someday.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_escape_warning(yyscanner);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Remember start of overall string token ... */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ... and set the <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> cursor to point at this esc seq */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (is_utf16_surrogate_first(c))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;utf16_first_part = c;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xeu);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="lexPatCode"> </span><span class="Statement">if</span><span class="lexPatCode"> (is_utf16_surrogate_second(c))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid Unicode surrogate pair&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addunicode(c, yyscanner);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Restore yylloc to be start of string token */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xeu&gt;</span><span class="Identifier">{</span><span class="Special">xeunicode</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pg_wchar&nbsp; &nbsp; c = strtoul(yytext + </span><span class="Constant">2</span><span class="lexPatCode">, </span><span class="Constant">NULL</span><span class="lexPatCode">, </span><span class="Constant">16</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Remember start of overall string token ... */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PUSH_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* ... and set the <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> cursor to point at this esc seq */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (!is_utf16_surrogate_second(c))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid Unicode surrogate pair&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c = surrogate_pair_to_codepoint(yyextra-&gt;utf16_first_part, c);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addunicode(c, yyscanner);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Restore yylloc to be start of string token */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; POP_YYLLOC();<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xe);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xeu&gt;</span><span class="Identifier">. |<br/></li>
<li></span><span class="Statement">&lt;xeu&gt;</span><span class="Identifier">\n |<br/></li>
<li></span><span class="Statement">&lt;xeu&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Set the <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> cursor to point at missing esc seq */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid Unicode surrogate pair&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe,xeu&gt;</span><span class="Identifier">{</span><span class="Special">xeunicodefail</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Set the <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> cursor to point at malformed esc seq */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_ESCAPE_SEQUENCE),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;invalid Unicode escape&quot;</span><span class="lexPatCode">),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(</span><span class="Constant">&quot;Unicode escapes must be </span><span class="Special">\\</span><span class="Constant">uXXXX or </span><span class="Special">\\</span><span class="Constant">UXXXXXXXX.&quot;</span><span class="lexPatCode">),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe&gt;</span><span class="Identifier">{</span><span class="Special">xeescape</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yytext[</span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Special">'\''</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;backslash_quote == BACKSLASH_QUOTE_OFF ||<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (yyextra-&gt;backslash_quote == BACKSLASH_QUOTE_SAFE_ENCODING &amp;&amp;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PG_ENCODING_IS_CLIENT_ONLY(<a href="../utils/mb/mbutils.c.html#L336" title="utils/mb/mbutils.c:336">pg_get_client_encoding</a>())))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NONSTANDARD_USE_OF_ESCAPE_CHARACTER),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;unsafe use of </span><span class="Special">\\</span><span class="Constant">' in a string literal&quot;</span><span class="lexPatCode">),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(</span><span class="Constant">&quot;Use '' to write quotes in strings. </span><span class="Special">\\</span><span class="Constant">' is insecure in client-only encodings.&quot;</span><span class="lexPatCode">),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_string_escape_warning(yytext[</span><span class="Constant">1</span><span class="lexPatCode">], yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(unescape_single_char(yytext[</span><span class="Constant">1</span><span class="lexPatCode">], yyscanner),<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe&gt;</span><span class="Identifier">{</span><span class="Special">xeoctesc</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">unsigned</span><span class="lexPatCode"> </span><span class="Type">char</span><span class="lexPatCode"> c = strtoul(yytext + </span><span class="Constant">1</span><span class="lexPatCode">, </span><span class="Constant">NULL</span><span class="lexPatCode">, </span><span class="Constant">8</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_escape_warning(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(c, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (c == </span><span class="Special">'\0'</span><span class="lexPatCode"> || IS_HIGHBIT_SET(c))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;saw_non_ascii = </span><span class="Constant">true</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe&gt;</span><span class="Identifier">{</span><span class="Special">xehexesc</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">unsigned</span><span class="lexPatCode"> </span><span class="Type">char</span><span class="lexPatCode"> c = strtoul(yytext + </span><span class="Constant">2</span><span class="lexPatCode">, </span><span class="Constant">NULL</span><span class="lexPatCode">, </span><span class="Constant">16</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; check_escape_warning(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(c, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (c == </span><span class="Special">'\0'</span><span class="lexPatCode"> || IS_HIGHBIT_SET(c))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;saw_non_ascii = </span><span class="Constant">true</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xe&gt;</span><span class="Identifier">.</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* This is only needed for \ just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> EOF */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(yytext[</span><span class="Constant">0</span><span class="lexPatCode">], yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xq,xe,xus&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{</span><span class="lexPatCode"> yyerror(</span><span class="Constant">&quot;unterminated quoted string&quot;</span><span class="lexPatCode">); </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">dolqdelim</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;dolqstart = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(yytext);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xdolq);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">dolqfailed</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* throw back all but the initial &quot;$&quot; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(</span><span class="Constant">1</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* and treat it as {other} */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> </span><span class="PreProc">yytext</span><span class="lexPatCode">[</span><span class="Constant">0</span><span class="lexPatCode">];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xdolq&gt;</span><span class="Identifier">{</span><span class="Special">dolqdelim</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (strcmp(yytext, yyextra-&gt;dolqstart) == </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(yyextra-&gt;dolqstart);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;dolqstart = </span><span class="Constant">NULL</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(INITIAL);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> SCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * When we fail to match $...$ to dolqstart, transfer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the $... part to the output, but put back the final<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * $ for rescanning.&nbsp; Consider $delim$...$junk$delim$<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng - </span><span class="Constant">1</span><span class="lexPatCode">, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(yyleng - </span><span class="Constant">1</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xdolq&gt;</span><span class="Identifier">{</span><span class="Special">dolqinside</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xdolq&gt;</span><span class="Identifier">{</span><span class="Special">dolqfailed</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xdolq&gt;</span><span class="Identifier">.</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* This is only needed for $ inside the quoted text */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(yytext[</span><span class="Constant">0</span><span class="lexPatCode">], yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xdolq&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{</span><span class="lexPatCode"> yyerror(</span><span class="Constant">&quot;unterminated dollar-quoted string&quot;</span><span class="lexPatCode">); </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xdstart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xd);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">xuistart</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(xui);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; startlit();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xd&gt;</span><span class="Identifier">{</span><span class="Special">xdstop</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">char</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp;&nbsp; *ident;<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(INITIAL);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;literallen == </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;zero-length delimited identifier&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;literallen &gt;= NAMEDATALEN)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="scansup.c.html#L93" title="parser/scansup.c:93">truncate_identifier</a>(ident, yyextra-&gt;literallen, </span><span class="Constant">true</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = ident;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> IDENT;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xui&gt;</span><span class="Identifier">{</span><span class="Special">dquote</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">BEGIN</span><span class="lexPatCode">(INITIAL);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yyextra-&gt;literallen == </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;zero-length delimited identifier&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* can't truncate till after we de-escape the ident */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = litbufdup(yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> UIDENT;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xd,xui&gt;</span><span class="Identifier">{</span><span class="Special">xddouble</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlitchar(</span><span class="Constant">'&quot;'</span><span class="lexPatCode">, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xd,xui&gt;</span><span class="Identifier">{</span><span class="Special">xdinside</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addlit(yytext, yyleng, yyscanner);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Statement">&lt;xd,xui&gt;</span><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{</span><span class="lexPatCode"> yyerror(</span><span class="Constant">&quot;unterminated quoted identifier&quot;</span><span class="lexPatCode">); </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">xufailed</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">char</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp;&nbsp; *ident;<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* throw back all but the initial u/U */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(</span><span class="Constant">1</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* and treat it as {identifier} */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident = <a href="scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(yytext, yyleng, </span><span class="Constant">true</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = ident;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> IDENT;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">typecast</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> TYPECAST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">dot_dot</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> DOT_DOT;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">colon_equals</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> COLON_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">equals_greater</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> EQUALS_GREATER;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">less_equals</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> LESS_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">greater_equals</span><span class="Identifier">}</span><span class="lexPatSep"> </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> GREATER_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">less_greater</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* We <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> both &quot;&lt;&gt;&quot; and &quot;!=&quot; as meaning NOT_EQUALS */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> NOT_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">not_equals</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* We <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> both &quot;&lt;&gt;&quot; and &quot;!=&quot; as meaning NOT_EQUALS */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> NOT_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">self</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> </span><span class="PreProc">yytext</span><span class="lexPatCode">[</span><span class="Constant">0</span><span class="lexPatCode">];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">operator</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for embedded slash-star or dash-dash; those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are comment starts, so operator must stop there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that slash-star or dash-dash at the first<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * character will match a prior rule, not this one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchars = </span><span class="PreProc">yyleng</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">char</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp;&nbsp; *slashstar = strstr(yytext, </span><span class="Constant">&quot;/*&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">char</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp;&nbsp; *dashdash = strstr(yytext, </span><span class="Constant">&quot;--&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (slashstar &amp;&amp; dashdash)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* if both appear, take the first one */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (slashstar &gt; dashdash)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slashstar = dashdash;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">else</span><span class="lexPatCode"> </span><span class="Statement">if</span><span class="lexPatCode"> (!slashstar)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; slashstar = dashdash;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (slashstar)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchars = slashstar - </span><span class="PreProc">yytext</span><span class="lexPatCode">;<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For SQL compatibility, '+' and '-' cannot be the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * last char of a multi-char operator unless the operator<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains chars that are not in SQL operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The idea is to lex '=-' as two operators, but not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to forbid operator names like '?-' that could not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sequences of SQL operators.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (nchars &gt; </span><span class="Constant">1</span><span class="lexPatCode"> &amp;&amp;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (yytext[nchars - </span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'+'</span><span class="lexPatCode"> ||<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; yytext[nchars - </span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'-'</span><span class="lexPatCode">))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ic;<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">for</span><span class="lexPatCode"> (ic = nchars - </span><span class="Constant">2</span><span class="lexPatCode">; ic &gt;= </span><span class="Constant">0</span><span class="lexPatCode">; ic--)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">char</span><span class="lexPatCode"> c = </span><span class="PreProc">yytext</span><span class="lexPatCode">[ic];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (c == </span><span class="Constant">'~'</span><span class="lexPatCode"> || c == </span><span class="Constant">'!'</span><span class="lexPatCode"> || c == </span><span class="Constant">'@'</span><span class="lexPatCode"> ||<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c == </span><span class="Constant">'#'</span><span class="lexPatCode"> || c == </span><span class="Constant">'^'</span><span class="lexPatCode"> || c == </span><span class="Constant">'&amp;'</span><span class="lexPatCode"> ||<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c == </span><span class="Constant">'|'</span><span class="lexPatCode"> || c == </span><span class="Constant">'`'</span><span class="lexPatCode"> || c == </span><span class="Constant">'?'</span><span class="lexPatCode"> ||<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c == </span><span class="Constant">'%'</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">break</span><span class="lexPatCode">;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (ic &lt; </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * didn't <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a qualifying character, so remove<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all trailing [+-]<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">do</span><span class="lexPatCode"> {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nchars--;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } </span><span class="Statement">while</span><span class="lexPatCode"> (nchars &gt; </span><span class="Constant">1</span><span class="lexPatCode"> &amp;&amp;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (yytext[nchars - </span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'+'</span><span class="lexPatCode"> ||<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yytext[nchars - </span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'-'</span><span class="lexPatCode">));<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (nchars &lt; yyleng)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Strip the unwanted chars from the token */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(nchars);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If what we have left is only one char, and it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one of the characters matching &quot;self&quot;, then<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * return it as a character token the same way<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that the &quot;self&quot; rule would have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (nchars == </span><span class="Constant">1</span><span class="lexPatCode"> &amp;&amp;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strchr(</span><span class="Constant">&quot;,()[].;:+-*/%^&lt;&gt;=&quot;</span><span class="lexPatCode">, yytext[</span><span class="Constant">0</span><span class="lexPatCode">]))<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> </span><span class="PreProc">yytext</span><span class="lexPatCode">[</span><span class="Constant">0</span><span class="lexPatCode">];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Likewise, if what we have left is two chars, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those match the tokens &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;=&gt;&quot;, &quot;&lt;&gt;&quot; or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;!=&quot;, then we must return the appropriate token<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than the generic Op.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (nchars == </span><span class="Constant">2</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yytext[</span><span class="Constant">0</span><span class="lexPatCode">] == </span><span class="Constant">'='</span><span class="lexPatCode"> &amp;&amp; yytext[</span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'&gt;'</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> EQUALS_GREATER;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yytext[</span><span class="Constant">0</span><span class="lexPatCode">] == </span><span class="Constant">'&gt;'</span><span class="lexPatCode"> &amp;&amp; yytext[</span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'='</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> GREATER_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yytext[</span><span class="Constant">0</span><span class="lexPatCode">] == </span><span class="Constant">'&lt;'</span><span class="lexPatCode"> &amp;&amp; yytext[</span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'='</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> LESS_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yytext[</span><span class="Constant">0</span><span class="lexPatCode">] == </span><span class="Constant">'&lt;'</span><span class="lexPatCode"> &amp;&amp; yytext[</span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'&gt;'</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> NOT_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (yytext[</span><span class="Constant">0</span><span class="lexPatCode">] == </span><span class="Constant">'!'</span><span class="lexPatCode"> &amp;&amp; yytext[</span><span class="Constant">1</span><span class="lexPatCode">] == </span><span class="Constant">'='</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> NOT_EQUALS;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Complain if operator is too long.&nbsp; Unlike the case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for identifiers, we make this an <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> not a notice-<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and-truncate, because the odds are we are looking at<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a syntactic mistake anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (nchars &gt;= NAMEDATALEN)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;operator too long&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(yytext);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> Op;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">param</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;ival = atol(yytext + </span><span class="Constant">1</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> PARAM;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">param_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after parameter&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">decinteger</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> process_integer_literal(yytext, yylval, </span><span class="Constant">10</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">hexinteger</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> process_integer_literal(yytext, yylval, </span><span class="Constant">16</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">octinteger</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> process_integer_literal(yytext, yylval, </span><span class="Constant">8</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">bininteger</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> process_integer_literal(yytext, yylval, </span><span class="Constant">2</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">hexfail</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid hexadecimal integer&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">octfail</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid octal integer&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">binfail</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid binary integer&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special"><a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a></span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(yytext);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> FCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">numericfail</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* throw back the .., and treat as integer */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyless</span><span class="lexPatCode">(yyleng - </span><span class="Constant">2</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> process_integer_literal(yytext, yylval, </span><span class="Constant">10</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">real</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(yytext);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> FCONST;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">realfail</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">decinteger_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">hexinteger_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">octinteger_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">bininteger_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">numeric_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><span class="Identifier">{</span><span class="Special">real_junk</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;trailing junk after <a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a> literal&quot;</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Identifier">{</span><span class="Special">identifier</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">int</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kwnum;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Type">char</span><span class="lexPatCode">&nbsp; &nbsp; &nbsp;&nbsp; *ident;<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* Is it a keyword? */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kwnum = ScanKeywordLookup(yytext,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;keywordlist);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexPatCode"> (kwnum &gt;= </span><span class="Constant">0</span><span class="lexPatCode">)<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;keyword = GetScanKeyword(kwnum,<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; yyextra-&gt;keywordlist);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> yyextra-&gt;keyword_tokens[kwnum];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li></span><br/></li>
<li><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * No.&nbsp; Convert the identifier to <a href="../utils/adt/oracle_compat.c.html#L49" title="utils/adt/oracle_compat.c:49">lower</a> case, and truncate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if necessary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ident = <a href="scansup.c.html#L37" title="parser/scansup.c:37">downcase_truncate_identifier</a>(yytext, yyleng, </span><span class="Constant">true</span><span class="lexPatCode">);<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yylval-&gt;str = ident;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> IDENT;<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">{</span><span class="Special">other</span><span class="Identifier">}</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexPatCode"> </span><span class="PreProc">yytext</span><span class="lexPatCode">[</span><span class="Constant">0</span><span class="lexPatCode">];<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Identifier">&lt;&lt;EOF&gt;&gt;</span><span class="lexPatSep">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">{<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SET_YYLLOC();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="PreProc">yyterminate</span><span class="lexPatCode">();<br/></li>
<li></span><span class="lexPatCode">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Special">}<br/></li>
<li></span><br/></li>
<li><span class="Todo">%%<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* LCOV_EXCL_STOP */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Arrange access to yyextra for subroutines of the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> yylex() function.<br/></li>
<li></span><span class="Comment"> * We expect each subroutine to have a yyscanner parameter.&nbsp; Rather than<br/></li>
<li></span><span class="Comment"> * use the yyget_xxx <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, which might or might not get inlined by the<br/></li>
<li></span><span class="Comment"> * compiler, we cheat just a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> and cast yyscanner to the right type.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#undef yyextra<br/></li>
<li></span><span class="PreProc">#define yyextra&nbsp; (((</span><span class="Type">struct</span><span class="PreProc"> yyguts_t *) yyscanner)-&gt;yyextra_r)<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* Likewise for a couple of other things we need. */<br/></li>
<li></span><span class="PreProc">#undef yylloc<br/></li>
<li></span><span class="PreProc">#define yylloc&nbsp; &nbsp; (((</span><span class="Type">struct</span><span class="PreProc"> yyguts_t *) yyscanner)-&gt;yylloc_r)<br/></li>
<li></span><span class="PreProc">#undef yyleng<br/></li>
<li></span><span class="PreProc">#define yyleng&nbsp; &nbsp; (((</span><span class="Type">struct</span><span class="PreProc"> yyguts_t *) yyscanner)-&gt;yyleng_r)<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * scanner_errposition<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Report a lexer or grammar <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> cursor position, if possible.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is expected to be used within an ereport() call, or via an <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a><br/></li>
<li></span><span class="Comment"> * callback such as setup_scanner_errposition_callback().&nbsp; The return value<br/></li>
<li></span><span class="Comment"> * is a dummy (always 0, in fact).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this can only be used for messages emitted during raw parsing<br/></li>
<li></span><span class="Comment"> * (essentially, scan.l, parser.c, and gram.y), since it requires the<br/></li>
<li></span><span class="Comment"> * yyscanner struct to still be available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">int<br/></li>
<li></span><span class="lexFinalCodeBlock">scanner_errposition(</span><span class="Type">int</span><span class="lexFinalCodeBlock"> location, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Type">int</span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pos;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (location &lt; </span><span class="Constant">0</span><span class="lexFinalCodeBlock">)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Constant">0</span><span class="lexFinalCodeBlock">;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* no-op if location is unknown */<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* Convert byte offset to character number */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; pos = <a href="../utils/mb/mbutils.c.html#L1057" title="utils/mb/mbutils.c:1057">pg_mbstrlen_with_len</a>(yyextra-&gt;scanbuf, location) + </span><span class="Constant">1</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* And pass it to the ereport mechanism */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> <a href="../utils/error/elog.c.html#L1448" title="utils/error/elog.c:1448">errposition</a>(pos);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Error context callback for inserting scanner <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> location.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that this will be called for *<a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>* <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> occurring while the<br/></li>
<li></span><span class="Comment"> * callback is installed.&nbsp; We avoid inserting an irrelevant <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> location<br/></li>
<li></span><span class="Comment"> * if the <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> is a query cancel --- are there <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other important cases?<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">scb_error_callback(</span><span class="Type">void</span><span class="lexFinalCodeBlock"> *arg)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; ScannerCallbackState *scbstate = (ScannerCallbackState *) arg;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (<a href="../utils/error/elog.c.html#L1563" title="utils/error/elog.c:1563">geterrcode</a>() != ERRCODE_QUERY_CANCELED)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; (</span><span class="Type">void</span><span class="lexFinalCodeBlock">) scanner_errposition(scbstate-&gt;location, scbstate-&gt;yyscanner);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * setup_scanner_errposition_callback<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Arrange for non-scanner errors to report an <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> position<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Sometimes the scanner calls <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> that aren't part of the scanner<br/></li>
<li></span><span class="Comment"> * subsystem and can't reasonably be passed the yyscanner pointer; yet<br/></li>
<li></span><span class="Comment"> * we would like <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors thrown in those <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to be tagged with an<br/></li>
<li></span><span class="Comment"> * <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> location.&nbsp; Use this function to set up an <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> context stack<br/></li>
<li></span><span class="Comment"> * entry that will accomplish that.&nbsp; Usage pattern:<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; declare a local variable &quot;ScannerCallbackState scbstate&quot;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; ...<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; setup_scanner_errposition_callback(&amp;scbstate, yyscanner, location);<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; call function that might throw <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a>;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; cancel_scanner_errposition_callback(&amp;scbstate);<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">setup_scanner_errposition_callback(ScannerCallbackState *scbstate,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; core_yyscan_t yyscanner,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Type">int</span><span class="lexFinalCodeBlock"> location)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* Setup <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> traceback support for ereport() */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; scbstate-&gt;yyscanner = yyscanner;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; scbstate-&gt;location = location;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; scbstate-&gt;errcallback.callback = scb_error_callback;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; scbstate-&gt;errcallback.arg = (</span><span class="Type">void</span><span class="lexFinalCodeBlock"> *) scbstate;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; scbstate-&gt;errcallback.previous = <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a>;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = &amp;scbstate-&gt;errcallback;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Cancel a previously-set-up <a href="../utils/error/elog.c.html#L1448" title="utils/error/elog.c:1448">errposition</a> callback.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">cancel_scanner_errposition_callback(ScannerCallbackState *scbstate)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* Pop the <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> context stack */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; <a href="../utils/error/elog.c.html#L94" title="utils/error/elog.c:94">error_context_stack</a> = scbstate-&gt;errcallback.previous;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * scanner_yyerror<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Report a lexer or grammar <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The message's cursor position is whatever YYLLOC was last set to,<br/></li>
<li></span><span class="Comment"> * ie, the start of the current token if called within yylex(), or the<br/></li>
<li></span><span class="Comment"> * most recently lexed token if called from the grammar.<br/></li>
<li></span><span class="Comment"> * This is OK for syntax <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> messages from the Bison parser, because Bison<br/></li>
<li></span><span class="Comment"> * parsers report <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a> as soon as the first unparsable token is reached.<br/></li>
<li></span><span class="Comment"> * Beware of using yyerror for other purposes, as the cursor position might<br/></li>
<li></span><span class="Comment"> * be misleading!<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">scanner_yyerror(</span><span class="Type">const</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> *message, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Type">const</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> *loc = yyextra-&gt;scanbuf + *yylloc;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (*loc == YY_END_OF_BUFFER_CHAR)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* translator: %s is typically the translation of &quot;syntax <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a>&quot; */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> at end of input&quot;</span><span class="lexFinalCodeBlock">, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(message)),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* translator: first %s is typically the translation of &quot;syntax <a href="check_keywords.pl.html#L17" title="parser/check_keywords.pl:17">error</a>&quot; */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> at or near </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span><span class="lexFinalCodeBlock">, <a href="../utils/error/elog.c.html#L89" title="utils/error/elog.c:89">_</a>(message), loc),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> actual parsing is done<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="lexFinalCodeBlock">core_yyscan_t<br/></li>
<li></span><span class="lexFinalCodeBlock">scanner_init(</span><span class="Type">const</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> *str,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; core_yy_extra_type *yyext,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Type">const</span><span class="lexFinalCodeBlock"> ScanKeywordList *keywordlist,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="Type">const</span><span class="lexFinalCodeBlock"> uint16 *keyword_tokens)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; Size&nbsp; &nbsp; &nbsp; &nbsp; slen = strlen(str);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyscan_t&nbsp; &nbsp; scanner;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (yylex_init(&amp;scanner) != </span><span class="Constant">0</span><span class="lexFinalCodeBlock">)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, </span><span class="Constant">&quot;yylex_init() failed: %m&quot;</span><span class="lexFinalCodeBlock">);<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; core_yyset_extra(yyext, scanner);<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;keywordlist = keywordlist;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;keyword_tokens = keyword_tokens;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;backslash_quote = backslash_quote;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;escape_string_warning = escape_string_warning;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;standard_conforming_strings = standard_conforming_strings;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make a scan buffer with special termination needed by flex.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;scanbuf = (</span><span class="Type">char</span><span class="lexFinalCodeBlock"> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(slen + </span><span class="Constant">2</span><span class="lexFinalCodeBlock">);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;scanbuflen = slen;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; memcpy(yyext-&gt;scanbuf, str, slen);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;scanbuf[slen] = yyext-&gt;scanbuf[slen + </span><span class="Constant">1</span><span class="lexFinalCodeBlock">] = YY_END_OF_BUFFER_CHAR;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yy_scan_buffer(yyext-&gt;scanbuf, slen + </span><span class="Constant">2</span><span class="lexFinalCodeBlock">, scanner);<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> literal buffer to a reasonable but expansible size */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;literalalloc = </span><span class="Constant">1024</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;literalbuf = (</span><span class="Type">char</span><span class="lexFinalCodeBlock"> *) <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(yyext-&gt;literalalloc);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyext-&gt;literallen = </span><span class="Constant">0</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> scanner;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Called after parsing is done to clean up after scanner_init()<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">scanner_finish(core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't bother to call yylex_destroy(), because all it would do is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> a small amount of control storage.&nbsp; It's cheaper to leak the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * storage until the parsing context is destroyed.&nbsp; The amount of space<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * involved is usually negligible compared to the output <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * anyway.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do bother to <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a> the scanbuf and literal buffer, but only if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * represent a nontrivial amount of space.&nbsp; The 8K cutoff is arbitrary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (yyextra-&gt;scanbuflen &gt;= </span><span class="Constant">8192</span><span class="lexFinalCodeBlock">)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(yyextra-&gt;scanbuf);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (yyextra-&gt;literalalloc &gt;= </span><span class="Constant">8192</span><span class="lexFinalCodeBlock">)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(yyextra-&gt;literalbuf);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">addlit(</span><span class="Type">char</span><span class="lexFinalCodeBlock"> *ytext, </span><span class="Type">int</span><span class="lexFinalCodeBlock"> yleng, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* enlarge buffer if needed */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> ((yyextra-&gt;literallen + yleng) &gt;= yyextra-&gt;literalalloc)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;literalalloc = pg_nextpower2_32(yyextra-&gt;literallen + yleng + </span><span class="Constant">1</span><span class="lexFinalCodeBlock">);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;literalbuf = (</span><span class="Type">char</span><span class="lexFinalCodeBlock"> *) <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(yyextra-&gt;literalbuf,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;literalalloc);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* append new data */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; memcpy(yyextra-&gt;literalbuf + yyextra-&gt;literallen, ytext, yleng);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyextra-&gt;literallen += yleng;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">addlitchar(</span><span class="Type">unsigned</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> ychar, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* enlarge buffer if needed */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> ((yyextra-&gt;literallen + </span><span class="Constant">1</span><span class="lexFinalCodeBlock">) &gt;= yyextra-&gt;literalalloc)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;literalalloc *= </span><span class="Constant">2</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;literalbuf = (</span><span class="Type">char</span><span class="lexFinalCodeBlock"> *) <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(yyextra-&gt;literalbuf,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;literalalloc);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/* append new data */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyextra-&gt;literalbuf[yyextra-&gt;literallen] = ychar;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyextra-&gt;literallen += </span><span class="Constant">1</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Create a <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d copy of literalbuf, adding a trailing null.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> *<br/></li>
<li></span><span class="lexFinalCodeBlock">litbufdup(core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Type">int</span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; llen = yyextra-&gt;literallen;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Type">char</span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp;&nbsp; *</span><span class="Statement">new</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">new</span><span class="lexFinalCodeBlock"> = <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(llen + </span><span class="Constant">1</span><span class="lexFinalCodeBlock">);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; memcpy(</span><span class="Statement">new</span><span class="lexFinalCodeBlock">, yyextra-&gt;literalbuf, llen);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">new</span><span class="lexFinalCodeBlock">[llen] = </span><span class="Special">'\0'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Statement">new</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process {decinteger}, {hexinteger}, etc.&nbsp; Note this will also do the right<br/></li>
<li></span><span class="Comment"> * thing with {<a href="../utils/adt/numeric.c.html#L1237" title="utils/adt/numeric.c:1237">numeric</a>}, ie digits and a decimal point.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">int<br/></li>
<li></span><span class="lexFinalCodeBlock">process_integer_literal(</span><span class="Type">const</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> *token, YYSTYPE *lval, </span><span class="Type">int</span><span class="lexFinalCodeBlock"> base)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; ErrorSaveContext escontext = {T_ErrorSaveContext};<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; val;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; val = <a href="../utils/adt/numutils.c.html#L389" title="utils/adt/numutils.c:389">pg_strtoint32_safe</a>(token, (Node *) &amp;escontext);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (escontext.error_occurred)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* integer too large (or contains decimal pt), treat it as a float */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; lval-&gt;str = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(token);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> FCONST;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; lval-&gt;ival = val;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> ICONST;<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">addunicode(pg_wchar c, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; ScannerCallbackState scbstate;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Type">char</span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; buf[MAX_UNICODE_EQUIVALENT_STRING + </span><span class="Constant">1</span><span class="lexFinalCodeBlock">];<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (!is_valid_unicode_codepoint(c))<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyerror(</span><span class="Constant">&quot;invalid Unicode escape value&quot;</span><span class="lexFinalCodeBlock">);<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We expect that <a href="../utils/mb/mbutils.c.html#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>() will complain about <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * unconvertible code point, so we don't have to set saw_non_ascii.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; setup_scanner_errposition_callback(&amp;scbstate, yyscanner, *(yylloc));<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; <a href="../utils/mb/mbutils.c.html#L864" title="utils/mb/mbutils.c:864">pg_unicode_to_server</a>(c, (</span><span class="Type">unsigned</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> *) buf);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; cancel_scanner_errposition_callback(&amp;scbstate);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; addlit(buf, strlen(buf), yyscanner);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">unsigned</span><span class="lexFinalCodeBlock"> </span><span class="Type">char<br/></li>
<li></span><span class="lexFinalCodeBlock">unescape_single_char(</span><span class="Type">unsigned</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> c, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">switch</span><span class="lexFinalCodeBlock"> (c)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexFinalCodeBlock"> </span><span class="Constant">'b'</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Special">'\b'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexFinalCodeBlock"> </span><span class="Constant">'f'</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Special">'\f'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexFinalCodeBlock"> </span><span class="Constant">'n'</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Special">'\n'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexFinalCodeBlock"> </span><span class="Constant">'r'</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Special">'\r'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexFinalCodeBlock"> </span><span class="Constant">'t'</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Special">'\t'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">case</span><span class="lexFinalCodeBlock"> </span><span class="Constant">'v'</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> </span><span class="Special">'\v'</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">default</span><span class="lexFinalCodeBlock">:<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* check for backslash followed by non-7-<a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a>-ASCII */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (c == </span><span class="Special">'\0'</span><span class="lexFinalCodeBlock"> || IS_HIGHBIT_SET(c))<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;saw_non_ascii = </span><span class="Constant">true</span><span class="lexFinalCodeBlock">;<br/></li>
<li></span><br/></li>
<li><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> c;<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">check_string_escape_warning(</span><span class="Type">unsigned</span><span class="lexFinalCodeBlock"> </span><span class="Type">char</span><span class="lexFinalCodeBlock"> ychar, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (ychar == </span><span class="Special">'\''</span><span class="lexFinalCodeBlock">)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (yyextra-&gt;warn_on_first_escape &amp;&amp; yyextra-&gt;escape_string_warning)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NONSTANDARD_USE_OF_ESCAPE_CHARACTER),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;nonstandard use of </span><span class="Special">\\</span><span class="Constant">' in a string literal&quot;</span><span class="lexFinalCodeBlock">),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(</span><span class="Constant">&quot;Use '' to write quotes in strings, or use the escape string syntax (E'...').&quot;</span><span class="lexFinalCodeBlock">),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;warn_on_first_escape = </span><span class="Constant">false</span><span class="lexFinalCodeBlock">;&nbsp; &nbsp; </span><span class="Comment">/* warn only once per string */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">else</span><span class="lexFinalCodeBlock"> </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (ychar == </span><span class="Special">'\\'</span><span class="lexFinalCodeBlock">)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; {<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (yyextra-&gt;warn_on_first_escape &amp;&amp; yyextra-&gt;escape_string_warning)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NONSTANDARD_USE_OF_ESCAPE_CHARACTER),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;nonstandard use of </span><span class="Special">\\\\</span><span class="Constant"> in a string literal&quot;</span><span class="lexFinalCodeBlock">),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(</span><span class="Constant">&quot;Use the escape string syntax for backslashes, e.g., E'</span><span class="Special">\\\\</span><span class="Constant">'.&quot;</span><span class="lexFinalCodeBlock">),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; yyextra-&gt;warn_on_first_escape = </span><span class="Constant">false</span><span class="lexFinalCodeBlock">;&nbsp; &nbsp; </span><span class="Comment">/* warn only once per string */<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; }<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; check_escape_warning(yyscanner);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span><span class="lexFinalCodeBlock"> </span><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">check_escape_warning(core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (yyextra-&gt;warn_on_first_escape &amp;&amp; yyextra-&gt;escape_string_warning)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; ereport(WARNING,<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_NONSTANDARD_USE_OF_ESCAPE_CHARACTER),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(</span><span class="Constant">&quot;nonstandard use of escape in a string literal&quot;</span><span class="lexFinalCodeBlock">),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(</span><span class="Constant">&quot;Use the escape string syntax for escapes, e.g., E'</span><span class="Special">\\</span><span class="Constant">r</span><span class="Special">\\</span><span class="Constant">n'.&quot;</span><span class="lexFinalCodeBlock">),<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lexer_errposition()));<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; yyextra-&gt;warn_on_first_escape = </span><span class="Constant">false</span><span class="lexFinalCodeBlock">;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Comment">/* warn only once per string */<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Interface <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to make flex use <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>() instead of malloc().<br/></li>
<li></span><span class="Comment"> * It'd be better to make these static, but flex insists otherwise.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Type">void</span><span class="lexFinalCodeBlock"> *<br/></li>
<li></span><span class="lexFinalCodeBlock">core_yyalloc(yy_size_t bytes, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bytes);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Type">void</span><span class="lexFinalCodeBlock"> *<br/></li>
<li></span><span class="lexFinalCodeBlock">core_yyrealloc(</span><span class="Type">void</span><span class="lexFinalCodeBlock"> *ptr, yy_size_t bytes, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (ptr)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>(ptr, bytes);<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">else<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Statement">return</span><span class="lexFinalCodeBlock"> <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>(bytes);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
<li></span><br/></li>
<li><span class="Type">void<br/></li>
<li></span><span class="lexFinalCodeBlock">core_yyfree(</span><span class="Type">void</span><span class="lexFinalCodeBlock"> *ptr, core_yyscan_t yyscanner)<br/></li>
<li></span><span class="lexFinalCodeBlock">{<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; </span><span class="Statement">if</span><span class="lexFinalCodeBlock"> (ptr)<br/></li>
<li></span><span class="lexFinalCodeBlock">&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(ptr);<br/></li>
<li></span><span class="lexFinalCodeBlock">}<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
