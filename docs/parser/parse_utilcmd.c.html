<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>parser/parse_utilcmd.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>parser/parse_utilcmd.c - pgsql17devel-backend</h1>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L112">CreateSchemaStmtContext</a></li>
<li><a href="#L100">CreateStmtContext</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L3424">checkPartition</a></li>
<li><a href="#L1301">expandTableLikeClause</a></li>
<li><a href="#L2011">generateClonedExtStatsStmt</a></li>
<li><a href="#L1659">generateClonedIndexStmt</a></li>
<li><a href="#L373">generateSerialExtraStmts</a></li>
<li><a href="#L2129">get_collation</a></li>
<li><a href="#L2163">get_opclass</a></li>
<li><a href="#L4242">setSchemaName</a></li>
<li><a href="#L3581">transformAlterTableStmt</a></li>
<li><a href="#L2856">transformCheckConstraints</a></li>
<li><a href="#L546">transformColumnDefinition</a></li>
<li><a href="#L4082">transformColumnType</a></li>
<li><a href="#L3967">transformConstraintAttrs</a></li>
<li><a href="#L4139">transformCreateSchemaStmtElements</a></li>
<li><a href="#L167">transformCreateStmt</a></li>
<li><a href="#L2841">transformExtendedStatistics</a></li>
<li><a href="#L2885">transformFKConstraints</a></li>
<li><a href="#L2296">transformIndexConstraint</a></li>
<li><a href="#L2195">transformIndexConstraints</a></li>
<li><a href="#L2956">transformIndexStmt</a></li>
<li><a href="#L1606">transformOfType</a></li>
<li><a href="#L4315">transformPartitionBound</a></li>
<li><a href="#L4625">transformPartitionBoundValue</a></li>
<li><a href="#L4262">transformPartitionCmd</a></li>
<li><a href="#L3499">transformPartitionCmdForMerge</a></li>
<li><a href="#L3460">transformPartitionCmdForSplit</a></li>
<li><a href="#L4469">transformPartitionRangeBounds</a></li>
<li><a href="#L3126">transformRuleStmt</a></li>
<li><a href="#L3051">transformStatsStmt</a></li>
<li><a href="#L933">transformTableConstraint</a></li>
<li><a href="#L1013">transformTableLikeClause</a></li>
<li><a href="#L4586">validateInfiniteBounds</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L3974">SUPPORTS_ATTRS</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parse_utilcmd.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; Perform <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis work for various utility commands<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Formerly we did this work during parse_analyze_*() in <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c.&nbsp; However<br/></li>
<li></span><span class="Comment"> * that is fairly unsafe in the presence of querytree caching, since <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * database state that we depend on in making the transformations might be<br/></li>
<li></span><span class="Comment"> * obsolete by the time the utility command is executed; and utility commands<br/></li>
<li></span><span class="Comment"> * have no infrastructure for holding locks or rechecking plan validity.<br/></li>
<li></span><span class="Comment"> * Hence these <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> called at the start of execution of their<br/></li>
<li></span><span class="Comment"> * respective utility commands.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/parser/parse_utilcmd.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/amapi.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/reloptions.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/table.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;access/toast_compression.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/dependency.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/heap.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/index.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/namespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/partition.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_am.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_collation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_constraint.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_opclass.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_statistic_ext.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/comment.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/sequence.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablecmds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/tablespace.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_collate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_target.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_utilcmd.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parser.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partdesc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;partitioning/partbounds.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;rewrite/rewriteManip.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/acl.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/partcache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/ruleutils.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* State shared by <a href="#L167" title="parser/parse_utilcmd.c:167">transformCreateStmt</a> and its subroutines */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* overall parser state */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *stmtType;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;CREATE [FOREIGN] TABLE&quot; or &quot;ALTER TABLE&quot; */<br/></li>
<li></span>&nbsp; &nbsp; RangeVar&nbsp;&nbsp; *relation;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* relation to create */<br/></li>
<li></span>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* opened/locked rel, if ALTER */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inhRelations;&nbsp; &nbsp; <span class="Comment">/* relations to inherit from */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isforeign;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if CREATE/ALTER FOREIGN TABLE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isalter;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if altering existing table */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *columns;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ColumnDef items */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ckconstraints;&nbsp; &nbsp; <span class="Comment">/* CHECK constraints */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *nnconstraints;&nbsp; &nbsp; <span class="Comment">/* NOT NULL constraints */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *fkconstraints;&nbsp; &nbsp; <span class="Comment">/* FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraints */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ixconstraints;&nbsp; &nbsp; <span class="Comment">/* index-creating constraints */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *likeclauses;&nbsp; &nbsp; <span class="Comment">/* LIKE clauses that need post-processing */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *extstats;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* cloned extended statistics */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *blist;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;<a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> list&quot; of things to do <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * creating the table */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *alist;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* &quot;after list&quot; of things to do after creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the table */<br/></li>
<li></span>&nbsp; &nbsp; IndexStmt&nbsp; *pkey;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> index, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ispartitioned;&nbsp; &nbsp; <span class="Comment">/* true if table is partitioned */<br/></li>
<li></span>&nbsp; &nbsp; PartitionBoundSpec *partbound;&nbsp; &nbsp; <span class="Comment">/* transformed FOR VALUES */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ofType;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* true if statement contains OF typename */<br/></li>
<li><a id="L100">&#x200c;</a></span>} <span class="linkable">CreateStmtContext</span>;<br/></li>
<li><br/></li>
<li><span class="Comment">/* State shared by <a href="#L4139" title="parser/parse_utilcmd.c:4139">transformCreateSchemaStmtElements</a> and its subroutines */<br/></li>
<li></span><span class="Type">typedef</span> <span class="Type">struct<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *schemaname;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* name of schema */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sequences;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CREATE SEQUENCE items */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tables;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CREATE TABLE items */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *views;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CREATE VIEW items */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexes;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CREATE INDEX items */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *triggers;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* CREATE TRIGGER items */<br/></li>
<li></span>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *grants;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* GRANT items */<br/></li>
<li><a id="L112">&#x200c;</a></span>} <span class="linkable">CreateSchemaStmtContext</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L546" title="parser/parse_utilcmd.c:546">transformColumnDefinition</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef *column);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L933" title="parser/parse_utilcmd.c:933">transformTableConstraint</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Constraint *constraint);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1013" title="parser/parse_utilcmd.c:1013">transformTableLikeClause</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; TableLikeClause *table_like_clause);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1606" title="parser/parse_utilcmd.c:1606">transformOfType</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TypeName *ofTypename);<br/></li>
<li><span class="Type">static</span> CreateStatsStmt *<a href="#L2011" title="parser/parse_utilcmd.c:2011">generateClonedExtStatsStmt</a>(RangeVar *heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid heapRelid, Oid source_statsid);<br/></li>
<li><span class="Type">static</span> List *<a href="#L2129" title="parser/parse_utilcmd.c:2129">get_collation</a>(Oid collation, Oid actual_datatype);<br/></li>
<li><span class="Type">static</span> List *<a href="#L2163" title="parser/parse_utilcmd.c:2163">get_opclass</a>(Oid opclass, Oid actual_datatype);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt);<br/></li>
<li><span class="Type">static</span> IndexStmt *<a href="#L2296" title="parser/parse_utilcmd.c:2296">transformIndexConstraint</a>(Constraint *constraint,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2841" title="parser/parse_utilcmd.c:2841">transformExtendedStatistics</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2885" title="parser/parse_utilcmd.c:2885">transformFKConstraints</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipValidation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isAddConstraint);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2856" title="parser/parse_utilcmd.c:2856">transformCheckConstraints</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipValidation);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3967" title="parser/parse_utilcmd.c:3967">transformConstraintAttrs</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *constraintList);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4082" title="parser/parse_utilcmd.c:4082">transformColumnType</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, ColumnDef *column);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a>(<span class="Type">const</span> <span class="Type">char</span> *context_schema, <span class="Type">char</span> **stmt_schema_name);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4262" title="parser/parse_utilcmd.c:4262">transformPartitionCmd</a>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, PartitionBoundSpec *bound);<br/></li>
<li><span class="Type">static</span> List *<a href="#L4469" title="parser/parse_utilcmd.c:4469">transformPartitionRangeBounds</a>(ParseState *pstate, List *blist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Relation parent);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L4586" title="parser/parse_utilcmd.c:4586">validateInfiniteBounds</a>(ParseState *pstate, List *blist);<br/></li>
<li><span class="Type">static</span> Const *<a href="#L4625" title="parser/parse_utilcmd.c:4625">transformPartitionBoundValue</a>(ParseState *pstate, Node *val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *colName, Oid colType, int32 colTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid partCollation);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L167" title="parser/parse_utilcmd.c:167">transformCreateStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis for CREATE TABLE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns a List of utility commands to be done in sequence.&nbsp; One of these<br/></li>
<li></span><span class="Comment"> * will be the transformed CreateStmt, but there may be additional actions<br/></li>
<li></span><span class="Comment"> * to be done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after the actual <a href="../commands/tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a>() call.<br/></li>
<li></span><span class="Comment"> * In addition to normal utility commands such as AlterTableStmt and<br/></li>
<li></span><span class="Comment"> * IndexStmt, the result list may contain TableLikeClause(s), representing<br/></li>
<li></span><span class="Comment"> * the need to perform additional <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis after <a href="../commands/tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a>().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SQL allows constraints to be scattered all over, so thumb through<br/></li>
<li></span><span class="Comment"> * the columns and collect all constraints into one place.<br/></li>
<li></span><span class="Comment"> * If there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> implied indices (e.g. UNIQUE or PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>)<br/></li>
<li></span><span class="Comment"> * then expand those into multiple IndexStmt blocks.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; - thomas 1997-12-02<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L167">&#x200c;</a><span class="linkable">transformCreateStmt</span>(CreateStmt *stmt, <span class="Type">const</span> <span class="Type">char</span> *queryString)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> cxt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *save_alist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *elements;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namespaceid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; existing_relid;<br/></li>
<li>&nbsp; &nbsp; ParseCallbackState pcbstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up pstate */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the creation namespace.&nbsp; This also checks permissions on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * target namespace, locks it against concurrent drops, checks for a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * preexisting relation in that namespace with the same name, and updates<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * stmt-&gt;relation-&gt;relpersistence if the selected namespace is temporary.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_node.c.html#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;location);<br/></li>
<li>&nbsp; &nbsp; namespaceid =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L724" title="catalog/namespace.c:724">RangeVarGetAndCheckCreationNamespace</a>(stmt-&gt;relation, NoLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;existing_relid);<br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the relation already exists and the user specified &quot;IF NOT EXISTS&quot;,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * bail out with a NOTICE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;if_not_exists &amp;&amp; OidIsValid(existing_relid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are in an extension script, insist that the pre-existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * object be a member of the extension, to avoid security risks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddress address;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ObjectAddressSet(address, RelationRelationId, existing_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/pg_depend.c.html#L257" title="catalog/pg_depend.c:257">checkMembershipInCurrentExtension</a>(&amp;address);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(NOTICE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> already exists, skipping&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the target relation name isn't schema-qualified, make it so.&nbsp; This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * prevents some corner cases in which added-on rewritten commands might<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * think they should apply to other relations that have the same name and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are earlier in the search path.&nbsp; But a local temp table is effectively<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * specified to be in pg_temp, so no need for anything extra in that case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;relation-&gt;schemaname == <span class="Constant">NULL<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; stmt-&gt;relation-&gt;relpersistence != RELPERSISTENCE_TEMP)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation-&gt;schemaname = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(namespaceid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up <a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; cxt.pstate = pstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(stmt, CreateForeignTableStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.stmtType = <span class="Constant">&quot;CREATE FOREIGN TABLE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.isforeign = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.stmtType = <span class="Constant">&quot;CREATE TABLE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.isforeign = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; cxt.relation = stmt-&gt;relation;<br/></li>
<li>&nbsp; &nbsp; cxt.rel = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.inhRelations = stmt-&gt;inhRelations;<br/></li>
<li>&nbsp; &nbsp; cxt.isalter = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.columns = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.ckconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.nnconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.fkconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.ixconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.likeclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.extstats = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.blist = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.alist = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.pkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.ispartitioned = stmt-&gt;partspec != <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.partbound = stmt-&gt;partbound;<br/></li>
<li>&nbsp; &nbsp; cxt.ofType = (stmt-&gt;ofTypename != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(!stmt-&gt;ofTypename || !stmt-&gt;inhRelations);&nbsp; &nbsp; <span class="Comment">/* grammar enforces */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;ofTypename)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1606" title="parser/parse_utilcmd.c:1606">transformOfType</a>(&amp;cxt, stmt-&gt;ofTypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;partspec)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;inhRelations &amp;&amp; !stmt-&gt;partbound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot create partitioned table as inheritance child&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run through each primary <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the table creation clause. Separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column defs from constraints, and do preliminary analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(elements, stmt-&gt;tableElts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = lfirst(elements);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ColumnDef:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L546" title="parser/parse_utilcmd.c:546">transformColumnDefinition</a>(&amp;cxt, (ColumnDef *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_Constraint:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L933" title="parser/parse_utilcmd.c:933">transformTableConstraint</a>(&amp;cxt, (Constraint *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_TableLikeClause:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1013" title="parser/parse_utilcmd.c:1013">transformTableLikeClause</a>(&amp;cxt, (TableLikeClause *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transfer anything we already have in cxt.alist into save_alist, to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it separate from the output of <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>.&nbsp; (This may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not be necessary anymore, but we'll keep doing it to preserve the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * historical order of execution of the alist commands.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_alist = cxt.alist;<br/></li>
<li>&nbsp; &nbsp; cxt.alist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;constraints == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postprocess constraints that give rise to index definitions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>(&amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-consideration of LIKE clauses should happen after creation of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * indexes, but <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> creation of foreign keys.&nbsp; This order is critical<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because a LIKE clause may attempt to create a primary key.&nbsp; If there's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also a pkey in the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> CREATE TABLE list, creation of that will not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * check for a duplicate at runtime (since <a href="../catalog/index.c.html#L201" title="catalog/index.c:201">index_check_primary_key</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * expects that we rejected dups here).&nbsp; Creation of the LIKE-generated<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pkey behaves like ALTER TABLE ADD, so it will check, but obviously that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * only works if it happens second.&nbsp; On the other hand, we want to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pkeys <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> foreign key constraints, in case the user tries to make a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * self-referential FK.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cxt.alist = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(cxt.alist, cxt.likeclauses);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postprocess foreign-key constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2885" title="parser/parse_utilcmd.c:2885">transformFKConstraints</a>(&amp;cxt, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postprocess check constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For regular tables all constraints can be marked valid immediately,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * because the table is new therefore empty. Not so for foreign tables.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2856" title="parser/parse_utilcmd.c:2856">transformCheckConstraints</a>(&amp;cxt, !cxt.isforeign);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Postprocess extended statistics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2841" title="parser/parse_utilcmd.c:2841">transformExtendedStatistics</a>(&amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Output results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;tableElts = cxt.columns;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;constraints = cxt.ckconstraints;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;nnconstraints = cxt.nnconstraints;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.blist, stmt);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.alist);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, save_alist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L373" title="parser/parse_utilcmd.c:373">generateSerialExtraStmts</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Generate CREATE SEQUENCE and ALTER SEQUENCE ... OWNED BY statements<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; to create the sequence for a serial or identity column.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This includes determining the name the sequence will have.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * can ask to get back the name components by passing non-null pointers<br/></li>
<li></span><span class="Comment"> * for snamespace_p and sname_p.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L373">&#x200c;</a></span><span class="linkable">generateSerialExtraStmts</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, ColumnDef *column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid seqtypid, List *seqoptions,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> for_identity, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> col_exists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">char</span> **snamespace_p, <span class="Type">char</span> **sname_p)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *option;<br/></li>
<li>&nbsp; &nbsp; DefElem&nbsp; &nbsp; *nameEl = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snamespaceid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *snamespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sname;<br/></li>
<li>&nbsp; &nbsp; CreateSeqStmt *seqstmt;<br/></li>
<li>&nbsp; &nbsp; AlterSeqStmt *altseqstmt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *attnamelist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nameEl_idx = -<span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a copy of this as we may end up modifying it in the code below */<br/></li>
<li></span>&nbsp; &nbsp; seqoptions = <a href="../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(seqoptions);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine namespace and name to use for the sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, check if a sequence name was passed in as an option.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used by pg_dump.&nbsp; Else, generate a name.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Although we use <a href="../commands/indexcmds.c.html#L2615" title="commands/indexcmds.c:2615">ChooseRelationName</a>, it's not guaranteed that the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selected sequence name won't conflict; given sufficiently long field<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * names, two different serial columns in the same table could be assigned<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the same sequence name, and we'd not notice since we aren't creating<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the sequence quite yet.&nbsp; In practice this seems quite unlikely to be a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * problem, especially since few people would need two serial columns in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(option, seqoptions)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *defel = lfirst_node(DefElem, option);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(defel-&gt;defname, <span class="Constant">&quot;sequence_name&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (nameEl)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../commands/define.c.html#L384" title="commands/define.c:384">errorConflictingDefElem</a>(defel, cxt-&gt;pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nameEl = defel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nameEl_idx = foreach_current_index(option);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nameEl)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *rv = <a href="../catalog/namespace.c.html#L3539" title="catalog/namespace.c:3539">makeRangeVarFromNameList</a>(castNode(List, nameEl-&gt;arg));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snamespace = rv-&gt;schemaname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!snamespace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Given unqualified SEQUENCE NAME, <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> namespace */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snamespaceid = RelationGetNamespace(cxt-&gt;rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snamespaceid = <a href="../catalog/namespace.c.html#L639" title="catalog/namespace.c:639">RangeVarGetCreationNamespace</a>(cxt-&gt;relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snamespace = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(snamespaceid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sname = rv-&gt;relname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remove the SEQUENCE NAME item from seqoptions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqoptions = <a href="../nodes/list.c.html#L767" title="nodes/list.c:767">list_delete_nth_cell</a>(seqoptions, nameEl_idx);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snamespaceid = RelationGetNamespace(cxt-&gt;rel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; snamespaceid = <a href="../catalog/namespace.c.html#L639" title="catalog/namespace.c:639">RangeVarGetCreationNamespace</a>(cxt-&gt;relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/namespace.c.html#L831" title="catalog/namespace.c:831">RangeVarAdjustRelationPersistence</a>(cxt-&gt;relation, snamespaceid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snamespace = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(snamespaceid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sname = <a href="../commands/indexcmds.c.html#L2615" title="commands/indexcmds.c:2615">ChooseRelationName</a>(cxt-&gt;relation-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; column-&gt;colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;seq&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; snamespaceid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ereport(DEBUG1,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L1159" title="utils/error/elog.c:1159">errmsg_internal</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> will create implicit sequence </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> for serial column </span><span class="Special">\&quot;%s</span><span class="Constant">.</span><span class="Special">%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cxt-&gt;stmtType, sname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; cxt-&gt;relation-&gt;relname, column-&gt;colname)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build a CREATE SEQUENCE command to create the sequence object, and add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it to the list of things to be done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> this CREATE/ALTER TABLE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seqstmt = makeNode(CreateSeqStmt);<br/></li>
<li>&nbsp; &nbsp; seqstmt-&gt;for_identity = for_identity;<br/></li>
<li>&nbsp; &nbsp; seqstmt-&gt;sequence = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(snamespace, sname, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy the persistence of the table.&nbsp; For CREATE TABLE, we get the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * persistence from cxt-&gt;relation, which comes from the CreateStmt in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * progress.&nbsp; For ALTER TABLE, the parser won't set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * cxt-&gt;relation-&gt;relpersistence, but we have cxt-&gt;rel as the existing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table, so we copy the persistence from there.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; seqstmt-&gt;sequence-&gt;relpersistence = cxt-&gt;rel ? cxt-&gt;rel-&gt;rd_rel-&gt;relpersistence : cxt-&gt;relation-&gt;relpersistence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; seqstmt-&gt;options = seqoptions;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a sequence data type was specified, add it to the options.&nbsp; Prepend<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the list rather than append; in case a user supplied their own AS<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clause, the &quot;redundant options&quot; error will point to their occurrence,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not our synthetic one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (seqtypid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;options = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(<a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;as&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) <a href="../nodes/makefuncs.c.html#L474" title="nodes/makefuncs.c:474">makeTypeNameFromOid</a>(seqtypid, -<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; -<span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; seqstmt-&gt;options);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is ALTER ADD COLUMN, make sure the sequence will be owned by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the table's owner.&nbsp; The current user might be someone else (perhaps a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/misc/superuser.c.html#L46" title="utils/misc/superuser.c:46">superuser</a>, or someone who's only a member of the owning role), but the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * SEQUENCE OWNED BY mechanisms will bleat unless table and sequence have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * exactly the same owning role.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;rel)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;ownerId = cxt-&gt;rel-&gt;rd_rel-&gt;relowner;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;ownerId = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt-&gt;blist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;blist, seqstmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Store the identity sequence name that we decided on.&nbsp; ALTER TABLE ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ADD COLUMN ... IDENTITY needs this so that it can fill the new column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> from the sequence, while the association of the sequence<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with the table is not set until after the ALTER TABLE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; column-&gt;identitySequence = seqstmt-&gt;sequence;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Build an ALTER SEQUENCE ... OWNED BY command to mark the sequence as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * owned by this column, and add it to the appropriate list of things to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * be done along with this CREATE/ALTER TABLE.&nbsp; In a CREATE or ALTER ADD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * COLUMN, it must be done after the statement because we don't know the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * column's attnum yet.&nbsp; But if we do have the attnum (in AT_AddIdentity),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can do the marking immediately, which improves some ALTER TABLE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * behaviors.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; altseqstmt = makeNode(AlterSeqStmt);<br/></li>
<li>&nbsp; &nbsp; altseqstmt-&gt;sequence = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(snamespace, sname, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; attnamelist = list_make3(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(snamespace),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(column-&gt;colname));<br/></li>
<li>&nbsp; &nbsp; altseqstmt-&gt;options = list_make1(<a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;owned_by&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) attnamelist, -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; altseqstmt-&gt;for_identity = for_identity;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (col_exists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;blist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;blist, altseqstmt);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;alist, altseqstmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (snamespace_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *snamespace_p = snamespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sname_p)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *sname_p = sname;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L546" title="parser/parse_utilcmd.c:546">transformColumnDefinition</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transform a single ColumnDef within CREATE TABLE<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Also used in ALTER TABLE ADD COLUMN<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L546">&#x200c;</a></span><span class="linkable">transformColumnDefinition</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, ColumnDef *column)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; is_serial;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_nullable;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_default;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_identity;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_generated;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; need_notnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt-&gt;columns = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;columns, column);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a> pseudo-types */<br/></li>
<li></span>&nbsp; &nbsp; is_serial = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;typeName<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; list_length(column-&gt;typeName-&gt;names) == <span class="Constant">1<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; !column-&gt;typeName-&gt;pct_type)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *typname = strVal(linitial(column-&gt;typeName-&gt;names));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(typname, <span class="Constant">&quot;smallserial&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(typname, <span class="Constant">&quot;serial2&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_serial = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;names = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;typeOid = INT2OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(typname, <span class="Constant">&quot;serial&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strcmp(typname, <span class="Constant">&quot;serial4&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_serial = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;names = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;typeOid = INT4OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(typname, <span class="Constant">&quot;bigserial&quot;</span>) == <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; strcmp(typname, <span class="Constant">&quot;serial8&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is_serial = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;names = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;typeOid = INT8OID;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have to reject &quot;serial[]&quot; explicitly, because once we've set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * typeid, <a href="parse_type.c.html#L38" title="parser/parse_type.c:38">LookupTypeName</a> won't notice arrayBounds.&nbsp; We don't need <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special coding for serial(typmod) though.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (is_serial &amp;&amp; column-&gt;typeName-&gt;arrayBounds != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;array of serial is not implemented&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;typeName-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do necessary work on the column type declaration */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;typeName)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4082" title="parser/parse_utilcmd.c:4082">transformColumnType</a>(cxt, column);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Special actions for <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a> pseudo-types */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (is_serial)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *snamespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *sname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *qstring;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; A_Const&nbsp; &nbsp; *snamenode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TypeCast&nbsp;&nbsp; *castnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; FuncCall&nbsp;&nbsp; *funccallnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *constraint;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="parser/parse_utilcmd.c:373">generateSerialExtraStmts</a>(cxt, column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; column-&gt;typeName-&gt;typeOid, NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;snamespace, &amp;sname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create appropriate constraints for <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a>.&nbsp; We do this in full,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather than shortcutting, so that we will detect <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> conflicting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints the user wrote (like a different DEFAULT).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create an expression tree representing the function call<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/sequence.c.html#L586" title="commands/sequence.c:586">nextval</a>('sequencename').&nbsp; We cannot reduce the raw tree to cooked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * form until after the sequence is created, but there's no need to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qstring = <a href="../utils/adt/ruleutils.c.html#L12707" title="utils/adt/ruleutils.c:12707">quote_qualified_identifier</a>(snamespace, sname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snamenode = makeNode(A_Const);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snamenode-&gt;val.node.type = T_String;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snamenode-&gt;val.sval.sval = qstring;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; snamenode-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; castnode = makeNode(TypeCast);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; castnode-&gt;typeName = SystemTypeName(<span class="Constant">&quot;regclass&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; castnode-&gt;arg = (Node *) snamenode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; castnode-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; funccallnode = <a href="../nodes/makefuncs.c.html#L603" title="nodes/makefuncs.c:603">makeFuncCall</a>(SystemFuncName(<span class="Constant">&quot;<a href="../commands/sequence.c.html#L586" title="commands/sequence.c:586">nextval</a>&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_make1(castnode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_EXPLICIT_CALL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraint = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;contype = CONSTR_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;raw_expr = (Node *) funccallnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;cooked_expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;constraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(column-&gt;constraints, constraint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* have a not-null constraint added later */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; need_notnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process column constraints, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L3967" title="parser/parse_utilcmd.c:3967">transformConstraintAttrs</a>(cxt, column-&gt;constraints);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; saw_nullable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; saw_default = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; saw_identity = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; saw_generated = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(clist, column-&gt;constraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *constraint = lfirst_node(Constraint, clist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (constraint-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((saw_nullable &amp;&amp; column-&gt;is_not_null) || need_notnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting NULL/NOT NULL declarations for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;is_not_null = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_nullable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_NOTNULL:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Disallow conflicting [NOT] NULL markings<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_nullable &amp;&amp; !column-&gt;is_not_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting NULL/NOT NULL declarations for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Ignore redundant NOT NULL markings */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If this is the first time we see this column being marked<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not null, add the constraint entry; and get rid of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * previous markings to mark the column NOT NULL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!column-&gt;is_not_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;is_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_nullable = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;keys = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(column-&gt;colname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;nnconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;nnconstraints, constraint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't need this anymore, if we had it */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_notnull = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple default <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> specified for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;raw_default = constraint-&gt;raw_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(constraint-&gt;cooked_expr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_default = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_IDENTITY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Type&nbsp; &nbsp; &nbsp; &nbsp; ctype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;ofType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;identity columns are not supported on typed tables&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;partbound)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;identity columns are not supported on partitions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctype = <a href="parse_type.c.html#L264" title="parser/parse_type.c:264">typenameType</a>(cxt-&gt;pstate, column-&gt;typeName, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOid = ((Form_pg_type) GETSTRUCT(ctype))-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ctype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_identity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple identity specifications for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="parser/parse_utilcmd.c:373">generateSerialExtraStmts</a>(cxt, column,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; typeOid, constraint-&gt;options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;identity = constraint-&gt;generated_when;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_identity = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Identity columns are always NOT NULL, but we may have a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!saw_nullable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; need_notnull = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!column-&gt;is_not_null)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conflicting NULL/NOT NULL declarations for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_GENERATED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;ofType)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;generated columns are not supported on typed tables&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple generation clauses specified for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;generated = ATTRIBUTE_GENERATED_STORED;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;raw_default = constraint-&gt;raw_expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(constraint-&gt;cooked_expr == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_generated = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;ckconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;ckconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_PRIMARY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;primary key constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* FALL THRU */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_UNIQUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unique constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;keys == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;keys = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(column-&gt;colname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;ixconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;ixconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_EXCLUSION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* grammar does not allow EXCLUDE as a column constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;column exclusion constraints are not supported&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_FOREIGN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Fill in the current attribute's name and throw it into the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list of FK constraints to be processed later.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;fk_attrs = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(column-&gt;colname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;fkconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;fkconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_DEFERRABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_NOT_DEFERRABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_DEFERRED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_IMMEDIATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="#L3967" title="parser/parse_utilcmd.c:3967">transformConstraintAttrs</a> took care of these */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized constraint type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraint-&gt;contype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_default &amp;&amp; saw_identity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;both default and identity specified for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_default &amp;&amp; saw_generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;both default and generation expression specified for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_identity &amp;&amp; saw_generated)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;both identity and generation expression specified for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;colname, cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we need a not-null constraint for <a href="../utils/sort/tuplesort.c.html#L406" title="utils/sort/tuplesort.c:406">SERIAL</a> or IDENTITY, and one was<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not explicitly specified, add one <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (need_notnull &amp;&amp; !(saw_nullable &amp;&amp; column-&gt;is_not_null))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *notnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; column-&gt;is_not_null = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;contype = CONSTR_NOTNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;conname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;keys = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(column-&gt;colname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;nnconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;nnconstraints, notnull);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If needed, generate ALTER FOREIGN TABLE ALTER COLUMN statement to add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * per-column foreign data wrapper options to this column after creation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;fdwoptions != NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *stmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;subtype = AT_AlterColumnGenericOptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name = column-&gt;colname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;def = (Node *) column-&gt;fdwoptions;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;behavior = DROP_RESTRICT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;missing_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt = makeNode(AlterTableStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;relation = cxt-&gt;relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;cmds = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;objtype = OBJECT_FOREIGN_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;cmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stmt-&gt;cmds, cmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;alist, stmt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L933" title="parser/parse_utilcmd.c:933">transformTableConstraint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; transform a Constraint node within CREATE TABLE or ALTER TABLE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L933">&#x200c;</a></span><span class="linkable">transformTableConstraint</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, Constraint *constraint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (constraint-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_PRIMARY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;primary key constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;ixconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;ixconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_UNIQUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;unique constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;ixconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;ixconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_EXCLUSION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;exclusion constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;ixconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;ixconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_CHECK:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;ckconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;ckconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_NOTNULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;nnconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;nnconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_FOREIGN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;foreign key constraints are not supported on foreign tables&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;fkconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;fkconstraints, constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_NULL:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_DEFAULT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_DEFERRABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_NOT_DEFERRABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_DEFERRED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_IMMEDIATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid context for constraint type </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraint-&gt;contype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized constraint type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraint-&gt;contype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1013" title="parser/parse_utilcmd.c:1013">transformTableLikeClause</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Change the LIKE &lt;srctable&gt; portion of a CREATE TABLE statement into<br/></li>
<li></span><span class="Comment"> * column definitions that recreate the user defined column portions of<br/></li>
<li></span><span class="Comment"> * &lt;srctable&gt;.&nbsp; Also, if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> LIKE options that we can't fully<br/></li>
<li></span><span class="Comment"> * process at this point, add the TableLikeClause to cxt-&gt;likeclauses, which<br/></li>
<li></span><span class="Comment"> * will cause utility.c to call <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a>() after the new<br/></li>
<li></span><span class="Comment"> * table has been created.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1013">&#x200c;</a></span><span class="linkable">transformTableLikeClause</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, TableLikeClause *table_like_clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; parent_attno;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; AclResult&nbsp; &nbsp; aclresult;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *comment;<br/></li>
<li>&nbsp; &nbsp; ParseCallbackState pcbstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; process_notnull_constraints = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; table_like_clause-&gt;relation-&gt;location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we could support LIKE in many cases, but worry about it another day */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;isforeign)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;LIKE is not supported for creating foreign tables&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Open the relation referenced by the LIKE clause */<br/></li>
<li></span>&nbsp; &nbsp; relation = <a href="../access/common/relation.c.html#L137" title="access/common/relation.c:137">relation_openrv</a>(table_like_clause-&gt;relation, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_VIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_MATVIEW &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_COMPOSITE_TYPE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_FOREIGN_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is invalid in LIKE clause&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../catalog/pg_class.c.html#L24" title="catalog/pg_class.c:24">errdetail_relkind_not_supported</a>(relation-&gt;rd_rel-&gt;relkind)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check for privileges<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (relation-&gt;rd_rel-&gt;relkind == RELKIND_COMPOSITE_TYPE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L3876" title="catalog/aclchk.c:3876">object_aclcheck</a>(TypeRelationId, relation-&gt;rd_rel-&gt;reltype, <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_USAGE);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, OBJECT_TYPE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; aclresult = <a href="../catalog/aclchk.c.html#L4079" title="catalog/aclchk.c:4079">pg_class_aclcheck</a>(RelationGetRelid(relation), <a href="../utils/init/miscinit.c.html#L514" title="utils/init/miscinit.c:514">GetUserId</a>(),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ACL_SELECT);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (aclresult != ACLCHECK_OK)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../catalog/aclchk.c.html#L2688" title="catalog/aclchk.c:2688">aclcheck_error</a>(aclresult, <a href="../catalog/objectaddress.c.html#L6057" title="catalog/objectaddress.c:6057">get_relkind_objtype</a>(relation-&gt;rd_rel-&gt;relkind),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupleDesc = RelationGetDescr(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> the copied attributes into the cxt for the new table definition.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must do this <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> so that they appear in the table in the relative<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * position where the LIKE clause is, as required by SQL99.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (parent_attno = <span class="Constant">1</span>; parent_attno &lt;= tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attribute = TupleDescAttr(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_attno - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *def;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore dropped columns in the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create a new column definition<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; def = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(NameStr(attribute-&gt;attname), attribute-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;atttypmod, attribute-&gt;attcollation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For constraints, ONLY the not-null constraint is inherited by the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * new column definition per SQL99; however we cannot do that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * correctly here, so we leave it for <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a> to handle.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attnotnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; process_notnull_constraints = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add to column list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;columns = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;columns, def);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Although we don't transfer the column's default/generation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we need to mark it GENERATED if appropriate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;atthasdef &amp;&amp; attribute-&gt;attgenerated &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_GENERATED))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;generated = attribute-&gt;attgenerated;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy identity if requested<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attidentity &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_IDENTITY))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *seq_options;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> sequence owned by old column; extract sequence parameters;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * build new create sequence command<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid = <a href="../catalog/pg_depend.c.html#L944" title="catalog/pg_depend.c:944">getIdentitySequence</a>(RelationGetRelid(relation), attribute-&gt;attnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_options = <a href="../commands/sequence.c.html#L1697" title="commands/sequence.c:1697">sequence_options</a>(seq_relid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="parser/parse_utilcmd.c:373">generateSerialExtraStmts</a>(cxt, def,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, seq_options,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;identity = attribute-&gt;attidentity;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Likewise, copy storage if requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_STORAGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;storage = attribute-&gt;attstorage;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;storage = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Likewise, copy compression if requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_COMPRESSION) != <span class="Constant">0<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; CompressionMethodIsValid(attribute-&gt;attcompression))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;compression =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(<a href="../access/common/toast_compression.c.html#L304" title="access/common/toast_compression.c:304">GetCompressionMethodName</a>(attribute-&gt;attcompression));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;compression = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Likewise, copy comment if requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_COMMENTS) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (comment = <a href="../commands/comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(attribute-&gt;attrelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attribute-&gt;attnum)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommentStmt *stmt = makeNode(CommentStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;objtype = OBJECT_COLUMN;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;object = (Node *) list_make3(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cxt-&gt;relation-&gt;schemaname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(def-&gt;colname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;comment = comment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;alist, stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We cannot yet deal with defaults, CHECK constraints, or indexes, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we don't yet know what column numbers the copied columns will have in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the finished table.&nbsp; If <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of those options are specified, add the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * LIKE clause to cxt-&gt;likeclauses so that <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a> will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called after we do know that; in addition, do that if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> NOT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NULL constraints, because those must be propagated even if not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * explicitly requested.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * In order for this to work, we remember the relation OID so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a> is certain to open the same table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (CREATE_TABLE_LIKE_DEFAULTS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CREATE_TABLE_LIKE_GENERATED |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CREATE_TABLE_LIKE_CONSTRAINTS |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CREATE_TABLE_LIKE_INDEXES)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; process_notnull_constraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; table_like_clause-&gt;relationOid = RelationGetRelid(relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;likeclauses = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;likeclauses, table_like_clause);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If INCLUDING INDEXES is not given and a primary key exists, we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * add not-null constraints to the columns covered by the PK (except those<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that already have one.)&nbsp; This is required for backwards compatibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_INDEXES) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *pkcols;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; x = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Bitmapset&nbsp; *donecols = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Obtain a bitmapset of columns on which we'll add not-null<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraints in <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a>, so that we <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> this for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, <a href="../catalog/pg_constraint.c.html#L858" title="catalog/pg_constraint.c:858">RelationGetNotNullConstraints</a>(RelationGetRelid(relation), <span class="Constant">true</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CookedConstraint *cooked = (CookedConstraint *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; donecols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(donecols, cooked-&gt;attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pkcols = <a href="../utils/cache/relcache.c.html#L5231" title="utils/cache/relcache.c:5231">RelationGetIndexAttrBitmap</a>(relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; INDEX_ATTR_BITMAP_PRIMARY_KEY);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> ((x = <a href="../nodes/bitmapset.c.html#L1306" title="nodes/bitmapset.c:1306">bms_next_member</a>(pkcols, x)) &gt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *notnull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = x + FirstLowInvalidHeapAttributeNumber;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attForm;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore if we already have one for this column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/bitmapset.c.html#L510" title="nodes/bitmapset.c:510">bms_is_member</a>(attnum, donecols))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attForm = TupleDescAttr(tupleDesc, attnum - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;contype = CONSTR_NOTNULL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;conname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;is_no_inherit = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;keys = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(attForm-&gt;attname))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;skip_validation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnull-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;nnconstraints = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;nnconstraints, notnull);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We may copy extended statistics if requested, since the representation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * of CreateStatsStmt doesn't depend on column numbers.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_STATISTICS)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *parent_extstats;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_extstats = <a href="../utils/cache/relcache.c.html#L4909" title="utils/cache/relcache.c:4909">RelationGetStatExtList</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, parent_extstats)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_stat_oid = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateStatsStmt *stats_stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats_stmt = <a href="#L2011" title="parser/parse_utilcmd.c:2011">generateClonedExtStatsStmt</a>(cxt-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_stat_oid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy comment on statistics object, if requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_COMMENTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comment = <a href="../commands/comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(parent_stat_oid, StatisticExtRelationId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We make use of CreateStatsStmt's stxcomment option, so as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not to need to know <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> what name the statistics will have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stats_stmt-&gt;stxcomment = comment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;extstats = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;extstats, stats_stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(parent_extstats);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the parent rel, but keep our AccessShareLock on it until xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit.&nbsp; That will prevent someone else from deleting or ALTERing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can run <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Process LIKE options that require knowing the final column numbers<br/></li>
<li></span><span class="Comment"> * assigned to the new table's columns.&nbsp; This executes after we have<br/></li>
<li></span><span class="Comment"> * run <a href="../commands/tablecmds.c.html#L700" title="commands/tablecmds.c:700">DefineRelation</a> for the new table.&nbsp; It returns a list of utility<br/></li>
<li></span><span class="Comment"> * commands that should be run to generate indexes etc.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1301">&#x200c;</a><span class="linkable">expandTableLikeClause</span>(RangeVar *heapRel, TableLikeClause *table_like_clause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *atsubcmds = NIL;<br/></li>
<li>&nbsp; &nbsp; AttrNumber&nbsp; &nbsp; parent_attno;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; relation;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; childrel;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupleDesc;<br/></li>
<li>&nbsp; &nbsp; TupleConstr *constr;<br/></li>
<li>&nbsp; &nbsp; AttrMap&nbsp; &nbsp; *attmap;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *comment;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; at_pushed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the relation referenced by the LIKE clause.&nbsp; We should still have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the table lock obtained by <a href="#L1013" title="parser/parse_utilcmd.c:1013">transformTableLikeClause</a> (and this'll throw<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * an assertion failure if not).&nbsp; Hence, no need to recheck privileges<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * etc.&nbsp; We must open the rel by OID not name, to be sure we get the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(table_like_clause-&gt;relationOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a> called on untransformed LIKE clause&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; relation = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(table_like_clause-&gt;relationOid, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tupleDesc = RelationGetDescr(relation);<br/></li>
<li>&nbsp; &nbsp; constr = tupleDesc-&gt;constr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Open the newly-created child relation; we have lock on that too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; childrel = <a href="../access/common/relation.c.html#L137" title="access/common/relation.c:137">relation_openrv</a>(heapRel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Construct a map from the LIKE relation's attnos to the child rel's.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This re-checks type match etc, although it shouldn't be possible to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have a failure since both tables are locked.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; attmap = <a href="../access/common/attmap.c.html#L177" title="access/common/attmap.c:177">build_attrmap_by_name</a>(RelationGetDescr(childrel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process defaults, if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (CREATE_TABLE_LIKE_DEFAULTS | CREATE_TABLE_LIKE_GENERATED)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (parent_attno = <span class="Constant">1</span>; parent_attno &lt;= tupleDesc-&gt;natts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_attno++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attribute = TupleDescAttr(tupleDesc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_attno - <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ignore dropped columns in the parent.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Copy default, if present and it should be copied.&nbsp; We have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate options for plain default expressions and GENERATED<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defaults.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attribute-&gt;atthasdef &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (attribute-&gt;attgenerated ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_GENERATED) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_DEFAULTS)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *this_default;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *atsubcmd;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; this_default = <a href="../access/common/tupdesc.c.html#L899" title="access/common/tupdesc.c:899">TupleDescGetDefault</a>(tupleDesc, parent_attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (this_default == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;default expression not found for attribute </span><span class="Special">%d</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_attno, RelationGetRelationName(relation));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;subtype = AT_CookedColumnDefault;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;num = attmap-&gt;attnums[parent_attno - <span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;def = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(this_default,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;found_whole_row);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prevent this for the same reason as for constraints below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that defaults cannot contain <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a>, so it's OK that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the error message refers to generated columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Generation expression for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a whole-row reference to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; NameStr(attribute-&gt;attname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(atsubcmds, atsubcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy CHECK constraints if requested, being careful to adjust attribute<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * numbers so they match the child.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_CONSTRAINTS) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; constr != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (ccnum = <span class="Constant">0</span>; ccnum &lt; constr-&gt;num_check; ccnum++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ccname = constr-&gt;check[ccnum].ccname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *ccbin = constr-&gt;check[ccnum].ccbin;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; ccnoinherit = constr-&gt;check[ccnum].ccnoinherit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ccbin_node;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *atsubcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ccbin_node = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(<a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(ccbin),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We reject whole-row variables because the whole point of LIKE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is that the new table's rowtype might later diverge from the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * parent's.&nbsp; So, while translation might be possible right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it wouldn't be possible to guarantee it would work in future.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Constraint </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a whole-row reference to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ccname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(relation))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n = makeNode(Constraint);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;contype = CONSTR_CHECK;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;conname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(ccname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;is_no_inherit = ccnoinherit;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;raw_expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;cooked_expr = <a href="../nodes/outfuncs.c.html#L791" title="nodes/outfuncs.c:791">nodeToString</a>(ccbin_node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We can <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> validation, since the new table should be empty. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;skip_validation = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;def = (Node *) n;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(atsubcmds, atsubcmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy comment on constraint */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_COMMENTS) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (comment = <a href="../commands/comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(<a href="../catalog/pg_constraint.c.html#L1331" title="catalog/pg_constraint.c:1331">get_relation_constraint_oid</a>(RelationGetRelid(relation),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; n-&gt;conname, <span class="Constant">false</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ConstraintRelationId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommentStmt *stmt = makeNode(CommentStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;objtype = OBJECT_TABCONSTRAINT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;object = (Node *) list_make3(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(heapRel-&gt;schemaname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(heapRel-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(n-&gt;conname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;comment = comment;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, stmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Copy not-null constraints, too (these do not require <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> option to have<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * been given).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, <a href="../catalog/pg_constraint.c.html#L858" title="catalog/pg_constraint.c:858">RelationGetNotNullConstraints</a>(RelationGetRelid(relation), <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *atsubcmd;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atsubcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atsubcmd-&gt;def = (Node *) lfirst_node(Constraint, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atsubcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(atsubcmds, atsubcmd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we generated <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> ALTER TABLE actions above, wrap them into a single<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ALTER TABLE command.&nbsp; Stick it at the front of the result, so it runs<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CommentStmts we made above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atsubcmds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *atcmd = makeNode(AlterTableStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;relation = copyObject(heapRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;cmds = atsubcmds;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;objtype = OBJECT_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;missing_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(atcmd, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; at_pushed = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Process indexes if required.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_INDEXES) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; relation-&gt;rd_rel-&gt;relhasindex)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *parent_indexes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; parent_indexes = <a href="../utils/cache/relcache.c.html#L4760" title="utils/cache/relcache.c:4760">RelationGetIndexList</a>(relation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, parent_indexes)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_index_oid = lfirst_oid(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; parent_index;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *index_stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent_index = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(parent_index_oid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build CREATE INDEX statement to recreate the parent_index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_stmt = <a href="#L1659" title="parser/parse_utilcmd.c:1659">generateClonedIndexStmt</a>(heapRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; parent_index,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The PK columns might not yet non-nullable, so make sure they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * become so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_stmt-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, index_stmt-&gt;indexParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *col = lfirst_node(IndexElem, lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *notnullcmd = makeNode(AlterTableCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnullcmd-&gt;subtype = AT_SetAttNotNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnullcmd-&gt;name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(col-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Luckily we can still add more AT-subcmds here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atsubcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(atsubcmds, notnullcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we had already put the AlterTableStmt into the output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * list, we don't need to do so again; otherwise do it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!at_pushed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *atcmd = makeNode(AlterTableStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;relation = copyObject(heapRel);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;cmds = atsubcmds;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;objtype = OBJECT_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atcmd-&gt;missing_ok = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L495" title="nodes/list.c:495">lcons</a>(atcmd, result);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy comment on index, if requested */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (table_like_clause-&gt;options &amp; CREATE_TABLE_LIKE_COMMENTS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; comment = <a href="../commands/comment.c.html#L410" title="commands/comment.c:410">GetComment</a>(parent_index_oid, RelationRelationId, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We make use of IndexStmt's idxcomment option, so as not to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * need to know <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> what name the index will have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_stmt-&gt;idxcomment = comment;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, index_stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/index/indexam.c.html#L177" title="access/index/indexam.c:177">index_close</a>(parent_index, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done with child rel */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(childrel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Close the parent rel, but keep our AccessShareLock on it until xact<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * commit.&nbsp; That will prevent someone else from deleting or ALTERing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * parent <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> the child is committed.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(relation, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1606">&#x200c;</a></span><span class="linkable">transformOfType</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, TypeName *ofTypename)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tuple;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ofTypeId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(ofTypename);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tuple = <a href="parse_type.c.html#L264" title="parser/parse_type.c:264">typenameType</a>(<span class="Constant">NULL</span>, ofTypename, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="../commands/tablecmds.c.html#L7014" title="commands/tablecmds.c:7014">check_of_type</a>(tuple);<br/></li>
<li>&nbsp; &nbsp; ofTypeId = ((Form_pg_type) GETSTRUCT(tuple))-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; ofTypename-&gt;typeOid = ofTypeId; <span class="Comment">/* cached for later */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; tupdesc = <a href="../utils/cache/typcache.c.html#L1833" title="utils/cache/typcache.c:1833">lookup_rowtype_tupdesc</a>(ofTypeId, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; tupdesc-&gt;natts; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(tupdesc, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *n;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n = <a href="../nodes/makefuncs.c.html#L492" title="nodes/makefuncs.c:492">makeColumnDef</a>(NameStr(attr-&gt;attname), attr-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;atttypmod, attr-&gt;attcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; n-&gt;is_from_type = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;columns = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;columns, n);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; ReleaseTupleDesc(tupdesc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tuple);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate an IndexStmt node using information from an already existing index<br/></li>
<li></span><span class="Comment"> * &quot;source_idx&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * heapRel is stored into the IndexStmt's relation field, but we don't use it<br/></li>
<li></span><span class="Comment"> * otherwise; some callers pass NULL, if they don't need it to be valid.<br/></li>
<li></span><span class="Comment"> * (The target relation might not exist yet, so we mustn't try to access it.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Attribute numbers in expression Vars are adjusted according to attmap.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If constraintOid isn't NULL, we store the OID of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> constraint associated<br/></li>
<li></span><span class="Comment"> * with the index there.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Unlike <a href="#L2296" title="parser/parse_utilcmd.c:2296">transformIndexConstraint</a>, we don't make <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> effort to force primary<br/></li>
<li></span><span class="Comment"> * key columns to be not-null.&nbsp; The larger cloning process this is part of<br/></li>
<li></span><span class="Comment"> * should have cloned their not-null status separately (and <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a> will<br/></li>
<li></span><span class="Comment"> * complain if that fails to happen).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexStmt *<br/></li>
<li><a id="L1659">&#x200c;</a><span class="linkable">generateClonedIndexStmt</span>(RangeVar *heapRel, Relation source_idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> AttrMap *attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *constraintOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source_relid = RelationGetRelid(source_idx);<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_idxrel;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_idx;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_am;<br/></li>
<li>&nbsp; &nbsp; Form_pg_class idxrelrec;<br/></li>
<li>&nbsp; &nbsp; Form_pg_index idxrec;<br/></li>
<li>&nbsp; &nbsp; Form_pg_am&nbsp; &nbsp; amrec;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indcollation;<br/></li>
<li>&nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; IndexStmt&nbsp; *index;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexprs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *indexpr_item;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indrelid;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keyno;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keycoltype;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (constraintOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *constraintOid = InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch pg_class tuple of source index.&nbsp; We can't use the copy in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relcache entry because it doesn't include optional fields.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ht_idxrel = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(RELOID, ObjectIdGetDatum(source_relid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ht_idxrel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for relation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, source_relid);<br/></li>
<li>&nbsp; &nbsp; idxrelrec = (Form_pg_class) GETSTRUCT(ht_idxrel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch pg_index tuple for source index from relcache entry */<br/></li>
<li></span>&nbsp; &nbsp; ht_idx = source_idx-&gt;rd_indextuple;<br/></li>
<li>&nbsp; &nbsp; idxrec = (Form_pg_index) GETSTRUCT(ht_idx);<br/></li>
<li>&nbsp; &nbsp; indrelid = idxrec-&gt;indrelid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch the pg_am tuple of the index' access method */<br/></li>
<li></span>&nbsp; &nbsp; ht_am = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(AMOID, ObjectIdGetDatum(idxrelrec-&gt;relam));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ht_am))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for access method </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; idxrelrec-&gt;relam);<br/></li>
<li>&nbsp; &nbsp; amrec = (Form_pg_am) GETSTRUCT(ht_am);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract indcollation from the pg_index tuple */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, ht_idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indcollation);<br/></li>
<li>&nbsp; &nbsp; indcollation = (oidvector *) DatumGetPointer(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Extract indclass from the pg_index tuple */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID, ht_idx, Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Begin building the IndexStmt */<br/></li>
<li></span>&nbsp; &nbsp; index = makeNode(IndexStmt);<br/></li>
<li>&nbsp; &nbsp; index-&gt;relation = heapRel;<br/></li>
<li>&nbsp; &nbsp; index-&gt;accessMethod = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(amrec-&gt;amname));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(idxrelrec-&gt;reltablespace))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;tableSpace = <a href="../commands/tablespace.c.html#L1472" title="commands/tablespace.c:1472">get_tablespace_name</a>(idxrelrec-&gt;reltablespace);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;tableSpace = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;excludeOpNames = NIL;<br/></li>
<li>&nbsp; &nbsp; index-&gt;idxcomment = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;indexOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; index-&gt;oldNumber = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; index-&gt;oldCreateSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; index-&gt;oldFirstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; index-&gt;unique = idxrec-&gt;indisunique;<br/></li>
<li>&nbsp; &nbsp; index-&gt;nulls_not_distinct = idxrec-&gt;indnullsnotdistinct;<br/></li>
<li>&nbsp; &nbsp; index-&gt;primary = idxrec-&gt;indisprimary;<br/></li>
<li>&nbsp; &nbsp; index-&gt;iswithoutoverlaps = (idxrec-&gt;indisprimary || idxrec-&gt;indisunique) &amp;&amp; idxrec-&gt;indisexclusion;<br/></li>
<li>&nbsp; &nbsp; index-&gt;transformed = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* don't need <a href="#L2956" title="parser/parse_utilcmd.c:2956">transformIndexStmt</a> */<br/></li>
<li></span>&nbsp; &nbsp; index-&gt;concurrent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;if_not_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;reset_default_tblspc = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We don't try to preserve the name of the source index; instead, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>() choose a reasonable name.&nbsp; (If we tried to preserve<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the name, we'd get duplicate-relation-name failures unless the source<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * table was in a different schema.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; index-&gt;idxname = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If the index is marked PRIMARY or has an exclusion condition, it's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certainly from a constraint; else, if it's not marked UNIQUE, it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * certainly isn't.&nbsp; If it is or might be from a constraint, we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * fetch the pg_constraint record.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;primary || index-&gt;unique || idxrec-&gt;indisexclusion)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraintId = <a href="../catalog/pg_depend.c.html#L968" title="catalog/pg_depend.c:968">get_index_constraint</a>(source_relid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(constraintId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_constr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_constraint conrec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraintOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *constraintOid = constraintId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ht_constr = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CONSTROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(constraintId));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ht_constr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for constraint </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraintId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; conrec = (Form_pg_constraint) GETSTRUCT(ht_constr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;isconstraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;deferrable = conrec-&gt;condeferrable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;initdeferred = conrec-&gt;condeferred;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's an exclusion constraint, we need the operator names */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (idxrec-&gt;indisexclusion)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp;&nbsp; *elems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nElems;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(conrec-&gt;contype == CONSTRAINT_EXCLUSION ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (index-&gt;iswithoutoverlaps &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (conrec-&gt;contype == CONSTRAINT_PRIMARY || conrec-&gt;contype == CONSTRAINT_UNIQUE)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract operator OIDs from the pg_constraint tuple */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(CONSTROID, ht_constr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_constraint_conexclop);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/arrayfuncs.c.html#L3678" title="utils/adt/arrayfuncs.c:3678">deconstruct_array_builtin</a>(DatumGetArrayTypeP(datum), OIDOID, &amp;elems, <span class="Constant">NULL</span>, &amp;nElems);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; nElems; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operid = DatumGetObjectId(elems[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HeapTuple&nbsp; &nbsp; opertup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_operator operform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *oprname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nspname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *namelist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opertup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ObjectIdGetDatum(operid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(opertup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for operator </span><span class="Special">%u</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; operid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operform = (Form_pg_operator) GETSTRUCT(opertup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oprname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(operform-&gt;oprname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For simplicity we always schema-qualify the op name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nspname = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(operform-&gt;oprnamespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namelist = list_make2(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(nspname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(oprname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;excludeOpNames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;excludeOpNames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; namelist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(opertup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ht_constr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;isconstraint = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;isconstraint = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Get the index expressions, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(INDEXRELID, ht_idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indexprs, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *exprsString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprsString = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexprs = (List *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(exprsString);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indexprs = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Build the list of IndexElem */<br/></li>
<li></span>&nbsp; &nbsp; index-&gt;indexParams = NIL;<br/></li>
<li>&nbsp; &nbsp; index-&gt;indexIncludingParams = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; indexpr_item = list_head(indexprs);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = <span class="Constant">0</span>; keyno &lt; idxrec-&gt;indnkeyatts; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *iparam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = idxrec-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(RelationGetDescr(source_idx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; keyno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; opt = source_idx-&gt;rd_indoption[keyno];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam = makeNode(IndexElem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AttributeNumberIsValid(attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname = <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(indrelid, attnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keycoltype = <a href="../utils/cache/lsyscache.c.html#L913" title="utils/cache/lsyscache.c:913">get_atttype</a>(indrelid, attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;name = attname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Expressional index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *indexkey;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indexpr_item == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;too few entries in indexprs list&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = (Node *) lfirst(indexpr_item);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexpr_item = lnext(indexprs, indexpr_item);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust Vars to match new table's column numbering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indexkey = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(indexkey,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As in <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a>, reject whole-row variables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a whole-row table reference.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(source_idx))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;expr = indexkey;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keycoltype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(indexkey);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the original index column name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;indexcolname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(attr-&gt;attname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the collation name, if non-default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;collation = <a href="#L2129" title="parser/parse_utilcmd.c:2129">get_collation</a>(indcollation-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[keyno], keycoltype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Add the operator class name, if non-default */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;opclass = <a href="#L2163" title="parser/parse_utilcmd.c:2163">get_opclass</a>(indclass-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[keyno], keycoltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;opclassopts =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/reloptions.c.html#L1331" title="access/common/reloptions.c:1331">untransformRelOptions</a>(<a href="../utils/cache/lsyscache.c.html#L970" title="utils/cache/lsyscache.c:970">get_attoptions</a>(source_relid, keyno + <span class="Constant">1</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;ordering = SORTBY_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;nulls_ordering = SORTBY_NULLS_DEFAULT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust options if necessary */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (source_idx-&gt;rd_indam-&gt;amcanorder)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it supports sort ordering, copy DESC and NULLS opts. Don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * set non-default settings unnecessarily, though, so as to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * improve the chance of recognizing equivalence to constraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opt &amp; INDOPTION_DESC)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;ordering = SORTBY_DESC;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> ((opt &amp; INDOPTION_NULLS_FIRST) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;nulls_ordering = SORTBY_NULLS_LAST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (opt &amp; INDOPTION_NULLS_FIRST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;nulls_ordering = SORTBY_NULLS_FIRST;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexParams = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;indexParams, iparam);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Handle included columns separately */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (keyno = idxrec-&gt;indnkeyatts; keyno &lt; idxrec-&gt;indnatts; keyno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *iparam;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = idxrec-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[keyno];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(RelationGetDescr(source_idx),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; keyno);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam = makeNode(IndexElem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (AttributeNumberIsValid(attnum))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Simple index column */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname = <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(indrelid, attnum, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;name = attname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;expressions are not supported in included columns&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Copy the original index column name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;indexcolname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(attr-&gt;attname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexIncludingParams = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;indexIncludingParams, iparam);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Copy reloptions if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(RELOID, ht_idxrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_class_reloptions, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;options = <a href="../access/common/reloptions.c.html#L1331" title="access/common/reloptions.c:1331">untransformRelOptions</a>(datum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's a partial index, decompile and append the predicate */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(INDEXRELID, ht_idx,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_index_indpred, &amp;isnull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *pred_str;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *pred_tree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found_whole_row;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Convert text string to node tree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pred_str = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pred_tree = (Node *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(pred_str);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Adjust Vars to match new table's column numbering */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pred_tree = <a href="../rewrite/rewriteManip.c.html#L1611" title="rewrite/rewriteManip.c:1611">map_variable_attnos</a>(pred_tree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">1</span>, <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attmap,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; InvalidOid, &amp;found_whole_row);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* As in <a href="#L1301" title="parser/parse_utilcmd.c:1301">expandTableLikeClause</a>, reject whole-row variables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found_whole_row)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot convert whole-row table reference&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains a whole-row table reference.&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(source_idx))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;whereClause = pred_tree;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ht_idxrel);<br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ht_am);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> index;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Generate a CreateStatsStmt node using information from an already existing<br/></li>
<li></span><span class="Comment"> * extended statistic &quot;source_statsid&quot;, for the rel identified by heapRel and<br/></li>
<li></span><span class="Comment"> * heapRelid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> CreateStatsStmt *<br/></li>
<li><a id="L2011">&#x200c;</a><span class="linkable">generateClonedExtStatsStmt</span>(RangeVar *heapRel, Oid heapRelid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid source_statsid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_stats;<br/></li>
<li>&nbsp; &nbsp; Form_pg_statistic_ext statsrec;<br/></li>
<li>&nbsp; &nbsp; CreateStatsStmt *stats;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *stat_types = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *def_names = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isnull;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; datum;<br/></li>
<li>&nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *enabled;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(OidIsValid(heapRelid));<br/></li>
<li>&nbsp; &nbsp; Assert(heapRel != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Fetch pg_statistic_ext tuple of source statistics object.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ht_stats = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(STATEXTOID, ObjectIdGetDatum(source_statsid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ht_stats))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for statistics object </span><span class="Special">%u</span><span class="Constant">&quot;</span>, source_statsid);<br/></li>
<li>&nbsp; &nbsp; statsrec = (Form_pg_statistic_ext) GETSTRUCT(ht_stats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine which statistics types exist */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(STATEXTOID, ht_stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_statistic_ext_stxkind);<br/></li>
<li>&nbsp; &nbsp; arr = DatumGetArrayTypeP(datum);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(arr) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(arr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arr) != CHAROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;stxkind is not a 1-D char array&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; enabled = (<span class="Type">char</span> *) ARR_DATA_PTR(arr);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; ARR_DIMS(arr)[<span class="Constant">0</span>]; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (enabled[i] == STATS_EXT_NDISTINCT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_types = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stat_types, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<span class="Constant">&quot;ndistinct&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (enabled[i] == STATS_EXT_DEPENDENCIES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_types = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stat_types, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<span class="Constant">&quot;dependencies&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (enabled[i] == STATS_EXT_MCV)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stat_types = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(stat_types, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(<span class="Constant">&quot;mcv&quot;</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (enabled[i] == STATS_EXT_EXPRESSIONS)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* expression stats are not exposed to users */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized statistics kind </span><span class="Special">%c</span><span class="Constant">&quot;</span>, enabled[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Determine which columns the statistics are on */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; statsrec-&gt;stxkeys.dim1; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StatsElem&nbsp; *selem = makeNode(StatsElem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = statsrec-&gt;stxkeys.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selem-&gt;name = <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(heapRelid, attnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selem-&gt;expr = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; def_names = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(def_names, selem);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now handle expressions, if there are <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. The order (with respect to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * regular attributes) does not really matter for extended stats, so we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simply append them after simple column references.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> Some places during build/estimation treat expressions as if they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> attributes, but for the CREATE command that's entirely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * irrelevant.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; datum = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(STATEXTOID, ht_stats,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_statistic_ext_stxexprs, &amp;isnull);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isnull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exprs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *exprsString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprsString = TextDatumGetCString(datum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exprs = (List *) <a href="../nodes/read.c.html#L90" title="nodes/read.c:90">stringToNode</a>(exprsString);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, exprs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; StatsElem&nbsp; *selem = makeNode(StatsElem);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selem-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selem-&gt;expr = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def_names = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(def_names, selem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1520" title="utils/mmgr/mcxt.c:1520">pfree</a>(exprsString);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* finally, build the output node */<br/></li>
<li></span>&nbsp; &nbsp; stats = makeNode(CreateStatsStmt);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;defnames = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;stat_types = stat_types;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;exprs = def_names;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;relations = list_make1(heapRel);<br/></li>
<li>&nbsp; &nbsp; stats-&gt;stxcomment = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; stats-&gt;transformed = <span class="Constant">true</span>;&nbsp; &nbsp; <span class="Comment">/* don't need <a href="#L3051" title="parser/parse_utilcmd.c:3051">transformStatsStmt</a> again */<br/></li>
<li></span>&nbsp; &nbsp; stats-&gt;if_not_exists = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Clean up */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ht_stats);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stats;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2129" title="parser/parse_utilcmd.c:2129">get_collation</a>&nbsp; &nbsp; &nbsp; &nbsp; - fetch qualified name of a collation<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If collation is InvalidOid or is the default for the given actual_datatype,<br/></li>
<li></span><span class="Comment"> * then the return value is NIL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2129">&#x200c;</a><span class="linkable">get_collation</span>(Oid collation, Oid actual_datatype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_coll;<br/></li>
<li>&nbsp; &nbsp; Form_pg_collation coll_rec;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nsp_name;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *coll_name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(collation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* easy case */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (collation == <a href="../utils/cache/lsyscache.c.html#L3056" title="utils/cache/lsyscache.c:3056">get_typcollation</a>(actual_datatype))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* just let it default */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; ht_coll = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(COLLOID, ObjectIdGetDatum(collation));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ht_coll))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for collation </span><span class="Special">%u</span><span class="Constant">&quot;</span>, collation);<br/></li>
<li>&nbsp; &nbsp; coll_rec = (Form_pg_collation) GETSTRUCT(ht_coll);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* For simplicity, we always schema-qualify the name */<br/></li>
<li></span>&nbsp; &nbsp; nsp_name = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(coll_rec-&gt;collnamespace);<br/></li>
<li>&nbsp; &nbsp; coll_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(coll_rec-&gt;collname));<br/></li>
<li>&nbsp; &nbsp; result = list_make2(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(nsp_name), <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(coll_name));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ht_coll);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2163" title="parser/parse_utilcmd.c:2163">get_opclass</a>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - fetch qualified name of an index operator class<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the opclass is the default for the given actual_datatype, then<br/></li>
<li></span><span class="Comment"> * the return value is NIL.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L2163">&#x200c;</a><span class="linkable">get_opclass</span>(Oid opclass, Oid actual_datatype)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; ht_opc;<br/></li>
<li>&nbsp; &nbsp; Form_pg_opclass opc_rec;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ht_opc = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(CLAOID, ObjectIdGetDatum(opclass));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(ht_opc))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for opclass </span><span class="Special">%u</span><span class="Constant">&quot;</span>, opclass);<br/></li>
<li>&nbsp; &nbsp; opc_rec = (Form_pg_opclass) GETSTRUCT(ht_opc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../commands/indexcmds.c.html#L2338" title="commands/indexcmds.c:2338">GetDefaultOpClass</a>(actual_datatype, opc_rec-&gt;opcmethod) != opclass)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For simplicity, we always schema-qualify the name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *nsp_name = <a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(opc_rec-&gt;opcnamespace);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opc_name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(opc_rec-&gt;opcname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = list_make2(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(nsp_name), <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(opc_name));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ht_opc);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Handle UNIQUE, PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, EXCLUDE constraints, which create indexes.<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; We also <a href="../lib/pairingheap.c.html#L79" title="lib/pairingheap.c:79">merge</a> in <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index definitions arising from<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; LIKE ... INCLUDING INDEXES.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2195">&#x200c;</a></span><span class="linkable">transformIndexConstraints</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexStmt&nbsp; *index;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indexlist = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *finalindexlist = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run through the constraints that need to generate an index, and do so.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, in addition we set each column's attnotnull flag true.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We do not create a separate not-null constraint, as that would be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * redundant: the PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraint itself fulfills that role.&nbsp; Other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * constraint types don't need <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> not-null markings.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, cxt-&gt;ixconstraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *constraint = lfirst_node(Constraint, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(constraint-&gt;contype == CONSTR_PRIMARY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraint-&gt;contype == CONSTR_UNIQUE ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraint-&gt;contype == CONSTR_EXCLUSION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = <a href="#L2296" title="parser/parse_utilcmd.c:2296">transformIndexConstraint</a>(constraint, cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indexlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(indexlist, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Scan the index list and remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> redundant index specifications. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can happen if, for instance, the user writes UNIQUE PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>. A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strict reading of SQL would suggest raising an error instead, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * strikes me as too anal-retentive. - tgl 2001-02-14<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> in ALTER TABLE case, it'd be nice to look for duplicate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * pre-existing indexes, too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;pkey != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure we keep the PKEY index in preference to others... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; finalindexlist = list_make1(cxt-&gt;pkey);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, indexlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; keep = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *k;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* if it's pkey, it's already in finalindexlist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index == cxt-&gt;pkey)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(k, finalindexlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *priorindex = lfirst(k);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(index-&gt;indexParams, priorindex-&gt;indexParams) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(index-&gt;indexIncludingParams, priorindex-&gt;indexIncludingParams) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(index-&gt;whereClause, priorindex-&gt;whereClause) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(index-&gt;excludeOpNames, priorindex-&gt;excludeOpNames) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(index-&gt;accessMethod, priorindex-&gt;accessMethod) == <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;nulls_not_distinct == priorindex-&gt;nulls_not_distinct &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;deferrable == priorindex-&gt;deferrable &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;initdeferred == priorindex-&gt;initdeferred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorindex-&gt;unique |= index-&gt;unique;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the prior index is as yet unnamed, and this one is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * named, then transfer the name to the prior index. This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ensures that if we have named and unnamed constraints,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we'll use (at least one of) the names for the index.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (priorindex-&gt;idxname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; priorindex-&gt;idxname = index-&gt;idxname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; keep = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (keep)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; finalindexlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(finalindexlist, index);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now append all the IndexStmts to cxt-&gt;alist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(cxt-&gt;alist, finalindexlist);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2296" title="parser/parse_utilcmd.c:2296">transformIndexConstraint</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Transform one UNIQUE, PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, or EXCLUDE constraint for<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>. An IndexStmt is returned.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For a PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraint, we additionally force the columns to be<br/></li>
<li></span><span class="Comment"> * marked as not-null, without producing a not-null constraint.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> IndexStmt *<br/></li>
<li><a id="L2296">&#x200c;</a><span class="linkable">transformIndexConstraint</span>(Constraint *constraint, <a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; IndexStmt&nbsp; *index;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *notnullcmds = NIL;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index = makeNode(IndexStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; index-&gt;unique = (constraint-&gt;contype != CONSTR_EXCLUSION);<br/></li>
<li>&nbsp; &nbsp; index-&gt;primary = (constraint-&gt;contype == CONSTR_PRIMARY);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;pkey != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple primary keys for table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> are not allowed&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;relation-&gt;relname),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;pkey = index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In ALTER TABLE case, a primary index might already exist, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a> will check for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; index-&gt;nulls_not_distinct = constraint-&gt;nulls_not_distinct;<br/></li>
<li>&nbsp; &nbsp; index-&gt;isconstraint = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;iswithoutoverlaps = constraint-&gt;without_overlaps;<br/></li>
<li>&nbsp; &nbsp; index-&gt;deferrable = constraint-&gt;deferrable;<br/></li>
<li>&nbsp; &nbsp; index-&gt;initdeferred = constraint-&gt;initdeferred;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;conname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;idxname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(constraint-&gt;conname);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;idxname = <span class="Constant">NULL</span>;&nbsp; &nbsp; <span class="Comment">/* <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a> will choose name */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; index-&gt;relation = cxt-&gt;relation;<br/></li>
<li>&nbsp; &nbsp; index-&gt;accessMethod = constraint-&gt;access_method ? constraint-&gt;access_method : DEFAULT_INDEX_TYPE;<br/></li>
<li>&nbsp; &nbsp; index-&gt;options = constraint-&gt;options;<br/></li>
<li>&nbsp; &nbsp; index-&gt;tableSpace = constraint-&gt;indexspace;<br/></li>
<li>&nbsp; &nbsp; index-&gt;whereClause = constraint-&gt;where_clause;<br/></li>
<li>&nbsp; &nbsp; index-&gt;indexParams = NIL;<br/></li>
<li>&nbsp; &nbsp; index-&gt;indexIncludingParams = NIL;<br/></li>
<li>&nbsp; &nbsp; index-&gt;excludeOpNames = NIL;<br/></li>
<li>&nbsp; &nbsp; index-&gt;idxcomment = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;indexOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; index-&gt;oldNumber = InvalidRelFileNumber;<br/></li>
<li>&nbsp; &nbsp; index-&gt;oldCreateSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; index-&gt;oldFirstRelfilelocatorSubid = InvalidSubTransactionId;<br/></li>
<li>&nbsp; &nbsp; index-&gt;transformed = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;concurrent = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;if_not_exists = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; index-&gt;reset_default_tblspc = constraint-&gt;reset_default_tblspc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's ALTER TABLE ADD CONSTRAINT USING INDEX, look up the index and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * verify it's usable, then extract the implied column name list.&nbsp; (We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will not actually need the column name list at runtime, but we need it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> to check for duplicate column entries below.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;indexname != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *index_name = constraint-&gt;indexname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; heap_rel = cxt-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; index_rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_index index_form;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; oidvector&nbsp; *indclass;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Grammar should not allow this with explicit column list */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(constraint-&gt;keys == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Grammar should only allow PRIMARY and UNIQUE constraints */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert(constraint-&gt;contype == CONSTR_PRIMARY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; constraint-&gt;contype == CONSTR_UNIQUE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must be ALTER, not CREATE, but grammar doesn't enforce that */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!cxt-&gt;isalter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot use an existing index in CREATE TABLE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Look for the index in the same schema as the table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; index_oid = <a href="../utils/cache/lsyscache.c.html#L1885" title="utils/cache/lsyscache.c:1885">get_relname_relid</a>(index_name, RelationGetNamespace(heap_rel));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(index_oid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Open the index (this will throw an error if it is not an index) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; index_rel = <a href="../access/index/indexam.c.html#L133" title="access/index/indexam.c:133">index_open</a>(index_oid, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index_form = index_rel-&gt;rd_index;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check that it does not have an associated constraint already */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(<a href="../catalog/pg_depend.c.html#L968" title="catalog/pg_depend.c:968">get_index_constraint</a>(index_oid)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already associated with a constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Perform validity checks on the index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_form-&gt;indrelid != RelationGetRelid(heap_rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not belong to table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_name, RelationGetRelationName(heap_rel)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index_form-&gt;indisvalid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not valid&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Today we forbid non-unique indexes, but we could permit GiST<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indexes whose last entry is a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> type and use that to create a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * WITHOUT OVERLAPS constraint (i.e. a temporal constraint).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index_form-&gt;indisunique)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a unique index&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Cannot create a primary key or unique constraint using such an index.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/relcache.c.html#L5025" title="utils/cache/relcache.c:5025">RelationGetIndexExpressions</a>(index_rel) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> contains expressions&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Cannot create a primary key or unique constraint using such an index.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/relcache.c.html#L5138" title="utils/cache/relcache.c:5138">RelationGetIndexPredicate</a>(index_rel) != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a partial index&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Cannot create a primary key or unique constraint using such an index.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It's probably unsafe to change a deferred index to non-deferred. (A<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-constraint index couldn't be deferred anyway, so this case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * should never occur; no need to sweat, but let's check it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!index_form-&gt;indimmediate &amp;&amp; !constraint-&gt;deferrable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is a deferrable index&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Cannot create a non-deferrable constraint using a deferrable index.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Insist on it being a btree.&nbsp; That's the only kind that supports<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uniqueness at the moment anyway; but we must have an index that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * exactly matches what you'd get from plain ADD CONSTRAINT syntax,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * else <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> and reload will produce a different index (breaking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pg_upgrade in particular).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index_rel-&gt;rd_rel-&gt;relam != <a href="../commands/amcmds.c.html#L163" title="commands/amcmds.c:163">get_index_am_oid</a>(DEFAULT_INDEX_TYPE, <span class="Constant">false</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a btree&quot;</span>, index_name),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Must get indclass the hard way */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indclassDatum = <a href="../utils/cache/syscache.c.html#L510" title="utils/cache/syscache.c:510">SysCacheGetAttrNotNull</a>(INDEXRELID,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_rel-&gt;rd_indextuple,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Anum_pg_index_indclass);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; indclass = (oidvector *) DatumGetPointer(indclassDatum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; index_form-&gt;indnatts; i++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int16&nbsp; &nbsp; &nbsp; &nbsp; attnum = index_form-&gt;indkey.<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> FormData_pg_attribute *attform;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *attname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defopclass;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We shouldn't see attnum == 0 here, since we already rejected<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression indexes.&nbsp; If we do, <a href="../catalog/heap.c.html#L240" title="catalog/heap.c:240">SystemAttributeDefinition</a> will<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * throw an error.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(attnum &lt;= heap_rel-&gt;rd_att-&gt;natts);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attform = TupleDescAttr(heap_rel-&gt;rd_att, attnum - <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attform = <a href="../catalog/heap.c.html#L240" title="catalog/heap.c:240">SystemAttributeDefinition</a>(attnum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attname = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(attform-&gt;attname));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (i &lt; index_form-&gt;indnkeyatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Insist on default opclass, collation, and sort options.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * While the index would still work as a constraint with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-default settings, it might not provide exactly the same<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * uniqueness semantics as you'd get from a normally-created<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * constraint; and there's also the <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a>/reload problem<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mentioned above.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; attoptions =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L970" title="utils/cache/lsyscache.c:970">get_attoptions</a>(RelationGetRelid(index_rel), i + <span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defopclass = <a href="../commands/indexcmds.c.html#L2338" title="commands/indexcmds.c:2338">GetDefaultOpClass</a>(attform-&gt;atttypid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; index_rel-&gt;rd_rel-&gt;relam);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (indclass-&gt;<a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>[i] != defopclass ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attform-&gt;attcollation != index_rel-&gt;rd_indcollation[i] ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attoptions != (Datum) <span class="Constant">0</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index_rel-&gt;rd_indoption[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> column number </span><span class="Special">%d</span><span class="Constant"> does not have default sorting behavior&quot;</span>, index_name, i + <span class="Constant">1</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Cannot create a primary key or unique constraint using such an index.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;keys = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(constraint-&gt;keys, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;including = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(constraint-&gt;including, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Close the index relation but keep the lock */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(index_rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexOid = index_oid;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If it's an EXCLUDE constraint, the grammar returns a list of pairs of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * IndexElems and operator names.&nbsp; We have to break that apart into<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * separate lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;contype == CONSTR_EXCLUSION)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, constraint-&gt;exclusions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *pair = (List *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *elem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *opname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(pair) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elem = linitial_node(IndexElem, pair);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opname = lsecond_node(List, pair);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexParams = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;indexParams, elem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;excludeOpNames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;excludeOpNames, opname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For UNIQUE and PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, we just have a list of column names.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Make sure referenced keys exist.&nbsp; If we are making a PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> index,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * also make sure they are not-null.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, constraint-&gt;keys)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *key = strVal(lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *column = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *columns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *iparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Make sure referenced column exists. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(columns, cxt-&gt;columns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column = lfirst_node(ColumnDef, columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(column-&gt;colname, key) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column is defined in the new table.&nbsp; For PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can apply the not-null constraint cheaply here ... unless<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the column is marked is_from_type, in which case marking it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * here would be ineffective (see <a href="../commands/tablecmds.c.html#L2491" title="commands/tablecmds.c:2491">MergeAttributes</a>).&nbsp; Note that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this isn't effective in ALTER TABLE either, unless the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column is being added in the same command.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;contype == CONSTR_PRIMARY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !column-&gt;is_from_type)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;is_not_null = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (<a href="../catalog/heap.c.html#L252" title="catalog/heap.c:252">SystemAttributeByName</a>(key) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column will be a system column in the new table, so <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it. System columns can't ever be null, so no need to worry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about PRIMARY/NOT NULL constraint.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cxt-&gt;inhRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try inherited tables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *inher;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(inher, cxt-&gt;inhRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *inh = lfirst_node(RangeVar, inher);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(inh, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check user requested inheritance from valid relkind */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_FOREIGN_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table or foreign table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inh-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (count = <span class="Constant">0</span>; count &lt; rel-&gt;rd_att-&gt;natts; count++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute inhattr = TupleDescAttr(rel-&gt;rd_att,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *inhname = NameStr(inhattr-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inhattr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(key, inhname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the ALTER TABLE case, don't complain about index keys not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created in the command; they may well exist already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a> will complain about them if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found &amp;&amp; !cxt-&gt;isalter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> named in key does not exist&quot;</span>, key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Check for PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>(foo, foo) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(columns, index-&gt;indexParams)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam = (IndexElem *) lfirst(columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (iparam-&gt;name &amp;&amp; strcmp(key, iparam-&gt;name) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (index-&gt;primary)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> appears twice in primary key constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> appears twice in unique constraint&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, add it to the index definition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam = makeNode(IndexElem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;indexcolname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;collation = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;opclass = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;opclassopts = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;ordering = SORTBY_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;nulls_ordering = SORTBY_NULLS_DEFAULT;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexParams = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;indexParams, iparam);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;contype == CONSTR_PRIMARY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *notnullcmd = makeNode(AlterTableCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnullcmd-&gt;subtype = AT_SetAttNotNull;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnullcmd-&gt;name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notnullcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(notnullcmds, notnullcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (constraint-&gt;without_overlaps)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This enforces that there is at least one equality column<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * besides the WITHOUT OVERLAPS columns.&nbsp; This is per SQL<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * standard.&nbsp; </span><span class="Todo">XXX</span><span class="Comment"> Do we need this?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(constraint-&gt;keys) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint using WITHOUT OVERLAPS needs at least two columns&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* WITHOUT OVERLAPS requires a GiST index */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; index-&gt;accessMethod = <span class="Constant">&quot;gist&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add included columns to index definition.&nbsp; This is much like the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * simple-column-name-list code above, except that we don't worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * NOT NULL marking; included columns in a primary key should not be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * forced NOT NULL.&nbsp; We don't complain about duplicate columns, either,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * though maybe we should?<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, constraint-&gt;including)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *key = strVal(lfirst(lc));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *column = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *columns;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *iparam;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(columns, cxt-&gt;columns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column = lfirst_node(ColumnDef, columns);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(column-&gt;colname, key) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/heap.c.html#L252" title="catalog/heap.c:252">SystemAttributeByName</a>(key) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column will be a system column in the new table, so <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (cxt-&gt;inhRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* try inherited tables */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *inher;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(inher, cxt-&gt;inhRelations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *inh = lfirst_node(RangeVar, inher);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(inh, AccessShareLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* check user requested inheritance from valid relkind */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_FOREIGN_TABLE &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rel-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;inherited relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table or foreign table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inh-&gt;relname)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (count = <span class="Constant">0</span>; count &lt; rel-&gt;rd_att-&gt;natts; count++)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute inhattr = TupleDescAttr(rel-&gt;rd_att,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; count);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *inhname = NameStr(inhattr-&gt;attname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (inhattr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(key, inhname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; found = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (found)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In the ALTER TABLE case, don't complain about index keys not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * created in the command; they may well exist already. <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will complain about them if not.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!found &amp;&amp; !cxt-&gt;isalter)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> named in key does not exist&quot;</span>, key),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, constraint-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OK, add it to the index definition */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; iparam = makeNode(IndexElem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;expr = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;indexcolname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;collation = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;opclass = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; iparam-&gt;opclassopts = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; index-&gt;indexIncludingParams = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(index-&gt;indexIncludingParams, iparam);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we found anything that requires run-time <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> NOT NULL, build a full<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * ALTER TABLE command for that and add it to cxt-&gt;alist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (notnullcmds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *alterstmt = makeNode(AlterTableStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;relation = copyObject(cxt-&gt;relation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;cmds = notnullcmds;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;objtype = OBJECT_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;missing_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;alist, alterstmt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> index;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2841" title="parser/parse_utilcmd.c:2841">transformExtendedStatistics</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp;&nbsp; Handle extended statistic objects<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, there's nothing to do here, so we just append the list to<br/></li>
<li></span><span class="Comment"> * the existing &quot;after&quot; list.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2841">&#x200c;</a></span><span class="linkable">transformExtendedStatistics</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(cxt-&gt;alist, cxt-&gt;extstats);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2856" title="parser/parse_utilcmd.c:2856">transformCheckConstraints</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; handle CHECK constraints<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Right <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, there's nothing to do here when called from ALTER TABLE,<br/></li>
<li></span><span class="Comment"> * but the other constraint-transformation <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> are called in both<br/></li>
<li></span><span class="Comment"> * the CREATE TABLE and ALTER TABLE paths, so do the same here, and just<br/></li>
<li></span><span class="Comment"> * don't do anything if we're not authorized to <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> validation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2856">&#x200c;</a></span><span class="linkable">transformCheckConstraints</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipValidation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *ckclist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;ckconstraints == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If creating a new table (but not a foreign table), we can safely <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * validation of check constraints, and nonetheless mark them valid. (This<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * will override <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-supplied NOT VALID flag.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skipValidation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(ckclist, cxt-&gt;ckconstraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *constraint = (Constraint *) lfirst(ckclist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;skip_validation = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2885" title="parser/parse_utilcmd.c:2885">transformFKConstraints</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; handle FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraints<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2885">&#x200c;</a></span><span class="linkable">transformFKConstraints</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> skipValidation, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isAddConstraint)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *fkclist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (cxt-&gt;fkconstraints == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If CREATE TABLE or adding a column with NULL default, we can safely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> validation of FK constraints, and nonetheless mark them valid.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (This will override <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> user-supplied NOT VALID flag.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (skipValidation)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(fkclist, cxt-&gt;fkconstraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *constraint = (Constraint *) lfirst(fkclist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;skip_validation = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; constraint-&gt;initially_valid = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For CREATE TABLE or ALTER TABLE ADD COLUMN, gin up an ALTER TABLE ADD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * CONSTRAINT command to execute after the basic command is complete. (If<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * called from ADD CONSTRAINT, that routine will add the FK constraints to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * its own subcommand list.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the ADD CONSTRAINT command must also execute after <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * creation commands.&nbsp; Thus, this should run after<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>, so that the CREATE INDEX commands are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * already in cxt-&gt;alist.&nbsp; See also the handling of cxt-&gt;likeclauses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!isAddConstraint)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *alterstmt = makeNode(AlterTableStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;relation = cxt-&gt;relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;cmds = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;objtype = OBJECT_TABLE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(fkclist, cxt-&gt;fkconstraints)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *constraint = (Constraint *) lfirst(fkclist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *altercmd = makeNode(AlterTableCmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altercmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altercmd-&gt;name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altercmd-&gt;def = (Node *) constraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; alterstmt-&gt;cmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(alterstmt-&gt;cmds, altercmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;alist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt-&gt;alist, alterstmt);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2956" title="parser/parse_utilcmd.c:2956">transformIndexStmt</a> - <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis for CREATE INDEX and ALTER TABLE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this is a no-op for an index not using either index expressions or<br/></li>
<li></span><span class="Comment"> * a predicate expression.&nbsp; There are several code paths that create indexes<br/></li>
<li></span><span class="Comment"> * without bothering to call this, because they know they don't have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment"> * such expressions to deal with.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid race conditions, it's important that this function rely only on<br/></li>
<li></span><span class="Comment"> * the passed-in relid (and not on stmt-&gt;relation) to determine the target<br/></li>
<li></span><span class="Comment"> * relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>IndexStmt *<br/></li>
<li><a id="L2956">&#x200c;</a><span class="linkable">transformIndexStmt</span>(Oid relid, IndexStmt *stmt, <span class="Type">const</span> <span class="Type">char</span> *queryString)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if statement already transformed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;transformed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up pstate */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Put the parent table into the rtable so that the expressions can refer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to its fields without qualification.&nbsp; Caller is responsible for locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, but we still need to open it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no to join list, yes to namespaces */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take care of the where clause */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;whereClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;whereClause = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_INDEX_PREDICATE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* we have to fix its collations too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, stmt-&gt;whereClause);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take care of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index expressions */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, stmt-&gt;indexParams)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; IndexElem&nbsp; *ielem = (IndexElem *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ielem-&gt;expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Extract preliminary index col name <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> transforming expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ielem-&gt;indexcolname == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ielem-&gt;indexcolname = <a href="parse_target.c.html#L1723" title="parser/parse_target.c:1723">FigureIndexColname</a>(ielem-&gt;expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation of the expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ielem-&gt;expr = <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, ielem-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_INDEX_EXPRESSION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have to fix its collations too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, ielem-&gt;expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>() should have already rejected subqueries,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * aggregates, window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and SRFs, based on the EXPR_KIND_<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for an index expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../commands/indexcmds.c.html#L535" title="commands/indexcmds.c:535">DefineIndex</a>() will make more checks.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that only the base rel is mentioned.&nbsp; (This should be dead code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that add_missing_from is history.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pstate-&gt;p_rtable) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_REFERENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index expressions and predicates can refer only to the table being indexed&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close relation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark statement as successfully transformed */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;transformed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3051" title="parser/parse_utilcmd.c:3051">transformStatsStmt</a> - <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis for CREATE STATISTICS<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid race conditions, it's important that this function relies only on<br/></li>
<li></span><span class="Comment"> * the passed-in relid (and not on stmt-&gt;relation) to determine the target<br/></li>
<li></span><span class="Comment"> * relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>CreateStatsStmt *<br/></li>
<li><a id="L3051">&#x200c;</a><span class="linkable">transformStatsStmt</span>(Oid relid, CreateStatsStmt *stmt, <span class="Type">const</span> <span class="Type">char</span> *queryString)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Nothing to do if statement already transformed. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;transformed)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up pstate */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Put the parent table into the rtable so that the expressions can refer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to its fields without qualification.&nbsp; Caller is responsible for locking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * relation, but we still need to open it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* no to join list, yes to namespaces */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take care of <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> expressions */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, stmt-&gt;exprs)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; StatsElem&nbsp; *selem = (StatsElem *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (selem-&gt;expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Now do <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> transformation of the expression */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selem-&gt;expr = <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, selem-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_STATS_EXPRESSION);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We have to fix its collations too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, selem-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that only the base rel is mentioned.&nbsp; (This should be dead code<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> that add_missing_from is history.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pstate-&gt;p_rtable) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_REFERENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;statistics expressions can refer only to the table being referenced&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close relation */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark statement as successfully transformed */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;transformed = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3126" title="parser/parse_utilcmd.c:3126">transformRuleStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transform a CREATE RULE Statement. The action is a list of <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; trees which is transformed into a list of query trees, and we also<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transform the WHERE clause if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * actions and whereClause are output parameters that receive the<br/></li>
<li></span><span class="Comment"> * transformed results.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3126">&#x200c;</a></span><span class="linkable">transformRuleStmt</span>(RuleStmt *stmt, <span class="Type">const</span> <span class="Type">char</span> *queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **actions, Node **whereClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *oldnsitem;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *newnsitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * To avoid deadlock, make sure the first thing we do is grab<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * AccessExclusiveLock on the target relation.&nbsp; This will be needed by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../rewrite/rewriteDefine.c.html#L224" title="rewrite/rewriteDefine.c:224">DefineQueryRewrite</a>(), and we don't want to grab a lesser lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * beforehand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/table/table.c.html#L83" title="access/table/table.c:83">table_openrv</a>(stmt-&gt;relation, AccessExclusiveLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;rules on materialized views are not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up pstate */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: 'OLD' must always have a varno <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 1 and 'NEW' <a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a> to 2.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Set up their ParseNamespaceItems in the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> pstate for use in parsing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rule qualification.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; oldnsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;old&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; newnsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;new&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * They must be in the namespace too for lookup purposes, but only add the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * one(s) that are relevant for the current kind of rule.&nbsp; In an UPDATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rule, quals must refer to OLD.field or NEW.field to be unambiguous, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there's no need to be so picky for INSERT &amp; DELETE.&nbsp; We do not add them<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the joinlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (stmt-&gt;event)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, oldnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, oldnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, newnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, newnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, oldnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized event type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) stmt-&gt;event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* take care of the where clause */<br/></li>
<li></span>&nbsp; &nbsp; *whereClause = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_WHERE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we have to fix its collations too */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, *whereClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this is probably dead code without add_missing_from: */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(pstate-&gt;p_rtable) != <span class="Constant">2</span>) <span class="Comment">/* naughty, naughty... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;rule WHERE condition cannot contain references to other relations&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * 'instead nothing' rules with a qualification need a query rangetable so<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the rewrite handler can add the negated rule qualification to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * original query. We create a query with the new command type CMD_NOTHING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * here that is treated specially by the rewrite system.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;actions == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *nothing_qry = makeNode(Query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nothing_qry-&gt;commandType = CMD_NOTHING;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nothing_qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nothing_qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nothing_qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(NIL, <span class="Constant">NULL</span>);&nbsp; &nbsp; <span class="Comment">/* no join wanted */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *actions = list_make1(nothing_qry);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newactions = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transform each statement, like <a href="analyze.c.html#L221" title="parser/analyze.c:221">parse_sub_analyze</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, stmt-&gt;actions)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *action = (Node *) lfirst(l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParseState *sub_pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *sub_qry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *top_subqry;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; has_old,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_new;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Since outer ParseState isn't parent of inner, have to pass down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the query text by hand.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_sourcetext = queryString;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Set up OLD/NEW in the rtable for this statement.&nbsp; The entries<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are added only to relnamespace, not varnamespace, because we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't want them to be referred to by unqualified field names<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nor &quot;*&quot; in the rule actions.&nbsp; We decide later whether to put<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * them in the joinlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; oldnsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(sub_pstate, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;old&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newnsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(sub_pstate, rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;new&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(sub_pstate, oldnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(sub_pstate, newnsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Transform the rule action statement */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; top_subqry = <a href="analyze.c.html#L311" title="parser/analyze.c:311">transformStmt</a>(sub_pstate, action);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We cannot support utility-statement actions (eg NOTIFY) with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * nonempty rule WHERE conditions, because there's no way to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the utility action execute conditionally.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (top_subqry-&gt;commandType == CMD_UTILITY &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *whereClause != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;rules with WHERE conditions can only have SELECT, INSERT, UPDATE, or DELETE actions&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the action is INSERT...SELECT, OLD/NEW have been pushed down<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * into the SELECT, and that's what we need to look at. (Ugly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * kluge ... try to fix this when we redesign querytrees.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_qry = <a href="../rewrite/rewriteManip.c.html#L998" title="rewrite/rewriteManip.c:998">getInsertSelectQuery</a>(top_subqry, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the sub_qry is a setop, we cannot attach <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> qualifications<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to it, because the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> won't notice them.&nbsp; This could<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * perhaps be relaxed someday, but for <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we may as well reject<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * such a rule immediately.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_qry-&gt;setOperations != <span class="Constant">NULL</span> &amp;&amp; *whereClause != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conditional UNION/INTERSECT/EXCEPT statements are not implemented&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Validate action's use of OLD/NEW, qual too<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_old =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) sub_qry, PRS2_OLD_VARNO, <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>(*whereClause, PRS2_OLD_VARNO, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; has_new =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) sub_qry, PRS2_NEW_VARNO, <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>(*whereClause, PRS2_NEW_VARNO, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (stmt-&gt;event)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_SELECT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_old)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ON SELECT rule cannot use OLD&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ON SELECT rule cannot use NEW&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_UPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* both are OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_INSERT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_old)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ON INSERT rule cannot use OLD&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CMD_DELETE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_new)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;ON DELETE rule cannot use NEW&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized event type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) stmt-&gt;event);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OLD/NEW are not allowed in WITH queries, because they would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * amount to outer references for the WITH, which we disallow.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * However, they were already in the outer rangetable when we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * analyzed the query, so we have to check.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that in the INSERT...SELECT case, we need to examine the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CTE lists of both top_subqry and sub_qry.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note that we aren't digging into the body of the query looking<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for WITHs in nested sub-SELECTs.&nbsp; A WITH down there can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * legitimately refer to OLD/NEW, because it'd be an<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indirect-correlated outer reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) top_subqry-&gt;cteList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_OLD_VARNO, <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) sub_qry-&gt;cteList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_OLD_VARNO, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot refer to OLD within WITH query&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) top_subqry-&gt;cteList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_NEW_VARNO, <span class="Constant">0</span>) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../rewrite/rewriteManip.c.html#L966" title="rewrite/rewriteManip.c:966">rangeTableEntry_used</a>((Node *) sub_qry-&gt;cteList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; PRS2_NEW_VARNO, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot refer to NEW within WITH query&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For efficiency's sake, add OLD to the rule action's jointree<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only if it was actually referenced in the statement or qual.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For INSERT, NEW is not really a relation (only a reference to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the to-be-inserted tuple) and should never be added to the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * jointree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For UPDATE, we treat NEW as being another kind of reference to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * OLD, because it represents references to *transformed* tuples<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the existing relation.&nbsp; It would be wrong to enter NEW<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separately in the jointree, since that would cause a double<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * join of the updated relation.&nbsp; It's also wrong to fail to make<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a jointree entry if only NEW and not OLD is mentioned.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (has_old || (has_new &amp;&amp; stmt-&gt;event == CMD_UPDATE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If sub_qry is a setop, manipulating its jointree will do no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * good at all, because the jointree is dummy. (This should be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * a can't-happen case because of prior tests.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sub_qry-&gt;setOperations != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;conditional UNION/INTERSECT/EXCEPT statements are not implemented&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* hackishly add OLD to the already-built FROM clause */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr = makeNode(RangeTblRef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtr-&gt;rtindex = oldnsitem-&gt;p_rtindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sub_qry-&gt;jointree-&gt;fromlist =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sub_qry-&gt;jointree-&gt;fromlist, rtr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newactions = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newactions, top_subqry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(sub_pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *actions = newactions;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close relation, but keep the exclusive lock */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/table/table.c.html#L126" title="access/table/table.c:126">table_close</a>(rel, NoLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3424" title="parser/parse_utilcmd.c:3424">checkPartition</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Check that partRelOid is an oid of partition of the parent table rel<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3424">&#x200c;</a></span><span class="linkable">checkPartition</span>(Relation rel, Oid partRelOid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; partRel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; partRel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(partRelOid, AccessShareLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (partRel-&gt;rd_rel-&gt;relkind != RELKIND_RELATION)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!partRel-&gt;rd_rel-&gt;relispartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partition&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partRel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/partition.c.html#L53" title="catalog/partition.c:53">get_partition_parent</a>(partRelOid, <span class="Constant">false</span>) != RelationGetRelid(rel))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partition of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(partRel),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(partRel, AccessShareLock);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3460" title="parser/parse_utilcmd.c:3460">transformPartitionCmdForSplit</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Analyze the ALTER TABLE ... SPLIT PARTITION command<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For each new partition sps-&gt;bound is set to the transformed value of bound.<br/></li>
<li></span><span class="Comment"> * Does checks for bounds of new partitions.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3460">&#x200c;</a></span><span class="linkable">transformPartitionCmdForSplit</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, PartitionCmd *partcmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parent = cxt-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; splitPartOid;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partitioned table&quot;</span>, RelationGetRelationName(parent))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform partition bounds for all partitions in the list: */<br/></li>
<li></span>&nbsp; &nbsp; foreach(listptr, partcmd-&gt;partlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SinglePartitionSpec *sps = (SinglePartitionSpec *) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;partbound = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4262" title="parser/parse_utilcmd.c:4262">transformPartitionCmd</a>(cxt, sps-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Assign transformed value of the partition bound. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sps-&gt;bound = cxt-&gt;partbound;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; splitPartOid = RangeVarGetRelid(partcmd-&gt;name, NoLock, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3424" title="parser/parse_utilcmd.c:3424">checkPartition</a>(parent, splitPartOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Then we should check partitions with transformed bounds. */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../partitioning/partbounds.c.html#L5535" title="partitioning/partbounds.c:5535">check_partitions_for_split</a>(parent, splitPartOid, partcmd-&gt;name, partcmd-&gt;partlist, cxt-&gt;pstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3499" title="parser/parse_utilcmd.c:3499">transformPartitionCmdForMerge</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Analyze the ALTER TABLE ... MERGE PARTITIONS command<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Does simple checks for merged partitions. Calculates bound of resulting<br/></li>
<li></span><span class="Comment"> * partition.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3499">&#x200c;</a></span><span class="linkable">transformPartitionCmdForMerge</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, PartitionCmd *partcmd)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; defaultPartOid;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partOid;<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parent = cxt-&gt;rel;<br/></li>
<li>&nbsp; &nbsp; PartitionKey key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; strategy;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *listptr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *listptr2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isDefaultPart = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partOids = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (parent-&gt;rd_rel-&gt;relkind != RELKIND_PARTITIONED_TABLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partitioned table&quot;</span>, RelationGetRelationName(parent))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; key = <a href="../utils/cache/partcache.c.html#L51" title="utils/cache/partcache.c:51">RelationGetPartitionKey</a>(parent);<br/></li>
<li>&nbsp; &nbsp; strategy = get_partition_strategy(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partition of <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-partitioned table cannot be merged&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Is current partition a DEFAULT partition? */<br/></li>
<li></span>&nbsp; &nbsp; defaultPartOid = <a href="../partitioning/partdesc.c.html#L459" title="partitioning/partdesc.c:459">get_default_oid_from_partdesc</a>(<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../partitioning/partdesc.c.html#L70" title="partitioning/partdesc.c:70">RelationGetPartitionDesc</a>(parent, <span class="Constant">true</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(listptr, partcmd-&gt;partlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *name = (RangeVar *) lfirst(listptr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Partitions in the list should have different names. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; for_each_cell(listptr2, partcmd-&gt;partlist, lnext(partcmd-&gt;partlist, listptr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *name2 = (RangeVar *) lfirst(listptr2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(name, name2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DUPLICATE_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;partition with name </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is already used&quot;</span>, name-&gt;relname)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, name2-&gt;location));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Search DEFAULT partition in the list. */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; partOid = RangeVarGetRelid(name, NoLock, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (partOid == defaultPartOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isDefaultPart = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3424" title="parser/parse_utilcmd.c:3424">checkPartition</a>(parent, partOid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partOids = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(partOids, partOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Allocate bound of resulting partition. */<br/></li>
<li></span>&nbsp; &nbsp; Assert(partcmd-&gt;bound == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; partcmd-&gt;bound = makeNode(PartitionBoundSpec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fill partition bound. */<br/></li>
<li></span>&nbsp; &nbsp; partcmd-&gt;bound-&gt;strategy = strategy;<br/></li>
<li>&nbsp; &nbsp; partcmd-&gt;bound-&gt;location = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; partcmd-&gt;bound-&gt;is_default = isDefaultPart;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isDefaultPart)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../partitioning/partbounds.c.html#L5754" title="partitioning/partbounds.c:5754">calculate_partition_bound_for_merge</a>(parent, partcmd-&gt;partlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partOids, partcmd-&gt;bound,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;pstate);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3581" title="parser/parse_utilcmd.c:3581">transformAlterTableStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis for ALTER TABLE<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns the transformed AlterTableStmt.&nbsp; There may be additional actions<br/></li>
<li></span><span class="Comment"> * to be done <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> and after the transformed statement, which are returned<br/></li>
<li></span><span class="Comment"> * in *beforeStmts and *afterStmts as lists of utility command parsetrees.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * To avoid race conditions, it's important that this function rely only on<br/></li>
<li></span><span class="Comment"> * the passed-in relid (and not on stmt-&gt;relation) to determine the target<br/></li>
<li></span><span class="Comment"> * relation.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>AlterTableStmt *<br/></li>
<li><a id="L3581">&#x200c;</a><span class="linkable">transformAlterTableStmt</span>(Oid relid, AlterTableStmt *stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *queryString,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List **beforeStmts, List **afterStmts)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; rel;<br/></li>
<li>&nbsp; &nbsp; TupleDesc&nbsp; &nbsp; tupdesc;<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate;<br/></li>
<li>&nbsp; &nbsp; <a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> cxt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *save_alist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lcmd,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newcmds = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; skipValidation = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; AlterTableCmd *newcmd;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Caller is responsible for locking the relation */<br/></li>
<li></span>&nbsp; &nbsp; rel = <a href="../access/common/relation.c.html#L47" title="access/common/relation.c:47">relation_open</a>(relid, NoLock);<br/></li>
<li>&nbsp; &nbsp; tupdesc = RelationGetDescr(rel);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up pstate */<br/></li>
<li></span>&nbsp; &nbsp; pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = queryString;<br/></li>
<li>&nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; AccessShareLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Set up <a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> */<br/></li>
<li></span>&nbsp; &nbsp; cxt.pstate = pstate;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (rel-&gt;rd_rel-&gt;relkind == RELKIND_FOREIGN_TABLE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.stmtType = <span class="Constant">&quot;ALTER FOREIGN TABLE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.isforeign = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.stmtType = <span class="Constant">&quot;ALTER TABLE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cxt.isforeign = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; cxt.relation = stmt-&gt;relation;<br/></li>
<li>&nbsp; &nbsp; cxt.rel = rel;<br/></li>
<li>&nbsp; &nbsp; cxt.inhRelations = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.isalter = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.columns = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.ckconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.nnconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.fkconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.ixconstraints = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.likeclauses = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.extstats = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.blist = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.alist = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.pkey = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.ispartitioned = (rel-&gt;rd_rel-&gt;relkind == RELKIND_PARTITIONED_TABLE);<br/></li>
<li>&nbsp; &nbsp; cxt.partbound = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; cxt.ofType = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform ALTER subcommands that need it (most don't).&nbsp; These largely<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * re-use code from CREATE TABLE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lcmd, stmt-&gt;cmds)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AlterTableCmd *cmd = (AlterTableCmd *) lfirst(lcmd);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (cmd-&gt;subtype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddColumn:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *def = castNode(ColumnDef, cmd-&gt;def);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L546" title="parser/parse_utilcmd.c:546">transformColumnDefinition</a>(&amp;cxt, def);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the column has a non-null default, we can't <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * validation of foreign keys.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;raw_default != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipValidation = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All constraints are processed in other ways. Remove the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * original list<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;constraints = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddConstraint:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The original AddConstraint cmd node doesn't go to newcmds<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(cmd-&gt;def, Constraint))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L933" title="parser/parse_utilcmd.c:933">transformTableConstraint</a>(&amp;cxt, (Constraint *) cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (((Constraint *) cmd-&gt;def)-&gt;contype == CONSTR_FOREIGN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; skipValidation = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(cmd-&gt;def));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AlterColumnType:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *def = castNode(ColumnDef, cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For ALTER COLUMN TYPE, transform the USING clause if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * one was specified.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (def-&gt;raw_default)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; def-&gt;cooked_default =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, def-&gt;raw_default,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_ALTER_COL_TRANSFORM);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For identity column, create ALTER SEQUENCE command to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * change the data type of the sequence.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(relid, cmd-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; <span class="Constant">0</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TupleDescAttr(tupdesc, attnum - <span class="Constant">1</span>)-&gt;attidentity)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid = <a href="../catalog/pg_depend.c.html#L944" title="catalog/pg_depend.c:944">getIdentitySequence</a>(relid, attnum, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typeOid = <a href="parse_type.c.html#L291" title="parser/parse_type.c:291">typenameTypeId</a>(pstate, def-&gt;typeName);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterSeqStmt *altseqstmt = makeNode(AlterSeqStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altseqstmt-&gt;sequence = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(<a href="../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(seq_relid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(seq_relid),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altseqstmt-&gt;options = list_make1(<a href="../nodes/makefuncs.c.html#L564" title="nodes/makefuncs.c:564">makeDefElem</a>(<span class="Constant">&quot;as&quot;</span>, (Node *) <a href="../nodes/makefuncs.c.html#L474" title="nodes/makefuncs.c:474">makeTypeNameFromOid</a>(typeOid, -<span class="Constant">1</span>), -<span class="Constant">1</span>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; altseqstmt-&gt;for_identity = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.blist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.blist, altseqstmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AddIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Constraint *def = castNode(Constraint, cmd-&gt;def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnDef&nbsp; *newdef = makeNode(ColumnDef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;colname = cmd-&gt;name;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef-&gt;identity = def-&gt;generated_when;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;def = (Node *) newdef;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(relid, cmd-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L373" title="parser/parse_utilcmd.c:373">generateSerialExtraStmts</a>(&amp;cxt, newdef,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L913" title="utils/cache/lsyscache.c:913">get_atttype</a>(relid, attnum),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; def-&gt;options, <span class="Constant">true</span>, <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SetIdentity:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Create an ALTER SEQUENCE statement for the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * sequence of the identity column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newseqopts = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *newdef = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Split options into those handled by ALTER SEQUENCE and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * those for ALTER TABLE proper.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, castNode(List, cmd-&gt;def))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *def = lfirst_node(DefElem, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(def-&gt;defname, <span class="Constant">&quot;generated&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newdef = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newdef, def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newseqopts = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newseqopts, def);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum = <a href="../utils/cache/lsyscache.c.html#L858" title="utils/cache/lsyscache.c:858">get_attnum</a>(relid, cmd-&gt;name);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;name, RelationGetRelationName(rel))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seq_relid = <a href="../catalog/pg_depend.c.html#L944" title="catalog/pg_depend.c:944">getIdentitySequence</a>(relid, attnum, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (seq_relid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterSeqStmt *seqstmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqstmt = makeNode(AlterSeqStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;sequence = <a href="../nodes/makefuncs.c.html#L424" title="nodes/makefuncs.c:424">makeRangeVar</a>(<a href="../utils/cache/lsyscache.c.html#L3366" title="utils/cache/lsyscache.c:3366">get_namespace_name</a>(<a href="../utils/cache/lsyscache.c.html#L1952" title="utils/cache/lsyscache.c:1952">get_rel_namespace</a>(seq_relid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/cache/lsyscache.c.html#L1928" title="utils/cache/lsyscache.c:1928">get_rel_name</a>(seq_relid), -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;options = newseqopts;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;for_identity = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; seqstmt-&gt;missing_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.blist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.blist, seqstmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If column was not an identity column, we just let the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ALTER TABLE command error out later.&nbsp; (There are cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this fails to cover, but we'll need to restructure<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where creation of the sequence dependency linkage<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happens <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we can fix it.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cmd-&gt;def = (Node *) newdef;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_AttachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_DetachPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionCmd *partcmd = (PartitionCmd *) cmd-&gt;def;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4262" title="parser/parse_utilcmd.c:4262">transformPartitionCmd</a>(&amp;cxt, partcmd-&gt;bound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assign transformed value of the partition bound */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partcmd-&gt;bound = cxt.partbound;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_SplitPartition:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> AT_MergePartitions:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionCmd *partcmd = (PartitionCmd *) cmd-&gt;def;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(partcmd-&gt;partlist) &lt; <span class="Constant">2</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;list of new partitions should contain at least two items&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (cmd-&gt;subtype == AT_SplitPartition)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3460" title="parser/parse_utilcmd.c:3460">transformPartitionCmdForSplit</a>(&amp;cxt, partcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3499" title="parser/parse_utilcmd.c:3499">transformPartitionCmdForMerge</a>(&amp;cxt, partcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Currently, we shouldn't actually get here for subcommand<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * types that don't require transformation; but if we do, just<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emit them unchanged.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, cmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transfer anything we already have in cxt.alist into save_alist, to keep<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it separate from the output of <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_alist = cxt.alist;<br/></li>
<li>&nbsp; &nbsp; cxt.alist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Postprocess constraints */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2195" title="parser/parse_utilcmd.c:2195">transformIndexConstraints</a>(&amp;cxt);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2885" title="parser/parse_utilcmd.c:2885">transformFKConstraints</a>(&amp;cxt, skipValidation, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="#L2856" title="parser/parse_utilcmd.c:2856">transformCheckConstraints</a>(&amp;cxt, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Push <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> index-creation commands into the ALTER, so that they can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * scheduled nicely by tablecmds.c.&nbsp; Note that tablecmds.c assumes that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the IndexStmt attached to an AT_AddIndex or AT_AddIndexConstraint<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subcommand has already been through <a href="#L2956" title="parser/parse_utilcmd.c:2956">transformIndexStmt</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, cxt.alist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *istmt = (Node *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We assume here that cxt.alist contains only IndexStmts and possibly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * AT_SetAttNotNull statements generated from primary key constraints.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We absorb the subcommands of the latter directly.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(istmt, IndexStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *idxstmt = (IndexStmt *) istmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; idxstmt = <a href="#L2956" title="parser/parse_utilcmd.c:2956">transformIndexStmt</a>(relid, idxstmt, queryString);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = OidIsValid(idxstmt-&gt;indexOid) ? AT_AddIndexConstraint : AT_AddIndex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = (Node *) idxstmt;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, newcmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(istmt, AlterTableStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AlterTableStmt *alterstmt = (AlterTableStmt *) istmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(newcmds, alterstmt-&gt;cmds);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected stmt type </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) nodeTag(istmt));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; cxt.alist = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Append <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CHECK, NOT NULL or FK constraints to the commands list */<br/></li>
<li></span>&nbsp; &nbsp; foreach(l, cxt.ckconstraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = (Node *) lfirst_node(Constraint, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, newcmd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; foreach(l, cxt.nnconstraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = (Node *) lfirst_node(Constraint, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, newcmd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; foreach(l, cxt.fkconstraints)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd = makeNode(AlterTableCmd);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;subtype = AT_AddConstraint;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmd-&gt;def = (Node *) lfirst_node(Constraint, l);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; newcmds = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(newcmds, newcmd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Append extended statistics objects */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L2841" title="parser/parse_utilcmd.c:2841">transformExtendedStatistics</a>(&amp;cxt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Close rel */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../access/common/relation.c.html#L205" title="access/common/relation.c:205">relation_close</a>(rel, NoLock);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Output results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;cmds = newcmds;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *beforeStmts = cxt.blist;<br/></li>
<li>&nbsp; &nbsp; *afterStmts = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(cxt.alist, save_alist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> stmt;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Preprocess a list of column constraint clauses<br/></li>
<li></span><span class="Comment"> * to attach constraint attributes to their primary constraint nodes<br/></li>
<li></span><span class="Comment"> * and detect inconsistent/misplaced constraint attributes.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: currently, attributes are only supported for FOREIGN <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>, UNIQUE,<br/></li>
<li></span><span class="Comment"> * EXCLUSION, and PRIMARY <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> constraints, but someday they ought to be<br/></li>
<li></span><span class="Comment"> * supported for other constraint types.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3967">&#x200c;</a></span><span class="linkable">transformConstraintAttrs</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, List *constraintList)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Constraint *lastprimarycon = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_deferrability = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; saw_initially = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *clist;<br/></li>
<li><br/></li>
<li><a id="L3974">&#x200c;</a><span class="PreProc">#define <span class="linkable">SUPPORTS_ATTRS</span>(node)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; ((node) != </span><span class="Constant">NULL</span><span class="PreProc"> &amp;&amp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp;&nbsp; ((node)-&gt;contype == CONSTR_PRIMARY ||&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; (node)-&gt;contype == CONSTR_UNIQUE ||&nbsp; &nbsp; \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; (node)-&gt;contype == CONSTR_EXCLUSION || \<br/></li>
<li></span><span class="PreProc">&nbsp; &nbsp; &nbsp; (node)-&gt;contype == CONSTR_FOREIGN))<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; foreach(clist, constraintList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Constraint *con = (Constraint *) lfirst(clist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(con, Constraint))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(con));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (con-&gt;contype)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_DEFERRABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3974" title="parser/parse_utilcmd.c:3974">SUPPORTS_ATTRS</a>(lastprimarycon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;misplaced DEFERRABLE clause&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_deferrability)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple DEFERRABLE/NOT DEFERRABLE clauses not allowed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_deferrability = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon-&gt;deferrable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_NOT_DEFERRABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3974" title="parser/parse_utilcmd.c:3974">SUPPORTS_ATTRS</a>(lastprimarycon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;misplaced NOT DEFERRABLE clause&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_deferrability)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple DEFERRABLE/NOT DEFERRABLE clauses not allowed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_deferrability = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon-&gt;deferrable = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_initially &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon-&gt;initdeferred)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint declared INITIALLY DEFERRED must be DEFERRABLE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_DEFERRED:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3974" title="parser/parse_utilcmd.c:3974">SUPPORTS_ATTRS</a>(lastprimarycon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;misplaced INITIALLY DEFERRED clause&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_initially)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple INITIALLY IMMEDIATE/DEFERRED clauses not allowed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_initially = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon-&gt;initdeferred = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If only INITIALLY DEFERRED appears, assume DEFERRABLE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!saw_deferrability)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon-&gt;deferrable = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!lastprimarycon-&gt;deferrable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;constraint declared INITIALLY DEFERRED must be DEFERRABLE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> CONSTR_ATTR_IMMEDIATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!<a href="#L3974" title="parser/parse_utilcmd.c:3974">SUPPORTS_ATTRS</a>(lastprimarycon))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;misplaced INITIALLY IMMEDIATE clause&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (saw_initially)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;multiple INITIALLY IMMEDIATE/DEFERRED clauses not allowed&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate, con-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_initially = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon-&gt;initdeferred = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Otherwise it's not an attribute */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lastprimarycon = con;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* reset flags for new primary node */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_deferrability = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; saw_initially = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Special handling of type definition for a column<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4082">&#x200c;</a></span><span class="linkable">transformColumnType</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, ColumnDef *column)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * All we really need to do here is verify that the type is valid,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * including <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> collation spec that might be present.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Type&nbsp; &nbsp; &nbsp; &nbsp; ctype = <a href="parse_type.c.html#L264" title="parser/parse_type.c:264">typenameType</a>(cxt-&gt;pstate, column-&gt;typeName, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (column-&gt;collClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_type typtup = (Form_pg_type) GETSTRUCT(ctype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_type.c.html#L515" title="parser/parse_type.c:515">LookupCollation</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;collClause-&gt;collname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;collClause-&gt;location);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Complain if COLLATE is applied to an uncollatable type */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(typtup-&gt;typcollation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;collations are not supported by type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(typtup-&gt;oid)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(cxt-&gt;pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; column-&gt;collClause-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(ctype);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4139" title="parser/parse_utilcmd.c:4139">transformCreateSchemaStmtElements</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; analyzes the elements of a CREATE SCHEMA statement<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Split the schema <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> list from a CREATE SCHEMA statement into<br/></li>
<li></span><span class="Comment"> * individual commands and place them in the result list in an order<br/></li>
<li></span><span class="Comment"> * such that there are no forward references (e.g. GRANT to a table<br/></li>
<li></span><span class="Comment"> * created later in the list). Note that the logic we use for determining<br/></li>
<li></span><span class="Comment"> * forward references is presently quite incomplete.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * &quot;schemaName&quot; is the name of the schema that will be used for the creation<br/></li>
<li></span><span class="Comment"> * of the objects listed, that may be compiled from the schema name defined<br/></li>
<li></span><span class="Comment"> * in the statement or a role specification.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * SQL also allows constraints to make forward references, so thumb through<br/></li>
<li></span><span class="Comment"> * the table columns and move forward references to a posterior alter-table<br/></li>
<li></span><span class="Comment"> * command.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a list of <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> nodes that still need to be analyzed ---<br/></li>
<li></span><span class="Comment"> * but we can't <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a> the later commands until we've executed the earlier<br/></li>
<li></span><span class="Comment"> * ones, because of possible inter-object references.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this breaks the rules a little <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> by modifying schema-name fields<br/></li>
<li></span><span class="Comment"> * within passed-in structs.&nbsp; However, the transformation would be the same<br/></li>
<li></span><span class="Comment"> * if done over, so it should be all right to scribble on the input to this<br/></li>
<li></span><span class="Comment"> * extent.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L4139">&#x200c;</a><span class="linkable">transformCreateSchemaStmtElements</span>(List *schemaElts, <span class="Type">const</span> <span class="Type">char</span> *schemaName)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L112" title="parser/parse_utilcmd.c:112">CreateSchemaStmtContext</a> cxt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *elements;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; cxt.schemaname = schemaName;<br/></li>
<li>&nbsp; &nbsp; cxt.sequences = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.tables = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.views = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.indexes = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.triggers = NIL;<br/></li>
<li>&nbsp; &nbsp; cxt.grants = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Run through each schema <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> in the schema <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> list. Separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * statements by type, and do preliminary analysis.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(elements, schemaElts)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> = lfirst(elements);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CreateSeqStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateSeqStmt *elp = (CreateSeqStmt *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a>(cxt.schemaname, &amp;elp-&gt;sequence-&gt;schemaname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.sequences = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.sequences, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CreateStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateStmt *elp = (CreateStmt *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a>(cxt.schemaname, &amp;elp-&gt;relation-&gt;schemaname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> todo: deal with constraints<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.tables = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.tables, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ViewStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ViewStmt&nbsp;&nbsp; *elp = (ViewStmt *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a>(cxt.schemaname, &amp;elp-&gt;view-&gt;schemaname);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> todo: deal with references between views<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.views = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.views, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_IndexStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IndexStmt&nbsp; *elp = (IndexStmt *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a>(cxt.schemaname, &amp;elp-&gt;relation-&gt;schemaname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.indexes = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.indexes, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CreateTrigStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateTrigStmt *elp = (CreateTrigStmt *) <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a>(cxt.schemaname, &amp;elp-&gt;relation-&gt;schemaname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.triggers = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.triggers, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_GrantStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt.grants = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cxt.grants, <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized node type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) nodeTag(<a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a>));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.sequences);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.tables);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.views);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.indexes);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.triggers);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L561" title="nodes/list.c:561">list_concat</a>(result, cxt.grants);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4242" title="parser/parse_utilcmd.c:4242">setSchemaName</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Set or check schema name in an <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> of a CREATE SCHEMA command<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4242">&#x200c;</a></span><span class="linkable">setSchemaName</span>(<span class="Type">const</span> <span class="Type">char</span> *context_schema, <span class="Type">char</span> **stmt_schema_name)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (*stmt_schema_name == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *stmt_schema_name = unconstify(<span class="Type">char</span> *, context_schema);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(context_schema, *stmt_schema_name) != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_SCHEMA_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;CREATE specifies a schema (</span><span class="Special">%s</span><span class="Constant">) &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;different from the one being created (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *stmt_schema_name, context_schema)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4262" title="parser/parse_utilcmd.c:4262">transformPartitionCmd</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Analyze the ATTACH/DETACH/SPLIT PARTITION command<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In case of the ATTACH/SPLIT PARTITION command, cxt-&gt;partbound is set to the<br/></li>
<li></span><span class="Comment"> * transformed value of bound.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4262">&#x200c;</a></span><span class="linkable">transformPartitionCmd</span>(<a href="#L100" title="parser/parse_utilcmd.c:100">CreateStmtContext</a> *cxt, PartitionBoundSpec *bound)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Relation&nbsp; &nbsp; parentRel = cxt-&gt;rel;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (parentRel-&gt;rd_rel-&gt;relkind)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_TABLE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* transform the partition bound, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<a href="../utils/cache/partcache.c.html#L51" title="utils/cache/partcache.c:51">RelationGetPartitionKey</a>(parentRel) != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bound != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cxt-&gt;partbound = <a href="#L4315" title="parser/parse_utilcmd.c:4315">transformPartitionBound</a>(cxt-&gt;pstate, parentRel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; bound);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_PARTITIONED_INDEX:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A partitioned index cannot have a partition bound set.&nbsp; ALTER<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * INDEX prevents that with its grammar, but not ALTER TABLE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (bound != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partitioned table&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the table must be partitioned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;table </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not partitioned&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RELKIND_INDEX:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* the index must be partitioned */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;index </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not partitioned&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(parentRel))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* parser shouldn't let this case through */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;</span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is not a partitioned table or index&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelationName(parentRel));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4315" title="parser/parse_utilcmd.c:4315">transformPartitionBound</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transform a partition bound specification<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>PartitionBoundSpec *<br/></li>
<li><a id="L4315">&#x200c;</a><span class="linkable">transformPartitionBound</span>(ParseState *pstate, Relation parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PartitionBoundSpec *spec)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; PartitionBoundSpec *result_spec;<br/></li>
<li>&nbsp; &nbsp; PartitionKey key = <a href="../utils/cache/partcache.c.html#L51" title="utils/cache/partcache.c:51">RelationGetPartitionKey</a>(parent);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; strategy = get_partition_strategy(key);<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partnatts = get_partition_natts(key);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partexprs = get_partition_exprs(key);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Avoid scribbling on input */<br/></li>
<li></span>&nbsp; &nbsp; result_spec = copyObject(spec);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (spec-&gt;is_default)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hash partitioning does not support a default partition; there's no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use case for it (since the set of partitions to create is perfectly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * defined), and if users do get into it accidentally, it's hard to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * back out from it afterwards.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a>-partitioned table may not have a default partition&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * In case of the default partition, parser had no way to identify the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition strategy. Assign the parent's strategy to the default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * partition bound spec.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_spec-&gt;strategy = strategy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result_spec;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spec-&gt;strategy != PARTITION_STRATEGY_HASH)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid bound specification for a <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partition&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) spec))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spec-&gt;modulus &lt;= <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;modulus for <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partition must be an integer value greater than zero&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(spec-&gt;remainder &gt;= <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spec-&gt;remainder &gt;= spec-&gt;modulus)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;remainder for <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> partition must be less than modulus&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_LIST)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; coltypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partcollation;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spec-&gt;strategy != PARTITION_STRATEGY_LIST)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid bound specification for a list partition&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) spec))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the only column's name in case we need to output an error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;partattrs[<span class="Constant">0</span>] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(parent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;partattrs[<span class="Constant">0</span>], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = <a href="../utils/adt/ruleutils.c.html#L3625" title="utils/adt/ruleutils.c:3625">deparse_expression</a>((Node *) linitial(partexprs),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/ruleutils.c.html#L3685" title="utils/adt/ruleutils.c:3685">deparse_context_for</a>(RelationGetRelationName(parent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need its type data too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; coltype = get_partition_col_typid(key, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coltypmod = get_partition_col_typmod(key, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; partcollation = get_partition_col_collation(key, <span class="Constant">0</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_spec-&gt;listdatums = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(cell, spec-&gt;listdatums)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = lfirst(cell);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *cell2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; duplicate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = <a href="#L4625" title="parser/parse_utilcmd.c:4625">transformPartitionBoundValue</a>(pstate, expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colname, coltype, coltypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partcollation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Don't add to the result if the value is a duplicate */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; duplicate = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(cell2, result_spec-&gt;listdatums)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *value2 = lfirst_node(Const, cell2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../nodes/equalfuncs.c.html#L223" title="nodes/equalfuncs.c:223">equal</a>(value, value2))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; duplicate = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (duplicate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result_spec-&gt;listdatums = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result_spec-&gt;listdatums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strategy == PARTITION_STRATEGY_RANGE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (spec-&gt;strategy != PARTITION_STRATEGY_RANGE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid bound specification for a <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> partition&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) spec))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(spec-&gt;lowerdatums) != partnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;FROM must specify exactly one value per partitioning column&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(spec-&gt;upperdatums) != partnatts)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_TABLE_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;TO must specify exactly one value per partitioning column&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Convert raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> nodes into PartitionRangeDatum nodes and perform<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> necessary validation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; result_spec-&gt;lowerdatums =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4469" title="parser/parse_utilcmd.c:4469">transformPartitionRangeBounds</a>(pstate, spec-&gt;lowerdatums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result_spec-&gt;upperdatums =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L4469" title="parser/parse_utilcmd.c:4469">transformPartitionRangeBounds</a>(pstate, spec-&gt;upperdatums,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected partition strategy: </span><span class="Special">%d</span><span class="Constant">&quot;</span>, (<span class="Type">int</span>) strategy);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result_spec;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4469" title="parser/parse_utilcmd.c:4469">transformPartitionRangeBounds</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; This converts the expressions for <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> partition bounds from the raw<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; grammar representation to PartitionRangeDatum structs<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> List *<br/></li>
<li><a id="L4469">&#x200c;</a><span class="linkable">transformPartitionRangeBounds</span>(ParseState *pstate, List *blist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Relation parent)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; PartitionKey key = <a href="../utils/cache/partcache.c.html#L51" title="utils/cache/partcache.c:51">RelationGetPartitionKey</a>(parent);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *partexprs = get_partition_exprs(key);<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; i = j = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, blist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *expr = lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionRangeDatum *prd = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Infinite <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bounds -- &quot;minvalue&quot; and &quot;maxvalue&quot; -- get passed in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as ColumnRefs.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, ColumnRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ColumnRef&nbsp; *cref = (ColumnRef *) expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *<a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * There should be a single field named either &quot;minvalue&quot; or<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * &quot;maxvalue&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(cref-&gt;fields) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IsA(linitial(cref-&gt;fields), String))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a> = strVal(linitial(cref-&gt;fields));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * ColumnRef is not in the desired single-field-name form. For<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consistency between all partition strategies, let the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression transformation report <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> errors rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doing it ourselves.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(<span class="Constant">&quot;minvalue&quot;</span>, <a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd = makeNode(PartitionRangeDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;kind = PARTITION_RANGE_DATUM_MINVALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (strcmp(<span class="Constant">&quot;maxvalue&quot;</span>, <a href="../regex/regc_locale.c.html#L55" title="regex/regc_locale.c:55">cname</a>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd = makeNode(PartitionRangeDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;kind = PARTITION_RANGE_DATUM_MAXVALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;value = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (prd == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; coltypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partcollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Const&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get the column's name in case we need to output an error */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key-&gt;partattrs[i] != <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = <a href="../utils/cache/lsyscache.c.html#L827" title="utils/cache/lsyscache.c:827">get_attname</a>(RelationGetRelid(parent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key-&gt;partattrs[i], <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colname = <a href="../utils/adt/ruleutils.c.html#L3625" title="utils/adt/ruleutils.c:3625">deparse_expression</a>((Node *) list_nth(partexprs, j),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/adt/ruleutils.c.html#L3685" title="utils/adt/ruleutils.c:3685">deparse_context_for</a>(RelationGetRelationName(parent),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RelationGetRelid(parent)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++j;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Need its type data too */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltype = get_partition_col_typid(key, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltypmod = get_partition_col_typmod(key, i);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; partcollation = get_partition_col_collation(key, i);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = <a href="#L4625" title="parser/parse_utilcmd.c:4625">transformPartitionBoundValue</a>(pstate, expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; colname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; coltype, coltypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partcollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (value-&gt;constisnull)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_OBJECT_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot specify NULL in <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> bound&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd = makeNode(PartitionRangeDatum);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;kind = PARTITION_RANGE_DATUM_VALUE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;value = (Node *) value;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; prd-&gt;location = <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, prd);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Once we see MINVALUE or MAXVALUE for one column, the remaining columns<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * must be the same.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L4586" title="parser/parse_utilcmd.c:4586">validateInfiniteBounds</a>(pstate, result);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L4586" title="parser/parse_utilcmd.c:4586">validateInfiniteBounds</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Check that a MAXVALUE or MINVALUE specification in a partition bound is<br/></li>
<li></span><span class="Comment"> * followed only by more of the same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L4586">&#x200c;</a></span><span class="linkable">validateInfiniteBounds</span>(ParseState *pstate, List *blist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; PartitionRangeDatumKind kind = PARTITION_RANGE_DATUM_VALUE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(lc, blist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; PartitionRangeDatum *prd = lfirst_node(PartitionRangeDatum, lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (kind == prd-&gt;kind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (kind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PARTITION_RANGE_DATUM_VALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; kind = prd-&gt;kind;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PARTITION_RANGE_DATUM_MAXVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;every bound following MAXVALUE must also be MAXVALUE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) prd))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PARTITION_RANGE_DATUM_MINVALUE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;every bound following MINVALUE must also be MINVALUE&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) prd))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transform one entry in a partition bound spec, producing a constant.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Const *<br/></li>
<li><a id="L4625">&#x200c;</a><span class="linkable">transformPartitionBoundValue</span>(ParseState *pstate, Node *val,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">const</span> <span class="Type">char</span> *colName, Oid colType, int32 colTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid partCollation)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *value;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform raw parsetree */<br/></li>
<li></span>&nbsp; &nbsp; value = <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, val, EXPR_KIND_PARTITION_BOUND);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>() should have already rejected column references,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * subqueries, aggregates, window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, and SRFs, based on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * EXPR_KIND_ of a partition bound expression.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(!<a href="../optimizer/util/var.c.html#L403" title="optimizer/util/var.c:403">contain_var_clause</a>(value));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Coerce to the correct type.&nbsp; This might cause an explicit coercion step<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to be added on top of the expression, which must be evaluated <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * returning the result to the caller.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; value = <a href="parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value, <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(value),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_ASSIGNMENT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (value == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;specified value cannot be cast to type </span><span class="Special">%s</span><span class="Constant"> for column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(colType), colName),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(val))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Evaluate the expression, if needed, assigning the partition key's data<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * type and collation to the resulting Const node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(value, Const))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = (Node *) <a href="../optimizer/plan/planner.c.html#L6457" title="optimizer/plan/planner.c:6457">expression_planner</a>((Expr *) value);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; value = (Node *) <a href="../optimizer/util/clauses.c.html#L4960" title="optimizer/util/clauses.c:4960">evaluate_expr</a>((Expr *) value, colType, colTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; partCollation);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(value, Const))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;could not evaluate partition bound expression&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the expression is already a Const, as is often the case, we can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regc_lex.c.html#L982" title="regex/regc_lex.c:982">skip</a> the rather expensive steps above.&nbsp; But we still have to insert<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the right collation, since <a href="parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a> doesn't handle<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ((Const *) value)-&gt;constcollid = partCollation;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Attach original expression's <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> location to the Const, so that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that's what will be reported for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> later errors related to this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * partition bound.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ((Const *) value)-&gt;location = <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(val);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Const *) value;<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
