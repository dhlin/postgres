<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>parser/analyze.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>parser/analyze.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L58">post_parse_analyze_hook</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1225">BuildOnConflictExcludedTargetlist</a></li>
<li><a href="#L3238">CheckSelectLocking</a></li>
<li><a href="#L3213">LCS_asString</a></li>
<li><a href="#L485">analyze_requires_snapshot</a></li>
<li><a href="#L3529">applyLockingClause</a></li>
<li><a href="#L1295">count_rowexpr_columns</a></li>
<li><a href="#L2334">determineRecursiveColTypes</a></li>
<li><a href="#L1956">makeSortGroupClauseForSetOp</a></li>
<li><a href="#L104">parse_analyze_fixedparams</a></li>
<li><a href="#L144">parse_analyze_varparams</a></li>
<li><a href="#L185">parse_analyze_withcb</a></li>
<li><a href="#L221">parse_sub_analyze</a></li>
<li><a href="#L441">stmt_requires_parse_analysis</a></li>
<li><a href="#L3589">test_raw_expression_coverage</a></li>
<li><a href="#L3088">transformCallStmt</a></li>
<li><a href="#L3013">transformCreateTableAsStmt</a></li>
<li><a href="#L2868">transformDeclareCursorStmt</a></li>
<li><a href="#L508">transformDeleteStmt</a></li>
<li><a href="#L2961">transformExplainStmt</a></li>
<li><a href="#L1008">transformInsertRow</a></li>
<li><a href="#L580">transformInsertStmt</a></li>
<li><a href="#L3302">transformLockingClause</a></li>
<li><a href="#L1118">transformOnConflictClause</a></li>
<li><a href="#L272">transformOptionalSelectInto</a></li>
<li><a href="#L2619">transformPLAssignStmt</a></li>
<li><a href="#L2388">transformReturnStmt</a></li>
<li><a href="#L2560">transformReturningList</a></li>
<li><a href="#L1337">transformSelectStmt</a></li>
<li><a href="#L1699">transformSetOperationStmt</a></li>
<li><a href="#L2003">transformSetOperationTree</a></li>
<li><a href="#L311">transformStmt</a></li>
<li><a href="#L248">transformTopLevelStmt</a></li>
<li><a href="#L2419">transformUpdateStmt</a></li>
<li><a href="#L2485">transformUpdateTargetList</a></li>
<li><a href="#L1480">transformValuesClause</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transform the raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree into a query tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * For optimizable statements, we are careful to obtain a suitable lock on<br/></li>
<li></span><span class="Comment"> * each referenced table, and other modules of the backend preserve or<br/></li>
<li></span><span class="Comment"> * re-obtain these locks <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> depending on the results.&nbsp; It is therefore<br/></li>
<li></span><span class="Comment"> * okay to do significant semantic analysis of these statements.&nbsp; For<br/></li>
<li></span><span class="Comment"> * utility commands, no locks are obtained here (and if they were, we could<br/></li>
<li></span><span class="Comment"> * not be sure we'd still have them at execution).&nbsp; Hence the general rule<br/></li>
<li></span><span class="Comment"> * for utility commands is to just <a href="../regex/regcomp.c.html#L2491" title="regex/regcomp.c:2491">dump</a> them into a Query node untransformed.<br/></li>
<li></span><span class="Comment"> * DECLARE CURSOR, EXPLAIN, and CREATE TABLE AS are exceptions because they<br/></li>
<li></span><span class="Comment"> * contain optimizable statements, which we should transform.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; src/backend/parser/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/sysattr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_proc.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;commands/defrem.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;miscadmin.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/makefuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/queryjumble.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;optimizer/optimizer.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/<a href="../regex/regc_nfa.c.html#L3016" title="regex/regc_nfa.c:3016">analyze</a>.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_agg.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_clause.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_collate.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_cte.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_expr.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_func.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_merge.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_oper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_param.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_relation.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_target.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parsetree.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/backend_status.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/rel.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/* Hook for plugins to get control at end of <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis */<br/></li>
<li><a id="L58">&#x200c;</a></span>post_parse_analyze_hook_type <span class="linkable">post_parse_analyze_hook</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><span class="Type">static</span> Query *<a href="#L272" title="parser/analyze.c:272">transformOptionalSelectInto</a>(ParseState *pstate, Node *parseTree);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L508" title="parser/analyze.c:508">transformDeleteStmt</a>(ParseState *pstate, DeleteStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L580" title="parser/analyze.c:580">transformInsertStmt</a>(ParseState *pstate, InsertStmt *stmt);<br/></li>
<li><span class="Type">static</span> OnConflictExpr *<a href="#L1118" title="parser/analyze.c:1118">transformOnConflictClause</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; OnConflictClause *onConflictClause);<br/></li>
<li><span class="Type">static</span> <span class="Type">int</span>&nbsp; &nbsp; <a href="#L1295" title="parser/analyze.c:1295">count_rowexpr_columns</a>(ParseState *pstate, Node *expr);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L1337" title="parser/analyze.c:1337">transformSelectStmt</a>(ParseState *pstate, SelectStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L1480" title="parser/analyze.c:1480">transformValuesClause</a>(ParseState *pstate, SelectStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L1699" title="parser/analyze.c:1699">transformSetOperationStmt</a>(ParseState *pstate, SelectStmt *stmt);<br/></li>
<li><span class="Type">static</span> Node *<a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a>(ParseState *pstate, SelectStmt *stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, List **targetlist);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L2334" title="parser/analyze.c:2334">determineRecursiveColTypes</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *larg, List *nrtargetlist);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L2388" title="parser/analyze.c:2388">transformReturnStmt</a>(ParseState *pstate, ReturnStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L2419" title="parser/analyze.c:2419">transformUpdateStmt</a>(ParseState *pstate, UpdateStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L2619" title="parser/analyze.c:2619">transformPLAssignStmt</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; PLAssignStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L2868" title="parser/analyze.c:2868">transformDeclareCursorStmt</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; DeclareCursorStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L2961" title="parser/analyze.c:2961">transformExplainStmt</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ExplainStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L3013" title="parser/analyze.c:3013">transformCreateTableAsStmt</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; CreateTableAsStmt *stmt);<br/></li>
<li><span class="Type">static</span> Query *<a href="#L3088" title="parser/analyze.c:3088">transformCallStmt</a>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CallStmt *stmt);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L3302" title="parser/analyze.c:3302">transformLockingClause</a>(ParseState *pstate, Query *qry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockingClause *lc, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> pushedDown);<br/></li>
<li><span class="PreProc">#ifdef RAW_EXPRESSION_COVERAGE_TEST<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L3589" title="parser/analyze.c:3589">test_raw_expression_coverage</a>(Node *node, <span class="Type">void</span> *context);<br/></li>
<li><span class="PreProc">#endif<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L104" title="parser/analyze.c:104">parse_analyze_fixedparams</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Analyze a raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree and transform it to Query form.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Optionally, information about $n parameter types can be supplied.<br/></li>
<li></span><span class="Comment"> * References to $n indexes not defined by paramTypes[] are disallowed.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The result is a Query node.&nbsp; Optimizable statements require considerable<br/></li>
<li></span><span class="Comment"> * transformation, while utility-type statements are simply hung off<br/></li>
<li></span><span class="Comment"> * a dummy CMD_UTILITY Query node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L104">&#x200c;</a><span class="linkable">parse_analyze_fixedparams</span>(RawStmt *parseTree, <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> Oid *paramTypes, <span class="Type">int</span> numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; JumbleState *jstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sourceText != <span class="Constant">NULL</span>); <span class="Comment">/* required as of 8.4 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = sourceText;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (numParams &gt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_param.c.html#L67" title="parser/parse_param.c:67">setup_parse_fixed_parameters</a>(pstate, paramTypes, numParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_queryEnv = queryEnv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="#L248" title="parser/analyze.c:248">transformTopLevelStmt</a>(pstate, parseTree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsQueryIdEnabled())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jstate = <a href="../nodes/queryjumblefuncs.c.html#L106" title="nodes/queryjumblefuncs.c:106">JumbleQuery</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L58" title="parser/analyze.c:58">post_parse_analyze_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L58" title="parser/analyze.c:58">post_parse_analyze_hook</a>) (pstate, query, jstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L613" title="utils/activity/backend_status.c:613">pgstat_report_query_id</a>(query-&gt;queryId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L144" title="parser/analyze.c:144">parse_analyze_varparams</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This variant is used when it's okay to deduce information about $n<br/></li>
<li></span><span class="Comment"> * symbol datatypes from context.&nbsp; The passed-in paramTypes[] array can<br/></li>
<li></span><span class="Comment"> * be modified or enlarged (via <a href="../utils/mmgr/mcxt.c.html#L1540" title="utils/mmgr/mcxt.c:1540">repalloc</a>).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L144">&#x200c;</a><span class="linkable">parse_analyze_varparams</span>(RawStmt *parseTree, <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid **paramTypes, <span class="Type">int</span> *numParams,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; JumbleState *jstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sourceText != <span class="Constant">NULL</span>); <span class="Comment">/* required as of 8.4 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = sourceText;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_param.c.html#L83" title="parser/parse_param.c:83">setup_parse_variable_parameters</a>(pstate, paramTypes, numParams);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_queryEnv = queryEnv;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="#L248" title="parser/analyze.c:248">transformTopLevelStmt</a>(pstate, parseTree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure all is well with parameter types */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_param.c.html#L268" title="parser/parse_param.c:268">check_variable_parameters</a>(pstate, query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsQueryIdEnabled())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jstate = <a href="../nodes/queryjumblefuncs.c.html#L106" title="nodes/queryjumblefuncs.c:106">JumbleQuery</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L58" title="parser/analyze.c:58">post_parse_analyze_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L58" title="parser/analyze.c:58">post_parse_analyze_hook</a>) (pstate, query, jstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L613" title="utils/activity/backend_status.c:613">pgstat_report_query_id</a>(query-&gt;queryId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L185" title="parser/analyze.c:185">parse_analyze_withcb</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This variant is used when the caller supplies their own parser callback to<br/></li>
<li></span><span class="Comment"> * resolve parameters and possibly other things.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L185">&#x200c;</a><span class="linkable">parse_analyze_withcb</span>(RawStmt *parseTree, <span class="Type">const</span> <span class="Type">char</span> *sourceText,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParserSetupHook parserSetup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">void</span> *parserSetupArg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/misc/queryenvironment.c.html#L32" title="utils/misc/queryenvironment.c:32">QueryEnvironment</a> *queryEnv)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(<span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li>&nbsp; &nbsp; JumbleState *jstate = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(sourceText != <span class="Constant">NULL</span>); <span class="Comment">/* required as of 8.4 */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_sourcetext = sourceText;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_queryEnv = queryEnv;<br/></li>
<li>&nbsp; &nbsp; (*parserSetup) (pstate, parserSetupArg);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="#L248" title="parser/analyze.c:248">transformTopLevelStmt</a>(pstate, parseTree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsQueryIdEnabled())<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; jstate = <a href="../nodes/queryjumblefuncs.c.html#L106" title="nodes/queryjumblefuncs.c:106">JumbleQuery</a>(query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L58" title="parser/analyze.c:58">post_parse_analyze_hook</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (*<a href="#L58" title="parser/analyze.c:58">post_parse_analyze_hook</a>) (pstate, query, jstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/activity/backend_status.c.html#L613" title="utils/activity/backend_status.c:613">pgstat_report_query_id</a>(query-&gt;queryId, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L221" title="parser/analyze.c:221">parse_sub_analyze</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Entry point for recursively analyzing a sub-statement.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L221">&#x200c;</a><span class="linkable">parse_sub_analyze</span>(Node *parseTree, ParseState *parentParseState,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CommonTableExpr *parentCTE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> locked_from_parent,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> resolve_unknowns)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseState *pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(parentParseState);<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_parent_cte = parentCTE;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_locked_from_parent = locked_from_parent;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_resolve_unknowns = resolve_unknowns;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; query = <a href="#L311" title="parser/analyze.c:311">transformStmt</a>(pstate, parseTree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> query;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L248" title="parser/analyze.c:248">transformTopLevelStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transform a Parse tree into a Query tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This function is just responsible for transferring statement location data<br/></li>
<li></span><span class="Comment"> * from the RawStmt into the finished Query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L248">&#x200c;</a><span class="linkable">transformTopLevelStmt</span>(ParseState *pstate, RawStmt *parseTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We're at top level, so allow SELECT INTO */<br/></li>
<li></span>&nbsp; &nbsp; result = <a href="#L272" title="parser/analyze.c:272">transformOptionalSelectInto</a>(pstate, parseTree-&gt;stmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;stmt_location = parseTree-&gt;stmt_location;<br/></li>
<li>&nbsp; &nbsp; result-&gt;stmt_len = parseTree-&gt;stmt_len;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L272" title="parser/analyze.c:272">transformOptionalSelectInto</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; If SELECT has INTO, convert it to CREATE TABLE AS.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The only thing we do here that we don't do in <a href="#L311" title="parser/analyze.c:311">transformStmt</a>() is to<br/></li>
<li></span><span class="Comment"> * convert SELECT ... INTO into CREATE TABLE AS.&nbsp; Since utility statements<br/></li>
<li></span><span class="Comment"> * aren't allowed within larger statements, this is only allowed at the top<br/></li>
<li></span><span class="Comment"> * of the <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree, and so we only try it <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> entering the recursive<br/></li>
<li></span><span class="Comment"> * <a href="#L311" title="parser/analyze.c:311">transformStmt</a>() processing.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L272">&#x200c;</a><span class="linkable">transformOptionalSelectInto</span>(ParseState *pstate, Node *parseTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(parseTree, SelectStmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; SelectStmt *stmt = (SelectStmt *) parseTree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* If it's a set-operation tree, drill down to leftmost SelectStmt */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (stmt &amp;&amp; stmt-&gt;op != SETOP_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt = stmt-&gt;larg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stmt &amp;&amp; IsA(stmt, SelectStmt) &amp;&amp; stmt-&gt;larg == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;intoClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; CreateTableAsStmt *ctas = makeNode(CreateTableAsStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctas-&gt;query = parseTree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctas-&gt;into = stmt-&gt;intoClause;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctas-&gt;objtype = OBJECT_TABLE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ctas-&gt;is_select_into = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the intoClause from the SelectStmt.&nbsp; This makes it safe<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for <a href="#L1337" title="parser/analyze.c:1337">transformSelectStmt</a> to complain if it finds intoClause set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (implying that the INTO appeared in a disallowed place).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;intoClause = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parseTree = (Node *) ctas;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L311" title="parser/analyze.c:311">transformStmt</a>(pstate, parseTree);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L311" title="parser/analyze.c:311">transformStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; recursively transform a Parse tree into a Query tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Query *<br/></li>
<li><a id="L311">&#x200c;</a><span class="linkable">transformStmt</span>(ParseState *pstate, Node *parseTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We apply RAW_EXPRESSION_COVERAGE_TEST testing to basic DML statements;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we can't just run it on everything because raw_expression_tree_walker()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't claim to handle utility statements.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span><span class="PreProc">#ifdef RAW_EXPRESSION_COVERAGE_TEST<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(parseTree))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SelectStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_InsertStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_UpdateStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_DeleteStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<span class="Type">void</span>) <a href="#L3589" title="parser/analyze.c:3589">test_raw_expression_coverage</a>(parseTree, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RAW_EXPRESSION_COVERAGE_TEST */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Caution: when changing the set of statement types that have non-default<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing here, see also <a href="#L441" title="parser/analyze.c:441">stmt_requires_parse_analysis</a>() and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L485" title="parser/analyze.c:485">analyze_requires_snapshot</a>().<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(parseTree))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Optimizable statements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_InsertStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L580" title="parser/analyze.c:580">transformInsertStmt</a>(pstate, (InsertStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_DeleteStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L508" title="parser/analyze.c:508">transformDeleteStmt</a>(pstate, (DeleteStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_UpdateStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2419" title="parser/analyze.c:2419">transformUpdateStmt</a>(pstate, (UpdateStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="parse_merge.c.html#L107" title="parser/parse_merge.c:107">transformMergeStmt</a>(pstate, (MergeStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SelectStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SelectStmt *n = (SelectStmt *) parseTree;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (n-&gt;valuesLists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1480" title="parser/analyze.c:1480">transformValuesClause</a>(pstate, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (n-&gt;op == SETOP_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1337" title="parser/analyze.c:1337">transformSelectStmt</a>(pstate, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L1699" title="parser/analyze.c:1699">transformSetOperationStmt</a>(pstate, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ReturnStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2388" title="parser/analyze.c:2388">transformReturnStmt</a>(pstate, (ReturnStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_PLAssignStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2619" title="parser/analyze.c:2619">transformPLAssignStmt</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (PLAssignStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_DeclareCursorStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2868" title="parser/analyze.c:2868">transformDeclareCursorStmt</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (DeclareCursorStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ExplainStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L2961" title="parser/analyze.c:2961">transformExplainStmt</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (ExplainStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CreateTableAsStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L3013" title="parser/analyze.c:3013">transformCreateTableAsStmt</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (CreateTableAsStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CallStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L3088" title="parser/analyze.c:3088">transformCallStmt</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (CallStmt *) parseTree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * other statements don't require <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> transformation; just return<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the original parsetree with a Query node plastered on top.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result-&gt;utilityStmt = (Node *) parseTree;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Mark as original query until we learn differently */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;querySource = QSRC_ORIGINAL;<br/></li>
<li>&nbsp; &nbsp; result-&gt;canSetTag = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L441" title="parser/analyze.c:441">stmt_requires_parse_analysis</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true if <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis will do anything non-trivial<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; with the given raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Generally, this should return true for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> statement type for which<br/></li>
<li></span><span class="Comment"> * <a href="#L311" title="parser/analyze.c:311">transformStmt</a>() does more than wrap a CMD_UTILITY Query around it.<br/></li>
<li></span><span class="Comment"> * When it returns false, the caller can assume that there is no situation<br/></li>
<li></span><span class="Comment"> * in which <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis of the raw statement could need to be re-done.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Currently, since the rewriter and <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> do nothing for CMD_UTILITY<br/></li>
<li></span><span class="Comment"> * Queries, a false result means that the entire <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis/rewrite/plan<br/></li>
<li></span><span class="Comment"> * pipeline will never need to be re-done.&nbsp; If that ever changes, callers<br/></li>
<li></span><span class="Comment"> * will likely need adjustment.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L441">&#x200c;</a></span><span class="linkable">stmt_requires_parse_analysis</span>(RawStmt *parseTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (nodeTag(parseTree-&gt;stmt))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Optimizable statements<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_InsertStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_DeleteStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_UpdateStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_MergeStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_SelectStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ReturnStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_PLAssignStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Special cases<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_DeclareCursorStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_ExplainStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CreateTableAsStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> T_CallStmt:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* all other statements just get wrapped in a CMD_UTILITY Query */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L485" title="parser/analyze.c:485">analyze_requires_snapshot</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Returns true if a snapshot must be set <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> doing <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; on the given raw <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> tree.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L485">&#x200c;</a></span><span class="linkable">analyze_requires_snapshot</span>(RawStmt *parseTree)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Currently, this should return true in exactly the same cases that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="#L441" title="parser/analyze.c:441">stmt_requires_parse_analysis</a>() does, so we just invoke that function<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * rather than duplicating it.&nbsp; We keep the two entry points separate for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * clarity of callers, since from the callers' standpoint these are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * different conditions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * While there may someday be a statement type for which <a href="#L311" title="parser/analyze.c:311">transformStmt</a>()<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * does something nontrivial and yet no snapshot is needed for that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing, it seems likely that making such a choice would be fragile.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If you want to install an exception, document the reasoning for it in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * comment.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L441" title="parser/analyze.c:441">stmt_requires_parse_analysis</a>(parseTree);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L508" title="parser/analyze.c:508">transformDeleteStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms a <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> Statement<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L508">&#x200c;</a><span class="linkable">transformDeleteStmt</span>(ParseState *pstate, DeleteStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_DELETE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the WITH clause independently of all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;withClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasRecursive = stmt-&gt;withClause-&gt;recursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;cteList = <a href="parse_cte.c.html#L109" title="parser/parse_cte.c:109">transformWithClause</a>(pstate, stmt-&gt;withClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasModifyingCTE = pstate-&gt;p_hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* set up <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table with just the result rel */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;resultRelation = <a href="parse_clause.c.html#L180" title="parser/parse_clause.c:180">setTargetTable</a>(pstate, stmt-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;relation-&gt;inh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ACL_DELETE);<br/></li>
<li>&nbsp; &nbsp; nsitem = pstate-&gt;p_target_nsitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* there's no DISTINCT in DELETE */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;distinctClause = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* subqueries in USING cannot access the result relation */<br/></li>
<li></span>&nbsp; &nbsp; nsitem-&gt;p_lateral_only = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; nsitem-&gt;p_lateral_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The USING clause is non-standard SQL syntax, and is equivalent in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * functionality to the FROM list that can be specified for UPDATE. The<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * USING keyword is used rather than FROM because FROM is already a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * keyword in the DELETE syntax.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_clause.c.html#L114" title="parser/parse_clause.c:114">transformFromClause</a>(pstate, stmt-&gt;usingClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remaining clauses can reference the result relation normally */<br/></li>
<li></span>&nbsp; &nbsp; nsitem-&gt;p_lateral_only = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; nsitem-&gt;p_lateral_ok = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qual = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate, stmt-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_WHERE, <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;returningList = <a href="#L2560" title="parser/analyze.c:2560">transformReturningList</a>(pstate, stmt-&gt;returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_RETURNING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done building the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table and jointree */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasWindowFuncs = pstate-&gt;p_hasWindowFuncs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasAggs = pstate-&gt;p_hasAggs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this must be done after collations, for reliable comparison of exprs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_agg.c.html#L1080" title="parser/parse_agg.c:1080">parseCheckAggregates</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L580" title="parser/analyze.c:580">transformInsertStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transform an <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> Statement<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L580">&#x200c;</a><span class="linkable">transformInsertStmt</span>(ParseState *pstate, InsertStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; SelectStmt *selectStmt = (SelectStmt *) stmt-&gt;selectStmt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exprList = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isGeneralSelect;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_rtable;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sub_namespace;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *icolumns;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *attrnos;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *icols;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *attnos;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isOnConflictUpdate;<br/></li>
<li>&nbsp; &nbsp; AclMode&nbsp; &nbsp; &nbsp; &nbsp; targetPerms;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* There can't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> outer WITH to worry about */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pstate-&gt;p_ctenamespace == NIL);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_INSERT;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_is_insert = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the WITH clause independently of all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;withClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasRecursive = stmt-&gt;withClause-&gt;recursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;cteList = <a href="parse_cte.c.html#L109" title="parser/parse_cte.c:109">transformWithClause</a>(pstate, stmt-&gt;withClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasModifyingCTE = pstate-&gt;p_hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;override = stmt-&gt;override;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; isOnConflictUpdate = (stmt-&gt;onConflictClause &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;onConflictClause-&gt;action == ONCONFLICT_UPDATE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We have three cases to deal with: DEFAULT VALUES (selectStmt == NULL),<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VALUES list, or general SELECT input.&nbsp; We special-case VALUES, both for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * efficiency and so we can handle DEFAULT specifications.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The grammar allows attaching ORDER BY, LIMIT, FOR UPDATE, or WITH to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VALUES clause.&nbsp; If we have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> of those, treat it as a general SELECT;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * so it will work, but you can't use DEFAULT items together with those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; isGeneralSelect = (selectStmt &amp;&amp; (selectStmt-&gt;valuesLists == NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectStmt-&gt;sortClause != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectStmt-&gt;limitOffset != <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectStmt-&gt;limitCount != <span class="Constant">NULL</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectStmt-&gt;lockingClause != NIL ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectStmt-&gt;withClause != <span class="Constant">NULL</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If a non-nil rangetable/namespace was passed in, and we are doing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INSERT/SELECT, arrange to pass the rangetable/rteperminfos/namespace<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * down to the SELECT.&nbsp; This can only happen if we are inside a CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RULE, and in that case we want the rule's OLD and NEW rtable entries to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * appear as part of the SELECT's rtable, not as outer references for it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * (Kluge!) The SELECT's joinlist is not affected however.&nbsp; We must do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> adding the target table to the INSERT's rtable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isGeneralSelect)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_rtable = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_rteperminfos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_namespace = pstate-&gt;p_namespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_namespace = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_rtable = NIL;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* not used, but keep compiler quiet */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_rteperminfos = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_namespace = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Must get write lock on INSERT target table <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> scanning SELECT, else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * we will grab the wrong kind of initial lock if the target table is also<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mentioned in the SELECT part.&nbsp; Note that the target table is not added<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * to the joinlist or namespace.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; targetPerms = ACL_INSERT;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isOnConflictUpdate)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetPerms |= ACL_UPDATE;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;resultRelation = <a href="parse_clause.c.html#L180" title="parser/parse_clause.c:180">setTargetTable</a>(pstate, stmt-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>, targetPerms);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Validate stmt-&gt;cols list, or build default list if no list given */<br/></li>
<li></span>&nbsp; &nbsp; icolumns = <a href="parse_target.c.html#L1015" title="parser/parse_target.c:1015">checkInsertTargets</a>(pstate, stmt-&gt;cols, &amp;attrnos);<br/></li>
<li>&nbsp; &nbsp; Assert(list_length(icolumns) == list_length(attrnos));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Determine which variant of INSERT we have.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (selectStmt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We have INSERT ... DEFAULT VALUES.&nbsp; We can handle this case by<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * emitting an empty targetlist --- all columns will be defaulted when<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> expands the targetlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = NIL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (isGeneralSelect)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We make the sub-pstate a child of the outer pstate so that it can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> Param definitions supplied from above.&nbsp; Since the outer<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * pstate's rtable and namespace are presently empty, there are no<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * side-effects of exposing names the sub-SELECT shouldn't be able to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * see.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ParseState *sub_pstate = <a href="parse_node.c.html#L39" title="parser/parse_node.c:39">make_parsestate</a>(pstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *selectQuery;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process the source SELECT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * It is important that this be handled just like a standalone SELECT;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise the behavior of SELECT within INSERT might be different<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * from a stand-alone SELECT. (Indeed, Postgres up through 6.5 had<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * bugs of just that nature...)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The sole exception is that we prevent resolving unknown-type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outputs as TEXT.&nbsp; This does not change the semantics since if the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * column type matters semantically, it would have been resolved to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * something else anyway.&nbsp; Doing this lets us resolve such outputs as<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the target column's type, which we handle below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_rtable = sub_rtable;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_rteperminfos = sub_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_joinexprs = NIL;&nbsp; &nbsp; <span class="Comment">/* sub_rtable has no joins */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_nullingrels = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_namespace = sub_namespace;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sub_pstate-&gt;p_resolve_unknowns = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; selectQuery = <a href="#L311" title="parser/analyze.c:311">transformStmt</a>(sub_pstate, stmt-&gt;selectStmt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L72" title="parser/parse_node.c:72">free_parsestate</a>(sub_pstate);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* The grammar should have produced a SELECT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(selectQuery, Query) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; selectQuery-&gt;commandType != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected non-SELECT command in INSERT ... SELECT&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the source be a subquery in the INSERT's rangetable, and add<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it to the INSERT's joinlist (but not the namespace).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L1638" title="parser/parse_relation.c:1638">addRangeTableEntryForSubquery</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; selectQuery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;*SELECT*&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate an expression list for the INSERT that selects all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * non-resjunk columns from the subquery.&nbsp; (INSERT's tlist must be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * separate from the subquery's tlist because we may add columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * insert datatype coercions, etc.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * HACK: unknown-type constants and params in the SELECT's targetlist<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * are copied up as-is rather than being referenced as subquery<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * outputs.&nbsp; This is to ensure that when we try to coerce them to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the target column's datatype, the right things happen (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * special cases in <a href="parse_coerce.c.html#L157" title="parser/parse_coerce.c:157">coerce_type</a>).&nbsp; Otherwise, this fails:<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *&nbsp; &nbsp; &nbsp; &nbsp; INSERT INTO foo SELECT 'bar', ... FROM baz<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *----------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, selectQuery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;expr &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (IsA(tle-&gt;expr, Const) || IsA(tle-&gt;expr, Param)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr) == UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = tle-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = <a href="../nodes/makefuncs.c.html#L105" title="nodes/makefuncs.c:105">makeVarFromTargetEntry</a>(nsitem-&gt;p_rtindex, tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var-&gt;location = <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) tle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Expr *) var;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(exprList, expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare row for assignment to target table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = <a href="#L1008" title="parser/analyze.c:1008">transformInsertRow</a>(pstate, exprList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icolumns, attrnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (list_length(selectStmt-&gt;valuesLists) &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process INSERT ... VALUES with multiple VALUES sublists. We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * generate a VALUES RTE holding the transformed expression lists, and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * build up a targetlist containing Vars that reference the VALUES<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exprsLists = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *coltypes = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *coltypmods = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *colcollations = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist_length = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lateral = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(selectStmt-&gt;intoClause == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, selectStmt-&gt;valuesLists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = (List *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do basic expression transformation (same as a ROW() expr, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * allow SetToDefault at top level)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="parse_target.c.html#L220" title="parser/parse_target.c:220">transformExpressionList</a>(pstate, sublist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_VALUES, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All the sublists must be the same length, *after*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * transformation (which might expand '*' into multiple items).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The VALUES RTE can't handle anything different.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sublist_length &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember post-transformation length of first sublist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist_length = list_length(sublist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sublist_length != list_length(sublist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;VALUES lists must all be the same length&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) sublist))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prepare row for assignment to target table.&nbsp; We process <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indirection on the target column specs normally but then strip<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * off the resulting field/array assignment nodes, since we don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want the parsed statement to contain copies of those in each<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * VALUES row.&nbsp; (It's annoying to have to transform the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * indirection specs over and over like this, but avoiding it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * would take some really messy refactoring of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="parse_target.c.html#L683" title="parser/parse_target.c:683">transformAssignmentIndirection</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="#L1008" title="parser/analyze.c:1008">transformInsertRow</a>(pstate, sublist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; icolumns, attrnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must assign collations <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * doesn't process rangetable entries.&nbsp; We just assign all the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collations independently in each row, and don't worry about<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * whether they are consistent vertically.&nbsp; The outer INSERT query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * isn't going to care about the collations of the VALUES columns,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * so it's not worth the effort to identify a common collation for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * each one here.&nbsp; (But note this does have one user-visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * consequence: INSERT ... VALUES won't complain about conflicting<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * explicit COLLATEs in a column, whereas the same VALUES<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * construct in another context would complain.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_collate.c.html#L155" title="parser/parse_collate.c:155">assign_list_collations</a>(pstate, sublist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exprsLists = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(exprsLists, sublist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct column type/typmod/collation lists for the VALUES RTE.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Every expression in each column has been coerced to the type/typmod<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of the corresponding target column or subfield, so it's sufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to look at the <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>/<a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a> of the first row.&nbsp; We don't care<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * about the collation labeling, so just fill in InvalidOid for that.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, (List *) linitial(exprsLists))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *val = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(coltypes, <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(coltypmods, <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(val));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colcollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(colcollations, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Ordinarily there can't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> current-level Vars in the expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * lists, because the namespace was empty ... but if we're inside<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * CREATE RULE, then NEW/OLD references might appear.&nbsp; In that case we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have to mark the VALUES RTE as LATERAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(pstate-&gt;p_rtable) != <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) exprsLists, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lateral = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate the VALUES RTE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L2134" title="parser/parse_relation.c:2134">addRangeTableEntryForValues</a>(pstate, exprsLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; coltypes, coltypmods, colcollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, lateral, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">true</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Generate list of Vars referencing the RTE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = <a href="parse_relation.c.html#L3123" title="parser/parse_relation.c:3123">expandNSItemVars</a>(pstate, nsitem, <span class="Constant">0</span>, -<span class="Constant">1</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Re-apply <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> indirection on the target column specs to the Vars<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = <a href="#L1008" title="parser/analyze.c:1008">transformInsertRow</a>(pstate, exprList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icolumns, attrnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Process INSERT ... VALUES with a single VALUES sublist.&nbsp; We treat<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * this case separately for efficiency.&nbsp; The sublist is just computed<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * directly as the Query's targetlist, with no VALUES RTE.&nbsp; So it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * works just like a SELECT without <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> FROM.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *valuesLists = selectStmt-&gt;valuesLists;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(list_length(valuesLists) == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(selectStmt-&gt;intoClause == <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do basic expression transformation (same as a ROW() expr, but allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * SetToDefault at top level)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = <a href="parse_target.c.html#L220" title="parser/parse_target.c:220">transformExpressionList</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (List *) linitial(valuesLists),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_VALUES_SINGLE,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare row for assignment to target table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprList = <a href="#L1008" title="parser/analyze.c:1008">transformInsertRow</a>(pstate, exprList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;cols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; icolumns, attrnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate query's target list using the computed list of expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Also, mark all the target columns as needing insert permissions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; perminfo = pstate-&gt;p_target_nsitem-&gt;p_perminfo;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;targetList = NIL;<br/></li>
<li>&nbsp; &nbsp; Assert(list_length(exprList) &lt;= list_length(icolumns));<br/></li>
<li>&nbsp; &nbsp; forthree(lc, exprList, icols, icolumns, attnos, attrnos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResTarget&nbsp; *col = lfirst_node(ResTarget, icols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attr_num = (AttrNumber) lfirst_int(attnos);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr_num,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qry-&gt;targetList, tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;insertedCols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(perminfo-&gt;insertedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr_num - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clauses yet to process, set the query namespace to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * contain only the target relation, removing <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> entries added in a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * sub-SELECT or VALUES list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;onConflictClause || stmt-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_namespace = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, pstate-&gt;p_target_nsitem,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process ON CONFLICT, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;onConflictClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;onConflict = <a href="#L1118" title="parser/analyze.c:1118">transformOnConflictClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;onConflictClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process RETURNING, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;returningList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;returningList = <a href="#L2560" title="parser/analyze.c:2560">transformReturningList</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_RETURNING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* done building the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table and jointree */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Prepare an INSERT row for assignment to the target table.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * exprlist: transformed expressions for source <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a>; these might come from<br/></li>
<li></span><span class="Comment"> * a VALUES row, or be Vars referencing a sub-SELECT or VALUES RTE output.<br/></li>
<li></span><span class="Comment"> * stmtcols: original target-columns spec for INSERT (we just test for NIL)<br/></li>
<li></span><span class="Comment"> * icolumns: effective target-columns spec (list of ResTarget)<br/></li>
<li></span><span class="Comment"> * attrnos: integer column numbers (must be same length as icolumns)<br/></li>
<li></span><span class="Comment"> * strip_indirection: if true, remove <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> field/array assignment nodes<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1008">&#x200c;</a><span class="linkable">transformInsertRow</span>(ParseState *pstate, List *exprlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; List *stmtcols, List *icolumns, List *attrnos,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> strip_indirection)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *icols;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *attnos;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check length of expr list.&nbsp; It must not have more expressions than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there are target columns.&nbsp; We allow fewer, but only if no explicit<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * columns list was given (the remaining columns are implicitly<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * defaulted).&nbsp; Note we must check this *after* transformation because<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that could expand '*' into multiple items.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(exprlist) &gt; list_length(icolumns))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INSERT has more expressions than target columns&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(list_nth(exprlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(icolumns))))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmtcols != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; list_length(exprlist) &lt; list_length(icolumns))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We can get here for cases like INSERT ... SELECT (a,b,c) FROM ...<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * where the user accidentally created a RowExpr instead of separate<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns.&nbsp; Add a suitable hint if that seems to be the problem,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> error message is quite misleading for this case.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (If there's no stmtcols, you'll get something about data type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * mismatch, which is less misleading so we don't worry about giving a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * hint in that case.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INSERT has more target columns than expressions&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ((list_length(exprlist) == <span class="Constant">1</span> &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1295" title="parser/analyze.c:1295">count_rowexpr_columns</a>(pstate, linitial(exprlist)) ==<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(icolumns)) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;The insertion source is a row expression containing the same number of columns expected by the INSERT. Did you accidentally use extra parentheses?&quot;</span>) : <span class="Constant">0</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(list_nth(icolumns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_length(exprlist))))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Prepare columns for assignment to target table.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; result = NIL;<br/></li>
<li>&nbsp; &nbsp; forthree(lc, exprlist, icols, icolumns, attnos, attrnos)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *expr = (Expr *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResTarget&nbsp; *col = lfirst_node(ResTarget, icols);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno = lfirst_int(attnos);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; expr = <a href="parse_target.c.html#L452" title="parser/parse_target.c:452">transformAssignedExpr</a>(pstate, expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_INSERT_TARGET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; col-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; col-&gt;indirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; col-&gt;location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strip_indirection)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We need to remove top-level FieldStores and SubscriptingRefs,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as well as <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> CoerceToDomain appearing above one of those ---<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * but not a CoerceToDomain that isn't above one of those.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (expr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Expr&nbsp; &nbsp; &nbsp;&nbsp; *subexpr = expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (IsA(subexpr, CoerceToDomain))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; subexpr = ((CoerceToDomain *) subexpr)-&gt;arg;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(subexpr, FieldStore))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FieldStore *fstore = (FieldStore *) subexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Expr *) linitial(fstore-&gt;newvals);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(subexpr, SubscriptingRef))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SubscriptingRef *sbsref = (SubscriptingRef *) subexpr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sbsref-&gt;refassgnexpr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = sbsref-&gt;refassgnexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, expr);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1118" title="parser/analyze.c:1118">transformOnConflictClause</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms an OnConflictClause in an INSERT<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> OnConflictExpr *<br/></li>
<li><a id="L1118">&#x200c;</a><span class="linkable">transformOnConflictClause</span>(ParseState *pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; OnConflictClause *onConflictClause)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *exclNSItem = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *arbiterElems;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *arbiterWhere;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arbiterConstraint;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *onConflictSet = NIL;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *onConflictWhere = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exclRelIndex = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exclRelTlist = NIL;<br/></li>
<li>&nbsp; &nbsp; OnConflictExpr *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If this is ON CONFLICT ... UPDATE, first create the <a href="../regex/regc_locale.c.html#L412" title="regex/regc_locale.c:412">range</a> table entry<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * for the EXCLUDED pseudo relation, so that that will be present while<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * processing arbiter expressions.&nbsp; (You can't actually reference it from<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there, but this provides a useful error message if you try.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (onConflictClause-&gt;action == ONCONFLICT_UPDATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Relation&nbsp; &nbsp; targetrel = pstate-&gt;p_target_relation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *exclRte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exclNSItem = <a href="parse_relation.c.html#L1567" title="parser/parse_relation.c:1567">addRangeTableEntryForRelation</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; RowExclusiveLock,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(<span class="Constant">&quot;excluded&quot;</span>, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exclRte = exclNSItem-&gt;p_rte;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; exclRelIndex = exclNSItem-&gt;p_rtindex;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relkind is set to composite to signal that we're not dealing with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * an actual relation, and no permission checks are required on it.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (We'll check the actual target relation, instead.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exclRte-&gt;relkind = RELKIND_COMPOSITE_TYPE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Create EXCLUDED rel's targetlist for use by EXPLAIN */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exclRelTlist = <a href="#L1225" title="parser/analyze.c:1225">BuildOnConflictExcludedTargetlist</a>(targetrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; exclRelIndex);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process the arbiter clause, ON CONFLICT ON (...) */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_clause.c.html#L3298" title="parser/parse_clause.c:3298">transformOnConflictArbiter</a>(pstate, onConflictClause, &amp;arbiterElems,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;arbiterWhere, &amp;arbiterConstraint);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process DO UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (onConflictClause-&gt;action == ONCONFLICT_UPDATE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Expressions in the UPDATE targetlist need to be handled like UPDATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not INSERT.&nbsp; We don't need to save/restore this because all INSERT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expressions have been parsed already.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_is_insert = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Add the EXCLUDED pseudo relation to the query namespace, making it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * available in the UPDATE subexpressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, exclNSItem, <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Now transform the UPDATE subexpressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; onConflictSet =<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2485" title="parser/analyze.c:2485">transformUpdateTargetList</a>(pstate, onConflictClause-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; onConflictWhere = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; onConflictClause-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_WHERE, <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Remove the EXCLUDED pseudo relation from the query namespace, since<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's not supposed to be available in RETURNING.&nbsp; (Maybe someday we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could allow that, and drop this step.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Assert((ParseNamespaceItem *) llast(pstate-&gt;p_namespace) == exclNSItem);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_namespace = <a href="../nodes/list.c.html#L957" title="nodes/list.c:957">list_delete_last</a>(pstate-&gt;p_namespace);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Finally, build ON CONFLICT DO [NOTHING | UPDATE] expression */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(OnConflictExpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result-&gt;action = onConflictClause-&gt;action;<br/></li>
<li>&nbsp; &nbsp; result-&gt;arbiterElems = arbiterElems;<br/></li>
<li>&nbsp; &nbsp; result-&gt;arbiterWhere = arbiterWhere;<br/></li>
<li>&nbsp; &nbsp; result-&gt;constraint = arbiterConstraint;<br/></li>
<li>&nbsp; &nbsp; result-&gt;onConflictSet = onConflictSet;<br/></li>
<li>&nbsp; &nbsp; result-&gt;onConflictWhere = onConflictWhere;<br/></li>
<li>&nbsp; &nbsp; result-&gt;exclRelIndex = exclRelIndex;<br/></li>
<li>&nbsp; &nbsp; result-&gt;exclRelTlist = exclRelTlist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1225" title="parser/analyze.c:1225">BuildOnConflictExcludedTargetlist</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Create target list for the EXCLUDED pseudo-relation of ON CONFLICT,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; representing the columns of targetrel with varno exclRelIndex.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: Exported for use in the rewriter.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L1225">&#x200c;</a><span class="linkable">BuildOnConflictExcludedTargetlist</span>(Relation targetrel,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Index exclRelIndex)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *result = NIL;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attno;<br/></li>
<li>&nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li>&nbsp; &nbsp; TargetEntry *te;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that resnos of the tlist must correspond to attnos of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * underlying relation, hence we need entries for dropped columns too.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (attno = <span class="Constant">0</span>; attno &lt; RelationGetNumberOfAttributes(targetrel); attno++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Form_pg_attribute attr = TupleDescAttr(targetrel-&gt;rd_att, attno);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *name;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attr-&gt;attisdropped)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * can't use atttypid here, but it doesn't really matter what type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the Const claims to be.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = (Var *) <a href="../nodes/makefuncs.c.html#L339" title="nodes/makefuncs.c:339">makeNullConst</a>(INT4OID, -<span class="Constant">1</span>, InvalidOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(exclRelIndex, attno + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;atttypid, attr-&gt;atttypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attr-&gt;attcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(NameStr(attr-&gt;attname));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; te = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; attno + <span class="Constant">1</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, te);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Add a whole-row-Var entry to support references to &quot;EXCLUDED.*&quot;.&nbsp; Like<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the other entries in the EXCLUDED tlist, its resno must match the Var's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * varattno, else the wrong things happen while resolving references in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setrefs.c.&nbsp; This is against normal conventions for targetlists, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * it's okay since we don't use this as a real tlist.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(exclRelIndex, InvalidAttrNumber,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetrel-&gt;rd_rel-&gt;reltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>, InvalidOid, <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; te = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var, InvalidAttrNumber, <span class="Constant">NULL</span>, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; result = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(result, te);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1295" title="parser/analyze.c:1295">count_rowexpr_columns</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; get number of columns contained in a ROW() expression;<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; return -1 if expression isn't a RowExpr or a Var referencing one.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is currently used only for hint purposes, so we aren't terribly<br/></li>
<li></span><span class="Comment"> * tense about recognizing all possible cases.&nbsp; The Var case is interesting<br/></li>
<li></span><span class="Comment"> * because that's what we'll get in the INSERT ... SELECT (...) case.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">int<br/></li>
<li><a id="L1295">&#x200c;</a></span><span class="linkable">count_rowexpr_columns</span>(ParseState *pstate, Node *expr)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, RowExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_length(((RowExpr *) expr)-&gt;args);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, Var))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var = (Var *) expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; AttrNumber&nbsp; &nbsp; attnum = var-&gt;varattno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attnum &gt; <span class="Constant">0</span> &amp;&amp; var-&gt;vartype == RECORDOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rte = <a href="parse_relation.c.html#L537" title="parser/parse_relation.c:537">GetRTEByRangeTablePosn</a>(pstate, var-&gt;varno, var-&gt;varlevelsup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Subselect-in-FROM: examine sub-<a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a>'s output expr */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *ste = <a href="parse_relation.c.html#L3439" title="parser/parse_relation.c:3439">get_tle_by_resno</a>(rte-&gt;subquery-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attnum);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ste == <span class="Constant">NULL</span> || ste-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; expr = (Node *) ste-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (IsA(expr, RowExpr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> list_length(((RowExpr *) expr)-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> -<span class="Constant">1</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1337" title="parser/analyze.c:1337">transformSelectStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms a Select Statement<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: this covers only cases with no set operations and no VALUES lists;<br/></li>
<li></span><span class="Comment"> * see below for the other cases.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1337">&#x200c;</a><span class="linkable">transformSelectStmt</span>(ParseState *pstate, SelectStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_SELECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the WITH clause independently of all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;withClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasRecursive = stmt-&gt;withClause-&gt;recursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;cteList = <a href="parse_cte.c.html#L109" title="parser/parse_cte.c:109">transformWithClause</a>(pstate, stmt-&gt;withClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasModifyingCTE = pstate-&gt;p_hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Complain if we get called from someplace where INTO is not allowed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;intoClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SELECT ... INTO is not allowed here&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) stmt-&gt;intoClause))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make FOR UPDATE/FOR SHARE info available to <a href="parse_relation.c.html#L1470" title="parser/parse_relation.c:1470">addRangeTableEntry</a> */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_locking_clause = stmt-&gt;lockingClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make WINDOW info available for window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, too */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_windowdefs = stmt-&gt;windowClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the FROM clause */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_clause.c.html#L114" title="parser/parse_clause.c:114">transformFromClause</a>(pstate, stmt-&gt;fromClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform targetlist */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;targetList = <a href="parse_target.c.html#L121" title="parser/parse_target.c:121">transformTargetList</a>(pstate, stmt-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_SELECT_TARGET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark column origins */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_target.c.html#L318" title="parser/parse_target.c:318">markTargetListOrigins</a>(pstate, qry-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform WHERE */<br/></li>
<li></span>&nbsp; &nbsp; qual = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate, stmt-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_WHERE, <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial processing of HAVING clause is much like WHERE clause */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;havingQual = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate, stmt-&gt;havingClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_HAVING, <span class="Constant">&quot;HAVING&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform sorting/grouping stuff.&nbsp; Do ORDER BY first because both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="parse_clause.c.html#L2632" title="parser/parse_clause.c:2632">transformGroupClause</a> and <a href="parse_clause.c.html#L2986" title="parser/parse_clause.c:2986">transformDistinctClause</a> need the results. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that these <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can also change the targetList, so it's passed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them by reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;sortClause = <a href="parse_clause.c.html#L2732" title="parser/parse_clause.c:2732">transformSortClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_ORDER_BY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow SQL92 rules */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;groupClause = <a href="parse_clause.c.html#L2632" title="parser/parse_clause.c:2632">transformGroupClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;groupingSets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_GROUP_BY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow SQL92 rules */</span> );<br/></li>
<li>&nbsp; &nbsp; qry-&gt;groupDistinct = stmt-&gt;groupDistinct;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;distinctClause == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;distinctClause = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasDistinctOn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (linitial(stmt-&gt;distinctClause) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We had SELECT DISTINCT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;distinctClause = <a href="parse_clause.c.html#L2986" title="parser/parse_clause.c:2986">transformDistinctClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasDistinctOn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We had SELECT DISTINCT ON */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;distinctClause = <a href="parse_clause.c.html#L3070" title="parser/parse_clause.c:3070">transformDistinctOnClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;sortClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasDistinctOn = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform LIMIT */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;limitOffset = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, stmt-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_OFFSET, <span class="Constant">&quot;OFFSET&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitCount = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, stmt-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_LIMIT, <span class="Constant">&quot;LIMIT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitOption = stmt-&gt;limitOption;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform window clauses after we have seen all window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;windowClause = <a href="parse_clause.c.html#L2765" title="parser/parse_clause.c:2765">transformWindowDefinitions</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pstate-&gt;p_windowdefs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qry-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* resolve <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> still-unresolved output columns as being type text */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_resolve_unknowns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_target.c.html#L288" title="parser/parse_target.c:288">resolveTargetListUnknowns</a>(pstate, qry-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasWindowFuncs = pstate-&gt;p_hasWindowFuncs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasAggs = pstate-&gt;p_hasAggs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, stmt-&gt;lockingClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3302" title="parser/analyze.c:3302">transformLockingClause</a>(pstate, qry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (LockingClause *) lfirst(l), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this must be done after collations, for reliable comparison of exprs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_hasAggs || qry-&gt;groupClause || qry-&gt;groupingSets || qry-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_agg.c.html#L1080" title="parser/parse_agg.c:1080">parseCheckAggregates</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1480" title="parser/analyze.c:1480">transformValuesClause</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms a VALUES clause that's being used as a standalone SELECT<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We build a Query containing a VALUES RTE, rather as if one had written<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SELECT * FROM (VALUES ...) AS &quot;*VALUES*&quot;<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1480">&#x200c;</a><span class="linkable">transformValuesClause</span>(ParseState *pstate, SelectStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *exprsLists = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *coltypes = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *coltypmods = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *colcollations = NIL;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp; **colexprs = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist_length = -<span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; lateral = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc2;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_SELECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Most SELECT stuff doesn't apply in a VALUES clause */<br/></li>
<li></span>&nbsp; &nbsp; Assert(stmt-&gt;distinctClause == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;intoClause == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;targetList == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;fromClause == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;whereClause == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;groupClause == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;havingClause == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;windowClause == NIL);<br/></li>
<li>&nbsp; &nbsp; Assert(stmt-&gt;op == SETOP_NONE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the WITH clause independently of all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;withClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasRecursive = stmt-&gt;withClause-&gt;recursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;cteList = <a href="parse_cte.c.html#L109" title="parser/parse_cte.c:109">transformWithClause</a>(pstate, stmt-&gt;withClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasModifyingCTE = pstate-&gt;p_hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For each row of VALUES, transform the raw expressions.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note that the intermediate representation we build is column-organized<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * not row-organized.&nbsp; That simplifies the type and collation processing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; foreach(lc, stmt-&gt;valuesLists)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = (List *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Do basic expression transformation (same as a ROW() expr, but here<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * we disallow SetToDefault)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="parse_target.c.html#L220" title="parser/parse_target.c:220">transformExpressionList</a>(pstate, sublist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_VALUES, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * All the sublists must be the same length, *after* transformation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (which might expand '*' into multiple items).&nbsp; The VALUES RTE can't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle anything different.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (sublist_length &lt; <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Remember post-transformation length of first sublist */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist_length = list_length(sublist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* and allocate array for per-column lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colexprs = (List **) <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(sublist_length * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(List *));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (sublist_length != list_length(sublist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;VALUES lists must all be the same length&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) sublist))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Build per-column expression lists */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc2, sublist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colexprs[i] = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(colexprs[i], col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Release sub-list's cells to save memory */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(sublist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Prepare an exprsLists <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> for this row */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; exprsLists = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(exprsLists, NIL);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now resolve the common types of the columns, and coerce everything to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * those types.&nbsp; Then identify the common typmod and common collation, if<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>, of each column.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We must do collation processing <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> because (1) <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * doesn't process rangetable entries, and (2) we need to label the VALUES<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RTE with column collations for use in the outer query.&nbsp; We don't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider conflict of implicit collations to be an error here; instead<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the column will just show InvalidOid as its collation, and you'll get a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * failure later if that results in failure to resolve a collation.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note we modify the per-column expression lists in-place.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sublist_length; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; coltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; coltypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colcoll;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coltype = <a href="parse_coerce.c.html#L1307" title="parser/parse_coerce.c:1307">select_common_type</a>(pstate, colexprs[i], <span class="Constant">&quot;VALUES&quot;</span>, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, colexprs[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; col = <a href="parse_coerce.c.html#L1537" title="parser/parse_coerce.c:1537">coerce_to_common_type</a>(pstate, col, coltype, <span class="Constant">&quot;VALUES&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc) = (<span class="Type">void</span> *) col;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coltypmod = <a href="parse_coerce.c.html#L1609" title="parser/parse_coerce.c:1609">select_common_typmod</a>(pstate, colexprs[i], coltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colcoll = <a href="parse_collate.c.html#L208" title="parser/parse_collate.c:208">select_common_collation</a>(pstate, colexprs[i], <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coltypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(coltypes, coltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; coltypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(coltypmods, coltypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colcollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(colcollations, colcoll);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Finally, rearrange the coerced expressions into row-organized lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">for</span> (i = <span class="Constant">0</span>; i &lt; sublist_length; i++)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(lc, colexprs[i], lc2, exprsLists)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *col = (Node *) lfirst(lc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sublist = lfirst(lc2);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sublist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(sublist, col);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lfirst(lc2) = sublist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/list.c.html#L1546" title="nodes/list.c:1546">list_free</a>(colexprs[i]);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Ordinarily there can't be <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> current-level Vars in the expression<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * lists, because the namespace was empty ... but if we're inside CREATE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * RULE, then NEW/OLD references might appear.&nbsp; In that case we have to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * mark the VALUES RTE as LATERAL.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_rtable != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) exprsLists, <span class="Constant">0</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; lateral = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate the VALUES RTE<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L2134" title="parser/parse_relation.c:2134">addRangeTableEntryForValues</a>(pstate, exprsLists,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; coltypes, coltypmods, colcollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>, lateral, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, nsitem, <span class="Constant">true</span>, <span class="Constant">true</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate a targetlist as though expanding &quot;*&quot;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; Assert(pstate-&gt;p_next_resno == <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;targetList = <a href="parse_relation.c.html#L3187" title="parser/parse_relation.c:3187">expandNSItemAttrs</a>(pstate, nsitem, <span class="Constant">0</span>, <span class="Constant">true</span>, -<span class="Constant">1</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The grammar allows attaching ORDER BY, LIMIT, and FOR UPDATE to a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * VALUES, so cope.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;sortClause = <a href="parse_clause.c.html#L2732" title="parser/parse_clause.c:2732">transformSortClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_ORDER_BY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow SQL92 rules */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitOffset = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, stmt-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_OFFSET, <span class="Constant">&quot;OFFSET&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitCount = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, stmt-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_LIMIT, <span class="Constant">&quot;LIMIT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitOption = stmt-&gt;limitOption;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;lockingClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to VALUES&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(((LockingClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(stmt-&gt;lockingClause))-&gt;strength))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1699" title="parser/analyze.c:1699">transformSetOperationStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms a set-operations tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * A set-operation tree is just a SELECT, but with UNION/INTERSECT/EXCEPT<br/></li>
<li></span><span class="Comment"> * structure to it.&nbsp; We must transform each leaf SELECT and build up a top-<br/></li>
<li></span><span class="Comment"> * level Query that contains the leaf SELECTs as subqueries in its rangetable.<br/></li>
<li></span><span class="Comment"> * The tree of set operations is converted into the setOperations field of<br/></li>
<li></span><span class="Comment"> * the top-level Query.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L1699">&#x200c;</a><span class="linkable">transformSetOperationStmt</span>(ParseState *pstate, SelectStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; SelectStmt *leftmostSelect;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftmostRTI;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *leftmostQuery;<br/></li>
<li>&nbsp; &nbsp; SetOperationStmt *sostmt;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *sortClause;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *limitOffset;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *limitCount;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *lockingClause;<br/></li>
<li>&nbsp; &nbsp; WithClause *withClause;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *left_tlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lct,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcm,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *lcc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *targetvars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *targetnames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *sv_namespace;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sv_rtable_length;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *jnsitem;<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceColumn *sortnscolumns;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortcolindex;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tllen;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_SELECT;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find leftmost leaf SelectStmt.&nbsp; We currently only need to do this in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * order to deliver a suitable error message if there's an INTO clause<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * there, implying the set-op tree is in a context that doesn't allow<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INTO.&nbsp; (<a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a> would throw error anyway, but it<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * seems worth the trouble to throw a different error for non-leftmost<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * INTO, so we produce that error in <a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a>.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; leftmostSelect = stmt-&gt;larg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (leftmostSelect &amp;&amp; leftmostSelect-&gt;op != SETOP_NONE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftmostSelect = leftmostSelect-&gt;larg;<br/></li>
<li>&nbsp; &nbsp; Assert(leftmostSelect &amp;&amp; IsA(leftmostSelect, SelectStmt) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; leftmostSelect-&gt;larg == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (leftmostSelect-&gt;intoClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;SELECT ... INTO is not allowed here&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) leftmostSelect-&gt;intoClause))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to extract ORDER BY and other top-level clauses here and not<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * let <a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a>() see them --- else it'll just recurse<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right back here!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sortClause = stmt-&gt;sortClause;<br/></li>
<li>&nbsp; &nbsp; limitOffset = stmt-&gt;limitOffset;<br/></li>
<li>&nbsp; &nbsp; limitCount = stmt-&gt;limitCount;<br/></li>
<li>&nbsp; &nbsp; lockingClause = stmt-&gt;lockingClause;<br/></li>
<li>&nbsp; &nbsp; withClause = stmt-&gt;withClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stmt-&gt;sortClause = NIL;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;limitOffset = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;limitCount = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;lockingClause = NIL;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;withClause = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't support FOR UPDATE/SHARE with set ops at the moment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (lockingClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with UNION/INTERSECT/EXCEPT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(((LockingClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(lockingClause))-&gt;strength))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Process the WITH clause independently of all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (withClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasRecursive = withClause-&gt;recursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;cteList = <a href="parse_cte.c.html#L109" title="parser/parse_cte.c:109">transformWithClause</a>(pstate, withClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasModifyingCTE = pstate-&gt;p_hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Recursively transform the components of the tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sostmt = castNode(SetOperationStmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a>(pstate, stmt, <span class="Constant">true</span>, <span class="Constant">NULL</span>));<br/></li>
<li>&nbsp; &nbsp; Assert(sostmt);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;setOperations = (Node *) sostmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Re-<a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> leftmost SELECT (<a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> it's a sub-query in rangetable)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; node = sostmt-&gt;larg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (node &amp;&amp; IsA(node, SetOperationStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = ((SetOperationStmt *) node)-&gt;larg;<br/></li>
<li>&nbsp; &nbsp; Assert(node &amp;&amp; IsA(node, RangeTblRef));<br/></li>
<li>&nbsp; &nbsp; leftmostRTI = ((RangeTblRef *) node)-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; leftmostQuery = rt_fetch(leftmostRTI, pstate-&gt;p_rtable)-&gt;subquery;<br/></li>
<li>&nbsp; &nbsp; Assert(leftmostQuery != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate dummy targetlist for outer query using column names of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * leftmost <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> and common datatypes/collations of topmost set<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * operation.&nbsp; Also make lists of the dummy <a href="../regex/regexec.c.html#L106" title="regex/regexec.c:106">vars</a> and their names for use<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * in parsing ORDER BY.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we use leftmostRTI as the varno of the dummy variables. It<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * shouldn't matter too much which RT index they have, as long as they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * have one that corresponds to a real RT entry; else funny things may<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * happen when the tree is mashed by rule rewriting.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;targetList = NIL;<br/></li>
<li>&nbsp; &nbsp; targetvars = NIL;<br/></li>
<li>&nbsp; &nbsp; targetnames = NIL;<br/></li>
<li>&nbsp; &nbsp; sortnscolumns = (ParseNamespaceColumn *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/mmgr/mcxt.c.html#L1346" title="utils/mmgr/mcxt.c:1346">palloc0</a>(list_length(sostmt-&gt;colTypes) * <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(ParseNamespaceColumn));<br/></li>
<li>&nbsp; &nbsp; sortcolindex = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forfour(lct, sostmt-&gt;colTypes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lcm, sostmt-&gt;colTypmods,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lcc, sostmt-&gt;colCollations,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_tlist, leftmostQuery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colType = lfirst_oid(lct);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; colTypmod = lfirst_int(lcm);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colCollation = lfirst_oid(lcc);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *lefttle = (TargetEntry *) lfirst(left_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colName;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Var&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *var;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!lefttle-&gt;resjunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colName = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(lefttle-&gt;resname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var = <a href="../nodes/makefuncs.c.html#L66" title="nodes/makefuncs.c:66">makeVar</a>(leftmostRTI,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lefttle-&gt;resno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colType,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colTypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colCollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; var-&gt;location = <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) lefttle-&gt;expr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) var,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (AttrNumber) pstate-&gt;p_next_resno++,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qry-&gt;targetList, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetvars = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(targetvars, var);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetnames = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(targetnames, <a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(colName));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_varno = leftmostRTI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_varattno = lefttle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_vartype = colType;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_vartypmod = colTypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_varcollid = colCollation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_varnosyn = leftmostRTI;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns[sortcolindex].p_varattnosyn = lefttle-&gt;resno;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; sortcolindex++;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * As a first step towards supporting sort clauses that are expressions<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * using the output columns, generate a namespace entry that makes the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * output columns visible.&nbsp; A Join RTE node is handy for this, since we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * can easily control the Vars generated upon matches.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: we don't yet do anything useful with such cases, but at least<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;ORDER BY <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>(foo)&quot; will draw the right error message rather than<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * &quot;foo not found&quot;.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; sv_rtable_length = list_length(pstate-&gt;p_rtable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; jnsitem = <a href="parse_relation.c.html#L2216" title="parser/parse_relation.c:2216">addRangeTableEntryForJoin</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetnames,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortnscolumns,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; JOIN_INNER,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetvars,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; NIL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; sv_namespace = pstate-&gt;p_namespace;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_namespace = NIL;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* add jnsitem to column namespace only */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_relation.c.html#L2619" title="parser/parse_relation.c:2619">addNSItemToQuery</a>(pstate, jnsitem, <span class="Constant">false</span>, <span class="Constant">false</span>, <span class="Constant">true</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we don't support resjunk sort clauses on the output of a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * setOperation tree --- you can only use the SQL92-spec options of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * selecting an output column by name or number.&nbsp; Enforce by checking that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="parse_clause.c.html#L2732" title="parser/parse_clause.c:2732">transformSortClause</a> doesn't add <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> items to tlist.&nbsp; Note, if changing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this, <a href="../optimizer/path/equivclass.c.html#L2899" title="optimizer/path/equivclass.c:2899">add_setop_child_rel_equivalences</a>() will need to be updated.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; tllen = list_length(qry-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;sortClause = <a href="parse_clause.c.html#L2732" title="parser/parse_clause.c:2732">transformSortClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_ORDER_BY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow SQL92 rules */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore namespace, remove join RTE from rtable */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_namespace = sv_namespace;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_rtable = <a href="../nodes/list.c.html#L631" title="nodes/list.c:631">list_truncate</a>(pstate-&gt;p_rtable, sv_rtable_length);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (tllen != list_length(qry-&gt;targetList))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;invalid UNION/INTERSECT/EXCEPT ORDER BY clause&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Only result column names can be used, not expressions or <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Add the expression/function to every SELECT, or move the UNION into a FROM clause.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(list_nth(qry-&gt;targetList, tllen)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitOffset = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_OFFSET, <span class="Constant">&quot;OFFSET&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitCount = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_LIMIT, <span class="Constant">&quot;LIMIT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitOption = stmt-&gt;limitOption;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasWindowFuncs = pstate-&gt;p_hasWindowFuncs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasAggs = pstate-&gt;p_hasAggs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, lockingClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3302" title="parser/analyze.c:3302">transformLockingClause</a>(pstate, qry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (LockingClause *) lfirst(l), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this must be done after collations, for reliable comparison of exprs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_hasAggs || qry-&gt;groupClause || qry-&gt;groupingSets || qry-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_agg.c.html#L1080" title="parser/parse_agg.c:1080">parseCheckAggregates</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Make a SortGroupClause node for a SetOperationStmt's groupClauses<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If require_hash is true, the caller is indicating that they need <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment"> * support or they will fail.&nbsp; So look extra hard for <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> support.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>SortGroupClause *<br/></li>
<li><a id="L1956">&#x200c;</a><span class="linkable">makeSortGroupClauseForSetOp</span>(Oid rescoltype, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> require_hash)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; SortGroupClause *grpcl = makeNode(SortGroupClause);<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sortop;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eqop;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hashable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* determine the eqop and optional sortop */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_oper.c.html#L180" title="parser/parse_oper.c:180">get_sort_group_operators</a>(rescoltype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>, <span class="Constant">true</span>, <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;sortop, &amp;eqop, <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;hashable);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The type cache doesn't believe that record is hashable (see<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../utils/cache/typcache.c.html#L1521" title="utils/cache/typcache.c:1521">cache_record_field_properties</a>()), but if the caller really needs <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * support, we can assume it does.&nbsp; Worst case, if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> components of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * record don't support hashing, we will fail at execution.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (require_hash &amp;&amp; (rescoltype == RECORDOID || rescoltype == RECORDARRAYOID))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; hashable = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't have a tlist yet, so can't assign sortgrouprefs */<br/></li>
<li></span>&nbsp; &nbsp; grpcl-&gt;tleSortGroupRef = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; grpcl-&gt;eqop = eqop;<br/></li>
<li>&nbsp; &nbsp; grpcl-&gt;sortop = sortop;<br/></li>
<li>&nbsp; &nbsp; grpcl-&gt;nulls_first = <span class="Constant">false</span>; <span class="Comment">/* OK with or without sortop */<br/></li>
<li></span>&nbsp; &nbsp; grpcl-&gt;hashable = hashable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> grpcl;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Recursively transform leaves and <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> nodes of a set-op tree<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to returning the transformed node, if targetlist isn't NULL<br/></li>
<li></span><span class="Comment"> * then we return a list of its non-resjunk TargetEntry nodes.&nbsp; For a leaf<br/></li>
<li></span><span class="Comment"> * set-op node these are the actual targetlist entries; otherwise they are<br/></li>
<li></span><span class="Comment"> * dummy entries created to carry the type, typmod, collation, and location<br/></li>
<li></span><span class="Comment"> * (for error messages) of each output column of the set-op node.&nbsp; This info<br/></li>
<li></span><span class="Comment"> * is needed only during the <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> recursion of this function, so outside<br/></li>
<li></span><span class="Comment"> * callers pass NULL for targetlist.&nbsp; Note: the reason for passing the<br/></li>
<li></span><span class="Comment"> * actual targetlist entries of a leaf node is so that <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> levels can<br/></li>
<li></span><span class="Comment"> * replace UNKNOWN Consts with properly-coerced constants.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Node *<br/></li>
<li><a id="L2003">&#x200c;</a><span class="linkable">transformSetOperationTree</span>(ParseState *pstate, SelectStmt *stmt,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> isTopLevel, List **targetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isLeaf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(stmt &amp;&amp; IsA(stmt, SelectStmt));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Guard against stack overflow due to overly complex set-expressions */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../tcop/postgres.c.html#L3531" title="tcop/postgres.c:3531">check_stack_depth</a>();<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Validity-check both leaf and <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> SELECTs for disallowed ops.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;intoClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;INTO is only allowed on first SELECT of UNION/INTERSECT/EXCEPT&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) stmt-&gt;intoClause))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* We don't support FOR UPDATE/SHARE with set ops at the moment. */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;lockingClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with UNION/INTERSECT/EXCEPT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(((LockingClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(stmt-&gt;lockingClause))-&gt;strength))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node of a set-op tree has ORDER BY, LIMIT, FOR UPDATE,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * or WITH clauses attached, we need to treat it like a leaf node to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * generate an independent sub-Query tree.&nbsp; Otherwise, it can be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * represented by a SetOperationStmt node underneath the parent Query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;op == SETOP_NONE)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stmt-&gt;larg == <span class="Constant">NULL</span> &amp;&amp; stmt-&gt;rarg == <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; isLeaf = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(stmt-&gt;larg != <span class="Constant">NULL</span> &amp;&amp; stmt-&gt;rarg != <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;sortClause || stmt-&gt;limitOffset || stmt-&gt;limitCount ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;lockingClause || stmt-&gt;withClause)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isLeaf = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isLeaf = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isLeaf)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process leaf SELECT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *selectQuery;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; selectName[<span class="Constant">32</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; RangeTblRef *rtr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *tl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Transform SelectStmt into a Query.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * This works the same as SELECT transformation normally would, except<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * that we prevent resolving unknown-type outputs as TEXT.&nbsp; This does<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * not change the subquery's semantics since if the column type<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * matters semantically, it would have been resolved to something else<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.&nbsp; Doing this lets us resolve such outputs using<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="parse_coerce.c.html#L1307" title="parser/parse_coerce.c:1307">select_common_type</a>(), below.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Note: previously transformed sub-queries don't affect the parsing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * of this sub-query, because they are not in the toplevel pstate's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * namespace list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; selectQuery = <a href="#L221" title="parser/analyze.c:221">parse_sub_analyze</a>((Node *) stmt, pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">NULL</span>, <span class="Constant">false</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check for bogus references to Vars on the current query level (but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level references are okay). Normally this can't happen<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because the namespace will be empty, but it could happen if we are<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * inside a rule.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_namespace)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../optimizer/util/var.c.html#L441" title="optimizer/util/var.c:441">contain_vars_of_level</a>((Node *) selectQuery, <span class="Constant">1</span>))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_COLUMN_REFERENCE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;UNION/INTERSECT/EXCEPT member statement cannot refer to other relations of same query level&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../optimizer/util/var.c.html#L509" title="optimizer/util/var.c:509">locate_var_of_level</a>((Node *) selectQuery, <span class="Constant">1</span>))));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Extract a list of the non-junk TLEs for <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a>-level processing.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(tl, selectQuery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(tl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *targetlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*targetlist, tle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Make the leaf query be a subquery in the top-level rangetable.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; snprintf(selectName, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(selectName), <span class="Constant">&quot;*SELECT* </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(pstate-&gt;p_rtable) + <span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nsitem = <a href="parse_relation.c.html#L1638" title="parser/parse_relation.c:1638">addRangeTableEntryForSubquery</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; selectQuery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/makefuncs.c.html#L389" title="nodes/makefuncs.c:389">makeAlias</a>(selectName, NIL),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Return a RangeTblRef to replace the SelectStmt in the set-op tree.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rtr = makeNode(RangeTblRef);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rtr-&gt;rtindex = nsitem-&gt;p_rtindex;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) rtr;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Process an <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> node (set operation node) */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; SetOperationStmt *op = makeNode(SetOperationStmt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *ltargetlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rtargetlist;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *ltl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *rtl;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">const</span> <span class="Type">char</span> *context;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; recursive = (pstate-&gt;p_parent_cte &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pstate-&gt;p_parent_cte-&gt;cterecursive);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; context = (stmt-&gt;op == SETOP_UNION ? <span class="Constant">&quot;UNION&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (stmt-&gt;op == SETOP_INTERSECT ? <span class="Constant">&quot;INTERSECT&quot;</span> :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;EXCEPT&quot;</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;op = stmt-&gt;op;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;all = stmt-&gt;all;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recursively transform the left child node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;larg = <a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a>(pstate, stmt-&gt;larg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ltargetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If we are processing a recursive union query, <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> is the time to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * examine the non-recursive term's output columns and mark the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * containing CTE as having those result columns.&nbsp; We should do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * only at the topmost setop of the CTE, of course.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (isTopLevel &amp;&amp; recursive)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L2334" title="parser/analyze.c:2334">determineRecursiveColTypes</a>(pstate, op-&gt;larg, ltargetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Recursively transform the right child node.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;rarg = <a href="#L2003" title="parser/analyze.c:2003">transformSetOperationTree</a>(pstate, stmt-&gt;rarg,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;rtargetlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify that the two children have the same number of non-junk<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * columns, and determine the types of the merged output columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (list_length(ltargetlist) != list_length(rtargetlist))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;each </span><span class="Special">%s</span><span class="Constant"> query must have the same number of columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>((Node *) rtargetlist))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *targetlist = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;colTypes = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;colTypmods = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;colCollations = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; op-&gt;groupClauses = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; forboth(ltl, ltargetlist, rtl, rtargetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *ltle = (TargetEntry *) lfirst(ltl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *rtle = (TargetEntry *) lfirst(rtl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *lcolnode = (Node *) ltle-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *rcolnode = (Node *) rtle-&gt;expr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lcoltype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(lcolnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcoltype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rcolnode);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *bestexpr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestlocation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescoltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; rescoltypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescolcoll;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> common type, same as CASE et al */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescoltype = <a href="parse_coerce.c.html#L1307" title="parser/parse_coerce.c:1307">select_common_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_make2(lcolnode, rcolnode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;bestexpr);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestlocation = <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(bestexpr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Verify the coercions are actually possible.&nbsp; If not, we'd fail<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * later anyway, but we want to fail <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> while we have sufficient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * context to produce an error cursor position.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For all non-UNKNOWN-type cases, we verify coercibility but we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * don't modify the child's expression, for fear of changing the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * child query's semantics.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If a child expression is an UNKNOWN-type Const or Param, we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to replace it with the coerced expression.&nbsp; This can only<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * happen when the child is a leaf set-op node.&nbsp; It's safe to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * replace the expression because if the child query's semantics<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * depended on the type of this output column, it'd have already<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coerced the UNKNOWN to something else.&nbsp; We want to do this<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * because (a) we want to verify that a Const is valid for the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * target type, or resolve the actual type of an UNKNOWN Param,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and (b) we want to avoid unnecessary discrepancies between the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * output type of the child query and the resolved target type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Such a discrepancy would disable optimization in the <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a>.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's some other UNKNOWN-type node, eg a Var, we do nothing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (knowing that <a href="parse_coerce.c.html#L1537" title="parser/parse_coerce.c:1537">coerce_to_common_type</a> would fail).&nbsp; The <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * is sometimes able to fold an UNKNOWN Var to a constant <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it has to coerce the type, so failing <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a> would just break<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases that might work.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (lcoltype != UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lcolnode = <a href="parse_coerce.c.html#L1537" title="parser/parse_coerce.c:1537">coerce_to_common_type</a>(pstate, lcolnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rescoltype, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(lcolnode, Const) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(lcolnode, Param))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lcolnode = <a href="parse_coerce.c.html#L1537" title="parser/parse_coerce.c:1537">coerce_to_common_type</a>(pstate, lcolnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rescoltype, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltle-&gt;expr = (Expr *) lcolnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rcoltype != UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcolnode = <a href="parse_coerce.c.html#L1537" title="parser/parse_coerce.c:1537">coerce_to_common_type</a>(pstate, rcolnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rescoltype, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (IsA(rcolnode, Const) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; IsA(rcolnode, Param))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rcolnode = <a href="parse_coerce.c.html#L1537" title="parser/parse_coerce.c:1537">coerce_to_common_type</a>(pstate, rcolnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rescoltype, context);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtle-&gt;expr = (Expr *) rcolnode;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescoltypmod = <a href="parse_coerce.c.html#L1609" title="parser/parse_coerce.c:1609">select_common_typmod</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; list_make2(lcolnode, rcolnode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescoltype);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Select common collation.&nbsp; A common collation is required for<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * all set operators except UNION ALL; see SQL:2008 7.13 &lt;query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * expression&gt; Syntax Rule 15c.&nbsp; (If we fail to identify a common<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation for a UNION ALL column, the colCollations <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * will be set to InvalidOid, which may result in a runtime error<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * if something at a higher query level wants to use the column's<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * collation.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescolcoll = <a href="parse_collate.c.html#L208" title="parser/parse_collate.c:208">select_common_collation</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_make2(lcolnode, rcolnode),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (op-&gt;op == SETOP_UNION &amp;&amp; op-&gt;all));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* emit results */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;colTypes = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(op-&gt;colTypes, rescoltype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;colTypmods = <a href="../nodes/list.c.html#L357" title="nodes/list.c:357">lappend_int</a>(op-&gt;colTypmods, rescoltypmod);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;colCollations = <a href="../nodes/list.c.html#L375" title="nodes/list.c:375">lappend_oid</a>(op-&gt;colCollations, rescolcoll);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For all cases except UNION ALL, identify the grouping operators<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (and, if available, sorting operators) that will be used to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * eliminate duplicates.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (op-&gt;op != SETOP_UNION || !op-&gt;all)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ParseCallbackState pcbstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bestlocation);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If it's a recursive union, we need to require hashing<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * support.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; op-&gt;groupClauses = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(op-&gt;groupClauses,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="#L1956" title="parser/analyze.c:1956">makeSortGroupClauseForSetOp</a>(rescoltype, recursive));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Construct a dummy tlist entry to return.&nbsp; We use a SetToDefault<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * node for the expression, since it carries exactly the fields<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * needed, but <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> other expression node type would do as well.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (targetlist)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SetToDefault *rescolnode = makeNode(SetToDefault);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *restle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescolnode-&gt;typeId = rescoltype;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescolnode-&gt;typeMod = rescoltypmod;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescolnode-&gt;collation = rescolcoll;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rescolnode-&gt;location = bestlocation;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; restle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) rescolnode,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">0</span>, <span class="Comment">/* no need to set resno */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">NULL</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; *targetlist = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(*targetlist, restle);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Node *) op;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Process the outputs of the non-recursive term of a recursive union<br/></li>
<li></span><span class="Comment"> * to set up the parent CTE's columns<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L2334">&#x200c;</a></span><span class="linkable">determineRecursiveColTypes</span>(ParseState *pstate, Node *larg, List *nrtargetlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftmostRTI;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *leftmostQuery;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *targetList;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *left_tlist;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *nrtl;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_resno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Find leftmost leaf SELECT<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; node = larg;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> (node &amp;&amp; IsA(node, SetOperationStmt))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; node = ((SetOperationStmt *) node)-&gt;larg;<br/></li>
<li>&nbsp; &nbsp; Assert(node &amp;&amp; IsA(node, RangeTblRef));<br/></li>
<li>&nbsp; &nbsp; leftmostRTI = ((RangeTblRef *) node)-&gt;rtindex;<br/></li>
<li>&nbsp; &nbsp; leftmostQuery = rt_fetch(leftmostRTI, pstate-&gt;p_rtable)-&gt;subquery;<br/></li>
<li>&nbsp; &nbsp; Assert(leftmostQuery != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Generate dummy targetlist using column names of leftmost <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * dummy result expressions of the non-recursive term.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; targetList = NIL;<br/></li>
<li>&nbsp; &nbsp; next_resno = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; forboth(nrtl, nrtargetlist, left_tlist, leftmostQuery-&gt;targetList)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *nrtle = (TargetEntry *) lfirst(nrtl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *lefttle = (TargetEntry *) lfirst(left_tlist);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *colName;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Assert(!lefttle-&gt;resjunk);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; colName = <a href="../utils/mmgr/mcxt.c.html#L1695" title="utils/mmgr/mcxt.c:1695">pstrdup</a>(lefttle-&gt;resname);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle = <a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>(nrtle-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; next_resno++,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; colName,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targetList = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(targetList, tle);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now build CTE's output column info using dummy targetlist */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_cte.c.html#L570" title="parser/parse_cte.c:570">analyzeCTETargetList</a>(pstate, pstate-&gt;p_parent_cte, targetList);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2388" title="parser/analyze.c:2388">transformReturnStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms a return statement<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L2388">&#x200c;</a><span class="linkable">transformReturnStmt</span>(ParseState *pstate, ReturnStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_SELECT;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;isReturn = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;targetList = list_make1(<a href="../nodes/makefuncs.c.html#L240" title="nodes/makefuncs.c:240">makeTargetEntry</a>((Expr *) <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, stmt-&gt;returnval, EXPR_KIND_SELECT_TARGET),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">1</span>, <span class="Constant">NULL</span>, <span class="Constant">false</span>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_resolve_unknowns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_target.c.html#L288" title="parser/parse_target.c:288">resolveTargetListUnknowns</a>(pstate, qry-&gt;targetList);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasWindowFuncs = pstate-&gt;p_hasWindowFuncs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasAggs = pstate-&gt;p_hasAggs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2419" title="parser/analyze.c:2419">transformUpdateStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transforms an update statement<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L2419">&#x200c;</a><span class="linkable">transformUpdateStmt</span>(ParseState *pstate, UpdateStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; ParseNamespaceItem *nsitem;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;commandType = CMD_UPDATE;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_is_insert = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the WITH clause independently of all else */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;withClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasRecursive = stmt-&gt;withClause-&gt;recursive;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;cteList = <a href="parse_cte.c.html#L109" title="parser/parse_cte.c:109">transformWithClause</a>(pstate, stmt-&gt;withClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasModifyingCTE = pstate-&gt;p_hasModifyingCTE;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;resultRelation = <a href="parse_clause.c.html#L180" title="parser/parse_clause.c:180">setTargetTable</a>(pstate, stmt-&gt;relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;relation-&gt;inh,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ACL_UPDATE);<br/></li>
<li>&nbsp; &nbsp; nsitem = pstate-&gt;p_target_nsitem;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* subqueries in FROM cannot access the result relation */<br/></li>
<li></span>&nbsp; &nbsp; nsitem-&gt;p_lateral_only = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; nsitem-&gt;p_lateral_ok = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the FROM clause is non-standard SQL syntax. We used to be able to do<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * this with REPLACE in POSTQUEL so we keep the feature.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_clause.c.html#L114" title="parser/parse_clause.c:114">transformFromClause</a>(pstate, stmt-&gt;fromClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* remaining clauses can reference the result relation normally */<br/></li>
<li></span>&nbsp; &nbsp; nsitem-&gt;p_lateral_only = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; nsitem-&gt;p_lateral_ok = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qual = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate, stmt-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_WHERE, <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;returningList = <a href="#L2560" title="parser/analyze.c:2560">transformReturningList</a>(pstate, stmt-&gt;returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_RETURNING);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now we are done with SELECT-like processing, and can get on with<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * transforming the target list to match the UPDATE target columns.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;targetList = <a href="#L2485" title="parser/analyze.c:2485">transformUpdateTargetList</a>(pstate, stmt-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2485" title="parser/analyze.c:2485">transformUpdateTargetList</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; handle <a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> clause in UPDATE/MERGE/INSERT ... ON CONFLICT UPDATE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L2485">&#x200c;</a><span class="linkable">transformUpdateTargetList</span>(ParseState *pstate, List *origTlist)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist = NIL;<br/></li>
<li>&nbsp; &nbsp; RTEPermissionInfo *target_perminfo;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *orig_tl;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *tl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tlist = <a href="parse_target.c.html#L121" title="parser/parse_target.c:121">transformTargetList</a>(pstate, origTlist,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_UPDATE_SOURCE);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare to assign non-conflicting resnos to resjunk attributes */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_next_resno &lt;= RelationGetNumberOfAttributes(pstate-&gt;p_target_relation))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_next_resno = RelationGetNumberOfAttributes(pstate-&gt;p_target_relation) + <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Prepare non-junk columns for assignment to target table */<br/></li>
<li></span>&nbsp; &nbsp; target_perminfo = pstate-&gt;p_target_nsitem-&gt;p_perminfo;<br/></li>
<li>&nbsp; &nbsp; orig_tl = list_head(origTlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(tl, tlist)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; TargetEntry *tle = (TargetEntry *) lfirst(tl);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ResTarget&nbsp; *origTarget;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;resjunk)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Resjunk nodes need no additional processing, but be sure they<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * have resnos that do not match <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> target columns; else rewriter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * or <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> might get confused.&nbsp; They don't need a resname<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * either.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resno = (AttrNumber) pstate-&gt;p_next_resno++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;resname = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (orig_tl == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;UPDATE target count mismatch --- <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; origTarget = lfirst_node(ResTarget, orig_tl);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; attrno = <a href="parse_relation.c.html#L3483" title="parser/parse_relation.c:3483">attnameAttNum</a>(pstate-&gt;p_target_relation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; origTarget-&gt;name, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (attrno == InvalidAttrNumber)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_COLUMN),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;column </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> of relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> does not exist&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origTarget-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RelationGetRelationName(pstate-&gt;p_target_relation)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (origTarget-&gt;indirection != NIL &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; strcmp(origTarget-&gt;name, pstate-&gt;p_target_nsitem-&gt;p_names-&gt;aliasname) == <span class="Constant">0</span>) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;<a href="../regex/regc_lex.c.html#L43" title="regex/regc_lex.c:43">SET</a> target columns cannot be qualified with the relation name.&quot;</span>) : <span class="Constant">0</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, origTarget-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_target.c.html#L619" title="parser/parse_target.c:619">updateTargetListEntry</a>(pstate, tle, origTarget-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origTarget-&gt;indirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; origTarget-&gt;location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Mark the target column as requiring update permissions */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; target_perminfo-&gt;updatedCols = <a href="../nodes/bitmapset.c.html#L815" title="nodes/bitmapset.c:815">bms_add_member</a>(target_perminfo-&gt;updatedCols,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attrno - FirstLowInvalidHeapAttributeNumber);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; orig_tl = lnext(origTlist, orig_tl);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (orig_tl != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;UPDATE target count mismatch --- <a href="../utils/adt/pseudotypes.c.html#L373" title="utils/adt/pseudotypes.c:373">internal</a> error&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> tlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2560" title="parser/analyze.c:2560">transformReturningList</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; handle a RETURNING clause in INSERT/UPDATE/DELETE/MERGE<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>List *<br/></li>
<li><a id="L2560">&#x200c;</a><span class="linkable">transformReturningList</span>(ParseState *pstate, List *returningList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ParseExprKind exprKind)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *rlist;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; save_next_resno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (returningList == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> NIL;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* nothing to do */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We need to assign resnos starting at one in the RETURNING list. Save<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * and restore the <a href="../storage/lmgr/s_lock.c.html#L257" title="storage/lmgr/s_lock.c:257">main</a> tlist's value of p_next_resno, just in case<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * someone looks at it later (probably won't happen).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; save_next_resno = pstate-&gt;p_next_resno;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_next_resno = <span class="Constant">1</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform RETURNING identically to a SELECT targetlist */<br/></li>
<li></span>&nbsp; &nbsp; rlist = <a href="parse_target.c.html#L121" title="parser/parse_target.c:121">transformTargetList</a>(pstate, returningList, exprKind);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Complain if the nonempty tlist expanded to nothing (which is possible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * if it contains only a star-expansion of a zero-column table).&nbsp; If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allow this, the parsed Query will look like it didn't have RETURNING,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * with results that would probably surprise the user.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rlist == NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;RETURNING must have at least one column&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(linitial(returningList)))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* mark column origins */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_target.c.html#L318" title="parser/parse_target.c:318">markTargetListOrigins</a>(pstate, rlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* resolve <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> still-unresolved output columns as being type text */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_resolve_unknowns)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_target.c.html#L288" title="parser/parse_target.c:288">resolveTargetListUnknowns</a>(pstate, rlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* restore state */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_next_resno = save_next_resno;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> rlist;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2619" title="parser/analyze.c:2619">transformPLAssignStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; transform a PL/pgSQL assignment statement<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If there is no opt_indirection, the transformed statement looks like<br/></li>
<li></span><span class="Comment"> * &quot;SELECT a_expr ...&quot;, except the expression has been cast to the type of<br/></li>
<li></span><span class="Comment"> * the target.&nbsp; With indirection, it's still a SELECT, but the expression will<br/></li>
<li></span><span class="Comment"> * incorporate FieldStore and/or assignment SubscriptingRef nodes to compute a<br/></li>
<li></span><span class="Comment"> * new value for a container-type variable represented by the target.&nbsp; The<br/></li>
<li></span><span class="Comment"> * expression references the target as the container source.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L2619">&#x200c;</a><span class="linkable">transformPLAssignStmt</span>(ParseState *pstate, PLAssignStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *qry = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; ColumnRef&nbsp; *cref = makeNode(ColumnRef);<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *indirection = stmt-&gt;indirection;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nnames = stmt-&gt;nnames;<br/></li>
<li>&nbsp; &nbsp; SelectStmt *sstmt = stmt-&gt;val;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *target;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettype;<br/></li>
<li>&nbsp; &nbsp; int32&nbsp; &nbsp; &nbsp; &nbsp; targettypmod;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targetcollation;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *tlist;<br/></li>
<li>&nbsp; &nbsp; TargetEntry *tle;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; type_id;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *qual;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, construct a ColumnRef for the target variable.&nbsp; If the target<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * has more than one dotted name, we have to <a href="../regex/regc_nfa.c.html#L1713" title="regex/regc_nfa.c:1713">pull</a> the extra names out of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * the indirection list.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; cref-&gt;fields = list_make1(<a href="../nodes/value.c.html#L63" title="nodes/value.c:63">makeString</a>(stmt-&gt;name));<br/></li>
<li>&nbsp; &nbsp; cref-&gt;location = stmt-&gt;location;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (nnames &gt; <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* avoid munging the raw parsetree */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; indirection = <a href="../nodes/list.c.html#L1573" title="nodes/list.c:1573">list_copy</a>(indirection);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">while</span> (--nnames &gt; <span class="Constant">0</span> &amp;&amp; indirection != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *ind = (Node *) linitial(indirection);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!IsA(ind, String))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid name count in PLAssignStmt&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cref-&gt;fields = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(cref-&gt;fields, ind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; indirection = <a href="../nodes/list.c.html#L943" title="nodes/list.c:943">list_delete_first</a>(indirection);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform the target reference.&nbsp; Typically we will get back a Param<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * node, but there's no reason to be too picky about its type.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; target = <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate, (Node *) cref,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_UPDATE_TARGET);<br/></li>
<li>&nbsp; &nbsp; targettype = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(target);<br/></li>
<li>&nbsp; &nbsp; targettypmod = <a href="../nodes/nodeFuncs.c.html#L298" title="nodes/nodeFuncs.c:298">exprTypmod</a>(target);<br/></li>
<li>&nbsp; &nbsp; targetcollation = <a href="../nodes/nodeFuncs.c.html#L816" title="nodes/nodeFuncs.c:816">exprCollation</a>(target);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The rest mostly matches <a href="#L1337" title="parser/analyze.c:1337">transformSelectStmt</a>, except that we needn't<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * consider WITH or INTO, and we build a targetlist our own way.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;commandType = CMD_SELECT;<br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_is_insert = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make FOR UPDATE/FOR SHARE info available to <a href="parse_relation.c.html#L1470" title="parser/parse_relation.c:1470">addRangeTableEntry</a> */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_locking_clause = sstmt-&gt;lockingClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make WINDOW info available for window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>, too */<br/></li>
<li></span>&nbsp; &nbsp; pstate-&gt;p_windowdefs = sstmt-&gt;windowClause;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* process the FROM clause */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_clause.c.html#L114" title="parser/parse_clause.c:114">transformFromClause</a>(pstate, sstmt-&gt;fromClause);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initially transform the targetlist as if in SELECT */<br/></li>
<li></span>&nbsp; &nbsp; tlist = <a href="parse_target.c.html#L121" title="parser/parse_target.c:121">transformTargetList</a>(pstate, sstmt-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_SELECT_TARGET);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we should have exactly one targetlist item */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (list_length(tlist) != <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1182" title="utils/error/elog.c:1182">errmsg_plural</a>(<span class="Constant">&quot;assignment source returned </span><span class="Special">%d</span><span class="Constant"> column&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;assignment source returned </span><span class="Special">%d</span><span class="Constant"> columns&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(tlist),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_length(tlist))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; tle = linitial_node(TargetEntry, tlist);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * This <a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a> <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> is similar to <a href="parse_target.c.html#L452" title="parser/parse_target.c:452">transformAssignedExpr</a>; the key difference<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * is we use COERCION_PLPGSQL not COERCION_ASSIGNMENT.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; type_id = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>((Node *) tle-&gt;expr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_expr_kind = EXPR_KIND_UPDATE_TARGET;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (indirection)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;expr = (Expr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_target.c.html#L683" title="parser/parse_target.c:683">transformAssignmentIndirection</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; target,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targettype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targettypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targetcollation,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; indirection,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; list_head(indirection),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) tle-&gt;expr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; COERCION_PLPGSQL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(target));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (targettype != type_id &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (targettype == RECORDOID || ISCOMPLEX(targettype)) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (type_id == RECORDOID || ISCOMPLEX(type_id)))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Hack: do not let <a href="parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>() deal with inconsistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * composite types.&nbsp; Just pass the expression result through as-is,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and let the PL/pgSQL executor do the conversion its way.&nbsp; This is<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rather bogus, but it's needed for backwards compatibility.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For normal non-qualified target column, do type checking and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coercion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *orig_expr = (Node *) tle-&gt;expr;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tle-&gt;expr = (Expr *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_coerce.c.html#L78" title="parser/parse_coerce.c:78">coerce_to_target_type</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; orig_expr, type_id,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; targettype, targettypmod,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCION_PLPGSQL,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; COERCE_IMPLICIT_CAST,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* With COERCION_PLPGSQL, this error is probably unreachable */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (tle-&gt;expr == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_DATATYPE_MISMATCH),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;variable </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> is of type </span><span class="Special">%s</span><span class="Constant">&quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot; but expression is of type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;name,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(targettype),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(type_id)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;You will need to rewrite or cast the expression.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, <a href="../nodes/nodeFuncs.c.html#L1386" title="nodes/nodeFuncs.c:1386">exprLocation</a>(orig_expr))));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; pstate-&gt;p_expr_kind = EXPR_KIND_NONE;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;targetList = list_make1(tle);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform WHERE */<br/></li>
<li></span>&nbsp; &nbsp; qual = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate, sstmt-&gt;whereClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_WHERE, <span class="Constant">&quot;WHERE&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* initial processing of HAVING clause is much like WHERE clause */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;havingQual = <a href="parse_clause.c.html#L1854" title="parser/parse_clause.c:1854">transformWhereClause</a>(pstate, sstmt-&gt;havingClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_HAVING, <span class="Constant">&quot;HAVING&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Transform sorting/grouping stuff.&nbsp; Do ORDER BY first because both<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="parse_clause.c.html#L2632" title="parser/parse_clause.c:2632">transformGroupClause</a> and <a href="parse_clause.c.html#L2986" title="parser/parse_clause.c:2986">transformDistinctClause</a> need the results. Note<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * that these <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> can also change the targetList, so it's passed to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * them by reference.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;sortClause = <a href="parse_clause.c.html#L2732" title="parser/parse_clause.c:2732">transformSortClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sstmt-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_ORDER_BY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow SQL92 rules */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;groupClause = <a href="parse_clause.c.html#L2632" title="parser/parse_clause.c:2632">transformGroupClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sstmt-&gt;groupClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;groupingSets,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_GROUP_BY,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span> <span class="Comment">/* allow SQL92 rules */</span> );<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (sstmt-&gt;distinctClause == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;distinctClause = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasDistinctOn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (linitial(sstmt-&gt;distinctClause) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We had SELECT DISTINCT */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;distinctClause = <a href="parse_clause.c.html#L2986" title="parser/parse_clause.c:2986">transformDistinctClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;sortClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasDistinctOn = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* We had SELECT DISTINCT ON */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;distinctClause = <a href="parse_clause.c.html#L3070" title="parser/parse_clause.c:3070">transformDistinctOnClause</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sstmt-&gt;distinctClause,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;qry-&gt;targetList,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;sortClause);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasDistinctOn = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform LIMIT */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;limitOffset = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, sstmt-&gt;limitOffset,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; EXPR_KIND_OFFSET, <span class="Constant">&quot;OFFSET&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sstmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitCount = <a href="parse_clause.c.html#L1881" title="parser/parse_clause.c:1881">transformLimitClause</a>(pstate, sstmt-&gt;limitCount,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_LIMIT, <span class="Constant">&quot;LIMIT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; sstmt-&gt;limitOption);<br/></li>
<li>&nbsp; &nbsp; qry-&gt;limitOption = sstmt-&gt;limitOption;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform window clauses after we have seen all window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> */<br/></li>
<li></span>&nbsp; &nbsp; qry-&gt;windowClause = <a href="parse_clause.c.html#L2765" title="parser/parse_clause.c:2765">transformWindowDefinitions</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pstate-&gt;p_windowdefs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;qry-&gt;targetList);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;rtable = pstate-&gt;p_rtable;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rteperminfos = pstate-&gt;p_rteperminfos;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;jointree = <a href="../nodes/makefuncs.c.html#L287" title="nodes/makefuncs.c:287">makeFromExpr</a>(pstate-&gt;p_joinlist, qual);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasSubLinks = pstate-&gt;p_hasSubLinks;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasWindowFuncs = pstate-&gt;p_hasWindowFuncs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasTargetSRFs = pstate-&gt;p_hasTargetSRFs;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;hasAggs = pstate-&gt;p_hasAggs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; foreach(l, sstmt-&gt;lockingClause)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3302" title="parser/analyze.c:3302">transformLockingClause</a>(pstate, qry,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (LockingClause *) lfirst(l), <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L101" title="parser/parse_collate.c:101">assign_query_collations</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* this must be done after collations, for reliable comparison of exprs */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_hasAggs || qry-&gt;groupClause || qry-&gt;groupingSets || qry-&gt;havingQual)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_agg.c.html#L1080" title="parser/parse_agg.c:1080">parseCheckAggregates</a>(pstate, qry);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> qry;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2868" title="parser/analyze.c:2868">transformDeclareCursorStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transform a DECLARE CURSOR Statement<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * DECLARE CURSOR is like other utility statements in that we emit it as a<br/></li>
<li></span><span class="Comment"> * CMD_UTILITY Query node; however, we must first transform the contained<br/></li>
<li></span><span class="Comment"> * query.&nbsp; We used to postpone that until execution, but it's really necessary<br/></li>
<li></span><span class="Comment"> * to do it during the normal <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis phase to ensure that side effects<br/></li>
<li></span><span class="Comment"> * of parser hooks happen at the expected time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L2868">&#x200c;</a><span class="linkable">transformDeclareCursorStmt</span>(ParseState *pstate, DeclareCursorStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((stmt-&gt;options &amp; CURSOR_OPT_SCROLL) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;options &amp; CURSOR_OPT_NO_SCROLL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL keyword */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot specify both </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;SCROLL&quot;</span>, <span class="Constant">&quot;NO SCROLL&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> ((stmt-&gt;options &amp; CURSOR_OPT_ASENSITIVE) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (stmt-&gt;options &amp; CURSOR_OPT_INSENSITIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* translator: %s is a SQL keyword */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;cannot specify both </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">&quot;ASENSITIVE&quot;</span>, <span class="Constant">&quot;INSENSITIVE&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Transform contained query, not allowing SELECT INTO */<br/></li>
<li></span>&nbsp; &nbsp; query = <a href="#L311" title="parser/analyze.c:311">transformStmt</a>(pstate, stmt-&gt;query);<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;query = (Node *) query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Grammar should not have allowed anything but SELECT */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!IsA(query, Query) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; query-&gt;commandType != CMD_SELECT)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unexpected non-SELECT command in DECLARE CURSOR&quot;</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * We also disallow data-modifying WITH in a cursor.&nbsp; (This could be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * allowed, but the semantics of when the updates occur might be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * surprising.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DECLARE CURSOR must not contain data-modifying statements in WITH&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* FOR UPDATE and WITH HOLD are not compatible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;rowMarks != NIL &amp;&amp; (stmt-&gt;options &amp; CURSOR_OPT_HOLD))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DECLARE CURSOR WITH HOLD ... </span><span class="Special">%s</span><span class="Constant"> is not supported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(((RowMarkClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(query-&gt;rowMarks))-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Holdable cursors must be READ ONLY.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* FOR UPDATE and SCROLL are not compatible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;rowMarks != NIL &amp;&amp; (stmt-&gt;options &amp; CURSOR_OPT_SCROLL))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DECLARE SCROLL CURSOR ... </span><span class="Special">%s</span><span class="Constant"> is not supported&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(((RowMarkClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(query-&gt;rowMarks))-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Scrollable cursors must be READ ONLY.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* FOR UPDATE and INSENSITIVE are not compatible */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;rowMarks != NIL &amp;&amp; (stmt-&gt;options &amp; CURSOR_OPT_INSENSITIVE))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_INVALID_CURSOR_DEFINITION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;DECLARE INSENSITIVE CURSOR ... </span><span class="Special">%s</span><span class="Constant"> is not valid&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(((RowMarkClause *)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; linitial(query-&gt;rowMarks))-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1205" title="utils/error/elog.c:1205">errdetail</a>(<span class="Constant">&quot;Insensitive cursors must be READ ONLY.&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* represent the command as a utility Query */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; result-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; result-&gt;utilityStmt = (Node *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L2961" title="parser/analyze.c:2961">transformExplainStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transform an EXPLAIN Statement<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * EXPLAIN is like other utility statements in that we emit it as a<br/></li>
<li></span><span class="Comment"> * CMD_UTILITY Query node; however, we must first transform the contained<br/></li>
<li></span><span class="Comment"> * query.&nbsp; We used to postpone that until execution, but it's really necessary<br/></li>
<li></span><span class="Comment"> * to do it during the normal <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis phase to ensure that side effects<br/></li>
<li></span><span class="Comment"> * of parser hooks happen at the expected time.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L2961">&#x200c;</a><span class="linkable">transformExplainStmt</span>(ParseState *pstate, ExplainStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; generic_plan = <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *paramTypes = <span class="Constant">NULL</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numParams = <span class="Constant">0</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * If we have no external source of parameter definitions, and the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * GENERIC_PLAN option is specified, then <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> variable parameter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * definitions (similarly to PREPARE, for example).<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (pstate-&gt;p_paramref_hook == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, stmt-&gt;options)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DefElem&nbsp; &nbsp; *opt = (DefElem *) lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(opt-&gt;defname, <span class="Constant">&quot;generic_plan&quot;</span>) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; generic_plan = <a href="../commands/define.c.html#L107" title="commands/define.c:107">defGetBoolean</a>(opt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* don't &quot;break&quot;, as we want the last value */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (generic_plan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_param.c.html#L83" title="parser/parse_param.c:83">setup_parse_variable_parameters</a>(pstate, &amp;paramTypes, &amp;numParams);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform contained query, allowing SELECT INTO */<br/></li>
<li></span>&nbsp; &nbsp; stmt-&gt;query = (Node *) <a href="#L272" title="parser/analyze.c:272">transformOptionalSelectInto</a>(pstate, stmt-&gt;query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make sure all is well with parameter types */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (generic_plan)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_param.c.html#L268" title="parser/parse_param.c:268">check_variable_parameters</a>(pstate, (Query *) stmt-&gt;query);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* represent the command as a utility Query */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; result-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; result-&gt;utilityStmt = (Node *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L3013" title="parser/analyze.c:3013">transformCreateTableAsStmt</a> -<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; transform a CREATE TABLE AS, SELECT ... INTO, or CREATE MATERIALIZED VIEW<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; Statement<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * As with DECLARE CURSOR and EXPLAIN, transform the contained statement <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L3013">&#x200c;</a><span class="linkable">transformCreateTableAsStmt</span>(ParseState *pstate, CreateTableAsStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* transform contained query, not allowing SELECT INTO */<br/></li>
<li></span>&nbsp; &nbsp; query = <a href="#L311" title="parser/analyze.c:311">transformStmt</a>(pstate, stmt-&gt;query);<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;query = (Node *) query;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* additional work needed for CREATE MATERIALIZED VIEW */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;objtype == OBJECT_MATVIEW)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Prohibit a data-modifying CTE in the query used to create a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * materialized view. It's not sufficiently clear what the user would<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * want to happen if the MV is refreshed or incrementally maintained.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (query-&gt;hasModifyingCTE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;materialized views must not use data-modifying statements in WITH&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Check whether <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> temporary database objects are used in the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * creation query. It would be hard to refresh data or incrementally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maintain it if a source disappeared.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="parse_relation.c.html#L3824" title="parser/parse_relation.c:3824">isQueryUsingTempRelation</a>(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;materialized views must not use temporary tables or views&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A materialized view would either need to save parameters for use in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * maintaining/loading the data or prohibit them entirely.&nbsp; The latter<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * seems safer and more sane.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="parse_param.c.html#L330" title="parser/parse_param.c:330">query_contains_extern_params</a>(query))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;materialized views may not be defined using bound parameters&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * For <a href="../utils/adt/timestamp.c.html#L1618" title="utils/adt/timestamp.c:1618">now</a>, we disallow unlogged materialized views, because it seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * like a bad idea for them to just go to empty after a crash. (If we<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * could mark them as unpopulated, that would be better, but that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * requires catalog changes which crash recovery can't presently<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * handle.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (stmt-&gt;into-&gt;rel-&gt;relpersistence == RELPERSISTENCE_UNLOGGED)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;materialized views cannot be unlogged&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * At runtime, we'll need a copy of the parsed-but-not-rewritten Query<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for purposes of creating the view's ON SELECT rule.&nbsp; We stash that<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in the IntoClause because that's where <a href="../commands/createas.c.html#L454" title="commands/createas.c:454">intorel_startup</a>() can<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * conveniently get it from.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; stmt-&gt;into-&gt;viewQuery = (Node *) copyObject(query);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* represent the command as a utility Query */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; result-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; result-&gt;utilityStmt = (Node *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * transform a CallStmt<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Query *<br/></li>
<li><a id="L3088">&#x200c;</a><span class="linkable">transformCallStmt</span>(ParseState *pstate, CallStmt *stmt)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *targs;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *lc;<br/></li>
<li>&nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *node;<br/></li>
<li>&nbsp; &nbsp; FuncExpr&nbsp;&nbsp; *fexpr;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; proctup;<br/></li>
<li>&nbsp; &nbsp; Datum&nbsp; &nbsp; &nbsp; &nbsp; proargmodes;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; isNull;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *outargs = NIL;<br/></li>
<li>&nbsp; &nbsp; Query&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First, do standard <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis on the procedure call and its<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * arguments, allowing us to identify the called procedure.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; targs = NIL;<br/></li>
<li>&nbsp; &nbsp; foreach(lc, stmt-&gt;funccall-&gt;args)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; targs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(targs, <a href="parse_expr.c.html#L121" title="parser/parse_expr.c:121">transformExpr</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (Node *) lfirst(lc),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; EXPR_KIND_CALL_ARGUMENT));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; node = <a href="parse_func.c.html#L90" title="parser/parse_func.c:90">ParseFuncOrColumn</a>(pstate,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;funccall-&gt;funcname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; targs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pstate-&gt;p_last_srf,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;funccall,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; stmt-&gt;funccall-&gt;location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="parse_collate.c.html#L177" title="parser/parse_collate.c:177">assign_expr_collations</a>(pstate, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; fexpr = castNode(FuncExpr, node);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; proctup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(PROCOID, ObjectIdGetDatum(fexpr-&gt;funcid));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!HeapTupleIsValid(proctup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;cache lookup failed for function </span><span class="Special">%u</span><span class="Constant">&quot;</span>, fexpr-&gt;funcid);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Expand the argument list to deal with named-argument notation and<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * default arguments.&nbsp; For ordinary FuncExprs this'd be done during<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * planning, but a CallStmt doesn't go through planning, and there seems<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * no good reason not to do it here.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; fexpr-&gt;args = <a href="../optimizer/util/clauses.c.html#L4162" title="optimizer/util/clauses.c:4162">expand_function_arguments</a>(fexpr-&gt;args,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Constant">true</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fexpr-&gt;funcresulttype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; proctup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Fetch proargmodes; if it's null, there are no output args */<br/></li>
<li></span>&nbsp; &nbsp; proargmodes = <a href="../utils/cache/syscache.c.html#L479" title="utils/cache/syscache.c:479">SysCacheGetAttr</a>(PROCOID, proctup,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Anum_pg_proc_proargmodes,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;isNull);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!isNull)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Split the list into input arguments in fexpr-&gt;args and output<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * arguments in stmt-&gt;outargs.&nbsp; INOUT arguments appear in both lists.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ArrayType&nbsp; *arr;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; numargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *argmodes;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *inargs;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arr = DatumGetArrayTypeP(proargmodes);&nbsp; &nbsp; <span class="Comment">/* ensure not toasted */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; numargs = list_length(fexpr-&gt;args);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (ARR_NDIM(arr) != <span class="Constant">1</span> ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_DIMS(arr)[<span class="Constant">0</span>] != numargs ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_HASNULL(arr) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ARR_ELEMTYPE(arr) != CHAROID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;proargmodes is not a 1-D char array of length </span><span class="Special">%d</span><span class="Constant"> or it contains nulls&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; numargs);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; argmodes = (<span class="Type">char</span> *) ARR_DATA_PTR(arr);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; inargs = NIL;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(lc, fexpr-&gt;args)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Node&nbsp; &nbsp; &nbsp;&nbsp; *n = lfirst(lc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (argmodes[i])<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROARGMODE_IN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROARGMODE_VARIADIC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inargs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(inargs, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROARGMODE_OUT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outargs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(outargs, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> PROARGMODE_INOUT:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inargs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(inargs, n);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outargs = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(outargs, copyObject(n));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* note we don't support PROARGMODE_TABLE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;invalid argmode </span><span class="Special">%c</span><span class="Constant"> for procedure&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; argmodes[i]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; fexpr-&gt;args = inargs;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; stmt-&gt;funcexpr = fexpr;<br/></li>
<li>&nbsp; &nbsp; stmt-&gt;outargs = outargs;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(proctup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* represent the command as a utility Query */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(Query);<br/></li>
<li>&nbsp; &nbsp; result-&gt;commandType = CMD_UTILITY;<br/></li>
<li>&nbsp; &nbsp; result-&gt;utilityStmt = (Node *) stmt;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Produce a string representation of a LockClauseStrength value.<br/></li>
<li></span><span class="Comment"> * This should only be applied to valid <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> (not LCS_NONE).<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L3213">&#x200c;</a><span class="linkable">LCS_asString</span>(LockClauseStrength strength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">switch</span> (strength)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_NONE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Assert(<span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORKEYSHARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;FOR <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> SHARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORSHARE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;FOR SHARE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORNOKEYUPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;FOR NO <a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a> UPDATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> LCS_FORUPDATE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;FOR UPDATE&quot;</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">&quot;FOR some&quot;</span>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* shouldn't happen */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Check for features that are not supported with FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * exported so <a href="../optimizer/plan/planner.c.html#L274" title="optimizer/plan/planner.c:274">planner</a> can check again after rewriting, query pullup, etc<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3238">&#x200c;</a></span><span class="linkable">CheckSelectLocking</span>(Query *qry, LockClauseStrength strength)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Assert(strength != LCS_NONE);&nbsp; &nbsp; <span class="Comment">/* else caller error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;setOperations)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with UNION/INTERSECT/EXCEPT&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;distinctClause != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with DISTINCT clause&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;groupClause != NIL || qry-&gt;groupingSets != NIL)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with GROUP BY clause&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;havingQual != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with HAVING clause&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;hasAggs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with aggregate <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;hasWindowFuncs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with window <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a>&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (qry-&gt;hasTargetSRFs)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> is not allowed with set-returning <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> in the target list&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(strength))));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Transform a FOR [<a href="../utils/cache/syscache.c.html#L76" title="utils/cache/syscache.c:76">KEY</a>] UPDATE/SHARE clause<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This basically involves replacing names by integer relids.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * NB: if you need to change this, see also <a href="../rewrite/rewriteHandler.c.html#L1899" title="rewrite/rewriteHandler.c:1899">markQueryForLocking</a>()<br/></li>
<li></span><span class="Comment"> * in rewriteHandler.c, and <a href="parse_relation.c.html#L2575" title="parser/parse_relation.c:2575">isLockedRefname</a>() in parse_relation.c.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L3302">&#x200c;</a></span><span class="linkable">transformLockingClause</span>(ParseState *pstate, Query *qry, LockingClause *lc,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> pushedDown)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *lockedRels = lc-&gt;lockedRels;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *l;<br/></li>
<li>&nbsp; &nbsp; ListCell&nbsp;&nbsp; *rt;<br/></li>
<li>&nbsp; &nbsp; Index&nbsp; &nbsp; &nbsp; &nbsp; i;<br/></li>
<li>&nbsp; &nbsp; LockingClause *allrels;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="#L3238" title="parser/analyze.c:3238">CheckSelectLocking</a>(qry, lc-&gt;strength);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* make a clause we can pass down to subqueries to <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> all rels */<br/></li>
<li></span>&nbsp; &nbsp; allrels = makeNode(LockingClause);<br/></li>
<li>&nbsp; &nbsp; allrels-&gt;lockedRels = NIL;&nbsp; &nbsp; <span class="Comment">/* indicates all rels */<br/></li>
<li></span>&nbsp; &nbsp; allrels-&gt;strength = lc-&gt;strength;<br/></li>
<li>&nbsp; &nbsp; allrels-&gt;waitPolicy = lc-&gt;waitPolicy;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (lockedRels == NIL)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock all regular tables used in query and its subqueries.&nbsp; We<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * examine inFromCl to exclude auto-added RTEs, particularly NEW/OLD<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * in rules.&nbsp; This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a> of an abuse of a mostly-obsolete flag, but<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * it's convenient.&nbsp; We can't rely on the namespace mechanism that has<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * largely replaced inFromCl, since for example we need to lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * base-relation RTEs even if they are masked by <a href="../utils/adt/oracle_compat.c.html#L80" title="utils/adt/oracle_compat.c:80">upper</a> joins.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; foreach(rt, qry-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(rt);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rte-&gt;inFromCl)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3529" title="parser/analyze.c:3529">applyLockingClause</a>(qry, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc-&gt;strength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc-&gt;waitPolicy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pushedDown);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(qry-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;requiredPerms |= ACL_SELECT_FOR_UPDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3529" title="parser/analyze.c:3529">applyLockingClause</a>(qry, i, lc-&gt;strength, lc-&gt;waitPolicy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pushedDown);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * FOR UPDATE/SHARE of subquery is propagated to all of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * subquery's rels, too.&nbsp; We could do this later (based on<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * the marking of the subquery RTE) but it is convenient<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * to have local knowledge in each query level about which<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * rels need to be opened with RowShareLock.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3302" title="parser/analyze.c:3302">transformLockingClause</a>(pstate, rte-&gt;subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allrels, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ignore JOIN, SPECIAL, FUNCTION, VALUES, CTE RTEs */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Lock just the named tables.&nbsp; As above, we allow locking <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> base<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * relation regardless of alias-visibility rules, so we need to<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * examine inFromCl to exclude OLD/NEW.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; foreach(l, lockedRels)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeVar&nbsp;&nbsp; *thisrel = (RangeVar *) lfirst(l);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* For simplicity we insist on unqualified alias names here */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (thisrel-&gt;catalogname || thisrel-&gt;schemaname)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> must specify unqualified relation names&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = <span class="Constant">0</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; foreach(rt, qry-&gt;rtable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RangeTblEntry *rte = (RangeTblEntry *) lfirst(rt);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *rtename = rte-&gt;eref-&gt;aliasname;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!rte-&gt;inFromCl)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * A join RTE without an alias is not visible as a relation<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * name and needs to be skipped (otherwise it might hide a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * base relation with the same name), except if it has a USING<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * alias, which *is* visible.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Subquery and <a href="../bootstrap/bootstrap.c.html#L152" title="bootstrap/bootstrap.c:152">values</a> RTEs without aliases are never visible<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * as relation names and must always be skipped.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;alias == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;rtekind == RTE_JOIN)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rte-&gt;join_using_alias == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtename = rte-&gt;join_using_alias-&gt;aliasname;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (rte-&gt;rtekind == RTE_SUBQUERY ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; rte-&gt;rtekind == RTE_VALUES)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">continue</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (strcmp(rtename, thisrel-&gt;relname) == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">switch</span> (rte-&gt;rtekind)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_RELATION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; RTEPermissionInfo *perminfo;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3529" title="parser/analyze.c:3529">applyLockingClause</a>(qry, i,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc-&gt;strength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc-&gt;waitPolicy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; pushedDown);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo = <a href="parse_relation.c.html#L3903" title="parser/parse_relation.c:3903">getRTEPermissionInfo</a>(qry-&gt;rteperminfos, rte);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; perminfo-&gt;requiredPerms |= ACL_SELECT_FOR_UPDATE;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_SUBQUERY:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3529" title="parser/analyze.c:3529">applyLockingClause</a>(qry, i, lc-&gt;strength,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; lc-&gt;waitPolicy, pushedDown);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* see comment above */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3302" title="parser/analyze.c:3302">transformLockingClause</a>(pstate, rte-&gt;subquery,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; allrels, <span class="Constant">true</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_JOIN:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to a join&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_FUNCTION:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to a function&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_TABLEFUNC:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to a table function&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_VALUES:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to VALUES&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_CTE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to a WITH query&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">case</span> RTE_NAMEDTUPLESTORE:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_FEATURE_NOT_SUPPORTED),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> cannot be applied to a named tuplestore&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Shouldn't be possible to see RTE_RESULT here */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">default</span>:<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;unrecognized RTE type: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (<span class="Type">int</span>) rte-&gt;rtekind);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">break</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* out of foreach loop */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rt == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_TABLE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*------<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; translator: %s is a SQL row locking clause such as FOR UPDATE */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;relation </span><span class="Special">\&quot;%s\&quot;</span><span class="Constant"> in </span><span class="Special">%s</span><span class="Constant"> clause not found in FROM clause&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; thisrel-&gt;relname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3213" title="parser/analyze.c:3213">LCS_asString</a>(lc-&gt;strength)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, thisrel-&gt;location)));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Record locking info for a single rangetable item<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L3529">&#x200c;</a></span><span class="linkable">applyLockingClause</span>(Query *qry, Index rtindex,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; LockClauseStrength strength, LockWaitPolicy waitPolicy,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> pushedDown)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; RowMarkClause *rc;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(strength != LCS_NONE);&nbsp; &nbsp; <span class="Comment">/* else caller error */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* If it's an explicit clause, make sure hasForUpdate gets set */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!pushedDown)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; qry-&gt;hasForUpdate = <span class="Constant">true</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check for pre-existing entry for same rtindex */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((rc = <a href="parse_relation.c.html#L3459" title="parser/parse_relation.c:3459">get_parse_rowmark</a>(qry, rtindex)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * If the same RTE is specified with more than one locking strength,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * use the strongest.&nbsp; (Reasonable, since you can't take both a shared<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * and exclusive lock at the same time; it'll end up being exclusive<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * anyway.)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Similarly, if the same RTE is specified with more than one lock<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * wait policy, consider that NOWAIT wins over SKIP <a href="../regex/regexec.c.html#L55" title="regex/regexec.c:55">LOCKED</a>, which in<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * turn wins over <a href="../storage/ipc/latch.c.html#L162" title="storage/ipc/latch.c:162">waiting</a> for the lock (the default).&nbsp; This is a <a href="../utils/adt/varbit.c.html#L391" title="utils/adt/varbit.c:391">bit</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * more debatable but raising an error doesn't seem helpful. (Consider<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * for instance SELECT FOR UPDATE NOWAIT from a view that internally<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * contains a plain FOR UPDATE spec.)&nbsp; Having NOWAIT win over SKIP<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * <a href="../regex/regexec.c.html#L55" title="regex/regexec.c:55">LOCKED</a> is reasonable since the former throws an error in case of<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * coming across a locked tuple, which may be undesirable in some<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * cases but it seems better than silently returning inconsistent<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * results.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * And of course pushedDown becomes false if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> clause is explicit.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;strength = Max(rc-&gt;strength, strength);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;waitPolicy = Max(rc-&gt;waitPolicy, waitPolicy);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rc-&gt;pushedDown &amp;= pushedDown;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Make a new RowMarkClause */<br/></li>
<li></span>&nbsp; &nbsp; rc = makeNode(RowMarkClause);<br/></li>
<li>&nbsp; &nbsp; rc-&gt;rti = rtindex;<br/></li>
<li>&nbsp; &nbsp; rc-&gt;strength = strength;<br/></li>
<li>&nbsp; &nbsp; rc-&gt;waitPolicy = waitPolicy;<br/></li>
<li>&nbsp; &nbsp; rc-&gt;pushedDown = pushedDown;<br/></li>
<li>&nbsp; &nbsp; qry-&gt;rowMarks = <a href="../nodes/list.c.html#L339" title="nodes/list.c:339">lappend</a>(qry-&gt;rowMarks, rc);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Coverage testing for raw_expression_tree_walker().<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * When enabled, we run raw_expression_tree_walker() over every DML statement<br/></li>
<li></span><span class="Comment"> * submitted to <a href="../regex/regcomp.c.html#L715" title="regex/regcomp.c:715">parse</a> analysis.&nbsp; Without this provision, that function is only<br/></li>
<li></span><span class="Comment"> * applied in limited cases involving CTEs, and we don't really want to have<br/></li>
<li></span><span class="Comment"> * to test everything inside as well as outside a CTE.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="PreProc">#ifdef RAW_EXPRESSION_COVERAGE_TEST<br/></li>
<li></span><br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L3589">&#x200c;</a></span><span class="linkable">test_raw_expression_coverage</span>(Node *node, <span class="Type">void</span> *context)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (node == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> raw_expression_tree_walker(node,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L3589" title="parser/analyze.c:3589">test_raw_expression_coverage</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="PreProc">#endif</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* RAW_EXPRESSION_COVERAGE_TEST */<br/></li>
</ol></span></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
