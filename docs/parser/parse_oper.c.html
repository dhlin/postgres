<!-- generated by the src2html.pl tool from code2ebook:
  https://github.com/agentzh/code2ebook
-->

<html>
 <head>
  <title>parser/parse_oper.c - pgsql17devel-backend</title>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <style>
body {
    text-align: left;
    text-align-last: left;
}

.nav-bar {
    font-size: 120%;
    margin-top: 5px;
    margin-bottom: 5px;
}

.nav-link {
    padding-left: 5em;
    padding-right: 5em;
}

ul.toc {
    line-height: 200%;
    font-size: 150%;
}

code {
    font-family: consolas, monospace;
    line-height: 130%;
}

span.Constant {
    color: DarkGreen;
}

span.Special {
    color: #c06000;
}

span.Comment {
    color: DarkRed;
    font-style: italic;
}

span.Identifier {
    color: DarkCyan;
}

span.PreProc {
    color: DarkMagenta;
}

span.Statement, span.Type, span.Keyword, span.Repeat, span.Conditional,
    span.Operator, span.Exception
{
    color: DarkBlue;
}

span.Todo {
    color: DarkRed;
    background-color: Gold;
    font-style: italic;
}

span.Underlined {
    text-decoration: underline;
}

span.linkable {
    font-weight: bold;
}

code ol {
    counter-reset: item;
    list-style-type: none;
    margin-left: 0;
    padding-left: 0;
    list-style-position: inside;
}

code li {
    display: block;
}

code li:before {
    content: counter(item) "  ";
    counter-increment: item;
    color: #999;
    padding-right: 0.5em;
    padding-left: 0.4em;
    list-style-position: inside;
    text-align: right
}

  </style>
 </head>
 <body>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

  <h1>parser/parse_oper.c - pgsql17devel-backend</h1>
 <h2>Global variables defined</h2>
 <ul class="toc">
<li><a href="#L923">OprCacheHash</a></li>
</ul>
 <h2>Data types defined</h2>
 <ul class="toc">
<li><a href="#L59">OprCacheEntry</a></li>
<li><a href="#L65">OprCacheEntry</a></li>
<li><a href="#L51">OprCacheKey</a></li>
<li><a href="#L57">OprCacheKey</a></li>
</ul>
 <h2>Functions defined</h2>
 <ul class="toc">
<li><a href="#L1036">InvalidateOprCacheCallBack</a></li>
<li><a href="#L99">LookupOperName</a></li>
<li><a href="#L133">LookupOperWithArgs</a></li>
<li><a href="#L262">binary_oper_exact</a></li>
<li><a href="#L450">compatible_oper</a></li>
<li><a href="#L487">compatible_oper_opid</a></li>
<li><a href="#L981">find_oper_cache_entry</a></li>
<li><a href="#L180">get_sort_group_operators</a></li>
<li><a href="#L518">left_oper</a></li>
<li><a href="#L660">make_op</a></li>
<li><a href="#L1020">make_oper_cache_entry</a></li>
<li><a href="#L937">make_oper_cache_key</a></li>
<li><a href="#L770">make_scalar_array_op</a></li>
<li><a href="#L622">op_error</a></li>
<li><a href="#L602">op_signature_string</a></li>
<li><a href="#L370">oper</a></li>
<li><a href="#L312">oper_select_candidate</a></li>
<li><a href="#L245">oprfuncid</a></li>
<li><a href="#L238">oprid</a></li>
</ul>
 <h2>Macros defined</h2>
 <ul class="toc">
<li><a href="#L49">MAX_CACHED_PATH_LEN</a></li>
</ul>
 <h2>Source code</h2>

  <code><ol><li><span class="Comment">/*-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * parse_oper.c<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; handle operator things for parser<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1996-2024, PostgreSQL Global Development Group<br/></li>
<li></span><span class="Comment"> * Portions Copyright (c) 1994, Regents of the University of California<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IDENTIFICATION<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; src/backend/parser/parse_oper.c<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *-------------------------------------------------------------------------<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;postgres.h&quot;<br/></li>
<li></span><br/></li>
<li><span class="PreProc">#include </span><span class="Constant">&quot;access/htup_details.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_operator.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;catalog/pg_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;lib/stringinfo.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;nodes/nodeFuncs.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_coerce.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_func.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_oper.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;parser/parse_type.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/builtins.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/inval.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/lsyscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/syscache.h&quot;<br/></li>
<li></span><span class="PreProc">#include </span><span class="Constant">&quot;utils/typcache.h&quot;<br/></li>
<li></span><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * The lookup key for the operator lookaside <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table.&nbsp; Unused bits must be<br/></li>
<li></span><span class="Comment"> * zeroes to ensure hashing works consistently --- in particular, oprname<br/></li>
<li></span><span class="Comment"> * must be zero-padded and <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> unused entries in search_path must be zero.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * search_path contains the actual search_path with which the entry was<br/></li>
<li></span><span class="Comment"> * derived (minus temp namespace if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>), or else the single specified<br/></li>
<li></span><span class="Comment"> * schema OID if we are looking up an explicitly-qualified operator name.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * search_path has to be fixed-length since the hashtable code insists on<br/></li>
<li></span><span class="Comment"> * fixed-size keys.&nbsp; If your search path is longer than that, we just punt<br/></li>
<li></span><span class="Comment"> * and don't cache anything.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* If your search_path is longer than this, sucks to be you ... */<br/></li>
<li><a id="L49">&#x200c;</a></span><span class="PreProc">#define <span class="linkable">MAX_CACHED_PATH_LEN</span>&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="Constant">16<br/></li>
<li></span><br/></li>
<li><a id="L51">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OprCacheKey</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp; &nbsp; oprname[NAMEDATALEN];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; left_arg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Left input OID, or 0 if prefix op */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; right_arg;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Right input OID */<br/></li>
<li></span>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; search_path[<a href="#L49" title="parser/parse_oper.c:49">MAX_CACHED_PATH_LEN</a>];<br/></li>
<li><a id="L57">&#x200c;</a>} <span class="linkable">OprCacheKey</span>;<br/></li>
<li><br/></li>
<li><a id="L59">&#x200c;</a><span class="Type">typedef</span> <span class="Type">struct</span> <span class="linkable">OprCacheEntry</span><br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> lookup key MUST BE FIRST */<br/></li>
<li></span>&nbsp; &nbsp; <a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> key;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opr_oid;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* OID of the resolved operator */<br/></li>
<li><a id="L65">&#x200c;</a></span>} <span class="linkable">OprCacheEntry</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L262" title="parser/parse_oper.c:262">binary_oper_exact</a>(List *opname, Oid arg1, Oid arg2);<br/></li>
<li><span class="Type">static</span> FuncDetailCode <a href="#L312" title="parser/parse_oper.c:312">oper_select_candidate</a>(<span class="Type">int</span> nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *input_typeids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList candidates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *operOid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L622" title="parser/parse_oper.c:622">op_error</a>(ParseState *pstate, List *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid arg1, Oid arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FuncDetailCode fdresult, <span class="Type">int</span> location);<br/></li>
<li><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> <a href="#L937" title="parser/parse_oper.c:937">make_oper_cache_key</a>(ParseState *pstate, <a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> *key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; List *opname, Oid ltypeId, Oid rtypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type">int</span> location);<br/></li>
<li><span class="Type">static</span> Oid&nbsp; &nbsp; <a href="#L981" title="parser/parse_oper.c:981">find_oper_cache_entry</a>(<a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> *key);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1020" title="parser/parse_oper.c:1020">make_oper_cache_entry</a>(<a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> *key, Oid opr_oid);<br/></li>
<li><span class="Type">static</span> <span class="Type">void</span> <a href="#L1036" title="parser/parse_oper.c:1036">InvalidateOprCacheCallBack</a>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue);<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L99" title="parser/parse_oper.c:99">LookupOperName</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given a possibly-qualified operator name and exact input datatypes,<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; look up the operator.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Pass oprleft = InvalidOid for a prefix op.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the operator name is not schema-qualified, it is sought in the current<br/></li>
<li></span><span class="Comment"> * namespace search path.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If the operator is not found, we return InvalidOid if noError is true,<br/></li>
<li></span><span class="Comment"> * else raise an error.&nbsp; pstate and location are used only to report the<br/></li>
<li></span><span class="Comment"> * error position; pass NULL/-1 if not available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L99">&#x200c;</a><span class="linkable">LookupOperName</span>(ParseState *pstate, List *opername, Oid oprleft, Oid oprright,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../catalog/namespace.c.html#L1770" title="catalog/namespace.c:1770">OpernameGetOprid</a>(opername, oprleft, oprright);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* we don't use <a href="#L622" title="parser/parse_oper.c:622">op_error</a> here because only an exact match is wanted */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!noError)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(oprright))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;postfix operators are not supported&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator does not exist: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a>(opername, oprleft, oprright)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L133" title="parser/parse_oper.c:133">LookupOperWithArgs</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Like <a href="#L99" title="parser/parse_oper.c:99">LookupOperName</a>, but the argument types are specified by<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; a ObjectWithArgs node.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L133">&#x200c;</a><span class="linkable">LookupOperWithArgs</span>(ObjectWithArgs *<a href="#L370" title="parser/parse_oper.c:370">oper</a>, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeName&nbsp;&nbsp; *oprleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; *oprright;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; leftoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rightoid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(list_length(<a href="#L370" title="parser/parse_oper.c:370">oper</a>-&gt;objargs) == <span class="Constant">2</span>);<br/></li>
<li>&nbsp; &nbsp; oprleft = linitial_node(TypeName, <a href="#L370" title="parser/parse_oper.c:370">oper</a>-&gt;objargs);<br/></li>
<li>&nbsp; &nbsp; oprright = lsecond_node(TypeName, <a href="#L370" title="parser/parse_oper.c:370">oper</a>-&gt;objargs);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oprleft == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; leftoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; leftoid = <a href="parse_type.c.html#L232" title="parser/parse_type.c:232">LookupTypeNameOid</a>(<span class="Constant">NULL</span>, oprleft, noError);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oprright == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rightoid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rightoid = <a href="parse_type.c.html#L232" title="parser/parse_type.c:232">LookupTypeNameOid</a>(<span class="Constant">NULL</span>, oprright, noError);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <a href="#L99" title="parser/parse_oper.c:99">LookupOperName</a>(<span class="Constant">NULL</span>, <a href="#L370" title="parser/parse_oper.c:370">oper</a>-&gt;objname, leftoid, rightoid,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; noError, -<span class="Constant">1</span>);<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L180" title="parser/parse_oper.c:180">get_sort_group_operators</a> - get default sorting/grouping operators for type<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * We fetch the &quot;&lt;&quot;, &quot;=&quot;, and &quot;&gt;&quot; operators all at once to reduce lookup<br/></li>
<li></span><span class="Comment"> * overhead (knowing that most callers will be interested in at least two).<br/></li>
<li></span><span class="Comment"> * However, a given datatype might have only an &quot;=&quot; operator, if it is<br/></li>
<li></span><span class="Comment"> * hashable but not sortable.&nbsp; (Other combinations of present and missing<br/></li>
<li></span><span class="Comment"> * operators shouldn't happen, unless the system catalogs are messed up.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If an operator is missing and the corresponding needXX flag is true,<br/></li>
<li></span><span class="Comment"> * throw a standard error message, else return InvalidOid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * In addition to the operator OIDs themselves, this function can identify<br/></li>
<li></span><span class="Comment"> * whether the &quot;=&quot; operator is hashable.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Callers can pass NULL pointers for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> results they don't care to get.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: the results are guaranteed to be exact or binary-compatible matches,<br/></li>
<li></span><span class="Comment"> * since most callers are not prepared to cope with adding <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> run-time type<br/></li>
<li></span><span class="Comment"> * coercion steps.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">void<br/></li>
<li><a id="L180">&#x200c;</a></span><span class="linkable">get_sort_group_operators</span>(Oid argtype,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> needLT, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> needEQ, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> needGT,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid *ltOpr, Oid *eqOpr, Oid *gtOpr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> *isHashable)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; TypeCacheEntry *typentry;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cache_flags;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lt_opr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; eq_opr;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; gt_opr;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; hashable;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Look up the operators using the type cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; *<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Note: the search algorithm used by typcache.c ensures that the results<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * are consistent, ie all from matching opclasses.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (isHashable != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; cache_flags = TYPECACHE_LT_OPR | TYPECACHE_EQ_OPR | TYPECACHE_GT_OPR |<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPECACHE_HASH_PROC;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; cache_flags = TYPECACHE_LT_OPR | TYPECACHE_EQ_OPR | TYPECACHE_GT_OPR;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; typentry = <a href="../utils/cache/typcache.c.html#L346" title="utils/cache/typcache.c:346">lookup_type_cache</a>(argtype, cache_flags);<br/></li>
<li>&nbsp; &nbsp; lt_opr = typentry-&gt;lt_opr;<br/></li>
<li>&nbsp; &nbsp; eq_opr = typentry-&gt;eq_opr;<br/></li>
<li>&nbsp; &nbsp; gt_opr = typentry-&gt;gt_opr;<br/></li>
<li>&nbsp; &nbsp; hashable = OidIsValid(typentry-&gt;hash_proc);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Report errors if needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((needLT &amp;&amp; !OidIsValid(lt_opr)) ||<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; (needGT &amp;&amp; !OidIsValid(gt_opr)))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an ordering operator for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(argtype)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Use an explicit ordering operator or modify the query.&quot;</span>)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (needEQ &amp;&amp; !OidIsValid(eq_opr))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not identify an equality operator for type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(argtype))));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Return results as needed */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ltOpr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *ltOpr = lt_opr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (eqOpr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *eqOpr = eq_opr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (gtOpr)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *gtOpr = gt_opr;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (isHashable)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *isHashable = hashable;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* given operator tuple, return the operator OID */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L238">&#x200c;</a><span class="linkable">oprid</span>(Operator op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> ((Form_pg_operator) GETSTRUCT(op))-&gt;oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* given operator tuple, return the underlying function's OID */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L245">&#x200c;</a><span class="linkable">oprfuncid</span>(Operator op)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator pgopform = (Form_pg_operator) GETSTRUCT(op);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> pgopform-&gt;oprcode;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L262" title="parser/parse_oper.c:262">binary_oper_exact</a>()<br/></li>
<li></span><span class="Comment"> * Check for an &quot;exact&quot; match to the specified operand types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If one operand is an unknown literal, assume it should be taken to be<br/></li>
<li></span><span class="Comment"> * the same type as the other operand for this purpose.&nbsp; Also, consider<br/></li>
<li></span><span class="Comment"> * the possibility that the other operand is a domain type that needs to<br/></li>
<li></span><span class="Comment"> * be reduced to its base type to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> an &quot;exact&quot; match.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L262">&#x200c;</a><span class="linkable">binary_oper_exact</span>(List *opname, Oid arg1, Oid arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; was_unknown = <span class="Constant">false</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Unspecified type for one of the arguments? then use the other */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> ((arg1 == UNKNOWNOID) &amp;&amp; (arg2 != InvalidOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg1 = arg2;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; was_unknown = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> ((arg2 == UNKNOWNOID) &amp;&amp; (arg1 != InvalidOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; arg2 = arg1;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; was_unknown = <span class="Constant">true</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; result = <a href="../catalog/namespace.c.html#L1770" title="catalog/namespace.c:1770">OpernameGetOprid</a>(opname, arg1, arg2);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (was_unknown)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* arg1 and arg2 are the same here, need only look at arg1 */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; basetype = <a href="../utils/cache/lsyscache.c.html#L2521" title="utils/cache/lsyscache.c:2521">getBaseType</a>(arg1);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (basetype != arg1)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result = <a href="../catalog/namespace.c.html#L1770" title="catalog/namespace.c:1770">OpernameGetOprid</a>(opname, basetype, basetype);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(result))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L312" title="parser/parse_oper.c:312">oper_select_candidate</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Given the input argtype array and one or more candidates<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; for the operator, attempt to resolve the conflict.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns FUNCDETAIL_NOTFOUND, FUNCDETAIL_MULTIPLE, or FUNCDETAIL_NORMAL.<br/></li>
<li></span><span class="Comment"> * In the success case the Oid of the best candidate is stored in *operOid.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note that the caller has already determined that there is no candidate<br/></li>
<li></span><span class="Comment"> * exactly matching the input argtype(s).&nbsp; Incompatible candidates are not yet<br/></li>
<li></span><span class="Comment"> * pruned away, however.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> FuncDetailCode<br/></li>
<li><a id="L312">&#x200c;</a><span class="linkable">oper_select_candidate</span>(<span class="Type">int</span> nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *input_typeids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList candidates,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid *operOid) <span class="Comment">/* output argument */<br/></li>
<li></span>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ncandidates;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="../storage/file/fd.c.html#L1268" title="storage/file/fd.c:1268">Delete</a> <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> candidates that cannot actually <a href="../port/win32/socket.c.html#L34" title="port/win32/socket.c:34">accept</a> the given input<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * types, whether directly or by coercion.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; ncandidates = <a href="parse_func.c.html#L922" title="parser/parse_func.c:922">func_match_argtypes</a>(nargs, input_typeids,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; candidates, &amp;candidates);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Done if no candidate or only one candidate survives */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ncandidates == <span class="Constant">0</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *operOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FUNCDETAIL_NOTFOUND;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (ncandidates == <span class="Constant">1</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *operOid = candidates-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FUNCDETAIL_NORMAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Use the same heuristics as for ambiguous <a href="../regex/regcomp.c.html#L356" title="regex/regcomp.c:356">functions</a> to resolve the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * conflict.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; candidates = <a href="parse_func.c.html#L1007" title="parser/parse_func.c:1007">func_select_candidate</a>(nargs, input_typeids, candidates);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (candidates)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; *operOid = candidates-&gt;oid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> FUNCDETAIL_NORMAL;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; *operOid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> FUNCDETAIL_MULTIPLE; <span class="Comment">/* failed to <a href="../port/win32/socket.c.html#L36" title="port/win32/socket.c:36">select</a> a best candidate */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L370" title="parser/parse_oper.c:370">oper</a>() -- search for a binary operator<br/></li>
<li></span><span class="Comment"> * Given operator name, types of arg1 and arg2, return <a href="#L370" title="parser/parse_oper.c:370">oper</a> struct.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IMPORTANT: the returned operator (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is only promised to be<br/></li>
<li></span><span class="Comment"> * coercion-compatible with the input datatypes.&nbsp; Do not use this if<br/></li>
<li></span><span class="Comment"> * you need an exact- or binary-compatible match; see <a href="#L450" title="parser/parse_oper.c:450">compatible_oper</a>.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no matching operator found, return NULL if noError is true,<br/></li>
<li></span><span class="Comment"> * raise an error if it is false.&nbsp; pstate and location are used only to report<br/></li>
<li></span><span class="Comment"> * the error position; pass NULL/-1 if not available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: on success, the returned object is a syscache entry.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * must <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>() the entry when done with it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Operator<br/></li>
<li><a id="L370">&#x200c;</a><span class="linkable">oper</span>(ParseState *pstate, List *opname, Oid ltypeId, Oid rtypeId,<br/></li>
<li>&nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; key_ok;<br/></li>
<li>&nbsp; &nbsp; FuncDetailCode fdresult = FUNCDETAIL_NOTFOUND;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the mapping in the lookaside cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; key_ok = <a href="#L937" title="parser/parse_oper.c:937">make_oper_cache_key</a>(pstate, &amp;key, opname, ltypeId, rtypeId, location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key_ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operOid = <a href="#L981" title="parser/parse_oper.c:981">find_oper_cache_entry</a>(&amp;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(operOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(operOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Operator) tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First try for an &quot;exact&quot; match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; operOid = <a href="#L262" title="parser/parse_oper.c:262">binary_oper_exact</a>(opname, ltypeId, rtypeId);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(operOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, search for the most suitable candidate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get binary operators of given name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clist = <a href="../catalog/namespace.c.html#L1873" title="catalog/namespace.c:1873">OpernameGetCandidates</a>(opname, <span class="Constant">'b'</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No operators found? Then fail... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clist != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Unspecified type for one of the arguments? then use the other<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * (</span><span class="Todo">XXX</span><span class="Comment"> this is probably dead code?)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputOids[<span class="Constant">2</span>];<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (rtypeId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtypeId = ltypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (ltypeId == InvalidOid)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltypeId = rtypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputOids[<span class="Constant">0</span>] = ltypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inputOids[<span class="Constant">1</span>] = rtypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdresult = <a href="#L312" title="parser/parse_oper.c:312">oper_select_candidate</a>(<span class="Constant">2</span>, inputOids, clist, &amp;operOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(operOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(operOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1020" title="parser/parse_oper.c:1020">make_oper_cache_entry</a>(&amp;key, operOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L622" title="parser/parse_oper.c:622">op_error</a>(pstate, opname, ltypeId, rtypeId, fdresult, location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Operator) tup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L450" title="parser/parse_oper.c:450">compatible_oper</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; given an opname and input datatypes, <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> a compatible binary operator<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; This is tighter than <a href="#L370" title="parser/parse_oper.c:370">oper</a>() because it will not return an operator that<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; requires coercion of the input datatypes (but binary-compatible operators<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; are accepted).&nbsp; Otherwise, the semantics are the same.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Operator<br/></li>
<li><a id="L450">&#x200c;</a><span class="linkable">compatible_oper</span>(ParseState *pstate, List *op, Oid arg1, Oid arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Operator&nbsp; &nbsp; optup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator opform;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* <a href="#L370" title="parser/parse_oper.c:370">oper</a>() will <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the best available match */<br/></li>
<li></span>&nbsp; &nbsp; optup = <a href="#L370" title="parser/parse_oper.c:370">oper</a>(pstate, op, arg1, arg2, noError, location);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (optup == (Operator) <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Operator) <span class="Constant">NULL</span>; <span class="Comment">/* must be noError case */<br/></li>
<li></span><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* but is it good enough? */<br/></li>
<li></span>&nbsp; &nbsp; opform = (Form_pg_operator) GETSTRUCT(optup);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(arg1, opform-&gt;oprleft) &amp;&amp;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_coerce.c.html#L2995" title="parser/parse_coerce.c:2995">IsBinaryCoercible</a>(arg2, opform-&gt;oprright))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> optup;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* nope... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(optup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator requires run-time type coercion: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a>(op, arg1, arg2)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Operator) <span class="Constant">NULL</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L487" title="parser/parse_oper.c:487">compatible_oper_opid</a>() -- get OID of a binary operator<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is a convenience routine that extracts only the operator OID<br/></li>
<li></span><span class="Comment"> * from the result of <a href="#L450" title="parser/parse_oper.c:450">compatible_oper</a>().&nbsp; InvalidOid is returned if the<br/></li>
<li></span><span class="Comment"> * lookup fails and noError is true.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Oid<br/></li>
<li><a id="L487">&#x200c;</a><span class="linkable">compatible_oper_opid</span>(List *op, Oid arg1, Oid arg2, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Operator&nbsp; &nbsp; optup;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; optup = <a href="#L450" title="parser/parse_oper.c:450">compatible_oper</a>(<span class="Constant">NULL</span>, op, arg1, arg2, noError, -<span class="Constant">1</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (optup != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; result = <a href="#L238" title="parser/parse_oper.c:238">oprid</a>(optup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(optup);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/* <a href="#L518" title="parser/parse_oper.c:518">left_oper</a>() -- search for a unary left operator (prefix operator)<br/></li>
<li></span><span class="Comment"> * Given operator name and type of arg, return <a href="#L370" title="parser/parse_oper.c:370">oper</a> struct.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * IMPORTANT: the returned operator (if <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a>) is only promised to be<br/></li>
<li></span><span class="Comment"> * coercion-compatible with the input datatype.&nbsp; Do not use this if<br/></li>
<li></span><span class="Comment"> * you need an exact- or binary-compatible match.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * If no matching operator found, return NULL if noError is true,<br/></li>
<li></span><span class="Comment"> * raise an error if it is false.&nbsp; pstate and location are used only to report<br/></li>
<li></span><span class="Comment"> * the error position; pass NULL/-1 if not available.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../regex/regcomp.c.html#L324" title="regex/regcomp.c:324">NOTE</a>: on success, the returned object is a syscache entry.&nbsp; The caller<br/></li>
<li></span><span class="Comment"> * must <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>() the entry when done with it.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Operator<br/></li>
<li><a id="L518">&#x200c;</a><span class="linkable">left_oper</span>(ParseState *pstate, List *op, Oid arg, <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> noError, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; operOid;<br/></li>
<li>&nbsp; &nbsp; <a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> key;<br/></li>
<li>&nbsp; &nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span>&nbsp; &nbsp; &nbsp; &nbsp; key_ok;<br/></li>
<li>&nbsp; &nbsp; FuncDetailCode fdresult = FUNCDETAIL_NOTFOUND;<br/></li>
<li>&nbsp; &nbsp; HeapTuple&nbsp; &nbsp; tup = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Try to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> the mapping in the lookaside cache.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; key_ok = <a href="#L937" title="parser/parse_oper.c:937">make_oper_cache_key</a>(pstate, &amp;key, op, InvalidOid, arg, location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (key_ok)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; operOid = <a href="#L981" title="parser/parse_oper.c:981">find_oper_cache_entry</a>(&amp;key);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(operOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(operOid));<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> (Operator) tup;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * First try for an &quot;exact&quot; match.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; operOid = <a href="../catalog/namespace.c.html#L1770" title="catalog/namespace.c:1770">OpernameGetOprid</a>(op, InvalidOid, arg);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(operOid))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * Otherwise, search for the most suitable candidate.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList clist;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Get prefix operators of given name */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; clist = <a href="../catalog/namespace.c.html#L1873" title="catalog/namespace.c:1873">OpernameGetCandidates</a>(op, <span class="Constant">'l'</span>, <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* No operators found? Then fail... */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (clist != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * The returned list has args in the form (0, oprright). Move the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * useful data into args[0] to keep <a href="#L312" title="parser/parse_oper.c:312">oper_select_candidate</a> simple.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * </span><span class="Todo">XXX</span><span class="Comment"> we are assuming here that we may scribble on the list!<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; FuncCandidateList clisti;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">for</span> (clisti = clist; clisti != <span class="Constant">NULL</span>; clisti = clisti-&gt;<a href="../regex/regc_lex.c.html#L200" title="regex/regc_lex.c:200">next</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clisti-&gt;args[<span class="Constant">0</span>] = clisti-&gt;args[<span class="Constant">1</span>];<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * We must run <a href="#L312" title="parser/parse_oper.c:312">oper_select_candidate</a> even if only one candidate,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; * otherwise we may falsely return a non-type-compatible operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fdresult = <a href="#L312" title="parser/parse_oper.c:312">oper_select_candidate</a>(<span class="Constant">1</span>, &amp;arg, clist, &amp;operOid);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(operOid))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="../utils/cache/syscache.c.html#L218" title="utils/cache/syscache.c:218">SearchSysCache1</a>(OPEROID, ObjectIdGetDatum(operOid));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (HeapTupleIsValid(tup))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (key_ok)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1020" title="parser/parse_oper.c:1020">make_oper_cache_entry</a>(&amp;key, operOid);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else</span> <span class="Statement">if</span> (!noError)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L622" title="parser/parse_oper.c:622">op_error</a>(pstate, op, InvalidOid, arg, fdresult, location);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Operator) tup;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build a string representing an operator name, including arg type(s).<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; The result is something like &quot;integer + integer&quot;.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * This is typically used in the construction of operator-not-found error<br/></li>
<li></span><span class="Comment"> * messages.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">const</span> <span class="Type">char</span> *<br/></li>
<li><a id="L602">&#x200c;</a><span class="linkable">op_signature_string</span>(List *op, Oid arg1, Oid arg2)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; StringInfoData argbuf;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; initStringInfo(&amp;argbuf);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (OidIsValid(arg1))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; appendStringInfo(&amp;argbuf, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> &quot;</span>, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(arg1));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfoString(&amp;argbuf, <a href="../catalog/namespace.c.html#L3579" title="catalog/namespace.c:3579">NameListToString</a>(op));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; appendStringInfo(&amp;argbuf, <span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant">&quot;</span>, <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(arg2));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> argbuf.data;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* return <a href="../utils/mmgr/mcxt.c.html#L1316" title="utils/mmgr/mcxt.c:1316">palloc</a>'d string buffer */<br/></li>
<li></span>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L622" title="parser/parse_oper.c:622">op_error</a> - utility routine to complain about an unresolvable operator<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L622">&#x200c;</a></span><span class="linkable">op_error</span>(ParseState *pstate, List *op,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Oid arg1, Oid arg2,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; FuncDetailCode fdresult, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (fdresult == FUNCDETAIL_MULTIPLE)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_AMBIGUOUS_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator is not unique: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a>(op, arg1, arg2)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;Could not choose a best candidate operator. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might need to add explicit type casts.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator does not exist: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a>(op, arg1, arg2)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; (!arg1 || !arg2) ?<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;No operator matches the given name and argument type. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might need to add an explicit type cast.&quot;</span>) :<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1319" title="utils/error/elog.c:1319">errhint</a>(<span class="Constant">&quot;No operator matches the given name and argument types. &quot;<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">&quot;You might need to add explicit type casts.&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L660" title="parser/parse_oper.c:660">make_op</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Operator expression construction.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Transform operator expression ensuring type compatibility.<br/></li>
<li></span><span class="Comment"> * This is where some type conversion happens.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * last_srf should be a copy of pstate-&gt;p_last_srf from just <a href="../regex/regc_locale.c.html#L488" title="regex/regc_locale.c:488">before</a> we<br/></li>
<li></span><span class="Comment"> * started transforming the operator's arguments; this is used for nested-SRF<br/></li>
<li></span><span class="Comment"> * detection.&nbsp; If the caller will throw an error anyway for a set-returning<br/></li>
<li></span><span class="Comment"> * expression, it's okay to cheat and just pass pstate-&gt;p_last_srf.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L660">&#x200c;</a><span class="linkable">make_op</span>(ParseState *pstate, List *opname, Node *ltree, Node *rtree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; Node *last_srf, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtypeId;<br/></li>
<li>&nbsp; &nbsp; Operator&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator opform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_arg_types[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; declared_arg_types[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; <span class="Type">int</span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nargs;<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rettype;<br/></li>
<li>&nbsp; &nbsp; OpExpr&nbsp; &nbsp; &nbsp;&nbsp; *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check it's not a postfix operator */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rtree == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_SYNTAX_ERROR),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;postfix operators are not supported&quot;</span>)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Select the operator */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ltree == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prefix operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; rtypeId = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rtree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ltypeId = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="#L518" title="parser/parse_oper.c:518">left_oper</a>(pstate, opname, rtypeId, <span class="Constant">false</span>, location);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, binary operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; ltypeId = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(ltree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rtypeId = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rtree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; tup = <a href="#L370" title="parser/parse_oper.c:370">oper</a>(pstate, opname, ltypeId, rtypeId, <span class="Constant">false</span>, location);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; opform = (Form_pg_operator) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check it's not a shell */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(opform-&gt;oprcode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator is only a shell: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a>(opname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opform-&gt;oprleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opform-&gt;oprright)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Do typecasting and build the expression tree */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (ltree == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* prefix operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; args = list_make1(rtree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actual_arg_types[<span class="Constant">0</span>] = rtypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; declared_arg_types[<span class="Constant">0</span>] = opform-&gt;oprright;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nargs = <span class="Constant">1</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* otherwise, binary operator */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; args = list_make2(ltree, rtree);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actual_arg_types[<span class="Constant">0</span>] = ltypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; actual_arg_types[<span class="Constant">1</span>] = rtypeId;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; declared_arg_types[<span class="Constant">0</span>] = opform-&gt;oprleft;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; declared_arg_types[<span class="Constant">1</span>] = opform-&gt;oprright;<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; nargs = <span class="Constant">2</span>;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enforce consistency with polymorphic argument and return types,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly adjusting return type or declared_arg_types (which will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used as the cast destination by <a href="parse_func.c.html#L1824" title="parser/parse_func.c:1824">make_fn_arguments</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rettype = <a href="parse_coerce.c.html#L2096" title="parser/parse_coerce.c:2096">enforce_generic_type_consistency</a>(actual_arg_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; declared_arg_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; nargs,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opform-&gt;oprresult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform the necessary typecasting of arguments */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_func.c.html#L1824" title="parser/parse_func.c:1824">make_fn_arguments</a>(pstate, args, actual_arg_types, declared_arg_types);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and build the expression node */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(OpExpr);<br/></li>
<li>&nbsp; &nbsp; result-&gt;opno = <a href="#L238" title="parser/parse_oper.c:238">oprid</a>(tup);<br/></li>
<li>&nbsp; &nbsp; result-&gt;opfuncid = opform-&gt;oprcode;<br/></li>
<li>&nbsp; &nbsp; result-&gt;opresulttype = rettype;<br/></li>
<li>&nbsp; &nbsp; result-&gt;opretset = <a href="../utils/cache/lsyscache.c.html#L1742" title="utils/cache/lsyscache.c:1742">get_func_retset</a>(opform-&gt;oprcode);<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* opcollid and inputcollid will be set by parse_collate.c */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;args = args;<br/></li>
<li>&nbsp; &nbsp; result-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* if it returns a set, check that's OK */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (result-&gt;opretset)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_func.c.html#L2510" title="parser/parse_func.c:2510">check_srf_call_placement</a>(pstate, last_srf, location);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* ... and remember it for error checks at higher levels */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; pstate-&gt;p_last_srf = (Node *) result;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L770" title="parser/parse_oper.c:770">make_scalar_array_op</a>()<br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Build expression tree for &quot;scalar op ANY/ALL (array)&quot; construct.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span>Expr *<br/></li>
<li><a id="L770">&#x200c;</a><span class="linkable">make_scalar_array_op</span>(ParseState *pstate, List *opname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a></span> useOr,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; Node *ltree, Node *rtree,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ltypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rtypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atypeId,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res_atypeId;<br/></li>
<li>&nbsp; &nbsp; Operator&nbsp; &nbsp; tup;<br/></li>
<li>&nbsp; &nbsp; Form_pg_operator opform;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; actual_arg_types[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; declared_arg_types[<span class="Constant">2</span>];<br/></li>
<li>&nbsp; &nbsp; List&nbsp; &nbsp; &nbsp;&nbsp; *args;<br/></li>
<li>&nbsp; &nbsp; Oid&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; rettype;<br/></li>
<li>&nbsp; &nbsp; ScalarArrayOpExpr *result;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; ltypeId = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(ltree);<br/></li>
<li>&nbsp; &nbsp; atypeId = <a href="../nodes/nodeFuncs.c.html#L42" title="nodes/nodeFuncs.c:42">exprType</a>(rtree);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * The right-hand input of the operator will be the <a href="../regex/regc_locale.c.html#L376" title="regex/regc_locale.c:376">element</a> type of the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * array.&nbsp; However, if we currently have just an untyped literal on the<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * right, stay with that and hope we can resolve the operator.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (atypeId == UNKNOWNOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rtypeId = UNKNOWNOID;<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; rtypeId = <a href="../utils/cache/lsyscache.c.html#L2832" title="utils/cache/lsyscache.c:2832">get_base_element_type</a>(atypeId);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(rtypeId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;op ANY/ALL (array) requires array on right side&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Now resolve the operator */<br/></li>
<li></span>&nbsp; &nbsp; tup = <a href="#L370" title="parser/parse_oper.c:370">oper</a>(pstate, opname, ltypeId, rtypeId, <span class="Constant">false</span>, location);<br/></li>
<li>&nbsp; &nbsp; opform = (Form_pg_operator) GETSTRUCT(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Check it's not a shell */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (!RegProcedureIsValid(opform-&gt;oprcode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_FUNCTION),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;operator is only a shell: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L602" title="parser/parse_oper.c:602">op_signature_string</a>(opname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opform-&gt;oprleft,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; opform-&gt;oprright)),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; args = list_make2(ltree, rtree);<br/></li>
<li>&nbsp; &nbsp; actual_arg_types[<span class="Constant">0</span>] = ltypeId;<br/></li>
<li>&nbsp; &nbsp; actual_arg_types[<span class="Constant">1</span>] = rtypeId;<br/></li>
<li>&nbsp; &nbsp; declared_arg_types[<span class="Constant">0</span>] = opform-&gt;oprleft;<br/></li>
<li>&nbsp; &nbsp; declared_arg_types[<span class="Constant">1</span>] = opform-&gt;oprright;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * enforce consistency with polymorphic argument and return types,<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * possibly adjusting return type or declared_arg_types (which will be<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * used as the cast destination by <a href="parse_func.c.html#L1824" title="parser/parse_func.c:1824">make_fn_arguments</a>)<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; rettype = <a href="parse_coerce.c.html#L2096" title="parser/parse_coerce.c:2096">enforce_generic_type_consistency</a>(actual_arg_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; declared_arg_types,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">2</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; opform-&gt;oprresult,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <span class="Constant">false</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Check that operator result is boolean<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (rettype != BOOLOID)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;op ANY/ALL (array) requires operator to yield boolean&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/cache/lsyscache.c.html#L1742" title="utils/cache/lsyscache.c:1742">get_func_retset</a>(opform-&gt;oprcode))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_WRONG_OBJECT_TYPE),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;op ANY/ALL (array) requires operator not to return a set&quot;</span>),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/*<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * Now switch back to the array type on the right, arranging for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a><br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * needed cast to be applied.&nbsp; Beware of polymorphic operators here;<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * <a href="parse_coerce.c.html#L2096" title="parser/parse_coerce.c:2096">enforce_generic_type_consistency</a> may or may not have replaced a<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; * polymorphic type with a real one.<br/></li>
<li></span><span class="Comment">&nbsp; &nbsp;&nbsp; */<br/></li>
<li></span>&nbsp; &nbsp; <span class="Statement">if</span> (IsPolymorphicType(declared_arg_types[<span class="Constant">1</span>]))<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* assume the actual array type is OK */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; res_atypeId = atypeId;<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; res_atypeId = <a href="../utils/cache/lsyscache.c.html#L2787" title="utils/cache/lsyscache.c:2787">get_array_type</a>(declared_arg_types[<span class="Constant">1</span>]);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (!OidIsValid(res_atypeId))<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ereport(ERROR,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (<a href="../utils/error/elog.c.html#L859" title="utils/error/elog.c:859">errcode</a>(ERRCODE_UNDEFINED_OBJECT),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="../utils/error/elog.c.html#L1072" title="utils/error/elog.c:1072">errmsg</a>(<span class="Constant">&quot;could not <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> array type for data type </span><span class="Special">%s</span><span class="Constant">&quot;</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/adt/format_type.c.html#L343" title="utils/adt/format_type.c:343">format_type_be</a>(declared_arg_types[<span class="Constant">1</span>])),<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; <a href="parse_node.c.html#L106" title="parser/parse_node.c:106">parser_errposition</a>(pstate, location)));<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; actual_arg_types[<span class="Constant">1</span>] = atypeId;<br/></li>
<li>&nbsp; &nbsp; declared_arg_types[<span class="Constant">1</span>] = res_atypeId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* perform the necessary typecasting of arguments */<br/></li>
<li></span>&nbsp; &nbsp; <a href="parse_func.c.html#L1824" title="parser/parse_func.c:1824">make_fn_arguments</a>(pstate, args, actual_arg_types, declared_arg_types);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* and build the expression node */<br/></li>
<li></span>&nbsp; &nbsp; result = makeNode(ScalarArrayOpExpr);<br/></li>
<li>&nbsp; &nbsp; result-&gt;opno = <a href="#L238" title="parser/parse_oper.c:238">oprid</a>(tup);<br/></li>
<li>&nbsp; &nbsp; result-&gt;opfuncid = opform-&gt;oprcode;<br/></li>
<li>&nbsp; &nbsp; result-&gt;hashfuncid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; result-&gt;negfuncid = InvalidOid;<br/></li>
<li>&nbsp; &nbsp; result-&gt;useOr = useOr;<br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* inputcollid will be set by parse_collate.c */<br/></li>
<li></span>&nbsp; &nbsp; result-&gt;args = args;<br/></li>
<li>&nbsp; &nbsp; result-&gt;location = location;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <a href="../utils/cache/syscache.c.html#L266" title="utils/cache/syscache.c:266">ReleaseSysCache</a>(tup);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> (Expr *) result;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Lookaside cache to speed operator lookup.&nbsp; Possibly this should be in<br/></li>
<li></span><span class="Comment"> * a separate module under utils/cache/ ?<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * The idea here is that the mapping from operator name and given argument<br/></li>
<li></span><span class="Comment"> * types is constant for a given search path (or single specified schema OID)<br/></li>
<li></span><span class="Comment"> * so long as the contents of pg_operator and pg_cast don't change.&nbsp; And that<br/></li>
<li></span><span class="Comment"> * mapping is pretty expensive to compute, especially for ambiguous operators;<br/></li>
<li></span><span class="Comment"> * this is mainly because there are a *lot* of instances of popular operator<br/></li>
<li></span><span class="Comment"> * names such as &quot;=&quot;, and we have to check each one to see which is the<br/></li>
<li></span><span class="Comment"> * best match.&nbsp; So once we have identified the correct mapping, we save it<br/></li>
<li></span><span class="Comment"> * in a cache that need only be flushed on pg_operator or pg_cast change.<br/></li>
<li></span><span class="Comment"> * (pg_cast must be considered because changes in the set of implicit casts<br/></li>
<li></span><span class="Comment"> * affect the set of applicable operators for <a href="../utils/adt/pseudotypes.c.html#L365" title="utils/adt/pseudotypes.c:365">any</a> given input datatype.)<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * </span><span class="Todo">XXX</span><span class="Comment"> in principle, ALTER TABLE ... INHERIT could affect the mapping as<br/></li>
<li></span><span class="Comment"> * well, but we disregard that since there's no convenient way to <a href="../regex/regexec.c.html#L419" title="regex/regexec.c:419">find</a> out<br/></li>
<li></span><span class="Comment"> * about it, and it seems a pretty far-fetched corner-case anyway.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Note: at some point it might be worth doing a similar cache for function<br/></li>
<li></span><span class="Comment"> * lookups.&nbsp; However, the potential gain is a lot less since (a) function<br/></li>
<li></span><span class="Comment"> * names are generally not overloaded as heavily as operator names, and<br/></li>
<li></span><span class="Comment"> * (b) we'd have to flush on pg_proc updates, which are probably a good<br/></li>
<li></span><span class="Comment"> * deal more common than pg_operator updates.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><br/></li>
<li><span class="Comment">/* The operator cache hashtable */<br/></li>
<li><a id="L923">&#x200c;</a></span><span class="Type">static</span> <a href="../utils/hash/dynahash.c.html#L219" title="utils/hash/dynahash.c:219">HTAB</a> *<span class="linkable">OprCacheHash</span> = <span class="Constant">NULL</span>;<br/></li>
<li><br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L937" title="parser/parse_oper.c:937">make_oper_cache_key</a><br/></li>
<li></span><span class="Comment"> *&nbsp; &nbsp; &nbsp; &nbsp; Fill the lookup key struct given operator name and arg types.<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Returns true if successful, false if the search_path overflowed<br/></li>
<li></span><span class="Comment"> * (hence no caching is possible).<br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * pstate/location are used only to report the error position; pass NULL/-1<br/></li>
<li></span><span class="Comment"> * if not available.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type"><a href="../utils/fmgr/dfmgr.c.html#L28" title="utils/fmgr/dfmgr.c:28">bool</a><br/></li>
<li><a id="L937">&#x200c;</a></span><span class="linkable">make_oper_cache_key</span>(ParseState *pstate, <a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> *key, List *opname,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Oid ltypeId, Oid rtypeId, <span class="Type">int</span> location)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *schemaname;<br/></li>
<li>&nbsp; &nbsp; <span class="Type">char</span>&nbsp; &nbsp; &nbsp;&nbsp; *opername;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* deconstruct the name list */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../catalog/namespace.c.html#L3286" title="catalog/namespace.c:3286">DeconstructQualifiedName</a>(opname, &amp;schemaname, &amp;opername);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* ensure zero-fill for stable hashing */<br/></li>
<li></span>&nbsp; &nbsp; MemSet(key, <span class="Constant">0</span>, <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a>));<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* save operator name and input types into key */<br/></li>
<li></span>&nbsp; &nbsp; strlcpy(key-&gt;oprname, opername, NAMEDATALEN);<br/></li>
<li>&nbsp; &nbsp; key-&gt;left_arg = ltypeId;<br/></li>
<li>&nbsp; &nbsp; key-&gt;right_arg = rtypeId;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (schemaname)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ParseCallbackState pcbstate;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* search only in exact schema given */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L140" title="parser/parse_node.c:140">setup_parser_errposition_callback</a>(&amp;pcbstate, pstate, location);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; key-&gt;search_path[<span class="Constant">0</span>] = <a href="../catalog/namespace.c.html#L3370" title="catalog/namespace.c:3370">LookupExplicitNamespace</a>(schemaname, <span class="Constant">false</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="parse_node.c.html#L156" title="parser/parse_node.c:156">cancel_parser_errposition_callback</a>(&amp;pcbstate);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">else<br/></li>
<li></span>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* get the active search path */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../catalog/namespace.c.html#L4835" title="catalog/namespace.c:4835">fetch_search_path_array</a>(key-&gt;search_path,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L49" title="parser/parse_oper.c:49">MAX_CACHED_PATH_LEN</a>) &gt; <a href="#L49" title="parser/parse_oper.c:49">MAX_CACHED_PATH_LEN</a>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">false</span>;&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* oops, didn't fit */<br/></li>
<li></span>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> <span class="Constant">true</span>;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L981" title="parser/parse_oper.c:981">find_oper_cache_entry</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * Look for a cache entry matching the given key.&nbsp; If found, return the<br/></li>
<li></span><span class="Comment"> * contained operator OID, else return InvalidOid.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> Oid<br/></li>
<li><a id="L981">&#x200c;</a><span class="linkable">find_oper_cache_entry</span>(<a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> *key)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a> *oprentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (<a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a> == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* First time through: <a href="../regex/rege_dfa.c.html#L731" title="regex/rege_dfa.c:731">initialize</a> the <a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; HASHCTL&nbsp; &nbsp; &nbsp; &nbsp; ctl;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.keysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; ctl.entrysize = <span class="Statement"><a href="../storage/page/itemptr.c.html#L23" title="storage/page/itemptr.c:23">sizeof</a></span>(<a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a> = <a href="../utils/hash/dynahash.c.html#L352" title="utils/hash/dynahash.c:352">hash_create</a>(<span class="Constant">&quot;Operator lookup cache&quot;</span>, <span class="Constant">256</span>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &amp;ctl, HASH_ELEM | HASH_BLOBS);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Comment">/* Arrange to flush cache on pg_operator and pg_cast changes */<br/></li>
<li></span>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(OPERNAMENSP,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="parser/parse_oper.c:1036">InvalidateOprCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <a href="../utils/cache/inval.c.html#L1516" title="utils/cache/inval.c:1516">CacheRegisterSyscacheCallback</a>(CASTSOURCETARGET,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="#L1036" title="parser/parse_oper.c:1036">InvalidateOprCacheCallBack</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Datum) <span class="Constant">0</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Look for an existing entry */<br/></li>
<li></span>&nbsp; &nbsp; oprentry = (<a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a> *) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_FIND, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; <span class="Statement">if</span> (oprentry == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">return</span> InvalidOid;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">return</span> oprentry-&gt;opr_oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * <a href="#L1020" title="parser/parse_oper.c:1020">make_oper_cache_entry</a><br/></li>
<li></span><span class="Comment"> *<br/></li>
<li></span><span class="Comment"> * <a href="../storage/file/fd.c.html#L1313" title="storage/file/fd.c:1313">Insert</a> a cache entry for the given key.<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1020">&#x200c;</a></span><span class="linkable">make_oper_cache_entry</span>(<a href="#L51" title="parser/parse_oper.c:51">OprCacheKey</a> *key, Oid opr_oid)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a> *oprentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; oprentry = (<a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a> *) <a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; HASH_ENTER, <span class="Constant">NULL</span>);<br/></li>
<li>&nbsp; &nbsp; oprentry-&gt;opr_oid = opr_oid;<br/></li>
<li>}<br/></li>
<li><br/></li>
<li><span class="Comment">/*<br/></li>
<li></span><span class="Comment"> * Callback for pg_operator and pg_cast inval events<br/></li>
<li></span><span class="Comment"> */<br/></li>
<li></span><span class="Type">static</span> <span class="Type">void<br/></li>
<li><a id="L1036">&#x200c;</a></span><span class="linkable">InvalidateOprCacheCallBack</span>(Datum arg, <span class="Type">int</span> cacheid, uint32 hashvalue)<br/></li>
<li>{<br/></li>
<li>&nbsp; &nbsp; HASH_SEQ_STATUS status;<br/></li>
<li>&nbsp; &nbsp; <a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a> *hentry;<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; Assert(<a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a> != <span class="Constant">NULL</span>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Comment">/* Currently we just flush all entries; hard to be smarter ... */<br/></li>
<li></span>&nbsp; &nbsp; <a href="../utils/hash/dynahash.c.html#L1385" title="utils/hash/dynahash.c:1385">hash_seq_init</a>(&amp;status, <a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a>);<br/></li>
<li><br/></li>
<li>&nbsp; &nbsp; <span class="Statement">while</span> ((hentry = (<a href="#L59" title="parser/parse_oper.c:59">OprCacheEntry</a> *) <a href="../utils/hash/dynahash.c.html#L1395" title="utils/hash/dynahash.c:1395">hash_seq_search</a>(&amp;status)) != <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; {<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; <span class="Statement">if</span> (<a href="../utils/hash/dynahash.c.html#L955" title="utils/hash/dynahash.c:955">hash_search</a>(<a href="#L923" title="parser/parse_oper.c:923">OprCacheHash</a>,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;hentry-&gt;key,<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HASH_REMOVE, <span class="Constant">NULL</span>) == <span class="Constant">NULL</span>)<br/></li>
<li>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; elog(ERROR, <span class="Constant">&quot;<a href="../regex/rege_dfa.c.html#L715" title="regex/rege_dfa.c:715">hash</a> table corrupted&quot;</span>);<br/></li>
<li>&nbsp; &nbsp; }<br/></li>
<li>}<br/></li>
</ol></code>
 <p class="nav-bar">
  <span class="nav-link"><a href="./index.html">One Level Up</a></span>
  <span class="nav-link"><a href="../index.html">Top Level</a></span>
 </p>

 </body>
</html>
